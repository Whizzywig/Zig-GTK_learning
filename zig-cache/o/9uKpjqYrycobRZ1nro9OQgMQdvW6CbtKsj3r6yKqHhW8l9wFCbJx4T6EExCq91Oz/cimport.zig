pub const va_list = [*c]u8;
pub extern fn __va_start(arg0: [*c]([*c]u8), ...) void;
pub const ptrdiff_t = c_longlong;
pub const __vcrt_bool = bool;
pub const wchar_t = c_ushort;
pub extern fn __security_init_cookie() void;
pub extern fn __security_check_cookie(_StackCookie: usize) void;
pub extern fn __report_gsfailure(_StackCookie: usize) noreturn;
pub extern var __security_cookie: usize;
pub const __crt_bool = bool;
pub extern fn _invalid_parameter(arg0: [*c]const wchar_t, arg1: [*c]const wchar_t, arg2: [*c]const wchar_t, arg3: c_uint, arg4: usize) void;
pub extern fn _invalid_parameter_noinfo() void;
pub extern fn _invalid_parameter_noinfo_noreturn() noreturn;
pub extern fn _invoke_watson(_Expression: [*c]const wchar_t, _FunctionName: [*c]const wchar_t, _FileName: [*c]const wchar_t, _LineNo: c_uint, _Reserved: usize) noreturn;
pub const errno_t = c_int;
pub const wint_t = c_ushort;
pub const wctype_t = c_ushort;
pub const __time32_t = c_long;
pub const __time64_t = c_longlong;
pub const struct___crt_locale_data_public = extern struct {
    _locale_pctype: [*c]const c_ushort,
    _locale_mb_cur_max: c_int,
    _locale_lc_codepage: c_uint,
};
pub const __crt_locale_data_public = struct___crt_locale_data_public;
pub const struct___crt_locale_data = @OpaqueType();
pub const struct___crt_multibyte_data = @OpaqueType();
pub const struct___crt_locale_pointers = extern struct {
    locinfo: ?*struct___crt_locale_data,
    mbcinfo: ?*struct___crt_multibyte_data,
};
pub const __crt_locale_pointers = struct___crt_locale_pointers;
pub const _locale_t = [*c]__crt_locale_pointers;
pub const struct__Mbstatet = extern struct {
    _Wchar: c_ulong,
    _Byte: c_ushort,
    _State: c_ushort,
};
pub const _Mbstatet = struct__Mbstatet;
pub const mbstate_t = _Mbstatet;
pub const time_t = __time64_t;
pub const rsize_t = usize;
pub fn __local_stdio_printf_options() [*c]c_ulonglong {
    var _OptionsStorage: c_ulonglong = undefined;
    return &_OptionsStorage;
}
pub fn __local_stdio_scanf_options() [*c]c_ulonglong {
    var _OptionsStorage: c_ulonglong = undefined;
    return &_OptionsStorage;
}
pub const struct__iobuf = extern struct {
    _Placeholder: ?*c_void,
};
pub const FILE = struct__iobuf;
pub extern fn __acrt_iob_func(_Ix: c_uint) [*c]FILE;
pub extern fn fgetwc(_Stream: [*c]FILE) wint_t;
pub extern fn _fgetwchar() wint_t;
pub extern fn fputwc(_Character: wchar_t, _Stream: [*c]FILE) wint_t;
pub extern fn _fputwchar(_Character: wchar_t) wint_t;
pub extern fn getwc(_Stream: [*c]FILE) wint_t;
pub extern fn getwchar() wint_t;
pub extern fn fgetws(_Buffer: [*c]wchar_t, _BufferCount: c_int, _Stream: [*c]FILE) [*c]wchar_t;
pub extern fn fputws(_Buffer: [*c]const wchar_t, _Stream: [*c]FILE) c_int;
pub extern fn _getws_s(_Buffer: [*c]wchar_t, _BufferCount: usize) [*c]wchar_t;
pub extern fn putwc(_Character: wchar_t, _Stream: [*c]FILE) wint_t;
pub extern fn putwchar(_Character: wchar_t) wint_t;
pub extern fn _putws(_Buffer: [*c]const wchar_t) c_int;
pub extern fn ungetwc(_Character: wint_t, _Stream: [*c]FILE) wint_t;
pub extern fn _wfdopen(_FileHandle: c_int, _Mode: [*c]const wchar_t) [*c]FILE;
pub extern fn _wfopen(_FileName: [*c]const wchar_t, _Mode: [*c]const wchar_t) [*c]FILE;
pub extern fn _wfopen_s(_Stream: [*c]([*c]FILE), _FileName: [*c]const wchar_t, _Mode: [*c]const wchar_t) errno_t;
pub extern fn _wfreopen(_FileName: [*c]const wchar_t, _Mode: [*c]const wchar_t, _OldStream: [*c]FILE) [*c]FILE;
pub extern fn _wfreopen_s(_Stream: [*c]([*c]FILE), _FileName: [*c]const wchar_t, _Mode: [*c]const wchar_t, _OldStream: [*c]FILE) errno_t;
pub extern fn _wfsopen(_FileName: [*c]const wchar_t, _Mode: [*c]const wchar_t, _ShFlag: c_int) [*c]FILE;
pub extern fn _wperror(_ErrorMessage: [*c]const wchar_t) void;
pub extern fn _wpopen(_Command: [*c]const wchar_t, _Mode: [*c]const wchar_t) [*c]FILE;
pub extern fn _wremove(_FileName: [*c]const wchar_t) c_int;
pub extern fn _wtempnam(_Directory: [*c]const wchar_t, _FilePrefix: [*c]const wchar_t) [*c]wchar_t;
pub extern fn _wtmpnam_s(_Buffer: [*c]wchar_t, _BufferCount: usize) errno_t;
pub extern fn _wtmpnam(_Buffer: [*c]wchar_t) [*c]wchar_t;
pub extern fn _fgetwc_nolock(_Stream: [*c]FILE) wint_t;
pub extern fn _fputwc_nolock(_Character: wchar_t, _Stream: [*c]FILE) wint_t;
pub extern fn _getwc_nolock(_Stream: [*c]FILE) wint_t;
pub extern fn _putwc_nolock(_Character: wchar_t, _Stream: [*c]FILE) wint_t;
pub extern fn _ungetwc_nolock(_Character: wint_t, _Stream: [*c]FILE) wint_t;
pub extern fn __stdio_common_vfwprintf(_Options: c_ulonglong, _Stream: [*c]FILE, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vfwprintf_s(_Options: c_ulonglong, _Stream: [*c]FILE, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vfwprintf_p(_Options: c_ulonglong, _Stream: [*c]FILE, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int;
pub fn _vfwprintf_l(_Stream: [*c]FILE, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vfwprintf(__local_stdio_printf_options().?.*, _Stream, _Format, _Locale, _ArgList);
}
pub fn vfwprintf(_Stream: [*c]FILE, _Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vfwprintf_l(_Stream, _Format, null, _ArgList);
}
pub fn _vfwprintf_s_l(_Stream: [*c]FILE, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vfwprintf_s(__local_stdio_printf_options().?.*, _Stream, _Format, _Locale, _ArgList);
}
pub fn vfwprintf_s(_Stream: [*c]FILE, _Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vfwprintf_s_l(_Stream, _Format, null, _ArgList);
}
pub fn _vfwprintf_p_l(_Stream: [*c]FILE, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vfwprintf_p(__local_stdio_printf_options().?.*, _Stream, _Format, _Locale, _ArgList);
}
pub fn _vfwprintf_p(_Stream: [*c]FILE, _Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vfwprintf_p_l(_Stream, _Format, null, _ArgList);
}
pub fn _vwprintf_l(_Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return _vfwprintf_l(__acrt_iob_func(c_uint(1)), _Format, _Locale, _ArgList);
}
pub fn vwprintf(_Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vfwprintf_l(__acrt_iob_func(c_uint(1)), _Format, null, _ArgList);
}
pub fn _vwprintf_s_l(_Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return _vfwprintf_s_l(__acrt_iob_func(c_uint(1)), _Format, _Locale, _ArgList);
}
pub fn vwprintf_s(_Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vfwprintf_s_l(__acrt_iob_func(c_uint(1)), _Format, null, _ArgList);
}
pub fn _vwprintf_p_l(_Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return _vfwprintf_p_l(__acrt_iob_func(c_uint(1)), _Format, _Locale, _ArgList);
}
pub fn _vwprintf_p(_Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vfwprintf_p_l(__acrt_iob_func(c_uint(1)), _Format, null, _ArgList);
}
pub extern fn __stdio_common_vfwscanf(_Options: c_ulonglong, _Stream: [*c]FILE, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int;
pub fn _vfwscanf_l(_Stream: [*c]FILE, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vfwscanf(__local_stdio_scanf_options().?.*, _Stream, _Format, _Locale, _ArgList);
}
pub fn vfwscanf(_Stream: [*c]FILE, _Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vfwscanf_l(_Stream, _Format, null, _ArgList);
}
pub fn _vfwscanf_s_l(_Stream: [*c]FILE, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vfwscanf(__local_stdio_scanf_options().?.* | (1 << @import("std").math.Log2Int(c_ulonglong)(0)), _Stream, _Format, _Locale, _ArgList);
}
pub fn vfwscanf_s(_Stream: [*c]FILE, _Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vfwscanf_s_l(_Stream, _Format, null, _ArgList);
}
pub fn _vwscanf_l(_Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return _vfwscanf_l(__acrt_iob_func(c_uint(0)), _Format, _Locale, _ArgList);
}
pub fn vwscanf(_Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vfwscanf_l(__acrt_iob_func(c_uint(0)), _Format, null, _ArgList);
}
pub fn _vwscanf_s_l(_Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return _vfwscanf_s_l(__acrt_iob_func(c_uint(0)), _Format, _Locale, _ArgList);
}
pub fn vwscanf_s(_Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vfwscanf_s_l(__acrt_iob_func(c_uint(0)), _Format, null, _ArgList);
}
pub extern fn __stdio_common_vswprintf(_Options: c_ulonglong, _Buffer: [*c]wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vswprintf_s(_Options: c_ulonglong, _Buffer: [*c]wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vsnwprintf_s(_Options: c_ulonglong, _Buffer: [*c]wchar_t, _BufferCount: usize, _MaxCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vswprintf_p(_Options: c_ulonglong, _Buffer: [*c]wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int;
pub fn _vsnwprintf_l(_Buffer: [*c]wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vswprintf(__local_stdio_printf_options().?.* | (1 << @import("std").math.Log2Int(c_ulonglong)(0)), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn _vsnwprintf_s_l(_Buffer: [*c]wchar_t, _BufferCount: usize, _MaxCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vsnwprintf_s(__local_stdio_printf_options().?.*, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn _vsnwprintf_s(_Buffer: [*c]wchar_t, _BufferCount: usize, _MaxCount: usize, _Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, null, _ArgList);
}
pub fn _vsnwprintf(_Buffer: [*c]wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _Args: va_list) c_int {
    return _vsnwprintf_l(_Buffer, _BufferCount, _Format, null, _ArgList);
}
pub fn _vswprintf_c_l(_Buffer: [*c]wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vswprintf(__local_stdio_printf_options().?.*, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn _vswprintf_c(_Buffer: [*c]wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, null, _ArgList);
}
pub fn _vswprintf_l(_Buffer: [*c]wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
}
pub fn __vswprintf_l(_Buffer: [*c]wchar_t, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return _vswprintf_l(_Buffer, usize(-1), _Format, _Locale, _ArgList);
}
pub fn _vswprintf(_Buffer: [*c]wchar_t, _Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vswprintf_l(_Buffer, usize(-1), _Format, null, _ArgList);
}
pub fn vswprintf(_Buffer: [*c]wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, null, _ArgList);
}
pub fn _vswprintf_s_l(_Buffer: [*c]wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vswprintf_s(__local_stdio_printf_options().?.*, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn vswprintf_s(_Buffer: [*c]wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vswprintf_s_l(_Buffer, _BufferCount, _Format, null, _ArgList);
}
pub fn _vswprintf_p_l(_Buffer: [*c]wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vswprintf_p(__local_stdio_printf_options().?.*, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn _vswprintf_p(_Buffer: [*c]wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vswprintf_p_l(_Buffer, _BufferCount, _Format, null, _ArgList);
}
pub fn _vscwprintf_l(_Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vswprintf(__local_stdio_printf_options().?.* | (1 << @import("std").math.Log2Int(c_ulonglong)(1)), null, usize(0), _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn _vscwprintf(_Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vscwprintf_l(_Format, null, _ArgList);
}
pub fn _vscwprintf_p_l(_Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vswprintf_p(__local_stdio_printf_options().?.* | (1 << @import("std").math.Log2Int(c_ulonglong)(1)), null, usize(0), _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn _vscwprintf_p(_Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vscwprintf_p_l(_Format, null, _ArgList);
}
pub extern fn __stdio_common_vswscanf(_Options: c_ulonglong, _Buffer: [*c]const wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int;
pub fn _vswscanf_l(_Buffer: [*c]const wchar_t, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vswscanf(__local_stdio_scanf_options().?.*, _Buffer, usize(-1), _Format, _Locale, _ArgList);
}
pub fn vswscanf(_Buffer: [*c]const wchar_t, _Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vswscanf_l(_Buffer, _Format, null, _ArgList);
}
pub fn _vswscanf_s_l(_Buffer: [*c]const wchar_t, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vswscanf(__local_stdio_scanf_options().?.* | (1 << @import("std").math.Log2Int(c_ulonglong)(0)), _Buffer, usize(-1), _Format, _Locale, _ArgList);
}
pub fn vswscanf_s(_Buffer: [*c]const wchar_t, _Format: [*c]const wchar_t, _ArgList: va_list) c_int {
    return _vswscanf_s_l(_Buffer, _Format, null, _ArgList);
}
pub fn _vsnwscanf_l(_Buffer: [*c]const wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vswscanf(__local_stdio_scanf_options().?.*, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
}
pub fn _vsnwscanf_s_l(_Buffer: [*c]const wchar_t, _BufferCount: usize, _Format: [*c]const wchar_t, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vswscanf(__local_stdio_scanf_options().?.* | (1 << @import("std").math.Log2Int(c_ulonglong)(0)), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
}
pub const fpos_t = c_longlong;
pub extern fn _get_stream_buffer_pointers(_Stream: [*c]FILE, _Base: [*c]([*c]([*c]u8)), _Pointer: [*c]([*c]([*c]u8)), _Count: [*c]([*c]c_int)) errno_t;
pub extern fn clearerr_s(_Stream: [*c]FILE) errno_t;
pub extern fn fopen_s(_Stream: [*c]([*c]FILE), _FileName: [*c]const u8, _Mode: [*c]const u8) errno_t;
pub extern fn fread_s(_Buffer: ?*c_void, _BufferSize: usize, _ElementSize: usize, _ElementCount: usize, _Stream: [*c]FILE) usize;
pub extern fn freopen_s(_Stream: [*c]([*c]FILE), _FileName: [*c]const u8, _Mode: [*c]const u8, _OldStream: [*c]FILE) errno_t;
pub extern fn gets_s(_Buffer: [*c]u8, _Size: rsize_t) [*c]u8;
pub extern fn tmpfile_s(_Stream: [*c]([*c]FILE)) errno_t;
pub extern fn tmpnam_s(_Buffer: [*c]u8, _Size: rsize_t) errno_t;
pub extern fn clearerr(_Stream: [*c]FILE) void;
pub extern fn fclose(_Stream: [*c]FILE) c_int;
pub extern fn _fcloseall() c_int;
pub extern fn _fdopen(_FileHandle: c_int, _Mode: [*c]const u8) [*c]FILE;
pub extern fn feof(_Stream: [*c]FILE) c_int;
pub extern fn ferror(_Stream: [*c]FILE) c_int;
pub extern fn fflush(_Stream: [*c]FILE) c_int;
pub extern fn fgetc(_Stream: [*c]FILE) c_int;
pub extern fn _fgetchar() c_int;
pub extern fn fgetpos(_Stream: [*c]FILE, _Position: [*c]fpos_t) c_int;
pub extern fn fgets(_Buffer: [*c]u8, _MaxCount: c_int, _Stream: [*c]FILE) [*c]u8;
pub extern fn _fileno(_Stream: [*c]FILE) c_int;
pub extern fn _flushall() c_int;
pub extern fn fopen(_FileName: [*c]const u8, _Mode: [*c]const u8) [*c]FILE;
pub extern fn fputc(_Character: c_int, _Stream: [*c]FILE) c_int;
pub extern fn _fputchar(_Character: c_int) c_int;
pub extern fn fputs(_Buffer: [*c]const u8, _Stream: [*c]FILE) c_int;
pub extern fn fread(_Buffer: ?*c_void, _ElementSize: c_ulonglong, _ElementCount: c_ulonglong, _Stream: [*c]FILE) c_ulonglong;
pub extern fn freopen(_FileName: [*c]const u8, _Mode: [*c]const u8, _Stream: [*c]FILE) [*c]FILE;
pub extern fn _fsopen(_FileName: [*c]const u8, _Mode: [*c]const u8, _ShFlag: c_int) [*c]FILE;
pub extern fn fsetpos(_Stream: [*c]FILE, _Position: [*c]const fpos_t) c_int;
pub extern fn fseek(_Stream: [*c]FILE, _Offset: c_long, _Origin: c_int) c_int;
pub extern fn _fseeki64(_Stream: [*c]FILE, _Offset: c_longlong, _Origin: c_int) c_int;
pub extern fn ftell(_Stream: [*c]FILE) c_long;
pub extern fn _ftelli64(_Stream: [*c]FILE) c_longlong;
pub extern fn fwrite(_Buffer: ?*const c_void, _ElementSize: c_ulonglong, _ElementCount: c_ulonglong, _Stream: [*c]FILE) c_ulonglong;
pub extern fn getc(_Stream: [*c]FILE) c_int;
pub extern fn getchar() c_int;
pub extern fn _getmaxstdio() c_int;
pub extern fn _getw(_Stream: [*c]FILE) c_int;
pub extern fn perror(_ErrorMessage: [*c]const u8) void;
pub extern fn _pclose(_Stream: [*c]FILE) c_int;
pub extern fn _popen(_Command: [*c]const u8, _Mode: [*c]const u8) [*c]FILE;
pub extern fn putc(_Character: c_int, _Stream: [*c]FILE) c_int;
pub extern fn putchar(_Character: c_int) c_int;
pub extern fn puts(_Buffer: [*c]const u8) c_int;
pub extern fn _putw(_Word: c_int, _Stream: [*c]FILE) c_int;
pub extern fn remove(_FileName: [*c]const u8) c_int;
pub extern fn rename(_OldFileName: [*c]const u8, _NewFileName: [*c]const u8) c_int;
pub extern fn _unlink(_FileName: [*c]const u8) c_int;
pub extern fn unlink(_FileName: [*c]const u8) c_int;
pub extern fn rewind(_Stream: [*c]FILE) void;
pub extern fn _rmtmp() c_int;
pub extern fn setbuf(_Stream: [*c]FILE, _Buffer: [*c]u8) void;
pub extern fn _setmaxstdio(_Maximum: c_int) c_int;
pub extern fn setvbuf(_Stream: [*c]FILE, _Buffer: [*c]u8, _Mode: c_int, _Size: usize) c_int;
pub extern fn _tempnam(_DirectoryName: [*c]const u8, _FilePrefix: [*c]const u8) [*c]u8;
pub extern fn tmpfile() [*c]FILE;
pub extern fn tmpnam(_Buffer: [*c]u8) [*c]u8;
pub extern fn ungetc(_Character: c_int, _Stream: [*c]FILE) c_int;
pub extern fn _lock_file(_Stream: [*c]FILE) void;
pub extern fn _unlock_file(_Stream: [*c]FILE) void;
pub extern fn _fclose_nolock(_Stream: [*c]FILE) c_int;
pub extern fn _fflush_nolock(_Stream: [*c]FILE) c_int;
pub extern fn _fgetc_nolock(_Stream: [*c]FILE) c_int;
pub extern fn _fputc_nolock(_Character: c_int, _Stream: [*c]FILE) c_int;
pub extern fn _fread_nolock(_Buffer: ?*c_void, _ElementSize: usize, _ElementCount: usize, _Stream: [*c]FILE) usize;
pub extern fn _fread_nolock_s(_Buffer: ?*c_void, _BufferSize: usize, _ElementSize: usize, _ElementCount: usize, _Stream: [*c]FILE) usize;
pub extern fn _fseek_nolock(_Stream: [*c]FILE, _Offset: c_long, _Origin: c_int) c_int;
pub extern fn _fseeki64_nolock(_Stream: [*c]FILE, _Offset: c_longlong, _Origin: c_int) c_int;
pub extern fn _ftell_nolock(_Stream: [*c]FILE) c_long;
pub extern fn _ftelli64_nolock(_Stream: [*c]FILE) c_longlong;
pub extern fn _fwrite_nolock(_Buffer: ?*const c_void, _ElementSize: usize, _ElementCount: usize, _Stream: [*c]FILE) usize;
pub extern fn _getc_nolock(_Stream: [*c]FILE) c_int;
pub extern fn _putc_nolock(_Character: c_int, _Stream: [*c]FILE) c_int;
pub extern fn _ungetc_nolock(_Character: c_int, _Stream: [*c]FILE) c_int;
pub extern fn __p__commode() [*c]c_int;
pub extern fn __stdio_common_vfprintf(_Options: c_ulonglong, _Stream: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vfprintf_s(_Options: c_ulonglong, _Stream: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vfprintf_p(_Options: c_ulonglong, _Stream: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int;
pub fn _vfprintf_l(_Stream: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vfprintf(__local_stdio_printf_options().?.*, _Stream, _Format, _Locale, _ArgList);
}
pub const __builtin_va_list = [*c]u8;
pub fn vfprintf(_Stream: [*c]FILE, _Format: [*c]const u8, _ArgList: __builtin_va_list) c_int {
    return _vfprintf_l(_Stream, _Format, null, _ArgList);
}
pub fn _vfprintf_s_l(_Stream: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vfprintf_s(__local_stdio_printf_options().?.*, _Stream, _Format, _Locale, _ArgList);
}
pub fn vfprintf_s(_Stream: [*c]FILE, _Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vfprintf_s_l(_Stream, _Format, null, _ArgList);
}
pub fn _vfprintf_p_l(_Stream: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vfprintf_p(__local_stdio_printf_options().?.*, _Stream, _Format, _Locale, _ArgList);
}
pub fn _vfprintf_p(_Stream: [*c]FILE, _Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vfprintf_p_l(_Stream, _Format, null, _ArgList);
}
pub fn _vprintf_l(_Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    return _vfprintf_l(__acrt_iob_func(c_uint(1)), _Format, _Locale, _ArgList);
}
pub fn vprintf(_Format: [*c]const u8, _ArgList: __builtin_va_list) c_int {
    return _vfprintf_l(__acrt_iob_func(c_uint(1)), _Format, null, _ArgList);
}
pub fn _vprintf_s_l(_Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    return _vfprintf_s_l(__acrt_iob_func(c_uint(1)), _Format, _Locale, _ArgList);
}
pub fn vprintf_s(_Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vfprintf_s_l(__acrt_iob_func(c_uint(1)), _Format, null, _ArgList);
}
pub fn _vprintf_p_l(_Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    return _vfprintf_p_l(__acrt_iob_func(c_uint(1)), _Format, _Locale, _ArgList);
}
pub fn _vprintf_p(_Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vfprintf_p_l(__acrt_iob_func(c_uint(1)), _Format, null, _ArgList);
}
pub extern fn _set_printf_count_output(_Value: c_int) c_int;
pub extern fn _get_printf_count_output() c_int;
pub extern fn __stdio_common_vfscanf(_Options: c_ulonglong, _Stream: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, _Arglist: va_list) c_int;
pub fn _vfscanf_l(_Stream: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vfscanf(__local_stdio_scanf_options().?.*, _Stream, _Format, _Locale, _ArgList);
}
pub fn vfscanf(noalias _Stream: [*c]FILE, noalias _Format: [*c]const u8, _ArgList: __builtin_va_list) c_int {
    return _vfscanf_l(_Stream, _Format, null, _ArgList);
}
pub fn _vfscanf_s_l(_Stream: [*c]FILE, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vfscanf(__local_stdio_scanf_options().?.* | (1 << @import("std").math.Log2Int(c_ulonglong)(0)), _Stream, _Format, _Locale, _ArgList);
}
pub fn vfscanf_s(_Stream: [*c]FILE, _Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vfscanf_s_l(_Stream, _Format, null, _ArgList);
}
pub fn _vscanf_l(_Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    return _vfscanf_l(__acrt_iob_func(c_uint(0)), _Format, _Locale, _ArgList);
}
pub fn vscanf(noalias _Format: [*c]const u8, _ArgList: __builtin_va_list) c_int {
    return _vfscanf_l(__acrt_iob_func(c_uint(0)), _Format, null, _ArgList);
}
pub fn _vscanf_s_l(_Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    return _vfscanf_s_l(__acrt_iob_func(c_uint(0)), _Format, _Locale, _ArgList);
}
pub fn vscanf_s(_Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vfscanf_s_l(__acrt_iob_func(c_uint(0)), _Format, null, _ArgList);
}
pub extern fn __stdio_common_vsprintf(_Options: c_ulonglong, _Buffer: [*c]u8, _BufferCount: usize, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vsprintf_s(_Options: c_ulonglong, _Buffer: [*c]u8, _BufferCount: usize, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vsnprintf_s(_Options: c_ulonglong, _Buffer: [*c]u8, _BufferCount: usize, _MaxCount: usize, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int;
pub extern fn __stdio_common_vsprintf_p(_Options: c_ulonglong, _Buffer: [*c]u8, _BufferCount: usize, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int;
pub fn _vsnprintf_l(_Buffer: [*c]u8, _BufferCount: usize, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vsprintf(__local_stdio_printf_options().?.* | (1 << @import("std").math.Log2Int(c_ulonglong)(0)), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn _vsnprintf(_Buffer: [*c]u8, _BufferCount: usize, _Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vsnprintf_l(_Buffer, _BufferCount, _Format, null, _ArgList);
}
pub fn vsnprintf(_Buffer: [*c]u8, _BufferCount: c_ulonglong, _Format: [*c]const u8, _ArgList: __builtin_va_list) c_int {
    const _Result: c_int = __stdio_common_vsprintf(__local_stdio_printf_options().?.* | (1 << @import("std").math.Log2Int(c_ulonglong)(1)), _Buffer, _BufferCount, _Format, null, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn _vsprintf_l(_Buffer: [*c]u8, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    return _vsnprintf_l(_Buffer, usize(-1), _Format, _Locale, _ArgList);
}
pub fn vsprintf(_Buffer: [*c]u8, _Format: [*c]const u8, _ArgList: __builtin_va_list) c_int {
    return _vsnprintf_l(_Buffer, usize(-1), _Format, null, _ArgList);
}
pub fn _vsprintf_s_l(_Buffer: [*c]u8, _BufferCount: usize, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vsprintf_s(__local_stdio_printf_options().?.*, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn vsprintf_s(_Buffer: [*c]u8, _BufferCount: usize, _Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vsprintf_s_l(_Buffer, _BufferCount, _Format, null, _ArgList);
}
pub fn _vsprintf_p_l(_Buffer: [*c]u8, _BufferCount: usize, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vsprintf_p(__local_stdio_printf_options().?.*, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn _vsprintf_p(_Buffer: [*c]u8, _BufferCount: usize, _Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vsprintf_p_l(_Buffer, _BufferCount, _Format, null, _ArgList);
}
pub fn _vsnprintf_s_l(_Buffer: [*c]u8, _BufferCount: usize, _MaxCount: usize, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vsnprintf_s(__local_stdio_printf_options().?.*, _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn _vsnprintf_s(_Buffer: [*c]u8, _BufferCount: usize, _MaxCount: usize, _Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, null, _ArgList);
}
pub fn vsnprintf_s(_Buffer: [*c]u8, _BufferCount: usize, _MaxCount: usize, _Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, null, _ArgList);
}
pub fn _vscprintf_l(_Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vsprintf(__local_stdio_printf_options().?.* | (1 << @import("std").math.Log2Int(c_ulonglong)(1)), null, usize(0), _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn _vscprintf(_Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vscprintf_l(_Format, null, _ArgList);
}
pub fn _vscprintf_p_l(_Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vsprintf_p(__local_stdio_printf_options().?.* | (1 << @import("std").math.Log2Int(c_ulonglong)(1)), null, usize(0), _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn _vscprintf_p(_Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vscprintf_p_l(_Format, null, _ArgList);
}
pub fn _vsnprintf_c_l(_Buffer: [*c]u8, _BufferCount: usize, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    const _Result: c_int = __stdio_common_vsprintf(__local_stdio_printf_options().?.*, _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    return if (_Result < 0) -1 else _Result;
}
pub fn _vsnprintf_c(_Buffer: [*c]u8, _BufferCount: usize, _Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, null, _ArgList);
}
pub extern fn __stdio_common_vsscanf(_Options: c_ulonglong, _Buffer: [*c]const u8, _BufferCount: usize, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int;
pub fn _vsscanf_l(_Buffer: [*c]const u8, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vsscanf(__local_stdio_scanf_options().?.*, _Buffer, usize(-1), _Format, _Locale, _ArgList);
}
pub fn vsscanf(noalias _Buffer: [*c]const u8, noalias _Format: [*c]const u8, _ArgList: __builtin_va_list) c_int {
    return _vsscanf_l(_Buffer, _Format, null, _ArgList);
}
pub fn _vsscanf_s_l(_Buffer: [*c]const u8, _Format: [*c]const u8, _Locale: _locale_t, _ArgList: va_list) c_int {
    return __stdio_common_vsscanf(__local_stdio_scanf_options().?.* | (1 << @import("std").math.Log2Int(c_ulonglong)(0)), _Buffer, usize(-1), _Format, _Locale, _ArgList);
}
pub fn vsscanf_s(_Buffer: [*c]const u8, _Format: [*c]const u8, _ArgList: va_list) c_int {
    return _vsscanf_s_l(_Buffer, _Format, null, _ArgList);
}
pub extern fn tempnam(_Directory: [*c]const u8, _FilePrefix: [*c]const u8) [*c]u8;
pub extern fn fcloseall() c_int;
pub extern fn fdopen(_FileHandle: c_int, _Format: [*c]const u8) [*c]FILE;
pub extern fn fgetchar() c_int;
pub extern fn fileno(_Stream: [*c]FILE) c_int;
pub extern fn flushall() c_int;
pub extern fn fputchar(_Ch: c_int) c_int;
pub extern fn getw(_Stream: [*c]FILE) c_int;
pub extern fn putw(_Ch: c_int, _Stream: [*c]FILE) c_int;
pub extern fn rmtmp() c_int;
pub extern fn _calloc_base(_Count: usize, _Size: usize) ?*c_void;
pub extern fn calloc(_Count: c_ulonglong, _Size: c_ulonglong) ?*c_void;
pub extern fn _callnewh(_Size: usize) c_int;
pub extern fn _expand(_Block: ?*c_void, _Size: usize) ?*c_void;
pub extern fn _free_base(_Block: ?*c_void) void;
pub extern fn free(_Block: ?*c_void) void;
pub extern fn _malloc_base(_Size: usize) ?*c_void;
pub extern fn malloc(_Size: c_ulonglong) ?*c_void;
pub extern fn _msize_base(_Block: ?*c_void) usize;
pub extern fn _msize(_Block: ?*c_void) usize;
pub extern fn _realloc_base(_Block: ?*c_void, _Size: usize) ?*c_void;
pub extern fn realloc(_Block: ?*c_void, _Size: c_ulonglong) ?*c_void;
pub extern fn _recalloc_base(_Block: ?*c_void, _Count: usize, _Size: usize) ?*c_void;
pub extern fn _recalloc(_Block: ?*c_void, _Count: usize, _Size: usize) ?*c_void;
pub extern fn _aligned_free(_Block: ?*c_void) void;
pub extern fn _aligned_malloc(_Size: usize, _Alignment: usize) ?*c_void;
pub extern fn _aligned_offset_malloc(_Size: usize, _Alignment: usize, _Offset: usize) ?*c_void;
pub extern fn _aligned_msize(_Block: ?*c_void, _Alignment: usize, _Offset: usize) usize;
pub extern fn _aligned_offset_realloc(_Block: ?*c_void, _Size: usize, _Alignment: usize, _Offset: usize) ?*c_void;
pub extern fn _aligned_offset_recalloc(_Block: ?*c_void, _Count: usize, _Size: usize, _Alignment: usize, _Offset: usize) ?*c_void;
pub extern fn _aligned_realloc(_Block: ?*c_void, _Size: usize, _Alignment: usize) ?*c_void;
pub extern fn _aligned_recalloc(_Block: ?*c_void, _Count: usize, _Size: usize, _Alignment: usize) ?*c_void;
pub const max_align_t = f64;
pub const _CoreCrtSecureSearchSortCompareFunction = ?extern fn (?*c_void, ?*const c_void, ?*const c_void) c_int;
pub const _CoreCrtNonSecureSearchSortCompareFunction = ?extern fn (?*const c_void, ?*const c_void) c_int;
pub extern fn bsearch_s(_Key: ?*const c_void, _Base: ?*const c_void, _NumOfElements: rsize_t, _SizeOfElements: rsize_t, _CompareFunction: _CoreCrtSecureSearchSortCompareFunction, _Context: ?*c_void) ?*c_void;
pub extern fn qsort_s(_Base: ?*c_void, _NumOfElements: rsize_t, _SizeOfElements: rsize_t, _CompareFunction: _CoreCrtSecureSearchSortCompareFunction, _Context: ?*c_void) void;
pub extern fn bsearch(_Key: ?*const c_void, _Base: ?*const c_void, _NumOfElements: usize, _SizeOfElements: usize, _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction) ?*c_void;
pub extern fn qsort(_Base: ?*c_void, _NumOfElements: usize, _SizeOfElements: usize, _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction) void;
pub extern fn _lfind_s(_Key: ?*const c_void, _Base: ?*const c_void, _NumOfElements: [*c]c_uint, _SizeOfElements: usize, _CompareFunction: _CoreCrtSecureSearchSortCompareFunction, _Context: ?*c_void) ?*c_void;
pub extern fn _lfind(_Key: ?*const c_void, _Base: ?*const c_void, _NumOfElements: [*c]c_uint, _SizeOfElements: c_uint, _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction) ?*c_void;
pub extern fn _lsearch_s(_Key: ?*const c_void, _Base: ?*c_void, _NumOfElements: [*c]c_uint, _SizeOfElements: usize, _CompareFunction: _CoreCrtSecureSearchSortCompareFunction, _Context: ?*c_void) ?*c_void;
pub extern fn _lsearch(_Key: ?*const c_void, _Base: ?*c_void, _NumOfElements: [*c]c_uint, _SizeOfElements: c_uint, _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction) ?*c_void;
pub extern fn lfind(_Key: ?*const c_void, _Base: ?*const c_void, _NumOfElements: [*c]c_uint, _SizeOfElements: c_uint, _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction) ?*c_void;
pub extern fn lsearch(_Key: ?*const c_void, _Base: ?*c_void, _NumOfElements: [*c]c_uint, _SizeOfElements: c_uint, _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction) ?*c_void;
pub extern fn _itow_s(_Value: c_int, _Buffer: [*c]wchar_t, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _itow(_Value: c_int, _Buffer: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn _ltow_s(_Value: c_long, _Buffer: [*c]wchar_t, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _ltow(_Value: c_long, _Buffer: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn _ultow_s(_Value: c_ulong, _Buffer: [*c]wchar_t, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _ultow(_Value: c_ulong, _Buffer: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn wcstod(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t)) f64;
pub extern fn _wcstod_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Locale: _locale_t) f64;
pub extern fn wcstol(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int) c_long;
pub extern fn _wcstol_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int, _Locale: _locale_t) c_long;
pub extern fn wcstoll(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int) c_longlong;
pub extern fn _wcstoll_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int, _Locale: _locale_t) c_longlong;
pub extern fn wcstoul(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int) c_ulong;
pub extern fn _wcstoul_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int, _Locale: _locale_t) c_ulong;
pub extern fn wcstoull(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int) c_ulonglong;
pub extern fn _wcstoull_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int, _Locale: _locale_t) c_ulonglong;
pub extern fn wcstold(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t)) c_longdouble;
pub extern fn _wcstold_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Locale: _locale_t) c_longdouble;
pub extern fn wcstof(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t)) f32;
pub extern fn _wcstof_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Locale: _locale_t) f32;
pub extern fn _wtof(_String: [*c]const wchar_t) f64;
pub extern fn _wtof_l(_String: [*c]const wchar_t, _Locale: _locale_t) f64;
pub extern fn _wtoi(_String: [*c]const wchar_t) c_int;
pub extern fn _wtoi_l(_String: [*c]const wchar_t, _Locale: _locale_t) c_int;
pub extern fn _wtol(_String: [*c]const wchar_t) c_long;
pub extern fn _wtol_l(_String: [*c]const wchar_t, _Locale: _locale_t) c_long;
pub extern fn _wtoll(_String: [*c]const wchar_t) c_longlong;
pub extern fn _wtoll_l(_String: [*c]const wchar_t, _Locale: _locale_t) c_longlong;
pub extern fn _i64tow_s(_Value: c_longlong, _Buffer: [*c]wchar_t, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _i64tow(_Value: c_longlong, _Buffer: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn _ui64tow_s(_Value: c_ulonglong, _Buffer: [*c]wchar_t, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _ui64tow(_Value: c_ulonglong, _Buffer: [*c]wchar_t, _Radix: c_int) [*c]wchar_t;
pub extern fn _wtoi64(_String: [*c]const wchar_t) c_longlong;
pub extern fn _wtoi64_l(_String: [*c]const wchar_t, _Locale: _locale_t) c_longlong;
pub extern fn _wcstoi64(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int) c_longlong;
pub extern fn _wcstoi64_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int, _Locale: _locale_t) c_longlong;
pub extern fn _wcstoui64(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int) c_ulonglong;
pub extern fn _wcstoui64_l(_String: [*c]const wchar_t, _EndPtr: [*c]([*c]wchar_t), _Radix: c_int, _Locale: _locale_t) c_ulonglong;
pub extern fn _wfullpath(_Buffer: [*c]wchar_t, _Path: [*c]const wchar_t, _BufferCount: usize) [*c]wchar_t;
pub extern fn _wmakepath_s(_Buffer: [*c]wchar_t, _BufferCount: usize, _Drive: [*c]const wchar_t, _Dir: [*c]const wchar_t, _Filename: [*c]const wchar_t, _Ext: [*c]const wchar_t) errno_t;
pub extern fn _wmakepath(_Buffer: [*c]wchar_t, _Drive: [*c]const wchar_t, _Dir: [*c]const wchar_t, _Filename: [*c]const wchar_t, _Ext: [*c]const wchar_t) void;
pub extern fn _wsplitpath(_FullPath: [*c]const wchar_t, _Drive: [*c]wchar_t, _Dir: [*c]wchar_t, _Filename: [*c]wchar_t, _Ext: [*c]wchar_t) void;
pub extern fn _wsplitpath_s(_FullPath: [*c]const wchar_t, _Drive: [*c]wchar_t, _DriveCount: usize, _Dir: [*c]wchar_t, _DirCount: usize, _Filename: [*c]wchar_t, _FilenameCount: usize, _Ext: [*c]wchar_t, _ExtCount: usize) errno_t;
pub extern fn _wdupenv_s(_Buffer: [*c]([*c]wchar_t), _BufferCount: [*c]usize, _VarName: [*c]const wchar_t) errno_t;
pub extern fn _wgetenv(_VarName: [*c]const wchar_t) [*c]wchar_t;
pub extern fn _wgetenv_s(_RequiredCount: [*c]usize, _Buffer: [*c]wchar_t, _BufferCount: usize, _VarName: [*c]const wchar_t) errno_t;
pub extern fn _wputenv(_EnvString: [*c]const wchar_t) c_int;
pub extern fn _wputenv_s(_Name: [*c]const wchar_t, _Value: [*c]const wchar_t) errno_t;
pub extern fn _wsearchenv_s(_Filename: [*c]const wchar_t, _VarName: [*c]const wchar_t, _Buffer: [*c]wchar_t, _BufferCount: usize) errno_t;
pub extern fn _wsearchenv(_Filename: [*c]const wchar_t, _VarName: [*c]const wchar_t, _ResultPath: [*c]wchar_t) void;
pub extern fn _wsystem(_Command: [*c]const wchar_t) c_int;
pub extern fn _swab(_Buf1: [*c]u8, _Buf2: [*c]u8, _SizeInBytes: c_int) void;
pub extern fn exit(_Code: c_int) noreturn;
pub extern fn _exit(_Code: c_int) noreturn;
pub extern fn _Exit(_Code: c_int) noreturn;
pub extern fn quick_exit(_Code: c_int) noreturn;
pub extern fn abort() noreturn;
pub extern fn _set_abort_behavior(_Flags: c_uint, _Mask: c_uint) c_uint;
pub const _onexit_t = ?extern fn () c_int;
pub extern fn atexit(arg0: ?extern fn () void) c_int;
pub extern fn _onexit(_Func: _onexit_t) _onexit_t;
pub extern fn at_quick_exit(arg0: ?extern fn () void) c_int;
pub const _purecall_handler = ?extern fn () void;
pub const _invalid_parameter_handler = ?extern fn ([*c]const wchar_t, [*c]const wchar_t, [*c]const wchar_t, c_uint, usize) void;
pub extern fn _set_purecall_handler(_Handler: _purecall_handler) _purecall_handler;
pub extern fn _get_purecall_handler() _purecall_handler;
pub extern fn _set_invalid_parameter_handler(_Handler: _invalid_parameter_handler) _invalid_parameter_handler;
pub extern fn _get_invalid_parameter_handler() _invalid_parameter_handler;
pub extern fn _set_thread_local_invalid_parameter_handler(_Handler: _invalid_parameter_handler) _invalid_parameter_handler;
pub extern fn _get_thread_local_invalid_parameter_handler() _invalid_parameter_handler;
pub extern fn _set_error_mode(_Mode: c_int) c_int;
pub extern fn _errno() [*c]c_int;
pub extern fn _set_errno(_Value: c_int) errno_t;
pub extern fn _get_errno(_Value: [*c]c_int) errno_t;
pub extern fn __doserrno() [*c]c_ulong;
pub extern fn _set_doserrno(_Value: c_ulong) errno_t;
pub extern fn _get_doserrno(_Value: [*c]c_ulong) errno_t;
pub extern fn __sys_errlist() [*c]([*c]u8);
pub extern fn __sys_nerr() [*c]c_int;
pub extern fn __p__pgmptr() [*c]([*c]u8);
pub extern fn __p__wpgmptr() [*c]([*c]wchar_t);
pub extern fn __p__fmode() [*c]c_int;
pub extern fn _get_pgmptr(_Value: [*c]([*c]u8)) errno_t;
pub extern fn _get_wpgmptr(_Value: [*c]([*c]wchar_t)) errno_t;
pub extern fn _set_fmode(_Mode: c_int) errno_t;
pub extern fn _get_fmode(_PMode: [*c]c_int) errno_t;
pub const struct__div_t = extern struct {
    quot: c_int,
    rem: c_int,
};
pub const div_t = struct__div_t;
pub const struct__ldiv_t = extern struct {
    quot: c_long,
    rem: c_long,
};
pub const ldiv_t = struct__ldiv_t;
pub const struct__lldiv_t = extern struct {
    quot: c_longlong,
    rem: c_longlong,
};
pub const lldiv_t = struct__lldiv_t;
pub extern fn abs(_Number: c_int) c_int;
pub extern fn labs(_Number: c_long) c_long;
pub extern fn llabs(_Number: c_longlong) c_longlong;
pub extern fn _abs64(_Number: c_longlong) c_longlong;
pub extern fn _byteswap_ushort(_Number: c_ushort) c_ushort;
pub extern fn _byteswap_ulong(_Number: c_ulong) c_ulong;
pub extern fn _byteswap_uint64(_Number: c_ulonglong) c_ulonglong;
pub extern fn div(_Numerator: c_int, _Denominator: c_int) div_t;
pub extern fn ldiv(_Numerator: c_long, _Denominator: c_long) ldiv_t;
pub extern fn lldiv(_Numerator: c_longlong, _Denominator: c_longlong) lldiv_t;
pub extern fn _rotl(_Value: c_uint, _Shift: c_int) c_uint;
pub extern fn _lrotl(_Value: c_ulong, _Shift: c_int) c_ulong;
pub extern fn _rotl64(_Value: c_ulonglong, _Shift: c_int) c_ulonglong;
pub extern fn _rotr(_Value: c_uint, _Shift: c_int) c_uint;
pub extern fn _lrotr(_Value: c_ulong, _Shift: c_int) c_ulong;
pub extern fn _rotr64(_Value: c_ulonglong, _Shift: c_int) c_ulonglong;
pub extern fn srand(_Seed: c_uint) void;
pub extern fn rand() c_int;
pub const _LDOUBLE = extern struct {
    ld: [10]u8,
};
pub const _CRT_DOUBLE = extern struct {
    x: f64,
};
pub const _CRT_FLOAT = extern struct {
    f: f32,
};
pub const _LONGDOUBLE = extern struct {
    x: c_longdouble,
};
pub const _LDBL12 = extern struct {
    ld12: [12]u8,
};
pub extern fn atof(_String: [*c]const u8) f64;
pub extern fn atoi(_String: [*c]const u8) c_int;
pub extern fn atol(_String: [*c]const u8) c_long;
pub extern fn atoll(_String: [*c]const u8) c_longlong;
pub extern fn _atoi64(_String: [*c]const u8) c_longlong;
pub extern fn _atof_l(_String: [*c]const u8, _Locale: _locale_t) f64;
pub extern fn _atoi_l(_String: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn _atol_l(_String: [*c]const u8, _Locale: _locale_t) c_long;
pub extern fn _atoll_l(_String: [*c]const u8, _Locale: _locale_t) c_longlong;
pub extern fn _atoi64_l(_String: [*c]const u8, _Locale: _locale_t) c_longlong;
pub extern fn _atoflt(_Result: [*c]_CRT_FLOAT, _String: [*c]const u8) c_int;
pub extern fn _atodbl(_Result: [*c]_CRT_DOUBLE, _String: [*c]u8) c_int;
pub extern fn _atoldbl(_Result: [*c]_LDOUBLE, _String: [*c]u8) c_int;
pub extern fn _atoflt_l(_Result: [*c]_CRT_FLOAT, _String: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn _atodbl_l(_Result: [*c]_CRT_DOUBLE, _String: [*c]u8, _Locale: _locale_t) c_int;
pub extern fn _atoldbl_l(_Result: [*c]_LDOUBLE, _String: [*c]u8, _Locale: _locale_t) c_int;
pub extern fn strtof(_String: [*c]const u8, _EndPtr: [*c]([*c]u8)) f32;
pub extern fn _strtof_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Locale: _locale_t) f32;
pub extern fn strtod(_String: [*c]const u8, _EndPtr: [*c]([*c]u8)) f64;
pub extern fn _strtod_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Locale: _locale_t) f64;
pub extern fn strtold(_String: [*c]const u8, _EndPtr: [*c]([*c]u8)) c_longdouble;
pub extern fn _strtold_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Locale: _locale_t) c_longdouble;
pub extern fn strtol(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int) c_long;
pub extern fn _strtol_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int, _Locale: _locale_t) c_long;
pub extern fn strtoll(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int) c_longlong;
pub extern fn _strtoll_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int, _Locale: _locale_t) c_longlong;
pub extern fn strtoul(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int) c_ulong;
pub extern fn _strtoul_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int, _Locale: _locale_t) c_ulong;
pub extern fn strtoull(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int) c_ulonglong;
pub extern fn _strtoull_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int, _Locale: _locale_t) c_ulonglong;
pub extern fn _strtoi64(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int) c_longlong;
pub extern fn _strtoi64_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int, _Locale: _locale_t) c_longlong;
pub extern fn _strtoui64(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int) c_ulonglong;
pub extern fn _strtoui64_l(_String: [*c]const u8, _EndPtr: [*c]([*c]u8), _Radix: c_int, _Locale: _locale_t) c_ulonglong;
pub extern fn _itoa_s(_Value: c_int, _Buffer: [*c]u8, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _itoa(_Value: c_int, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn _ltoa_s(_Value: c_long, _Buffer: [*c]u8, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _ltoa(_Value: c_long, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn _ultoa_s(_Value: c_ulong, _Buffer: [*c]u8, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _ultoa(_Value: c_ulong, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn _i64toa_s(_Value: c_longlong, _Buffer: [*c]u8, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _i64toa(_Value: c_longlong, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn _ui64toa_s(_Value: c_ulonglong, _Buffer: [*c]u8, _BufferCount: usize, _Radix: c_int) errno_t;
pub extern fn _ui64toa(_Value: c_ulonglong, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn _ecvt_s(_Buffer: [*c]u8, _BufferCount: usize, _Value: f64, _DigitCount: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) errno_t;
pub extern fn _ecvt(_Value: f64, _DigitCount: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) [*c]u8;
pub extern fn _fcvt_s(_Buffer: [*c]u8, _BufferCount: usize, _Value: f64, _FractionalDigitCount: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) errno_t;
pub extern fn _fcvt(_Value: f64, _FractionalDigitCount: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) [*c]u8;
pub extern fn _gcvt_s(_Buffer: [*c]u8, _BufferCount: usize, _Value: f64, _DigitCount: c_int) errno_t;
pub extern fn _gcvt(_Value: f64, _DigitCount: c_int, _Buffer: [*c]u8) [*c]u8;
pub extern fn ___mb_cur_max_func() c_int;
pub extern fn ___mb_cur_max_l_func(_Locale: _locale_t) c_int;
pub extern fn mblen(_Ch: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn _mblen_l(_Ch: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _mbstrlen(_String: [*c]const u8) usize;
pub extern fn _mbstrlen_l(_String: [*c]const u8, _Locale: _locale_t) usize;
pub extern fn _mbstrnlen(_String: [*c]const u8, _MaxCount: usize) usize;
pub extern fn _mbstrnlen_l(_String: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn mbtowc(_DstCh: [*c]wchar_t, _SrcCh: [*c]const u8, _SrcSizeInBytes: usize) c_int;
pub extern fn _mbtowc_l(_DstCh: [*c]wchar_t, _SrcCh: [*c]const u8, _SrcSizeInBytes: usize, _Locale: _locale_t) c_int;
pub extern fn mbstowcs_s(_PtNumOfCharConverted: [*c]usize, _DstBuf: [*c]wchar_t, _SizeInWords: usize, _SrcBuf: [*c]const u8, _MaxCount: usize) errno_t;
pub extern fn mbstowcs(_Dest: [*c]wchar_t, _Source: [*c]const u8, _MaxCount: usize) usize;
pub extern fn _mbstowcs_s_l(_PtNumOfCharConverted: [*c]usize, _DstBuf: [*c]wchar_t, _SizeInWords: usize, _SrcBuf: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) errno_t;
pub extern fn _mbstowcs_l(_Dest: [*c]wchar_t, _Source: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn wctomb(_MbCh: [*c]u8, _WCh: wchar_t) c_int;
pub extern fn _wctomb_l(_MbCh: [*c]u8, _WCh: wchar_t, _Locale: _locale_t) c_int;
pub extern fn wctomb_s(_SizeConverted: [*c]c_int, _MbCh: [*c]u8, _SizeInBytes: rsize_t, _WCh: wchar_t) errno_t;
pub extern fn _wctomb_s_l(_SizeConverted: [*c]c_int, _MbCh: [*c]u8, _SizeInBytes: usize, _WCh: wchar_t, _Locale: _locale_t) errno_t;
pub extern fn wcstombs_s(_PtNumOfCharConverted: [*c]usize, _Dst: [*c]u8, _DstSizeInBytes: usize, _Src: [*c]const wchar_t, _MaxCountInBytes: usize) errno_t;
pub extern fn wcstombs(_Dest: [*c]u8, _Source: [*c]const wchar_t, _MaxCount: usize) usize;
pub extern fn _wcstombs_s_l(_PtNumOfCharConverted: [*c]usize, _Dst: [*c]u8, _DstSizeInBytes: usize, _Src: [*c]const wchar_t, _MaxCountInBytes: usize, _Locale: _locale_t) errno_t;
pub extern fn _wcstombs_l(_Dest: [*c]u8, _Source: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn _fullpath(_Buffer: [*c]u8, _Path: [*c]const u8, _BufferCount: usize) [*c]u8;
pub extern fn _makepath_s(_Buffer: [*c]u8, _BufferCount: usize, _Drive: [*c]const u8, _Dir: [*c]const u8, _Filename: [*c]const u8, _Ext: [*c]const u8) errno_t;
pub extern fn _makepath(_Buffer: [*c]u8, _Drive: [*c]const u8, _Dir: [*c]const u8, _Filename: [*c]const u8, _Ext: [*c]const u8) void;
pub extern fn _splitpath(_FullPath: [*c]const u8, _Drive: [*c]u8, _Dir: [*c]u8, _Filename: [*c]u8, _Ext: [*c]u8) void;
pub extern fn _splitpath_s(_FullPath: [*c]const u8, _Drive: [*c]u8, _DriveCount: usize, _Dir: [*c]u8, _DirCount: usize, _Filename: [*c]u8, _FilenameCount: usize, _Ext: [*c]u8, _ExtCount: usize) errno_t;
pub extern fn getenv_s(_RequiredCount: [*c]usize, _Buffer: [*c]u8, _BufferCount: rsize_t, _VarName: [*c]const u8) errno_t;
pub extern fn __p___argc() [*c]c_int;
pub extern fn __p___argv() [*c]([*c]([*c]u8));
pub extern fn __p___wargv() [*c]([*c]([*c]wchar_t));
pub extern fn __p__environ() [*c]([*c]([*c]u8));
pub extern fn __p__wenviron() [*c]([*c]([*c]wchar_t));
pub extern fn getenv(_VarName: [*c]const u8) [*c]u8;
pub extern fn _dupenv_s(_Buffer: [*c]([*c]u8), _BufferCount: [*c]usize, _VarName: [*c]const u8) errno_t;
pub extern fn system(_Command: [*c]const u8) c_int;
pub extern fn _putenv(_EnvString: [*c]const u8) c_int;
pub extern fn _putenv_s(_Name: [*c]const u8, _Value: [*c]const u8) errno_t;
pub extern fn _searchenv_s(_Filename: [*c]const u8, _VarName: [*c]const u8, _Buffer: [*c]u8, _BufferCount: usize) errno_t;
pub extern fn _searchenv(_Filename: [*c]const u8, _VarName: [*c]const u8, _Buffer: [*c]u8) void;
pub extern fn _seterrormode(_Mode: c_int) void;
pub extern fn _beep(_Frequency: c_uint, _Duration: c_uint) void;
pub extern fn _sleep(_Duration: c_ulong) void;
pub extern fn ecvt(_Value: f64, _DigitCount: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) [*c]u8;
pub extern fn fcvt(_Value: f64, _FractionalDigitCount: c_int, _PtDec: [*c]c_int, _PtSign: [*c]c_int) [*c]u8;
pub extern fn gcvt(_Value: f64, _DigitCount: c_int, _DstBuf: [*c]u8) [*c]u8;
pub extern fn itoa(_Value: c_int, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn ltoa(_Value: c_long, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn swab(_Buf1: [*c]u8, _Buf2: [*c]u8, _SizeInBytes: c_int) void;
pub extern fn ultoa(_Value: c_ulong, _Buffer: [*c]u8, _Radix: c_int) [*c]u8;
pub extern fn putenv(_EnvString: [*c]const u8) c_int;
pub extern fn onexit(_Func: _onexit_t) _onexit_t;
pub extern fn _clearfp() c_uint;
pub extern fn _controlfp(_NewValue: c_uint, _Mask: c_uint) c_uint;
pub extern fn _set_controlfp(_NewValue: c_uint, _Mask: c_uint) void;
pub extern fn _controlfp_s(_CurrentState: [*c]c_uint, _NewValue: c_uint, _Mask: c_uint) errno_t;
pub extern fn _statusfp() c_uint;
pub extern fn _fpreset() void;
pub extern fn _control87(_NewValue: c_uint, _Mask: c_uint) c_uint;
pub extern fn __fpecode() [*c]c_int;
pub extern fn __fpe_flt_rounds() c_int;
pub extern fn _copysign(_Number: f64, _Sign: f64) f64;
pub extern fn _chgsign(_X: f64) f64;
pub extern fn _scalb(_X: f64, _Y: c_long) f64;
pub extern fn _logb(_X: f64) f64;
pub extern fn _nextafter(_X: f64, _Y: f64) f64;
pub extern fn _finite(_X: f64) c_int;
pub extern fn _isnan(_X: f64) c_int;
pub extern fn _fpclass(_X: f64) c_int;
pub extern fn _scalbf(_X: f32, _Y: c_long) f32;
pub extern fn fpreset() void;
pub const gint8 = i8;
pub const guint8 = u8;
pub const gint16 = c_short;
pub const guint16 = c_ushort;
pub const gint32 = c_int;
pub const guint32 = c_uint;
pub const gint64 = c_longlong;
pub const guint64 = c_ulonglong;
pub const gssize = c_longlong;
pub const gsize = c_ulonglong;
pub const goffset = gint64;
pub const gintptr = c_longlong;
pub const guintptr = c_ulonglong;
pub const GPid = ?*c_void;
pub const struct_tm = extern struct {
    tm_sec: c_int,
    tm_min: c_int,
    tm_hour: c_int,
    tm_mday: c_int,
    tm_mon: c_int,
    tm_year: c_int,
    tm_wday: c_int,
    tm_yday: c_int,
    tm_isdst: c_int,
};
pub extern fn _wasctime(_Tm: [*c]const struct_tm) [*c]wchar_t;
pub extern fn _wasctime_s(_Buffer: [*c]wchar_t, _SizeInWords: usize, _Tm: [*c]const struct_tm) errno_t;
pub extern fn wcsftime(_Buffer: [*c]wchar_t, _SizeInWords: usize, _Format: [*c]const wchar_t, _Tm: [*c]const struct_tm) usize;
pub extern fn _wcsftime_l(_Buffer: [*c]wchar_t, _SizeInWords: usize, _Format: [*c]const wchar_t, _Tm: [*c]const struct_tm, _Locale: _locale_t) usize;
pub extern fn _wctime32(_Time: [*c]const __time32_t) [*c]wchar_t;
pub extern fn _wctime32_s(_Buffer: [*c]wchar_t, _SizeInWords: usize, _Time: [*c]const __time32_t) errno_t;
pub extern fn _wctime64(_Time: [*c]const __time64_t) [*c]wchar_t;
pub extern fn _wctime64_s(_Buffer: [*c]wchar_t, _SizeInWords: usize, _Time: [*c]const __time64_t) errno_t;
pub extern fn _wstrdate_s(_Buffer: [*c]wchar_t, _SizeInWords: usize) errno_t;
pub extern fn _wstrdate(_Buffer: [*c]wchar_t) [*c]wchar_t;
pub extern fn _wstrtime_s(_Buffer: [*c]wchar_t, _SizeInWords: usize) errno_t;
pub extern fn _wstrtime(_Buffer: [*c]wchar_t) [*c]wchar_t;
pub fn _wctime(_Time: [*c]const time_t) [*c]wchar_t {
    return _wctime64(_Time);
}
pub fn _wctime_s(_Buffer: [*c]wchar_t, _SizeInWords: usize, _Time: [*c]const time_t) errno_t {
    return _wctime64_s(_Buffer, _SizeInWords, _Time);
}
pub const clock_t = c_long;
pub const struct__timespec32 = extern struct {
    tv_sec: __time32_t,
    tv_nsec: c_long,
};
pub const struct__timespec64 = extern struct {
    tv_sec: __time64_t,
    tv_nsec: c_long,
};
pub const struct_timespec = extern struct {
    tv_sec: time_t,
    tv_nsec: c_long,
};
pub extern fn __daylight() [*c]c_int;
pub extern fn __dstbias() [*c]c_long;
pub extern fn __timezone() [*c]c_long;
pub extern fn __tzname() [*c]([*c]u8);
pub extern fn _get_daylight(_Daylight: [*c]c_int) errno_t;
pub extern fn _get_dstbias(_DaylightSavingsBias: [*c]c_long) errno_t;
pub extern fn _get_timezone(_TimeZone: [*c]c_long) errno_t;
pub extern fn _get_tzname(_ReturnValue: [*c]usize, _Buffer: [*c]u8, _SizeInBytes: usize, _Index: c_int) errno_t;
pub extern fn asctime(_Tm: [*c]const struct_tm) [*c]u8;
pub extern fn asctime_s(_Buffer: [*c]u8, _SizeInBytes: usize, _Tm: [*c]const struct_tm) errno_t;
pub extern fn clock() clock_t;
pub extern fn _ctime32(_Time: [*c]const __time32_t) [*c]u8;
pub extern fn _ctime32_s(_Buffer: [*c]u8, _SizeInBytes: usize, _Time: [*c]const __time32_t) errno_t;
pub extern fn _ctime64(_Time: [*c]const __time64_t) [*c]u8;
pub extern fn _ctime64_s(_Buffer: [*c]u8, _SizeInBytes: usize, _Time: [*c]const __time64_t) errno_t;
pub extern fn _difftime32(_Time1: __time32_t, _Time2: __time32_t) f64;
pub extern fn _difftime64(_Time1: __time64_t, _Time2: __time64_t) f64;
pub extern fn _gmtime32(_Time: [*c]const __time32_t) [*c]struct_tm;
pub extern fn _gmtime32_s(_Tm: [*c]struct_tm, _Time: [*c]const __time32_t) errno_t;
pub extern fn _gmtime64(_Time: [*c]const __time64_t) [*c]struct_tm;
pub extern fn _gmtime64_s(_Tm: [*c]struct_tm, _Time: [*c]const __time64_t) errno_t;
pub extern fn _localtime32(_Time: [*c]const __time32_t) [*c]struct_tm;
pub extern fn _localtime32_s(_Tm: [*c]struct_tm, _Time: [*c]const __time32_t) errno_t;
pub extern fn _localtime64(_Time: [*c]const __time64_t) [*c]struct_tm;
pub extern fn _localtime64_s(_Tm: [*c]struct_tm, _Time: [*c]const __time64_t) errno_t;
pub extern fn _mkgmtime32(_Tm: [*c]struct_tm) __time32_t;
pub extern fn _mkgmtime64(_Tm: [*c]struct_tm) __time64_t;
pub extern fn _mktime32(_Tm: [*c]struct_tm) __time32_t;
pub extern fn _mktime64(_Tm: [*c]struct_tm) __time64_t;
pub extern fn strftime(_Buffer: [*c]u8, _SizeInBytes: usize, _Format: [*c]const u8, _Tm: [*c]const struct_tm) usize;
pub extern fn _strftime_l(_Buffer: [*c]u8, _MaxSize: usize, _Format: [*c]const u8, _Tm: [*c]const struct_tm, _Locale: _locale_t) usize;
pub extern fn _strdate_s(_Buffer: [*c]u8, _SizeInBytes: usize) errno_t;
pub extern fn _strdate(_Buffer: [*c]u8) [*c]u8;
pub extern fn _strtime_s(_Buffer: [*c]u8, _SizeInBytes: usize) errno_t;
pub extern fn _strtime(_Buffer: [*c]u8) [*c]u8;
pub extern fn _time32(_Time: [*c]__time32_t) __time32_t;
pub extern fn _time64(_Time: [*c]__time64_t) __time64_t;
pub extern fn _timespec32_get(_Ts: [*c]struct__timespec32, _Base: c_int) c_int;
pub extern fn _timespec64_get(_Ts: [*c]struct__timespec64, _Base: c_int) c_int;
pub extern fn _tzset() void;
pub extern fn _getsystime(_Tm: [*c]struct_tm) c_uint;
pub extern fn _setsystime(_Tm: [*c]struct_tm, _Milliseconds: c_uint) c_uint;
pub fn ctime(_Time: [*c]const time_t) [*c]u8 {
    return _ctime64(_Time);
}
pub fn difftime(_Time1: time_t, _Time2: time_t) f64 {
    return _difftime64(_Time1, _Time2);
}
pub fn gmtime(_Time: [*c]const time_t) [*c]struct_tm {
    return _gmtime64(_Time);
}
pub fn localtime(_Time: [*c]const time_t) [*c]struct_tm {
    return _localtime64(_Time);
}
pub fn _mkgmtime(_Tm: [*c]struct_tm) time_t {
    return _mkgmtime64(_Tm);
}
pub fn mktime(_Tm: [*c]struct_tm) time_t {
    return _mktime64(_Tm);
}
pub fn time(_Time: [*c]time_t) time_t {
    return _time64(_Time);
}
pub fn timespec_get(_Ts: [*c]struct_timespec, _Base: c_int) c_int {
    return _timespec64_get(@ptrCast([*c]struct__timespec64, @alignCast(@alignOf(struct__timespec64), _Ts)), _Base);
}
pub fn ctime_s(_Buffer: [*c]u8, _SizeInBytes: usize, _Time: [*c]const time_t) errno_t {
    return _ctime64_s(_Buffer, _SizeInBytes, _Time);
}
pub fn gmtime_s(_Tm: [*c]struct_tm, _Time: [*c]const time_t) errno_t {
    return _gmtime64_s(_Tm, _Time);
}
pub fn localtime_s(_Tm: [*c]struct_tm, _Time: [*c]const time_t) errno_t {
    return _localtime64_s(_Tm, _Time);
}
pub extern fn tzset() void;
pub const gchar = u8;
pub const gshort = c_short;
pub const glong = c_long;
pub const gint = c_int;
pub const gboolean = gint;
pub const guchar = u8;
pub const gushort = c_ushort;
pub const gulong = c_ulong;
pub const guint = c_uint;
pub const gfloat = f32;
pub const gdouble = f64;
pub const gpointer = ?*c_void;
pub const gconstpointer = ?*const c_void;
pub const GCompareFunc = ?extern fn (gconstpointer, gconstpointer) gint;
pub const GCompareDataFunc = ?extern fn (gconstpointer, gconstpointer, gpointer) gint;
pub const GEqualFunc = ?extern fn (gconstpointer, gconstpointer) gboolean;
pub const GDestroyNotify = ?extern fn (gpointer) void;
pub const GFunc = ?extern fn (gpointer, gpointer) void;
pub const GHashFunc = ?extern fn (gconstpointer) guint;
pub const GHFunc = ?extern fn (gpointer, gpointer, gpointer) void;
pub const GCopyFunc = ?extern fn (gconstpointer, gpointer) gpointer;
pub const GFreeFunc = ?extern fn (gpointer) void;
pub const GTranslateFunc = ?extern fn ([*c]const gchar, gpointer) [*c]const gchar;
pub const union__GDoubleIEEE754 = extern union {
    v_double: gdouble,
    mpn: @OpaqueType(),
};
pub const GDoubleIEEE754 = union__GDoubleIEEE754;
pub const union__GFloatIEEE754 = extern union {
    v_float: gfloat,
    mpn: @OpaqueType(),
};
pub const GFloatIEEE754 = union__GFloatIEEE754;
pub const struct__GTimeVal = extern struct {
    tv_sec: glong,
    tv_usec: glong,
};
pub const GTimeVal = struct__GTimeVal;
pub const grefcount = gint;
pub const gatomicrefcount = gint;
pub const struct__heapinfo = extern struct {
    _pentry: [*c]c_int,
    _size: usize,
    _useflag: c_int,
};
pub const _HEAPINFO = struct__heapinfo;
pub extern fn _alloca(_Size: c_ulonglong) ?*c_void;
pub extern fn _get_heap_handle() isize;
pub extern fn _heapmin() c_int;
pub extern fn _heapwalk(_EntryInfo: [*c]_HEAPINFO) c_int;
pub extern fn _heapchk() c_int;
pub extern fn _resetstkoflw() c_int;
pub const __static_assert_t = [1]u8;
pub fn _MarkAllocaS(_arg__Ptr: ?*c_void, _Marker: c_uint) ?*c_void {
    var _Ptr = _arg__Ptr;
    if (_Ptr != null) {
        @ptrCast([*c]c_uint, @alignCast(@alignOf(c_uint), _Ptr)).?.* = _Marker;
        _Ptr = @ptrCast(?*c_void, @ptrCast([*c]u8, @alignCast(@alignOf(u8), _Ptr)) +% 16);
    }
    return _Ptr;
}
pub fn _MallocaComputeSize(_Size: usize) usize {
    var _MarkedSize: usize = _Size +% c_ulonglong(16);
    return if (_MarkedSize > _Size) _MarkedSize else c_ulonglong(0);
}
pub fn _freea(_arg__Memory: ?*c_void) void {
    var _Memory = _arg__Memory;
    var _Marker: c_uint = undefined;
    if (_Memory != null) {
        _Memory = @ptrCast(?*c_void, @ptrCast([*c]u8, @alignCast(@alignOf(u8), _Memory)) -% 16);
        _Marker = @ptrCast([*c]c_uint, @alignCast(@alignOf(c_uint), _Memory)).?.*;
        if (_Marker == c_uint(56797)) {
            free(_Memory);
        }
    }
}
pub const struct__GBytes = @OpaqueType();
pub const GBytes = struct__GBytes;
pub const struct__GArray = extern struct {
    data: [*c]gchar,
    len: guint,
};
pub const GArray = struct__GArray;
pub const struct__GByteArray = extern struct {
    data: [*c]guint8,
    len: guint,
};
pub const GByteArray = struct__GByteArray;
pub const struct__GPtrArray = extern struct {
    pdata: [*c]gpointer,
    len: guint,
};
pub const GPtrArray = struct__GPtrArray;
pub extern fn g_array_new(zero_terminated: gboolean, clear_: gboolean, element_size: guint) [*c]GArray;
pub extern fn g_array_sized_new(zero_terminated: gboolean, clear_: gboolean, element_size: guint, reserved_size: guint) [*c]GArray;
pub extern fn g_array_copy(array: [*c]GArray) [*c]GArray;
pub extern fn g_array_free(array: [*c]GArray, free_segment: gboolean) [*c]gchar;
pub extern fn g_array_ref(array: [*c]GArray) [*c]GArray;
pub extern fn g_array_unref(array: [*c]GArray) void;
pub extern fn g_array_get_element_size(array: [*c]GArray) guint;
pub extern fn g_array_append_vals(array: [*c]GArray, data: gconstpointer, len: guint) [*c]GArray;
pub extern fn g_array_prepend_vals(array: [*c]GArray, data: gconstpointer, len: guint) [*c]GArray;
pub extern fn g_array_insert_vals(array: [*c]GArray, index_: guint, data: gconstpointer, len: guint) [*c]GArray;
pub extern fn g_array_set_size(array: [*c]GArray, length: guint) [*c]GArray;
pub extern fn g_array_remove_index(array: [*c]GArray, index_: guint) [*c]GArray;
pub extern fn g_array_remove_index_fast(array: [*c]GArray, index_: guint) [*c]GArray;
pub extern fn g_array_remove_range(array: [*c]GArray, index_: guint, length: guint) [*c]GArray;
pub extern fn g_array_sort(array: [*c]GArray, compare_func: GCompareFunc) void;
pub extern fn g_array_sort_with_data(array: [*c]GArray, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_array_binary_search(array: [*c]GArray, target: gconstpointer, compare_func: GCompareFunc, out_match_index: [*c]guint) gboolean;
pub extern fn g_array_set_clear_func(array: [*c]GArray, clear_func: GDestroyNotify) void;
pub extern fn g_ptr_array_new() [*c]GPtrArray;
pub extern fn g_ptr_array_new_with_free_func(element_free_func: GDestroyNotify) [*c]GPtrArray;
pub extern fn g_ptr_array_copy(array: [*c]GPtrArray, func: GCopyFunc, user_data: gpointer) [*c]GPtrArray;
pub extern fn g_ptr_array_sized_new(reserved_size: guint) [*c]GPtrArray;
pub extern fn g_ptr_array_new_full(reserved_size: guint, element_free_func: GDestroyNotify) [*c]GPtrArray;
pub extern fn g_ptr_array_free(array: [*c]GPtrArray, free_seg: gboolean) [*c]gpointer;
pub extern fn g_ptr_array_ref(array: [*c]GPtrArray) [*c]GPtrArray;
pub extern fn g_ptr_array_unref(array: [*c]GPtrArray) void;
pub extern fn g_ptr_array_set_free_func(array: [*c]GPtrArray, element_free_func: GDestroyNotify) void;
pub extern fn g_ptr_array_set_size(array: [*c]GPtrArray, length: gint) void;
pub extern fn g_ptr_array_remove_index(array: [*c]GPtrArray, index_: guint) gpointer;
pub extern fn g_ptr_array_remove_index_fast(array: [*c]GPtrArray, index_: guint) gpointer;
pub extern fn g_ptr_array_steal_index(array: [*c]GPtrArray, index_: guint) gpointer;
pub extern fn g_ptr_array_steal_index_fast(array: [*c]GPtrArray, index_: guint) gpointer;
pub extern fn g_ptr_array_remove(array: [*c]GPtrArray, data: gpointer) gboolean;
pub extern fn g_ptr_array_remove_fast(array: [*c]GPtrArray, data: gpointer) gboolean;
pub extern fn g_ptr_array_remove_range(array: [*c]GPtrArray, index_: guint, length: guint) [*c]GPtrArray;
pub extern fn g_ptr_array_add(array: [*c]GPtrArray, data: gpointer) void;
pub extern fn g_ptr_array_extend(array_to_extend: [*c]GPtrArray, array: [*c]GPtrArray, func: GCopyFunc, user_data: gpointer) void;
pub extern fn g_ptr_array_extend_and_steal(array_to_extend: [*c]GPtrArray, array: [*c]GPtrArray) void;
pub extern fn g_ptr_array_insert(array: [*c]GPtrArray, index_: gint, data: gpointer) void;
pub extern fn g_ptr_array_sort(array: [*c]GPtrArray, compare_func: GCompareFunc) void;
pub extern fn g_ptr_array_sort_with_data(array: [*c]GPtrArray, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_ptr_array_foreach(array: [*c]GPtrArray, func: GFunc, user_data: gpointer) void;
pub extern fn g_ptr_array_find(haystack: [*c]GPtrArray, needle: gconstpointer, index_: [*c]guint) gboolean;
pub extern fn g_ptr_array_find_with_equal_func(haystack: [*c]GPtrArray, needle: gconstpointer, equal_func: GEqualFunc, index_: [*c]guint) gboolean;
pub extern fn g_byte_array_new() [*c]GByteArray;
pub extern fn g_byte_array_new_take(data: [*c]guint8, len: gsize) [*c]GByteArray;
pub extern fn g_byte_array_sized_new(reserved_size: guint) [*c]GByteArray;
pub extern fn g_byte_array_free(array: [*c]GByteArray, free_segment: gboolean) [*c]guint8;
pub extern fn g_byte_array_free_to_bytes(array: [*c]GByteArray) ?*GBytes;
pub extern fn g_byte_array_ref(array: [*c]GByteArray) [*c]GByteArray;
pub extern fn g_byte_array_unref(array: [*c]GByteArray) void;
pub extern fn g_byte_array_append(array: [*c]GByteArray, data: [*c]const guint8, len: guint) [*c]GByteArray;
pub extern fn g_byte_array_prepend(array: [*c]GByteArray, data: [*c]const guint8, len: guint) [*c]GByteArray;
pub extern fn g_byte_array_set_size(array: [*c]GByteArray, length: guint) [*c]GByteArray;
pub extern fn g_byte_array_remove_index(array: [*c]GByteArray, index_: guint) [*c]GByteArray;
pub extern fn g_byte_array_remove_index_fast(array: [*c]GByteArray, index_: guint) [*c]GByteArray;
pub extern fn g_byte_array_remove_range(array: [*c]GByteArray, index_: guint, length: guint) [*c]GByteArray;
pub extern fn g_byte_array_sort(array: [*c]GByteArray, compare_func: GCompareFunc) void;
pub extern fn g_byte_array_sort_with_data(array: [*c]GByteArray, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_atomic_int_get(atomic: [*c]const volatile gint) gint;
pub extern fn g_atomic_int_set(atomic: [*c]volatile gint, newval: gint) void;
pub extern fn g_atomic_int_inc(atomic: [*c]volatile gint) void;
pub extern fn g_atomic_int_dec_and_test(atomic: [*c]volatile gint) gboolean;
pub extern fn g_atomic_int_compare_and_exchange(atomic: [*c]volatile gint, oldval: gint, newval: gint) gboolean;
pub extern fn g_atomic_int_add(atomic: [*c]volatile gint, val: gint) gint;
pub extern fn g_atomic_int_and(atomic: [*c]volatile guint, val: guint) guint;
pub extern fn g_atomic_int_or(atomic: [*c]volatile guint, val: guint) guint;
pub extern fn g_atomic_int_xor(atomic: [*c]volatile guint, val: guint) guint;
pub extern fn g_atomic_pointer_get(atomic: ?*const volatile c_void) gpointer;
pub extern fn g_atomic_pointer_set(atomic: ?*volatile c_void, newval: gpointer) void;
pub extern fn g_atomic_pointer_compare_and_exchange(atomic: ?*volatile c_void, oldval: gpointer, newval: gpointer) gboolean;
pub extern fn g_atomic_pointer_add(atomic: ?*volatile c_void, val: gssize) gssize;
pub extern fn g_atomic_pointer_and(atomic: ?*volatile c_void, val: gsize) gsize;
pub extern fn g_atomic_pointer_or(atomic: ?*volatile c_void, val: gsize) gsize;
pub extern fn g_atomic_pointer_xor(atomic: ?*volatile c_void, val: gsize) gsize;
pub extern fn g_atomic_int_exchange_and_add(atomic: [*c]volatile gint, val: gint) gint;
pub const __gnuc_va_list = __builtin_va_list;
pub const GQuark = guint32;
pub extern fn g_quark_try_string(string: [*c]const gchar) GQuark;
pub extern fn g_quark_from_static_string(string: [*c]const gchar) GQuark;
pub extern fn g_quark_from_string(string: [*c]const gchar) GQuark;
pub extern fn g_quark_to_string(quark: GQuark) [*c]const gchar;
pub extern fn g_intern_string(string: [*c]const gchar) [*c]const gchar;
pub extern fn g_intern_static_string(string: [*c]const gchar) [*c]const gchar;
pub const struct__GError = extern struct {
    domain: GQuark,
    code: gint,
    message: [*c]gchar,
};
pub const GError = struct__GError;
pub extern fn g_error_new(domain: GQuark, code: gint, format: [*c]const gchar, ...) [*c]GError;
pub extern fn g_error_new_literal(domain: GQuark, code: gint, message: [*c]const gchar) [*c]GError;
pub extern fn g_error_new_valist(domain: GQuark, code: gint, format: [*c]const gchar, args: va_list) [*c]GError;
pub extern fn g_error_free(@"error": [*c]GError) void;
pub extern fn g_error_copy(@"error": [*c]const GError) [*c]GError;
pub extern fn g_error_matches(@"error": [*c]const GError, domain: GQuark, code: gint) gboolean;
pub extern fn g_set_error(err: [*c]([*c]GError), domain: GQuark, code: gint, format: [*c]const gchar, ...) void;
pub extern fn g_set_error_literal(err: [*c]([*c]GError), domain: GQuark, code: gint, message: [*c]const gchar) void;
pub extern fn g_propagate_error(dest: [*c]([*c]GError), src: [*c]GError) void;
pub extern fn g_clear_error(err: [*c]([*c]GError)) void;
pub extern fn g_prefix_error(err: [*c]([*c]GError), format: [*c]const gchar, ...) void;
pub extern fn g_propagate_prefixed_error(dest: [*c]([*c]GError), src: [*c]GError, format: [*c]const gchar, ...) void;
pub extern fn g_get_user_name() [*c]const gchar;
pub extern fn g_get_real_name() [*c]const gchar;
pub extern fn g_get_home_dir() [*c]const gchar;
pub extern fn g_get_tmp_dir() [*c]const gchar;
pub extern fn g_get_host_name() [*c]const gchar;
pub extern fn g_get_prgname() [*c]const gchar;
pub extern fn g_set_prgname(prgname: [*c]const gchar) void;
pub extern fn g_get_application_name() [*c]const gchar;
pub extern fn g_set_application_name(application_name: [*c]const gchar) void;
pub extern fn g_reload_user_special_dirs_cache() void;
pub extern fn g_get_user_data_dir() [*c]const gchar;
pub extern fn g_get_user_config_dir() [*c]const gchar;
pub extern fn g_get_user_cache_dir() [*c]const gchar;
pub extern fn g_get_system_data_dirs() [*c]const ([*c]const gchar);
pub extern fn g_win32_get_system_data_dirs_for_module(address_of_function: ?extern fn () void) [*c]const ([*c]const gchar);
pub fn _g_win32_get_system_data_dirs() [*c]const ([*c]const gchar) {
    return g_win32_get_system_data_dirs_for_module(@ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), &_g_win32_get_system_data_dirs)));
}
pub extern fn g_get_system_config_dirs() [*c]const ([*c]const gchar);
pub extern fn g_get_user_runtime_dir() [*c]const gchar;
pub const G_USER_DIRECTORY_DESKTOP = 0;
pub const G_USER_DIRECTORY_DOCUMENTS = 1;
pub const G_USER_DIRECTORY_DOWNLOAD = 2;
pub const G_USER_DIRECTORY_MUSIC = 3;
pub const G_USER_DIRECTORY_PICTURES = 4;
pub const G_USER_DIRECTORY_PUBLIC_SHARE = 5;
pub const G_USER_DIRECTORY_TEMPLATES = 6;
pub const G_USER_DIRECTORY_VIDEOS = 7;
pub const G_USER_N_DIRECTORIES = 8;
pub const GUserDirectory = extern enum {
    G_USER_DIRECTORY_DESKTOP = 0,
    G_USER_DIRECTORY_DOCUMENTS = 1,
    G_USER_DIRECTORY_DOWNLOAD = 2,
    G_USER_DIRECTORY_MUSIC = 3,
    G_USER_DIRECTORY_PICTURES = 4,
    G_USER_DIRECTORY_PUBLIC_SHARE = 5,
    G_USER_DIRECTORY_TEMPLATES = 6,
    G_USER_DIRECTORY_VIDEOS = 7,
    G_USER_N_DIRECTORIES = 8,
};
pub extern fn g_get_user_special_dir(directory: GUserDirectory) [*c]const gchar;
pub const struct__GDebugKey = extern struct {
    key: [*c]const gchar,
    value: guint,
};
pub const GDebugKey = struct__GDebugKey;
pub extern fn g_parse_debug_string(string: [*c]const gchar, keys: [*c]const GDebugKey, nkeys: guint) guint;
pub extern fn g_snprintf(string: [*c]gchar, n: gulong, format: [*c]const gchar, ...) gint;
pub extern fn g_vsnprintf(string: [*c]gchar, n: gulong, format: [*c]const gchar, args: va_list) gint;
pub extern fn g_nullify_pointer(nullify_location: [*c]gpointer) void;
pub const G_FORMAT_SIZE_DEFAULT = 0;
pub const G_FORMAT_SIZE_LONG_FORMAT = 1;
pub const G_FORMAT_SIZE_IEC_UNITS = 2;
pub const G_FORMAT_SIZE_BITS = 4;
pub const GFormatSizeFlags = extern enum {
    G_FORMAT_SIZE_DEFAULT = 0,
    G_FORMAT_SIZE_LONG_FORMAT = 1,
    G_FORMAT_SIZE_IEC_UNITS = 2,
    G_FORMAT_SIZE_BITS = 4,
};
pub extern fn g_format_size_full(size: guint64, flags: GFormatSizeFlags) [*c]gchar;
pub extern fn g_format_size(size: guint64) [*c]gchar;
pub extern fn g_format_size_for_display(size: goffset) [*c]gchar;
pub const GVoidFunc = ?extern fn () void;
pub extern fn g_atexit(func: GVoidFunc) void;
pub extern fn g_find_program_in_path(program: [*c]const gchar) [*c]gchar;
pub extern fn g_bit_nth_lsf(mask: gulong, nth_bit: gint) gint;
pub extern fn g_bit_nth_msf(mask: gulong, nth_bit: gint) gint;
pub extern fn g_bit_storage(number: gulong) guint;
pub fn g_bit_nth_lsf_impl(mask: gulong, _arg_nth_bit: gint) gint {
    var nth_bit = _arg_nth_bit;
    if (nth_bit < (-1)) nth_bit = (-1);
    while (nth_bit < ((4 * 8) - 1)) {
        nth_bit += 1;
        if (mask & (1 << @import("std").math.Log2Int(c_ulong)(nth_bit))) return nth_bit;
    }
    return -1;
}
pub fn g_bit_nth_msf_impl(mask: gulong, _arg_nth_bit: gint) gint {
    var nth_bit = _arg_nth_bit;
    if ((nth_bit < 0) or (nth_bit > (4 * 8))) nth_bit = (4 * 8);
    while (nth_bit > 0) {
        nth_bit -= 1;
        if (mask & (1 << @import("std").math.Log2Int(c_ulong)(nth_bit))) return nth_bit;
    }
    return -1;
}
pub fn g_bit_storage_impl(_arg_number: gulong) guint {
    var number = _arg_number;
    var n_bits: guint = guint(0);
    while (true) {
        n_bits +%= 1;
        number >>= @import("std").math.Log2Int(gulong)(1);
        if (!number) break;
    }
    return n_bits;
}
pub extern fn g_abort() void;
pub extern fn g_thread_error_quark() GQuark;
pub const G_THREAD_ERROR_AGAIN = 0;
pub const GThreadError = extern enum {
    G_THREAD_ERROR_AGAIN = 0,
};
pub const GThreadFunc = ?extern fn (gpointer) gpointer;
pub const G_THREAD_PRIORITY_LOW = 0;
pub const G_THREAD_PRIORITY_NORMAL = 1;
pub const G_THREAD_PRIORITY_HIGH = 2;
pub const G_THREAD_PRIORITY_URGENT = 3;
pub const GThreadPriority = extern enum {
    G_THREAD_PRIORITY_LOW = 0,
    G_THREAD_PRIORITY_NORMAL = 1,
    G_THREAD_PRIORITY_HIGH = 2,
    G_THREAD_PRIORITY_URGENT = 3,
};
pub const struct__GThread = extern struct {
    func: GThreadFunc,
    data: gpointer,
    joinable: gboolean,
    priority: GThreadPriority,
};
pub const GThread = struct__GThread;
pub const union__GMutex = extern union {
    p: gpointer,
    i: [2]guint,
};
pub const GMutex = union__GMutex;
pub const struct__GRecMutex = extern struct {
    p: gpointer,
    i: [2]guint,
};
pub const GRecMutex = struct__GRecMutex;
pub const struct__GRWLock = extern struct {
    p: gpointer,
    i: [2]guint,
};
pub const GRWLock = struct__GRWLock;
pub const struct__GCond = extern struct {
    p: gpointer,
    i: [2]guint,
};
pub const GCond = struct__GCond;
pub const struct__GPrivate = extern struct {
    p: gpointer,
    notify: GDestroyNotify,
    future: [2]gpointer,
};
pub const GPrivate = struct__GPrivate;
pub const G_ONCE_STATUS_NOTCALLED = 0;
pub const G_ONCE_STATUS_PROGRESS = 1;
pub const G_ONCE_STATUS_READY = 2;
pub const GOnceStatus = extern enum {
    G_ONCE_STATUS_NOTCALLED = 0,
    G_ONCE_STATUS_PROGRESS = 1,
    G_ONCE_STATUS_READY = 2,
};
pub const struct__GOnce = extern struct {
    status: GOnceStatus,
    retval: gpointer,
};
pub const GOnce = struct__GOnce;
pub extern fn g_thread_ref(thread: [*c]GThread) [*c]GThread;
pub extern fn g_thread_unref(thread: [*c]GThread) void;
pub extern fn g_thread_new(name: [*c]const gchar, func: GThreadFunc, data: gpointer) [*c]GThread;
pub extern fn g_thread_try_new(name: [*c]const gchar, func: GThreadFunc, data: gpointer, @"error": [*c]([*c]GError)) [*c]GThread;
pub extern fn g_thread_self() [*c]GThread;
pub extern fn g_thread_exit(retval: gpointer) void;
pub extern fn g_thread_join(thread: [*c]GThread) gpointer;
pub extern fn g_thread_yield() void;
pub extern fn g_mutex_init(mutex: [*c]GMutex) void;
pub extern fn g_mutex_clear(mutex: [*c]GMutex) void;
pub extern fn g_mutex_lock(mutex: [*c]GMutex) void;
pub extern fn g_mutex_trylock(mutex: [*c]GMutex) gboolean;
pub extern fn g_mutex_unlock(mutex: [*c]GMutex) void;
pub extern fn g_rw_lock_init(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_clear(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_writer_lock(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_writer_trylock(rw_lock: [*c]GRWLock) gboolean;
pub extern fn g_rw_lock_writer_unlock(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_reader_lock(rw_lock: [*c]GRWLock) void;
pub extern fn g_rw_lock_reader_trylock(rw_lock: [*c]GRWLock) gboolean;
pub extern fn g_rw_lock_reader_unlock(rw_lock: [*c]GRWLock) void;
pub extern fn g_rec_mutex_init(rec_mutex: [*c]GRecMutex) void;
pub extern fn g_rec_mutex_clear(rec_mutex: [*c]GRecMutex) void;
pub extern fn g_rec_mutex_lock(rec_mutex: [*c]GRecMutex) void;
pub extern fn g_rec_mutex_trylock(rec_mutex: [*c]GRecMutex) gboolean;
pub extern fn g_rec_mutex_unlock(rec_mutex: [*c]GRecMutex) void;
pub extern fn g_cond_init(cond: [*c]GCond) void;
pub extern fn g_cond_clear(cond: [*c]GCond) void;
pub extern fn g_cond_wait(cond: [*c]GCond, mutex: [*c]GMutex) void;
pub extern fn g_cond_signal(cond: [*c]GCond) void;
pub extern fn g_cond_broadcast(cond: [*c]GCond) void;
pub extern fn g_cond_wait_until(cond: [*c]GCond, mutex: [*c]GMutex, end_time: gint64) gboolean;
pub extern fn g_private_get(key: [*c]GPrivate) gpointer;
pub extern fn g_private_set(key: [*c]GPrivate, value: gpointer) void;
pub extern fn g_private_replace(key: [*c]GPrivate, value: gpointer) void;
pub extern fn g_once_impl(once: [*c]GOnce, func: GThreadFunc, arg: gpointer) gpointer;
pub extern fn g_once_init_enter(location: ?*volatile c_void) gboolean;
pub extern fn g_once_init_leave(location: ?*volatile c_void, result: gsize) void;
pub extern fn g_get_num_processors() guint;
pub const GMutexLocker = c_void;
pub fn g_mutex_locker_new(mutex: [*c]GMutex) ?*GMutexLocker {
    g_mutex_lock(mutex);
    return @ptrCast(?*GMutexLocker, mutex);
}
pub fn g_mutex_locker_free(locker: ?*GMutexLocker) void {
    g_mutex_unlock(@ptrCast([*c]GMutex, @alignCast(@alignOf(GMutex), locker)));
}
pub const GRecMutexLocker = c_void;
pub fn g_rec_mutex_locker_new(rec_mutex: [*c]GRecMutex) ?*GRecMutexLocker {
    g_rec_mutex_lock(rec_mutex);
    return @ptrCast(?*GRecMutexLocker, rec_mutex);
}
pub fn g_rec_mutex_locker_free(locker: ?*GRecMutexLocker) void {
    g_rec_mutex_unlock(@ptrCast([*c]GRecMutex, @alignCast(@alignOf(GRecMutex), locker)));
}
pub const GRWLockWriterLocker = c_void;
pub fn g_rw_lock_writer_locker_new(rw_lock: [*c]GRWLock) ?*GRWLockWriterLocker {
    g_rw_lock_writer_lock(rw_lock);
    return @ptrCast(?*GRWLockWriterLocker, rw_lock);
}
pub fn g_rw_lock_writer_locker_free(locker: ?*GRWLockWriterLocker) void {
    g_rw_lock_writer_unlock(@ptrCast([*c]GRWLock, @alignCast(@alignOf(GRWLock), locker)));
}
pub const GRWLockReaderLocker = c_void;
pub fn g_rw_lock_reader_locker_new(rw_lock: [*c]GRWLock) ?*GRWLockReaderLocker {
    g_rw_lock_reader_lock(rw_lock);
    return @ptrCast(?*GRWLockReaderLocker, rw_lock);
}
pub fn g_rw_lock_reader_locker_free(locker: ?*GRWLockReaderLocker) void {
    g_rw_lock_reader_unlock(@ptrCast([*c]GRWLock, @alignCast(@alignOf(GRWLock), locker)));
}
pub const struct__GAsyncQueue = @OpaqueType();
pub const GAsyncQueue = struct__GAsyncQueue;
pub extern fn g_async_queue_new() ?*GAsyncQueue;
pub extern fn g_async_queue_new_full(item_free_func: GDestroyNotify) ?*GAsyncQueue;
pub extern fn g_async_queue_lock(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_unlock(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_ref(queue: ?*GAsyncQueue) ?*GAsyncQueue;
pub extern fn g_async_queue_unref(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_ref_unlocked(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_unref_and_unlock(queue: ?*GAsyncQueue) void;
pub extern fn g_async_queue_push(queue: ?*GAsyncQueue, data: gpointer) void;
pub extern fn g_async_queue_push_unlocked(queue: ?*GAsyncQueue, data: gpointer) void;
pub extern fn g_async_queue_push_sorted(queue: ?*GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_async_queue_push_sorted_unlocked(queue: ?*GAsyncQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_async_queue_pop(queue: ?*GAsyncQueue) gpointer;
pub extern fn g_async_queue_pop_unlocked(queue: ?*GAsyncQueue) gpointer;
pub extern fn g_async_queue_try_pop(queue: ?*GAsyncQueue) gpointer;
pub extern fn g_async_queue_try_pop_unlocked(queue: ?*GAsyncQueue) gpointer;
pub extern fn g_async_queue_timeout_pop(queue: ?*GAsyncQueue, timeout: guint64) gpointer;
pub extern fn g_async_queue_timeout_pop_unlocked(queue: ?*GAsyncQueue, timeout: guint64) gpointer;
pub extern fn g_async_queue_length(queue: ?*GAsyncQueue) gint;
pub extern fn g_async_queue_length_unlocked(queue: ?*GAsyncQueue) gint;
pub extern fn g_async_queue_sort(queue: ?*GAsyncQueue, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_async_queue_sort_unlocked(queue: ?*GAsyncQueue, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_async_queue_remove(queue: ?*GAsyncQueue, item: gpointer) gboolean;
pub extern fn g_async_queue_remove_unlocked(queue: ?*GAsyncQueue, item: gpointer) gboolean;
pub extern fn g_async_queue_push_front(queue: ?*GAsyncQueue, item: gpointer) void;
pub extern fn g_async_queue_push_front_unlocked(queue: ?*GAsyncQueue, item: gpointer) void;
pub extern fn g_async_queue_timed_pop(queue: ?*GAsyncQueue, end_time: [*c]GTimeVal) gpointer;
pub extern fn g_async_queue_timed_pop_unlocked(queue: ?*GAsyncQueue, end_time: [*c]GTimeVal) gpointer;
pub const sig_atomic_t = c_int;
pub const _crt_signal_t = ?extern fn (c_int) void;
pub extern fn __pxcptinfoptrs() [*c](?*c_void);
pub extern fn signal(_Signal: c_int, _Function: _crt_signal_t) _crt_signal_t;
pub extern fn raise(_Signal: c_int) c_int;
pub extern fn g_on_error_query(prg_name: [*c]const gchar) void;
pub extern fn g_on_error_stack_trace(prg_name: [*c]const gchar) void;
pub extern fn g_base64_encode_step(in: [*c]const guchar, len: gsize, break_lines: gboolean, out: [*c]gchar, state: [*c]gint, save: [*c]gint) gsize;
pub extern fn g_base64_encode_close(break_lines: gboolean, out: [*c]gchar, state: [*c]gint, save: [*c]gint) gsize;
pub extern fn g_base64_encode(data: [*c]const guchar, len: gsize) [*c]gchar;
pub extern fn g_base64_decode_step(in: [*c]const gchar, len: gsize, out: [*c]guchar, state: [*c]gint, save: [*c]guint) gsize;
pub extern fn g_base64_decode(text: [*c]const gchar, out_len: [*c]gsize) [*c]guchar;
pub extern fn g_base64_decode_inplace(text: [*c]gchar, out_len: [*c]gsize) [*c]guchar;
pub extern fn g_bit_lock(address: [*c]volatile gint, lock_bit: gint) void;
pub extern fn g_bit_trylock(address: [*c]volatile gint, lock_bit: gint) gboolean;
pub extern fn g_bit_unlock(address: [*c]volatile gint, lock_bit: gint) void;
pub extern fn g_pointer_bit_lock(address: ?*volatile c_void, lock_bit: gint) void;
pub extern fn g_pointer_bit_trylock(address: ?*volatile c_void, lock_bit: gint) gboolean;
pub extern fn g_pointer_bit_unlock(address: ?*volatile c_void, lock_bit: gint) void;
pub const G_BOOKMARK_FILE_ERROR_INVALID_URI = 0;
pub const G_BOOKMARK_FILE_ERROR_INVALID_VALUE = 1;
pub const G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED = 2;
pub const G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND = 3;
pub const G_BOOKMARK_FILE_ERROR_READ = 4;
pub const G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING = 5;
pub const G_BOOKMARK_FILE_ERROR_WRITE = 6;
pub const G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND = 7;
pub const GBookmarkFileError = extern enum {
    G_BOOKMARK_FILE_ERROR_INVALID_URI = 0,
    G_BOOKMARK_FILE_ERROR_INVALID_VALUE = 1,
    G_BOOKMARK_FILE_ERROR_APP_NOT_REGISTERED = 2,
    G_BOOKMARK_FILE_ERROR_URI_NOT_FOUND = 3,
    G_BOOKMARK_FILE_ERROR_READ = 4,
    G_BOOKMARK_FILE_ERROR_UNKNOWN_ENCODING = 5,
    G_BOOKMARK_FILE_ERROR_WRITE = 6,
    G_BOOKMARK_FILE_ERROR_FILE_NOT_FOUND = 7,
};
pub extern fn g_bookmark_file_error_quark() GQuark;
pub const struct__GBookmarkFile = @OpaqueType();
pub const GBookmarkFile = struct__GBookmarkFile;
pub extern fn g_bookmark_file_new() ?*GBookmarkFile;
pub extern fn g_bookmark_file_free(bookmark: ?*GBookmarkFile) void;
pub extern fn g_bookmark_file_load_from_file(bookmark: ?*GBookmarkFile, filename: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bookmark_file_load_from_data(bookmark: ?*GBookmarkFile, data: [*c]const gchar, length: gsize, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bookmark_file_load_from_data_dirs(bookmark: ?*GBookmarkFile, file: [*c]const gchar, full_path: [*c]([*c]gchar), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bookmark_file_to_data(bookmark: ?*GBookmarkFile, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_bookmark_file_to_file(bookmark: ?*GBookmarkFile, filename: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bookmark_file_set_title(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, title: [*c]const gchar) void;
pub extern fn g_bookmark_file_get_title(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_bookmark_file_set_description(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, description: [*c]const gchar) void;
pub extern fn g_bookmark_file_get_description(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_bookmark_file_set_mime_type(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, mime_type: [*c]const gchar) void;
pub extern fn g_bookmark_file_get_mime_type(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_bookmark_file_set_groups(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, groups: [*c]([*c]const gchar), length: gsize) void;
pub extern fn g_bookmark_file_add_group(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, group: [*c]const gchar) void;
pub extern fn g_bookmark_file_has_group(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, group: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bookmark_file_get_groups(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]([*c]gchar);
pub extern fn g_bookmark_file_add_application(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, exec: [*c]const gchar) void;
pub extern fn g_bookmark_file_has_application(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bookmark_file_get_applications(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]([*c]gchar);
pub extern fn g_bookmark_file_set_app_info(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, exec: [*c]const gchar, count: gint, stamp: time_t, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bookmark_file_get_app_info(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, exec: [*c]([*c]gchar), count: [*c]guint, stamp: [*c]time_t, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bookmark_file_set_is_private(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, is_private: gboolean) void;
pub extern fn g_bookmark_file_get_is_private(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bookmark_file_set_icon(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, href: [*c]const gchar, mime_type: [*c]const gchar) void;
pub extern fn g_bookmark_file_get_icon(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, href: [*c]([*c]gchar), mime_type: [*c]([*c]gchar), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bookmark_file_set_added(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, added: time_t) void;
pub extern fn g_bookmark_file_get_added(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c]([*c]GError)) time_t;
pub extern fn g_bookmark_file_set_modified(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, modified: time_t) void;
pub extern fn g_bookmark_file_get_modified(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c]([*c]GError)) time_t;
pub extern fn g_bookmark_file_set_visited(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, visited: time_t) void;
pub extern fn g_bookmark_file_get_visited(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c]([*c]GError)) time_t;
pub extern fn g_bookmark_file_has_item(bookmark: ?*GBookmarkFile, uri: [*c]const gchar) gboolean;
pub extern fn g_bookmark_file_get_size(bookmark: ?*GBookmarkFile) gint;
pub extern fn g_bookmark_file_get_uris(bookmark: ?*GBookmarkFile, length: [*c]gsize) [*c]([*c]gchar);
pub extern fn g_bookmark_file_remove_group(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, group: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bookmark_file_remove_application(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, name: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bookmark_file_remove_item(bookmark: ?*GBookmarkFile, uri: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bookmark_file_move_item(bookmark: ?*GBookmarkFile, old_uri: [*c]const gchar, new_uri: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_bytes_new(data: gconstpointer, size: gsize) ?*GBytes;
pub extern fn g_bytes_new_take(data: gpointer, size: gsize) ?*GBytes;
pub extern fn g_bytes_new_static(data: gconstpointer, size: gsize) ?*GBytes;
pub extern fn g_bytes_new_with_free_func(data: gconstpointer, size: gsize, free_func: GDestroyNotify, user_data: gpointer) ?*GBytes;
pub extern fn g_bytes_new_from_bytes(bytes: ?*GBytes, offset: gsize, length: gsize) ?*GBytes;
pub extern fn g_bytes_get_data(bytes: ?*GBytes, size: [*c]gsize) gconstpointer;
pub extern fn g_bytes_get_size(bytes: ?*GBytes) gsize;
pub extern fn g_bytes_ref(bytes: ?*GBytes) ?*GBytes;
pub extern fn g_bytes_unref(bytes: ?*GBytes) void;
pub extern fn g_bytes_unref_to_data(bytes: ?*GBytes, size: [*c]gsize) gpointer;
pub extern fn g_bytes_unref_to_array(bytes: ?*GBytes) [*c]GByteArray;
pub extern fn g_bytes_hash(bytes: gconstpointer) guint;
pub extern fn g_bytes_equal(bytes1: gconstpointer, bytes2: gconstpointer) gboolean;
pub extern fn g_bytes_compare(bytes1: gconstpointer, bytes2: gconstpointer) gint;
pub extern fn g_get_charset(charset: [*c]([*c]const u8)) gboolean;
pub extern fn g_get_codeset() [*c]gchar;
pub extern fn g_get_console_charset(charset: [*c]([*c]const u8)) gboolean;
pub extern fn g_get_language_names() [*c]const ([*c]const gchar);
pub extern fn g_get_language_names_with_category(category_name: [*c]const gchar) [*c]const ([*c]const gchar);
pub extern fn g_get_locale_variants(locale: [*c]const gchar) [*c]([*c]gchar);
pub const G_CHECKSUM_MD5 = 0;
pub const G_CHECKSUM_SHA1 = 1;
pub const G_CHECKSUM_SHA256 = 2;
pub const G_CHECKSUM_SHA512 = 3;
pub const G_CHECKSUM_SHA384 = 4;
pub const GChecksumType = extern enum {
    G_CHECKSUM_MD5 = 0,
    G_CHECKSUM_SHA1 = 1,
    G_CHECKSUM_SHA256 = 2,
    G_CHECKSUM_SHA512 = 3,
    G_CHECKSUM_SHA384 = 4,
};
pub const struct__GChecksum = @OpaqueType();
pub const GChecksum = struct__GChecksum;
pub extern fn g_checksum_type_get_length(checksum_type: GChecksumType) gssize;
pub extern fn g_checksum_new(checksum_type: GChecksumType) ?*GChecksum;
pub extern fn g_checksum_reset(checksum: ?*GChecksum) void;
pub extern fn g_checksum_copy(checksum: ?*const GChecksum) ?*GChecksum;
pub extern fn g_checksum_free(checksum: ?*GChecksum) void;
pub extern fn g_checksum_update(checksum: ?*GChecksum, data: [*c]const guchar, length: gssize) void;
pub extern fn g_checksum_get_string(checksum: ?*GChecksum) [*c]const gchar;
pub extern fn g_checksum_get_digest(checksum: ?*GChecksum, buffer: [*c]guint8, digest_len: [*c]gsize) void;
pub extern fn g_compute_checksum_for_data(checksum_type: GChecksumType, data: [*c]const guchar, length: gsize) [*c]gchar;
pub extern fn g_compute_checksum_for_string(checksum_type: GChecksumType, str: [*c]const gchar, length: gssize) [*c]gchar;
pub extern fn g_compute_checksum_for_bytes(checksum_type: GChecksumType, data: ?*GBytes) [*c]gchar;
pub const G_CONVERT_ERROR_NO_CONVERSION = 0;
pub const G_CONVERT_ERROR_ILLEGAL_SEQUENCE = 1;
pub const G_CONVERT_ERROR_FAILED = 2;
pub const G_CONVERT_ERROR_PARTIAL_INPUT = 3;
pub const G_CONVERT_ERROR_BAD_URI = 4;
pub const G_CONVERT_ERROR_NOT_ABSOLUTE_PATH = 5;
pub const G_CONVERT_ERROR_NO_MEMORY = 6;
pub const G_CONVERT_ERROR_EMBEDDED_NUL = 7;
pub const GConvertError = extern enum {
    G_CONVERT_ERROR_NO_CONVERSION = 0,
    G_CONVERT_ERROR_ILLEGAL_SEQUENCE = 1,
    G_CONVERT_ERROR_FAILED = 2,
    G_CONVERT_ERROR_PARTIAL_INPUT = 3,
    G_CONVERT_ERROR_BAD_URI = 4,
    G_CONVERT_ERROR_NOT_ABSOLUTE_PATH = 5,
    G_CONVERT_ERROR_NO_MEMORY = 6,
    G_CONVERT_ERROR_EMBEDDED_NUL = 7,
};
pub extern fn g_convert_error_quark() GQuark;
pub const struct__GIConv = @OpaqueType();
pub const GIConv = ?*struct__GIConv;
pub extern fn g_iconv_open(to_codeset: [*c]const gchar, from_codeset: [*c]const gchar) GIConv;
pub extern fn g_iconv(converter: GIConv, inbuf: [*c]([*c]gchar), inbytes_left: [*c]gsize, outbuf: [*c]([*c]gchar), outbytes_left: [*c]gsize) gsize;
pub extern fn g_iconv_close(converter: GIConv) gint;
pub extern fn g_convert(str: [*c]const gchar, len: gssize, to_codeset: [*c]const gchar, from_codeset: [*c]const gchar, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_convert_with_iconv(str: [*c]const gchar, len: gssize, converter: GIConv, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_convert_with_fallback(str: [*c]const gchar, len: gssize, to_codeset: [*c]const gchar, from_codeset: [*c]const gchar, fallback: [*c]const gchar, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_locale_to_utf8(opsysstring: [*c]const gchar, len: gssize, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_locale_from_utf8(utf8string: [*c]const gchar, len: gssize, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_filename_to_utf8(opsysstring: [*c]const gchar, len: gssize, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_filename_from_utf8(utf8string: [*c]const gchar, len: gssize, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_filename_from_uri(uri: [*c]const gchar, hostname: [*c]([*c]gchar), @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_filename_to_uri(filename: [*c]const gchar, hostname: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_filename_display_name(filename: [*c]const gchar) [*c]gchar;
pub extern fn g_get_filename_charsets(filename_charsets: [*c]([*c]([*c]const gchar))) gboolean;
pub extern fn g_filename_display_basename(filename: [*c]const gchar) [*c]gchar;
pub extern fn g_uri_list_extract_uris(uri_list: [*c]const gchar) [*c]([*c]gchar);
pub const struct__GData = @OpaqueType();
pub const GData = struct__GData;
pub const GDataForeachFunc = ?extern fn (GQuark, gpointer, gpointer) void;
pub extern fn g_datalist_init(datalist: [*c](?*GData)) void;
pub extern fn g_datalist_clear(datalist: [*c](?*GData)) void;
pub extern fn g_datalist_id_get_data(datalist: [*c](?*GData), key_id: GQuark) gpointer;
pub extern fn g_datalist_id_set_data_full(datalist: [*c](?*GData), key_id: GQuark, data: gpointer, destroy_func: GDestroyNotify) void;
pub const GDuplicateFunc = ?extern fn (gpointer, gpointer) gpointer;
pub extern fn g_datalist_id_dup_data(datalist: [*c](?*GData), key_id: GQuark, dup_func: GDuplicateFunc, user_data: gpointer) gpointer;
pub extern fn g_datalist_id_replace_data(datalist: [*c](?*GData), key_id: GQuark, oldval: gpointer, newval: gpointer, destroy: GDestroyNotify, old_destroy: [*c]GDestroyNotify) gboolean;
pub extern fn g_datalist_id_remove_no_notify(datalist: [*c](?*GData), key_id: GQuark) gpointer;
pub extern fn g_datalist_foreach(datalist: [*c](?*GData), func: GDataForeachFunc, user_data: gpointer) void;
pub extern fn g_datalist_set_flags(datalist: [*c](?*GData), flags: guint) void;
pub extern fn g_datalist_unset_flags(datalist: [*c](?*GData), flags: guint) void;
pub extern fn g_datalist_get_flags(datalist: [*c](?*GData)) guint;
pub extern fn g_dataset_destroy(dataset_location: gconstpointer) void;
pub extern fn g_dataset_id_get_data(dataset_location: gconstpointer, key_id: GQuark) gpointer;
pub extern fn g_datalist_get_data(datalist: [*c](?*GData), key: [*c]const gchar) gpointer;
pub extern fn g_dataset_id_set_data_full(dataset_location: gconstpointer, key_id: GQuark, data: gpointer, destroy_func: GDestroyNotify) void;
pub extern fn g_dataset_id_remove_no_notify(dataset_location: gconstpointer, key_id: GQuark) gpointer;
pub extern fn g_dataset_foreach(dataset_location: gconstpointer, func: GDataForeachFunc, user_data: gpointer) void;
pub const GTime = gint32;
pub const GDateYear = guint16;
pub const GDateDay = guint8;
pub const struct__GDate = @OpaqueType();
pub const GDate = struct__GDate;
pub const G_DATE_DAY = 0;
pub const G_DATE_MONTH = 1;
pub const G_DATE_YEAR = 2;
pub const GDateDMY = extern enum {
    G_DATE_DAY = 0,
    G_DATE_MONTH = 1,
    G_DATE_YEAR = 2,
};
pub const G_DATE_BAD_WEEKDAY = 0;
pub const G_DATE_MONDAY = 1;
pub const G_DATE_TUESDAY = 2;
pub const G_DATE_WEDNESDAY = 3;
pub const G_DATE_THURSDAY = 4;
pub const G_DATE_FRIDAY = 5;
pub const G_DATE_SATURDAY = 6;
pub const G_DATE_SUNDAY = 7;
pub const GDateWeekday = extern enum {
    G_DATE_BAD_WEEKDAY = 0,
    G_DATE_MONDAY = 1,
    G_DATE_TUESDAY = 2,
    G_DATE_WEDNESDAY = 3,
    G_DATE_THURSDAY = 4,
    G_DATE_FRIDAY = 5,
    G_DATE_SATURDAY = 6,
    G_DATE_SUNDAY = 7,
};
pub const G_DATE_BAD_MONTH = 0;
pub const G_DATE_JANUARY = 1;
pub const G_DATE_FEBRUARY = 2;
pub const G_DATE_MARCH = 3;
pub const G_DATE_APRIL = 4;
pub const G_DATE_MAY = 5;
pub const G_DATE_JUNE = 6;
pub const G_DATE_JULY = 7;
pub const G_DATE_AUGUST = 8;
pub const G_DATE_SEPTEMBER = 9;
pub const G_DATE_OCTOBER = 10;
pub const G_DATE_NOVEMBER = 11;
pub const G_DATE_DECEMBER = 12;
pub const GDateMonth = extern enum {
    G_DATE_BAD_MONTH = 0,
    G_DATE_JANUARY = 1,
    G_DATE_FEBRUARY = 2,
    G_DATE_MARCH = 3,
    G_DATE_APRIL = 4,
    G_DATE_MAY = 5,
    G_DATE_JUNE = 6,
    G_DATE_JULY = 7,
    G_DATE_AUGUST = 8,
    G_DATE_SEPTEMBER = 9,
    G_DATE_OCTOBER = 10,
    G_DATE_NOVEMBER = 11,
    G_DATE_DECEMBER = 12,
};
pub extern fn g_date_new() ?*GDate;
pub extern fn g_date_new_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) ?*GDate;
pub extern fn g_date_new_julian(julian_day: guint32) ?*GDate;
pub extern fn g_date_free(date: ?*GDate) void;
pub extern fn g_date_copy(date: ?*const GDate) ?*GDate;
pub extern fn g_date_valid(date: ?*const GDate) gboolean;
pub extern fn g_date_valid_day(day: GDateDay) gboolean;
pub extern fn g_date_valid_month(month: GDateMonth) gboolean;
pub extern fn g_date_valid_year(year: GDateYear) gboolean;
pub extern fn g_date_valid_weekday(weekday: GDateWeekday) gboolean;
pub extern fn g_date_valid_julian(julian_date: guint32) gboolean;
pub extern fn g_date_valid_dmy(day: GDateDay, month: GDateMonth, year: GDateYear) gboolean;
pub extern fn g_date_get_weekday(date: ?*const GDate) GDateWeekday;
pub extern fn g_date_get_month(date: ?*const GDate) GDateMonth;
pub extern fn g_date_get_year(date: ?*const GDate) GDateYear;
pub extern fn g_date_get_day(date: ?*const GDate) GDateDay;
pub extern fn g_date_get_julian(date: ?*const GDate) guint32;
pub extern fn g_date_get_day_of_year(date: ?*const GDate) guint;
pub extern fn g_date_get_monday_week_of_year(date: ?*const GDate) guint;
pub extern fn g_date_get_sunday_week_of_year(date: ?*const GDate) guint;
pub extern fn g_date_get_iso8601_week_of_year(date: ?*const GDate) guint;
pub extern fn g_date_clear(date: ?*GDate, n_dates: guint) void;
pub extern fn g_date_set_parse(date: ?*GDate, str: [*c]const gchar) void;
pub extern fn g_date_set_time_t(date: ?*GDate, timet: time_t) void;
pub extern fn g_date_set_time_val(date: ?*GDate, timeval: [*c]GTimeVal) void;
pub extern fn g_date_set_time(date: ?*GDate, time_: GTime) void;
pub extern fn g_date_set_month(date: ?*GDate, month: GDateMonth) void;
pub extern fn g_date_set_day(date: ?*GDate, day: GDateDay) void;
pub extern fn g_date_set_year(date: ?*GDate, year: GDateYear) void;
pub extern fn g_date_set_dmy(date: ?*GDate, day: GDateDay, month: GDateMonth, y: GDateYear) void;
pub extern fn g_date_set_julian(date: ?*GDate, julian_date: guint32) void;
pub extern fn g_date_is_first_of_month(date: ?*const GDate) gboolean;
pub extern fn g_date_is_last_of_month(date: ?*const GDate) gboolean;
pub extern fn g_date_add_days(date: ?*GDate, n_days: guint) void;
pub extern fn g_date_subtract_days(date: ?*GDate, n_days: guint) void;
pub extern fn g_date_add_months(date: ?*GDate, n_months: guint) void;
pub extern fn g_date_subtract_months(date: ?*GDate, n_months: guint) void;
pub extern fn g_date_add_years(date: ?*GDate, n_years: guint) void;
pub extern fn g_date_subtract_years(date: ?*GDate, n_years: guint) void;
pub extern fn g_date_is_leap_year(year: GDateYear) gboolean;
pub extern fn g_date_get_days_in_month(month: GDateMonth, year: GDateYear) guint8;
pub extern fn g_date_get_monday_weeks_in_year(year: GDateYear) guint8;
pub extern fn g_date_get_sunday_weeks_in_year(year: GDateYear) guint8;
pub extern fn g_date_days_between(date1: ?*const GDate, date2: ?*const GDate) gint;
pub extern fn g_date_compare(lhs: ?*const GDate, rhs: ?*const GDate) gint;
pub extern fn g_date_to_struct_tm(date: ?*const GDate, tm: [*c]struct_tm) void;
pub extern fn g_date_clamp(date: ?*GDate, min_date: ?*const GDate, max_date: ?*const GDate) void;
pub extern fn g_date_order(date1: ?*GDate, date2: ?*GDate) void;
pub extern fn g_date_strftime(s: [*c]gchar, slen: gsize, format: [*c]const gchar, date: ?*const GDate) gsize;
pub const struct__GTimeZone = @OpaqueType();
pub const GTimeZone = struct__GTimeZone;
pub const G_TIME_TYPE_STANDARD = 0;
pub const G_TIME_TYPE_DAYLIGHT = 1;
pub const G_TIME_TYPE_UNIVERSAL = 2;
pub const GTimeType = extern enum {
    G_TIME_TYPE_STANDARD = 0,
    G_TIME_TYPE_DAYLIGHT = 1,
    G_TIME_TYPE_UNIVERSAL = 2,
};
pub extern fn g_time_zone_new(identifier: [*c]const gchar) ?*GTimeZone;
pub extern fn g_time_zone_new_utc() ?*GTimeZone;
pub extern fn g_time_zone_new_local() ?*GTimeZone;
pub extern fn g_time_zone_new_offset(seconds: gint32) ?*GTimeZone;
pub extern fn g_time_zone_ref(tz: ?*GTimeZone) ?*GTimeZone;
pub extern fn g_time_zone_unref(tz: ?*GTimeZone) void;
pub extern fn g_time_zone_find_interval(tz: ?*GTimeZone, type_0: GTimeType, time_: gint64) gint;
pub extern fn g_time_zone_adjust_time(tz: ?*GTimeZone, type_0: GTimeType, time_: [*c]gint64) gint;
pub extern fn g_time_zone_get_abbreviation(tz: ?*GTimeZone, interval: gint) [*c]const gchar;
pub extern fn g_time_zone_get_offset(tz: ?*GTimeZone, interval: gint) gint32;
pub extern fn g_time_zone_is_dst(tz: ?*GTimeZone, interval: gint) gboolean;
pub extern fn g_time_zone_get_identifier(tz: ?*GTimeZone) [*c]const gchar;
pub const GTimeSpan = gint64;
pub const struct__GDateTime = @OpaqueType();
pub const GDateTime = struct__GDateTime;
pub extern fn g_date_time_unref(datetime: ?*GDateTime) void;
pub extern fn g_date_time_ref(datetime: ?*GDateTime) ?*GDateTime;
pub extern fn g_date_time_new_now(tz: ?*GTimeZone) ?*GDateTime;
pub extern fn g_date_time_new_now_local() ?*GDateTime;
pub extern fn g_date_time_new_now_utc() ?*GDateTime;
pub extern fn g_date_time_new_from_unix_local(t: gint64) ?*GDateTime;
pub extern fn g_date_time_new_from_unix_utc(t: gint64) ?*GDateTime;
pub extern fn g_date_time_new_from_timeval_local(tv: [*c]const GTimeVal) ?*GDateTime;
pub extern fn g_date_time_new_from_timeval_utc(tv: [*c]const GTimeVal) ?*GDateTime;
pub extern fn g_date_time_new_from_iso8601(text: [*c]const gchar, default_tz: ?*GTimeZone) ?*GDateTime;
pub extern fn g_date_time_new(tz: ?*GTimeZone, year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_new_local(year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_new_utc(year: gint, month: gint, day: gint, hour: gint, minute: gint, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_add(datetime: ?*GDateTime, timespan: GTimeSpan) ?*GDateTime;
pub extern fn g_date_time_add_years(datetime: ?*GDateTime, years: gint) ?*GDateTime;
pub extern fn g_date_time_add_months(datetime: ?*GDateTime, months: gint) ?*GDateTime;
pub extern fn g_date_time_add_weeks(datetime: ?*GDateTime, weeks: gint) ?*GDateTime;
pub extern fn g_date_time_add_days(datetime: ?*GDateTime, days: gint) ?*GDateTime;
pub extern fn g_date_time_add_hours(datetime: ?*GDateTime, hours: gint) ?*GDateTime;
pub extern fn g_date_time_add_minutes(datetime: ?*GDateTime, minutes: gint) ?*GDateTime;
pub extern fn g_date_time_add_seconds(datetime: ?*GDateTime, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_add_full(datetime: ?*GDateTime, years: gint, months: gint, days: gint, hours: gint, minutes: gint, seconds: gdouble) ?*GDateTime;
pub extern fn g_date_time_compare(dt1: gconstpointer, dt2: gconstpointer) gint;
pub extern fn g_date_time_difference(end: ?*GDateTime, begin: ?*GDateTime) GTimeSpan;
pub extern fn g_date_time_hash(datetime: gconstpointer) guint;
pub extern fn g_date_time_equal(dt1: gconstpointer, dt2: gconstpointer) gboolean;
pub extern fn g_date_time_get_ymd(datetime: ?*GDateTime, year: [*c]gint, month: [*c]gint, day: [*c]gint) void;
pub extern fn g_date_time_get_year(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_month(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_day_of_month(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_week_numbering_year(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_week_of_year(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_day_of_week(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_day_of_year(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_hour(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_minute(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_second(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_microsecond(datetime: ?*GDateTime) gint;
pub extern fn g_date_time_get_seconds(datetime: ?*GDateTime) gdouble;
pub extern fn g_date_time_to_unix(datetime: ?*GDateTime) gint64;
pub extern fn g_date_time_to_timeval(datetime: ?*GDateTime, tv: [*c]GTimeVal) gboolean;
pub extern fn g_date_time_get_utc_offset(datetime: ?*GDateTime) GTimeSpan;
pub extern fn g_date_time_get_timezone(datetime: ?*GDateTime) ?*GTimeZone;
pub extern fn g_date_time_get_timezone_abbreviation(datetime: ?*GDateTime) [*c]const gchar;
pub extern fn g_date_time_is_daylight_savings(datetime: ?*GDateTime) gboolean;
pub extern fn g_date_time_to_timezone(datetime: ?*GDateTime, tz: ?*GTimeZone) ?*GDateTime;
pub extern fn g_date_time_to_local(datetime: ?*GDateTime) ?*GDateTime;
pub extern fn g_date_time_to_utc(datetime: ?*GDateTime) ?*GDateTime;
pub extern fn g_date_time_format(datetime: ?*GDateTime, format: [*c]const gchar) [*c]gchar;
pub extern fn g_date_time_format_iso8601(datetime: ?*GDateTime) [*c]gchar;
pub const struct__GDir = @OpaqueType();
pub const GDir = struct__GDir;
pub extern fn g_dir_open(path: [*c]const gchar, flags: guint, @"error": [*c]([*c]GError)) ?*GDir;
pub extern fn g_dir_read_name(dir: ?*GDir) [*c]const gchar;
pub extern fn g_dir_rewind(dir: ?*GDir) void;
pub extern fn g_dir_close(dir: ?*GDir) void;
pub extern fn g_getenv(variable: [*c]const gchar) [*c]const gchar;
pub extern fn g_setenv(variable: [*c]const gchar, value: [*c]const gchar, overwrite: gboolean) gboolean;
pub extern fn g_unsetenv(variable: [*c]const gchar) void;
pub extern fn g_listenv() [*c]([*c]gchar);
pub extern fn g_get_environ() [*c]([*c]gchar);
pub extern fn g_environ_getenv(envp: [*c]([*c]gchar), variable: [*c]const gchar) [*c]const gchar;
pub extern fn g_environ_setenv(envp: [*c]([*c]gchar), variable: [*c]const gchar, value: [*c]const gchar, overwrite: gboolean) [*c]([*c]gchar);
pub extern fn g_environ_unsetenv(envp: [*c]([*c]gchar), variable: [*c]const gchar) [*c]([*c]gchar);
pub const G_FILE_ERROR_EXIST = 0;
pub const G_FILE_ERROR_ISDIR = 1;
pub const G_FILE_ERROR_ACCES = 2;
pub const G_FILE_ERROR_NAMETOOLONG = 3;
pub const G_FILE_ERROR_NOENT = 4;
pub const G_FILE_ERROR_NOTDIR = 5;
pub const G_FILE_ERROR_NXIO = 6;
pub const G_FILE_ERROR_NODEV = 7;
pub const G_FILE_ERROR_ROFS = 8;
pub const G_FILE_ERROR_TXTBSY = 9;
pub const G_FILE_ERROR_FAULT = 10;
pub const G_FILE_ERROR_LOOP = 11;
pub const G_FILE_ERROR_NOSPC = 12;
pub const G_FILE_ERROR_NOMEM = 13;
pub const G_FILE_ERROR_MFILE = 14;
pub const G_FILE_ERROR_NFILE = 15;
pub const G_FILE_ERROR_BADF = 16;
pub const G_FILE_ERROR_INVAL = 17;
pub const G_FILE_ERROR_PIPE = 18;
pub const G_FILE_ERROR_AGAIN = 19;
pub const G_FILE_ERROR_INTR = 20;
pub const G_FILE_ERROR_IO = 21;
pub const G_FILE_ERROR_PERM = 22;
pub const G_FILE_ERROR_NOSYS = 23;
pub const G_FILE_ERROR_FAILED = 24;
pub const GFileError = extern enum {
    G_FILE_ERROR_EXIST = 0,
    G_FILE_ERROR_ISDIR = 1,
    G_FILE_ERROR_ACCES = 2,
    G_FILE_ERROR_NAMETOOLONG = 3,
    G_FILE_ERROR_NOENT = 4,
    G_FILE_ERROR_NOTDIR = 5,
    G_FILE_ERROR_NXIO = 6,
    G_FILE_ERROR_NODEV = 7,
    G_FILE_ERROR_ROFS = 8,
    G_FILE_ERROR_TXTBSY = 9,
    G_FILE_ERROR_FAULT = 10,
    G_FILE_ERROR_LOOP = 11,
    G_FILE_ERROR_NOSPC = 12,
    G_FILE_ERROR_NOMEM = 13,
    G_FILE_ERROR_MFILE = 14,
    G_FILE_ERROR_NFILE = 15,
    G_FILE_ERROR_BADF = 16,
    G_FILE_ERROR_INVAL = 17,
    G_FILE_ERROR_PIPE = 18,
    G_FILE_ERROR_AGAIN = 19,
    G_FILE_ERROR_INTR = 20,
    G_FILE_ERROR_IO = 21,
    G_FILE_ERROR_PERM = 22,
    G_FILE_ERROR_NOSYS = 23,
    G_FILE_ERROR_FAILED = 24,
};
pub const G_FILE_TEST_IS_REGULAR = 1;
pub const G_FILE_TEST_IS_SYMLINK = 2;
pub const G_FILE_TEST_IS_DIR = 4;
pub const G_FILE_TEST_IS_EXECUTABLE = 8;
pub const G_FILE_TEST_EXISTS = 16;
pub const GFileTest = extern enum {
    G_FILE_TEST_IS_REGULAR = 1,
    G_FILE_TEST_IS_SYMLINK = 2,
    G_FILE_TEST_IS_DIR = 4,
    G_FILE_TEST_IS_EXECUTABLE = 8,
    G_FILE_TEST_EXISTS = 16,
};
pub extern fn g_file_error_quark() GQuark;
pub extern fn g_file_error_from_errno(err_no: gint) GFileError;
pub extern fn g_file_test(filename: [*c]const gchar, @"test": GFileTest) gboolean;
pub extern fn g_file_get_contents(filename: [*c]const gchar, contents: [*c]([*c]gchar), length: [*c]gsize, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_set_contents(filename: [*c]const gchar, contents: [*c]const gchar, length: gssize, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_read_link(filename: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_mkdtemp(tmpl: [*c]gchar) [*c]gchar;
pub extern fn g_mkdtemp_full(tmpl: [*c]gchar, mode: gint) [*c]gchar;
pub extern fn g_mkstemp(tmpl: [*c]gchar) gint;
pub extern fn g_mkstemp_full(tmpl: [*c]gchar, flags: gint, mode: gint) gint;
pub extern fn g_file_open_tmp(tmpl: [*c]const gchar, name_used: [*c]([*c]gchar), @"error": [*c]([*c]GError)) gint;
pub extern fn g_dir_make_tmp(tmpl: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_build_path(separator: [*c]const gchar, first_element: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_build_pathv(separator: [*c]const gchar, args: [*c]([*c]gchar)) [*c]gchar;
pub extern fn g_build_filename(first_element: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_build_filenamev(args: [*c]([*c]gchar)) [*c]gchar;
pub extern fn g_build_filename_valist(first_element: [*c]const gchar, args: [*c]va_list) [*c]gchar;
pub extern fn g_mkdir_with_parents(pathname: [*c]const gchar, mode: gint) gint;
pub extern fn g_path_is_absolute(file_name: [*c]const gchar) gboolean;
pub extern fn g_path_skip_root(file_name: [*c]const gchar) [*c]const gchar;
pub extern fn g_basename(file_name: [*c]const gchar) [*c]const gchar;
pub extern fn g_get_current_dir() [*c]gchar;
pub extern fn g_path_get_basename(file_name: [*c]const gchar) [*c]gchar;
pub extern fn g_path_get_dirname(file_name: [*c]const gchar) [*c]gchar;
pub extern fn g_canonicalize_filename(filename: [*c]const gchar, relative_to: [*c]const gchar) [*c]gchar;
pub extern fn g_strip_context(msgid: [*c]const gchar, msgval: [*c]const gchar) [*c]const gchar;
pub extern fn g_dgettext(domain: [*c]const gchar, msgid: [*c]const gchar) [*c]const gchar;
pub extern fn g_dcgettext(domain: [*c]const gchar, msgid: [*c]const gchar, category: gint) [*c]const gchar;
pub extern fn g_dngettext(domain: [*c]const gchar, msgid: [*c]const gchar, msgid_plural: [*c]const gchar, n: gulong) [*c]const gchar;
pub extern fn g_dpgettext(domain: [*c]const gchar, msgctxtid: [*c]const gchar, msgidoffset: gsize) [*c]const gchar;
pub extern fn g_dpgettext2(domain: [*c]const gchar, context: [*c]const gchar, msgid: [*c]const gchar) [*c]const gchar;
pub const struct__GMemVTable = extern struct {
    malloc: ?extern fn (gsize) gpointer,
    realloc: ?extern fn (gpointer, gsize) gpointer,
    free: ?extern fn (gpointer) void,
    calloc: ?extern fn (gsize, gsize) gpointer,
    try_malloc: ?extern fn (gsize) gpointer,
    try_realloc: ?extern fn (gpointer, gsize) gpointer,
};
pub const GMemVTable = struct__GMemVTable;
pub extern fn g_free(mem: gpointer) void;
pub extern fn g_clear_pointer(pp: [*c]gpointer, destroy: GDestroyNotify) void;
pub extern fn g_malloc(n_bytes: gsize) gpointer;
pub extern fn g_malloc0(n_bytes: gsize) gpointer;
pub extern fn g_realloc(mem: gpointer, n_bytes: gsize) gpointer;
pub extern fn g_try_malloc(n_bytes: gsize) gpointer;
pub extern fn g_try_malloc0(n_bytes: gsize) gpointer;
pub extern fn g_try_realloc(mem: gpointer, n_bytes: gsize) gpointer;
pub extern fn g_malloc_n(n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_try_malloc_n(n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_try_malloc0_n(n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub extern fn g_try_realloc_n(mem: gpointer, n_blocks: gsize, n_block_bytes: gsize) gpointer;
pub fn g_steal_pointer(pp: gpointer) gpointer {
    var ptr: [*c]gpointer = @ptrCast([*c]gpointer, @alignCast(@alignOf(gpointer), pp));
    var ref: gpointer = undefined;
    ref = ptr.?.*;
    ptr.?.* = (?*c_void)(0);
    return ref;
}
pub extern fn g_mem_set_vtable(vtable: [*c]GMemVTable) void;
pub extern fn g_mem_is_system_malloc() gboolean;
pub extern var g_mem_gc_friendly: gboolean;
pub extern var glib_mem_profiler_table: [*c]GMemVTable;
pub extern fn g_mem_profile() void;
pub const GNode = struct__GNode;
pub const struct__GNode = extern struct {
    data: gpointer,
    next: [*c]GNode,
    prev: [*c]GNode,
    parent: [*c]GNode,
    children: [*c]GNode,
};
pub const G_TRAVERSE_LEAVES = 1;
pub const G_TRAVERSE_NON_LEAVES = 2;
pub const G_TRAVERSE_ALL = 3;
pub const G_TRAVERSE_MASK = 3;
pub const G_TRAVERSE_LEAFS = 1;
pub const G_TRAVERSE_NON_LEAFS = 2;
pub const GTraverseFlags = extern enum {
    G_TRAVERSE_LEAVES = 1,
    G_TRAVERSE_NON_LEAVES = 2,
    G_TRAVERSE_ALL = 3,
    G_TRAVERSE_MASK = 3,
    G_TRAVERSE_LEAFS = 1,
    G_TRAVERSE_NON_LEAFS = 2,
};
pub const G_IN_ORDER = 0;
pub const G_PRE_ORDER = 1;
pub const G_POST_ORDER = 2;
pub const G_LEVEL_ORDER = 3;
pub const GTraverseType = extern enum {
    G_IN_ORDER = 0,
    G_PRE_ORDER = 1,
    G_POST_ORDER = 2,
    G_LEVEL_ORDER = 3,
};
pub const GNodeTraverseFunc = ?extern fn ([*c]GNode, gpointer) gboolean;
pub const GNodeForeachFunc = ?extern fn ([*c]GNode, gpointer) void;
pub extern fn g_node_new(data: gpointer) [*c]GNode;
pub extern fn g_node_destroy(root: [*c]GNode) void;
pub extern fn g_node_unlink(node: [*c]GNode) void;
pub extern fn g_node_copy_deep(node: [*c]GNode, copy_func: GCopyFunc, data: gpointer) [*c]GNode;
pub extern fn g_node_copy(node: [*c]GNode) [*c]GNode;
pub extern fn g_node_insert(parent: [*c]GNode, position: gint, node: [*c]GNode) [*c]GNode;
pub extern fn g_node_insert_before(parent: [*c]GNode, sibling: [*c]GNode, node: [*c]GNode) [*c]GNode;
pub extern fn g_node_insert_after(parent: [*c]GNode, sibling: [*c]GNode, node: [*c]GNode) [*c]GNode;
pub extern fn g_node_prepend(parent: [*c]GNode, node: [*c]GNode) [*c]GNode;
pub extern fn g_node_n_nodes(root: [*c]GNode, flags: GTraverseFlags) guint;
pub extern fn g_node_get_root(node: [*c]GNode) [*c]GNode;
pub extern fn g_node_is_ancestor(node: [*c]GNode, descendant: [*c]GNode) gboolean;
pub extern fn g_node_depth(node: [*c]GNode) guint;
pub extern fn g_node_find(root: [*c]GNode, order: GTraverseType, flags: GTraverseFlags, data: gpointer) [*c]GNode;
pub extern fn g_node_traverse(root: [*c]GNode, order: GTraverseType, flags: GTraverseFlags, max_depth: gint, func: GNodeTraverseFunc, data: gpointer) void;
pub extern fn g_node_max_height(root: [*c]GNode) guint;
pub extern fn g_node_children_foreach(node: [*c]GNode, flags: GTraverseFlags, func: GNodeForeachFunc, data: gpointer) void;
pub extern fn g_node_reverse_children(node: [*c]GNode) void;
pub extern fn g_node_n_children(node: [*c]GNode) guint;
pub extern fn g_node_nth_child(node: [*c]GNode, n: guint) [*c]GNode;
pub extern fn g_node_last_child(node: [*c]GNode) [*c]GNode;
pub extern fn g_node_find_child(node: [*c]GNode, flags: GTraverseFlags, data: gpointer) [*c]GNode;
pub extern fn g_node_child_position(node: [*c]GNode, child: [*c]GNode) gint;
pub extern fn g_node_child_index(node: [*c]GNode, data: gpointer) gint;
pub extern fn g_node_first_sibling(node: [*c]GNode) [*c]GNode;
pub extern fn g_node_last_sibling(node: [*c]GNode) [*c]GNode;
pub const GList = struct__GList;
pub const struct__GList = extern struct {
    data: gpointer,
    next: [*c]GList,
    prev: [*c]GList,
};
pub extern fn g_list_alloc() [*c]GList;
pub extern fn g_list_free(list: [*c]GList) void;
pub extern fn g_list_free_1(list: [*c]GList) void;
pub extern fn g_list_free_full(list: [*c]GList, free_func: GDestroyNotify) void;
pub extern fn g_list_append(list: [*c]GList, data: gpointer) [*c]GList;
pub extern fn g_list_prepend(list: [*c]GList, data: gpointer) [*c]GList;
pub extern fn g_list_insert(list: [*c]GList, data: gpointer, position: gint) [*c]GList;
pub extern fn g_list_insert_sorted(list: [*c]GList, data: gpointer, func: GCompareFunc) [*c]GList;
pub extern fn g_list_insert_sorted_with_data(list: [*c]GList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) [*c]GList;
pub extern fn g_list_insert_before(list: [*c]GList, sibling: [*c]GList, data: gpointer) [*c]GList;
pub extern fn g_list_insert_before_link(list: [*c]GList, sibling: [*c]GList, link_: [*c]GList) [*c]GList;
pub extern fn g_list_concat(list1: [*c]GList, list2: [*c]GList) [*c]GList;
pub extern fn g_list_remove(list: [*c]GList, data: gconstpointer) [*c]GList;
pub extern fn g_list_remove_all(list: [*c]GList, data: gconstpointer) [*c]GList;
pub extern fn g_list_remove_link(list: [*c]GList, llink: [*c]GList) [*c]GList;
pub extern fn g_list_delete_link(list: [*c]GList, link_: [*c]GList) [*c]GList;
pub extern fn g_list_reverse(list: [*c]GList) [*c]GList;
pub extern fn g_list_copy(list: [*c]GList) [*c]GList;
pub extern fn g_list_copy_deep(list: [*c]GList, func: GCopyFunc, user_data: gpointer) [*c]GList;
pub extern fn g_list_nth(list: [*c]GList, n: guint) [*c]GList;
pub extern fn g_list_nth_prev(list: [*c]GList, n: guint) [*c]GList;
pub extern fn g_list_find(list: [*c]GList, data: gconstpointer) [*c]GList;
pub extern fn g_list_find_custom(list: [*c]GList, data: gconstpointer, func: GCompareFunc) [*c]GList;
pub extern fn g_list_position(list: [*c]GList, llink: [*c]GList) gint;
pub extern fn g_list_index(list: [*c]GList, data: gconstpointer) gint;
pub extern fn g_list_last(list: [*c]GList) [*c]GList;
pub extern fn g_list_first(list: [*c]GList) [*c]GList;
pub extern fn g_list_length(list: [*c]GList) guint;
pub extern fn g_list_foreach(list: [*c]GList, func: GFunc, user_data: gpointer) void;
pub extern fn g_list_sort(list: [*c]GList, compare_func: GCompareFunc) [*c]GList;
pub extern fn g_list_sort_with_data(list: [*c]GList, compare_func: GCompareDataFunc, user_data: gpointer) [*c]GList;
pub extern fn g_list_nth_data(list: [*c]GList, n: guint) gpointer;
pub const struct__GHashTable = @OpaqueType();
pub const GHashTable = struct__GHashTable;
pub const GHRFunc = ?extern fn (gpointer, gpointer, gpointer) gboolean;
pub const struct__GHashTableIter = extern struct {
    dummy1: gpointer,
    dummy2: gpointer,
    dummy3: gpointer,
    dummy4: c_int,
    dummy5: gboolean,
    dummy6: gpointer,
};
pub const GHashTableIter = struct__GHashTableIter;
pub extern fn g_hash_table_new(hash_func: GHashFunc, key_equal_func: GEqualFunc) ?*GHashTable;
pub extern fn g_hash_table_new_full(hash_func: GHashFunc, key_equal_func: GEqualFunc, key_destroy_func: GDestroyNotify, value_destroy_func: GDestroyNotify) ?*GHashTable;
pub extern fn g_hash_table_destroy(hash_table: ?*GHashTable) void;
pub extern fn g_hash_table_insert(hash_table: ?*GHashTable, key: gpointer, value: gpointer) gboolean;
pub extern fn g_hash_table_replace(hash_table: ?*GHashTable, key: gpointer, value: gpointer) gboolean;
pub extern fn g_hash_table_add(hash_table: ?*GHashTable, key: gpointer) gboolean;
pub extern fn g_hash_table_remove(hash_table: ?*GHashTable, key: gconstpointer) gboolean;
pub extern fn g_hash_table_remove_all(hash_table: ?*GHashTable) void;
pub extern fn g_hash_table_steal(hash_table: ?*GHashTable, key: gconstpointer) gboolean;
pub extern fn g_hash_table_steal_extended(hash_table: ?*GHashTable, lookup_key: gconstpointer, stolen_key: [*c]gpointer, stolen_value: [*c]gpointer) gboolean;
pub extern fn g_hash_table_steal_all(hash_table: ?*GHashTable) void;
pub extern fn g_hash_table_lookup(hash_table: ?*GHashTable, key: gconstpointer) gpointer;
pub extern fn g_hash_table_contains(hash_table: ?*GHashTable, key: gconstpointer) gboolean;
pub extern fn g_hash_table_lookup_extended(hash_table: ?*GHashTable, lookup_key: gconstpointer, orig_key: [*c]gpointer, value: [*c]gpointer) gboolean;
pub extern fn g_hash_table_foreach(hash_table: ?*GHashTable, func: GHFunc, user_data: gpointer) void;
pub extern fn g_hash_table_find(hash_table: ?*GHashTable, predicate: GHRFunc, user_data: gpointer) gpointer;
pub extern fn g_hash_table_foreach_remove(hash_table: ?*GHashTable, func: GHRFunc, user_data: gpointer) guint;
pub extern fn g_hash_table_foreach_steal(hash_table: ?*GHashTable, func: GHRFunc, user_data: gpointer) guint;
pub extern fn g_hash_table_size(hash_table: ?*GHashTable) guint;
pub extern fn g_hash_table_get_keys(hash_table: ?*GHashTable) [*c]GList;
pub extern fn g_hash_table_get_values(hash_table: ?*GHashTable) [*c]GList;
pub extern fn g_hash_table_get_keys_as_array(hash_table: ?*GHashTable, length: [*c]guint) [*c]gpointer;
pub extern fn g_hash_table_iter_init(iter: [*c]GHashTableIter, hash_table: ?*GHashTable) void;
pub extern fn g_hash_table_iter_next(iter: [*c]GHashTableIter, key: [*c]gpointer, value: [*c]gpointer) gboolean;
pub extern fn g_hash_table_iter_get_hash_table(iter: [*c]GHashTableIter) ?*GHashTable;
pub extern fn g_hash_table_iter_remove(iter: [*c]GHashTableIter) void;
pub extern fn g_hash_table_iter_replace(iter: [*c]GHashTableIter, value: gpointer) void;
pub extern fn g_hash_table_iter_steal(iter: [*c]GHashTableIter) void;
pub extern fn g_hash_table_ref(hash_table: ?*GHashTable) ?*GHashTable;
pub extern fn g_hash_table_unref(hash_table: ?*GHashTable) void;
pub extern fn g_str_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub extern fn g_str_hash(v: gconstpointer) guint;
pub extern fn g_int_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub extern fn g_int_hash(v: gconstpointer) guint;
pub extern fn g_int64_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub extern fn g_int64_hash(v: gconstpointer) guint;
pub extern fn g_double_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub extern fn g_double_hash(v: gconstpointer) guint;
pub extern fn g_direct_hash(v: gconstpointer) guint;
pub extern fn g_direct_equal(v1: gconstpointer, v2: gconstpointer) gboolean;
pub const struct__GHmac = @OpaqueType();
pub const GHmac = struct__GHmac;
pub extern fn g_hmac_new(digest_type: GChecksumType, key: [*c]const guchar, key_len: gsize) ?*GHmac;
pub extern fn g_hmac_copy(hmac: ?*const GHmac) ?*GHmac;
pub extern fn g_hmac_ref(hmac: ?*GHmac) ?*GHmac;
pub extern fn g_hmac_unref(hmac: ?*GHmac) void;
pub extern fn g_hmac_update(hmac: ?*GHmac, data: [*c]const guchar, length: gssize) void;
pub extern fn g_hmac_get_string(hmac: ?*GHmac) [*c]const gchar;
pub extern fn g_hmac_get_digest(hmac: ?*GHmac, buffer: [*c]guint8, digest_len: [*c]gsize) void;
pub extern fn g_compute_hmac_for_data(digest_type: GChecksumType, key: [*c]const guchar, key_len: gsize, data: [*c]const guchar, length: gsize) [*c]gchar;
pub extern fn g_compute_hmac_for_string(digest_type: GChecksumType, key: [*c]const guchar, key_len: gsize, str: [*c]const gchar, length: gssize) [*c]gchar;
pub extern fn g_compute_hmac_for_bytes(digest_type: GChecksumType, key: ?*GBytes, data: ?*GBytes) [*c]gchar;
pub const GHook = struct__GHook;
pub const struct__GHook = extern struct {
    data: gpointer,
    next: [*c]GHook,
    prev: [*c]GHook,
    ref_count: guint,
    hook_id: gulong,
    flags: guint,
    func: gpointer,
    destroy: GDestroyNotify,
};
pub const struct__GHookList = @OpaqueType();
pub const GHookList = struct__GHookList;
pub const GHookCompareFunc = ?extern fn ([*c]GHook, [*c]GHook) gint;
pub const GHookFindFunc = ?extern fn ([*c]GHook, gpointer) gboolean;
pub const GHookMarshaller = ?extern fn ([*c]GHook, gpointer) void;
pub const GHookCheckMarshaller = ?extern fn ([*c]GHook, gpointer) gboolean;
pub const GHookFunc = ?extern fn (gpointer) void;
pub const GHookCheckFunc = ?extern fn (gpointer) gboolean;
pub const GHookFinalizeFunc = ?extern fn (?*GHookList, [*c]GHook) void;
pub const G_HOOK_FLAG_ACTIVE = 1;
pub const G_HOOK_FLAG_IN_CALL = 2;
pub const G_HOOK_FLAG_MASK = 15;
pub const GHookFlagMask = extern enum {
    G_HOOK_FLAG_ACTIVE = 1,
    G_HOOK_FLAG_IN_CALL = 2,
    G_HOOK_FLAG_MASK = 15,
};
pub extern fn g_hook_list_init(hook_list: ?*GHookList, hook_size: guint) void;
pub extern fn g_hook_list_clear(hook_list: ?*GHookList) void;
pub extern fn g_hook_alloc(hook_list: ?*GHookList) [*c]GHook;
pub extern fn g_hook_free(hook_list: ?*GHookList, hook: [*c]GHook) void;
pub extern fn g_hook_ref(hook_list: ?*GHookList, hook: [*c]GHook) [*c]GHook;
pub extern fn g_hook_unref(hook_list: ?*GHookList, hook: [*c]GHook) void;
pub extern fn g_hook_destroy(hook_list: ?*GHookList, hook_id: gulong) gboolean;
pub extern fn g_hook_destroy_link(hook_list: ?*GHookList, hook: [*c]GHook) void;
pub extern fn g_hook_prepend(hook_list: ?*GHookList, hook: [*c]GHook) void;
pub extern fn g_hook_insert_before(hook_list: ?*GHookList, sibling: [*c]GHook, hook: [*c]GHook) void;
pub extern fn g_hook_insert_sorted(hook_list: ?*GHookList, hook: [*c]GHook, func: GHookCompareFunc) void;
pub extern fn g_hook_get(hook_list: ?*GHookList, hook_id: gulong) [*c]GHook;
pub extern fn g_hook_find(hook_list: ?*GHookList, need_valids: gboolean, func: GHookFindFunc, data: gpointer) [*c]GHook;
pub extern fn g_hook_find_data(hook_list: ?*GHookList, need_valids: gboolean, data: gpointer) [*c]GHook;
pub extern fn g_hook_find_func(hook_list: ?*GHookList, need_valids: gboolean, func: gpointer) [*c]GHook;
pub extern fn g_hook_find_func_data(hook_list: ?*GHookList, need_valids: gboolean, func: gpointer, data: gpointer) [*c]GHook;
pub extern fn g_hook_first_valid(hook_list: ?*GHookList, may_be_in_call: gboolean) [*c]GHook;
pub extern fn g_hook_next_valid(hook_list: ?*GHookList, hook: [*c]GHook, may_be_in_call: gboolean) [*c]GHook;
pub extern fn g_hook_compare_ids(new_hook: [*c]GHook, sibling: [*c]GHook) gint;
pub extern fn g_hook_list_invoke(hook_list: ?*GHookList, may_recurse: gboolean) void;
pub extern fn g_hook_list_invoke_check(hook_list: ?*GHookList, may_recurse: gboolean) void;
pub extern fn g_hook_list_marshal(hook_list: ?*GHookList, may_recurse: gboolean, marshaller: GHookMarshaller, marshal_data: gpointer) void;
pub extern fn g_hook_list_marshal_check(hook_list: ?*GHookList, may_recurse: gboolean, marshaller: GHookCheckMarshaller, marshal_data: gpointer) void;
pub extern fn g_hostname_is_non_ascii(hostname: [*c]const gchar) gboolean;
pub extern fn g_hostname_is_ascii_encoded(hostname: [*c]const gchar) gboolean;
pub extern fn g_hostname_is_ip_address(hostname: [*c]const gchar) gboolean;
pub extern fn g_hostname_to_ascii(hostname: [*c]const gchar) [*c]gchar;
pub extern fn g_hostname_to_unicode(hostname: [*c]const gchar) [*c]gchar;
pub const struct__GPollFD = extern struct {
    fd: gint64,
    events: gushort,
    revents: gushort,
};
pub const GPollFD = struct__GPollFD;
pub const GPollFunc = ?extern fn ([*c]GPollFD, guint, gint) gint;
pub extern fn g_poll(fds: [*c]GPollFD, nfds: guint, timeout: gint) gint;
pub const GSList = struct__GSList;
pub const struct__GSList = extern struct {
    data: gpointer,
    next: [*c]GSList,
};
pub extern fn g_slist_alloc() [*c]GSList;
pub extern fn g_slist_free(list: [*c]GSList) void;
pub extern fn g_slist_free_1(list: [*c]GSList) void;
pub extern fn g_slist_free_full(list: [*c]GSList, free_func: GDestroyNotify) void;
pub extern fn g_slist_append(list: [*c]GSList, data: gpointer) [*c]GSList;
pub extern fn g_slist_prepend(list: [*c]GSList, data: gpointer) [*c]GSList;
pub extern fn g_slist_insert(list: [*c]GSList, data: gpointer, position: gint) [*c]GSList;
pub extern fn g_slist_insert_sorted(list: [*c]GSList, data: gpointer, func: GCompareFunc) [*c]GSList;
pub extern fn g_slist_insert_sorted_with_data(list: [*c]GSList, data: gpointer, func: GCompareDataFunc, user_data: gpointer) [*c]GSList;
pub extern fn g_slist_insert_before(slist: [*c]GSList, sibling: [*c]GSList, data: gpointer) [*c]GSList;
pub extern fn g_slist_concat(list1: [*c]GSList, list2: [*c]GSList) [*c]GSList;
pub extern fn g_slist_remove(list: [*c]GSList, data: gconstpointer) [*c]GSList;
pub extern fn g_slist_remove_all(list: [*c]GSList, data: gconstpointer) [*c]GSList;
pub extern fn g_slist_remove_link(list: [*c]GSList, link_: [*c]GSList) [*c]GSList;
pub extern fn g_slist_delete_link(list: [*c]GSList, link_: [*c]GSList) [*c]GSList;
pub extern fn g_slist_reverse(list: [*c]GSList) [*c]GSList;
pub extern fn g_slist_copy(list: [*c]GSList) [*c]GSList;
pub extern fn g_slist_copy_deep(list: [*c]GSList, func: GCopyFunc, user_data: gpointer) [*c]GSList;
pub extern fn g_slist_nth(list: [*c]GSList, n: guint) [*c]GSList;
pub extern fn g_slist_find(list: [*c]GSList, data: gconstpointer) [*c]GSList;
pub extern fn g_slist_find_custom(list: [*c]GSList, data: gconstpointer, func: GCompareFunc) [*c]GSList;
pub extern fn g_slist_position(list: [*c]GSList, llink: [*c]GSList) gint;
pub extern fn g_slist_index(list: [*c]GSList, data: gconstpointer) gint;
pub extern fn g_slist_last(list: [*c]GSList) [*c]GSList;
pub extern fn g_slist_length(list: [*c]GSList) guint;
pub extern fn g_slist_foreach(list: [*c]GSList, func: GFunc, user_data: gpointer) void;
pub extern fn g_slist_sort(list: [*c]GSList, compare_func: GCompareFunc) [*c]GSList;
pub extern fn g_slist_sort_with_data(list: [*c]GSList, compare_func: GCompareDataFunc, user_data: gpointer) [*c]GSList;
pub extern fn g_slist_nth_data(list: [*c]GSList, n: guint) gpointer;
pub const G_IO_IN = 1;
pub const G_IO_OUT = 4;
pub const G_IO_PRI = 2;
pub const G_IO_ERR = 8;
pub const G_IO_HUP = 16;
pub const G_IO_NVAL = 32;
pub const GIOCondition = extern enum {
    G_IO_IN = 1,
    G_IO_OUT = 4,
    G_IO_PRI = 2,
    G_IO_ERR = 8,
    G_IO_HUP = 16,
    G_IO_NVAL = 32,
};
pub const struct__GMainContext = @OpaqueType();
pub const GMainContext = struct__GMainContext;
pub const struct__GMainLoop = @OpaqueType();
pub const GMainLoop = struct__GMainLoop;
pub const GSource = struct__GSource;
pub const GSourceFunc = ?extern fn (gpointer) gboolean;
pub const struct__GSourceCallbackFuncs = extern struct {
    ref: ?extern fn (gpointer) void,
    unref: ?extern fn (gpointer) void,
    get: ?extern fn (gpointer, [*c]GSource, [*c]GSourceFunc, [*c]gpointer) void,
};
pub const GSourceCallbackFuncs = struct__GSourceCallbackFuncs;
pub const GSourceDummyMarshal = ?extern fn () void;
pub const struct__GSourceFuncs = extern struct {
    prepare: ?extern fn ([*c]GSource, [*c]gint) gboolean,
    check: ?extern fn ([*c]GSource) gboolean,
    dispatch: ?extern fn ([*c]GSource, GSourceFunc, gpointer) gboolean,
    finalize: ?extern fn ([*c]GSource) void,
    closure_callback: GSourceFunc,
    closure_marshal: GSourceDummyMarshal,
};
pub const GSourceFuncs = struct__GSourceFuncs;
pub const struct__GSourcePrivate = @OpaqueType();
pub const GSourcePrivate = struct__GSourcePrivate;
pub const struct__GSource = extern struct {
    callback_data: gpointer,
    callback_funcs: [*c]GSourceCallbackFuncs,
    source_funcs: [*c]const GSourceFuncs,
    ref_count: guint,
    context: ?*GMainContext,
    priority: gint,
    flags: guint,
    source_id: guint,
    poll_fds: [*c]GSList,
    prev: [*c]GSource,
    next: [*c]GSource,
    name: [*c]u8,
    priv: ?*GSourcePrivate,
};
pub const GChildWatchFunc = ?extern fn (GPid, gint, gpointer) void;
pub extern fn g_main_context_new() ?*GMainContext;
pub extern fn g_main_context_ref(context: ?*GMainContext) ?*GMainContext;
pub extern fn g_main_context_unref(context: ?*GMainContext) void;
pub extern fn g_main_context_default() ?*GMainContext;
pub extern fn g_main_context_iteration(context: ?*GMainContext, may_block: gboolean) gboolean;
pub extern fn g_main_context_pending(context: ?*GMainContext) gboolean;
pub extern fn g_main_context_find_source_by_id(context: ?*GMainContext, source_id: guint) [*c]GSource;
pub extern fn g_main_context_find_source_by_user_data(context: ?*GMainContext, user_data: gpointer) [*c]GSource;
pub extern fn g_main_context_find_source_by_funcs_user_data(context: ?*GMainContext, funcs: [*c]GSourceFuncs, user_data: gpointer) [*c]GSource;
pub extern fn g_main_context_wakeup(context: ?*GMainContext) void;
pub extern fn g_main_context_acquire(context: ?*GMainContext) gboolean;
pub extern fn g_main_context_release(context: ?*GMainContext) void;
pub extern fn g_main_context_is_owner(context: ?*GMainContext) gboolean;
pub extern fn g_main_context_wait(context: ?*GMainContext, cond: [*c]GCond, mutex: [*c]GMutex) gboolean;
pub extern fn g_main_context_prepare(context: ?*GMainContext, priority: [*c]gint) gboolean;
pub extern fn g_main_context_query(context: ?*GMainContext, max_priority: gint, timeout_: [*c]gint, fds: [*c]GPollFD, n_fds: gint) gint;
pub extern fn g_main_context_check(context: ?*GMainContext, max_priority: gint, fds: [*c]GPollFD, n_fds: gint) gboolean;
pub extern fn g_main_context_dispatch(context: ?*GMainContext) void;
pub extern fn g_main_context_set_poll_func(context: ?*GMainContext, func: GPollFunc) void;
pub extern fn g_main_context_get_poll_func(context: ?*GMainContext) GPollFunc;
pub extern fn g_main_context_add_poll(context: ?*GMainContext, fd: [*c]GPollFD, priority: gint) void;
pub extern fn g_main_context_remove_poll(context: ?*GMainContext, fd: [*c]GPollFD) void;
pub extern fn g_main_depth() gint;
pub extern fn g_main_current_source() [*c]GSource;
pub extern fn g_main_context_push_thread_default(context: ?*GMainContext) void;
pub extern fn g_main_context_pop_thread_default(context: ?*GMainContext) void;
pub extern fn g_main_context_get_thread_default() ?*GMainContext;
pub extern fn g_main_context_ref_thread_default() ?*GMainContext;
pub extern fn g_main_loop_new(context: ?*GMainContext, is_running: gboolean) ?*GMainLoop;
pub extern fn g_main_loop_run(loop: ?*GMainLoop) void;
pub extern fn g_main_loop_quit(loop: ?*GMainLoop) void;
pub extern fn g_main_loop_ref(loop: ?*GMainLoop) ?*GMainLoop;
pub extern fn g_main_loop_unref(loop: ?*GMainLoop) void;
pub extern fn g_main_loop_is_running(loop: ?*GMainLoop) gboolean;
pub extern fn g_main_loop_get_context(loop: ?*GMainLoop) ?*GMainContext;
pub extern fn g_source_new(source_funcs: [*c]GSourceFuncs, struct_size: guint) [*c]GSource;
pub extern fn g_source_ref(source: [*c]GSource) [*c]GSource;
pub extern fn g_source_unref(source: [*c]GSource) void;
pub extern fn g_source_attach(source: [*c]GSource, context: ?*GMainContext) guint;
pub extern fn g_source_destroy(source: [*c]GSource) void;
pub extern fn g_source_set_priority(source: [*c]GSource, priority: gint) void;
pub extern fn g_source_get_priority(source: [*c]GSource) gint;
pub extern fn g_source_set_can_recurse(source: [*c]GSource, can_recurse: gboolean) void;
pub extern fn g_source_get_can_recurse(source: [*c]GSource) gboolean;
pub extern fn g_source_get_id(source: [*c]GSource) guint;
pub extern fn g_source_get_context(source: [*c]GSource) ?*GMainContext;
pub extern fn g_source_set_callback(source: [*c]GSource, func: GSourceFunc, data: gpointer, notify: GDestroyNotify) void;
pub extern fn g_source_set_funcs(source: [*c]GSource, funcs: [*c]GSourceFuncs) void;
pub extern fn g_source_is_destroyed(source: [*c]GSource) gboolean;
pub extern fn g_source_set_name(source: [*c]GSource, name: [*c]const u8) void;
pub extern fn g_source_get_name(source: [*c]GSource) [*c]const u8;
pub extern fn g_source_set_name_by_id(tag: guint, name: [*c]const u8) void;
pub extern fn g_source_set_ready_time(source: [*c]GSource, ready_time: gint64) void;
pub extern fn g_source_get_ready_time(source: [*c]GSource) gint64;
pub extern fn g_source_set_callback_indirect(source: [*c]GSource, callback_data: gpointer, callback_funcs: [*c]GSourceCallbackFuncs) void;
pub extern fn g_source_add_poll(source: [*c]GSource, fd: [*c]GPollFD) void;
pub extern fn g_source_remove_poll(source: [*c]GSource, fd: [*c]GPollFD) void;
pub extern fn g_source_add_child_source(source: [*c]GSource, child_source: [*c]GSource) void;
pub extern fn g_source_remove_child_source(source: [*c]GSource, child_source: [*c]GSource) void;
pub extern fn g_source_get_current_time(source: [*c]GSource, timeval: [*c]GTimeVal) void;
pub extern fn g_source_get_time(source: [*c]GSource) gint64;
pub extern fn g_idle_source_new() [*c]GSource;
pub extern fn g_child_watch_source_new(pid: GPid) [*c]GSource;
pub extern fn g_timeout_source_new(interval: guint) [*c]GSource;
pub extern fn g_timeout_source_new_seconds(interval: guint) [*c]GSource;
pub extern fn g_get_current_time(result: [*c]GTimeVal) void;
pub extern fn g_get_monotonic_time() gint64;
pub extern fn g_get_real_time() gint64;
pub extern fn g_source_remove(tag: guint) gboolean;
pub extern fn g_source_remove_by_user_data(user_data: gpointer) gboolean;
pub extern fn g_source_remove_by_funcs_user_data(funcs: [*c]GSourceFuncs, user_data: gpointer) gboolean;
pub const GClearHandleFunc = ?extern fn (guint) void;
pub extern fn g_clear_handle_id(tag_ptr: [*c]guint, clear_func: GClearHandleFunc) void;
pub extern fn g_timeout_add_full(priority: gint, interval: guint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_timeout_add(interval: guint, function: GSourceFunc, data: gpointer) guint;
pub extern fn g_timeout_add_seconds_full(priority: gint, interval: guint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_timeout_add_seconds(interval: guint, function: GSourceFunc, data: gpointer) guint;
pub extern fn g_child_watch_add_full(priority: gint, pid: GPid, function: GChildWatchFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_child_watch_add(pid: GPid, function: GChildWatchFunc, data: gpointer) guint;
pub extern fn g_idle_add(function: GSourceFunc, data: gpointer) guint;
pub extern fn g_idle_add_full(priority: gint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_idle_remove_by_data(data: gpointer) gboolean;
pub extern fn g_main_context_invoke_full(context: ?*GMainContext, priority: gint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) void;
pub extern fn g_main_context_invoke(context: ?*GMainContext, function: GSourceFunc, data: gpointer) void;
pub extern var g_timeout_funcs: GSourceFuncs;
pub extern var g_child_watch_funcs: GSourceFuncs;
pub extern var g_idle_funcs: GSourceFuncs;
pub const gunichar = guint32;
pub const gunichar2 = guint16;
pub const G_UNICODE_CONTROL = 0;
pub const G_UNICODE_FORMAT = 1;
pub const G_UNICODE_UNASSIGNED = 2;
pub const G_UNICODE_PRIVATE_USE = 3;
pub const G_UNICODE_SURROGATE = 4;
pub const G_UNICODE_LOWERCASE_LETTER = 5;
pub const G_UNICODE_MODIFIER_LETTER = 6;
pub const G_UNICODE_OTHER_LETTER = 7;
pub const G_UNICODE_TITLECASE_LETTER = 8;
pub const G_UNICODE_UPPERCASE_LETTER = 9;
pub const G_UNICODE_SPACING_MARK = 10;
pub const G_UNICODE_ENCLOSING_MARK = 11;
pub const G_UNICODE_NON_SPACING_MARK = 12;
pub const G_UNICODE_DECIMAL_NUMBER = 13;
pub const G_UNICODE_LETTER_NUMBER = 14;
pub const G_UNICODE_OTHER_NUMBER = 15;
pub const G_UNICODE_CONNECT_PUNCTUATION = 16;
pub const G_UNICODE_DASH_PUNCTUATION = 17;
pub const G_UNICODE_CLOSE_PUNCTUATION = 18;
pub const G_UNICODE_FINAL_PUNCTUATION = 19;
pub const G_UNICODE_INITIAL_PUNCTUATION = 20;
pub const G_UNICODE_OTHER_PUNCTUATION = 21;
pub const G_UNICODE_OPEN_PUNCTUATION = 22;
pub const G_UNICODE_CURRENCY_SYMBOL = 23;
pub const G_UNICODE_MODIFIER_SYMBOL = 24;
pub const G_UNICODE_MATH_SYMBOL = 25;
pub const G_UNICODE_OTHER_SYMBOL = 26;
pub const G_UNICODE_LINE_SEPARATOR = 27;
pub const G_UNICODE_PARAGRAPH_SEPARATOR = 28;
pub const G_UNICODE_SPACE_SEPARATOR = 29;
pub const GUnicodeType = extern enum {
    G_UNICODE_CONTROL = 0,
    G_UNICODE_FORMAT = 1,
    G_UNICODE_UNASSIGNED = 2,
    G_UNICODE_PRIVATE_USE = 3,
    G_UNICODE_SURROGATE = 4,
    G_UNICODE_LOWERCASE_LETTER = 5,
    G_UNICODE_MODIFIER_LETTER = 6,
    G_UNICODE_OTHER_LETTER = 7,
    G_UNICODE_TITLECASE_LETTER = 8,
    G_UNICODE_UPPERCASE_LETTER = 9,
    G_UNICODE_SPACING_MARK = 10,
    G_UNICODE_ENCLOSING_MARK = 11,
    G_UNICODE_NON_SPACING_MARK = 12,
    G_UNICODE_DECIMAL_NUMBER = 13,
    G_UNICODE_LETTER_NUMBER = 14,
    G_UNICODE_OTHER_NUMBER = 15,
    G_UNICODE_CONNECT_PUNCTUATION = 16,
    G_UNICODE_DASH_PUNCTUATION = 17,
    G_UNICODE_CLOSE_PUNCTUATION = 18,
    G_UNICODE_FINAL_PUNCTUATION = 19,
    G_UNICODE_INITIAL_PUNCTUATION = 20,
    G_UNICODE_OTHER_PUNCTUATION = 21,
    G_UNICODE_OPEN_PUNCTUATION = 22,
    G_UNICODE_CURRENCY_SYMBOL = 23,
    G_UNICODE_MODIFIER_SYMBOL = 24,
    G_UNICODE_MATH_SYMBOL = 25,
    G_UNICODE_OTHER_SYMBOL = 26,
    G_UNICODE_LINE_SEPARATOR = 27,
    G_UNICODE_PARAGRAPH_SEPARATOR = 28,
    G_UNICODE_SPACE_SEPARATOR = 29,
};
pub const G_UNICODE_BREAK_MANDATORY = 0;
pub const G_UNICODE_BREAK_CARRIAGE_RETURN = 1;
pub const G_UNICODE_BREAK_LINE_FEED = 2;
pub const G_UNICODE_BREAK_COMBINING_MARK = 3;
pub const G_UNICODE_BREAK_SURROGATE = 4;
pub const G_UNICODE_BREAK_ZERO_WIDTH_SPACE = 5;
pub const G_UNICODE_BREAK_INSEPARABLE = 6;
pub const G_UNICODE_BREAK_NON_BREAKING_GLUE = 7;
pub const G_UNICODE_BREAK_CONTINGENT = 8;
pub const G_UNICODE_BREAK_SPACE = 9;
pub const G_UNICODE_BREAK_AFTER = 10;
pub const G_UNICODE_BREAK_BEFORE = 11;
pub const G_UNICODE_BREAK_BEFORE_AND_AFTER = 12;
pub const G_UNICODE_BREAK_HYPHEN = 13;
pub const G_UNICODE_BREAK_NON_STARTER = 14;
pub const G_UNICODE_BREAK_OPEN_PUNCTUATION = 15;
pub const G_UNICODE_BREAK_CLOSE_PUNCTUATION = 16;
pub const G_UNICODE_BREAK_QUOTATION = 17;
pub const G_UNICODE_BREAK_EXCLAMATION = 18;
pub const G_UNICODE_BREAK_IDEOGRAPHIC = 19;
pub const G_UNICODE_BREAK_NUMERIC = 20;
pub const G_UNICODE_BREAK_INFIX_SEPARATOR = 21;
pub const G_UNICODE_BREAK_SYMBOL = 22;
pub const G_UNICODE_BREAK_ALPHABETIC = 23;
pub const G_UNICODE_BREAK_PREFIX = 24;
pub const G_UNICODE_BREAK_POSTFIX = 25;
pub const G_UNICODE_BREAK_COMPLEX_CONTEXT = 26;
pub const G_UNICODE_BREAK_AMBIGUOUS = 27;
pub const G_UNICODE_BREAK_UNKNOWN = 28;
pub const G_UNICODE_BREAK_NEXT_LINE = 29;
pub const G_UNICODE_BREAK_WORD_JOINER = 30;
pub const G_UNICODE_BREAK_HANGUL_L_JAMO = 31;
pub const G_UNICODE_BREAK_HANGUL_V_JAMO = 32;
pub const G_UNICODE_BREAK_HANGUL_T_JAMO = 33;
pub const G_UNICODE_BREAK_HANGUL_LV_SYLLABLE = 34;
pub const G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE = 35;
pub const G_UNICODE_BREAK_CLOSE_PARANTHESIS = 36;
pub const G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER = 37;
pub const G_UNICODE_BREAK_HEBREW_LETTER = 38;
pub const G_UNICODE_BREAK_REGIONAL_INDICATOR = 39;
pub const G_UNICODE_BREAK_EMOJI_BASE = 40;
pub const G_UNICODE_BREAK_EMOJI_MODIFIER = 41;
pub const G_UNICODE_BREAK_ZERO_WIDTH_JOINER = 42;
pub const GUnicodeBreakType = extern enum {
    G_UNICODE_BREAK_MANDATORY = 0,
    G_UNICODE_BREAK_CARRIAGE_RETURN = 1,
    G_UNICODE_BREAK_LINE_FEED = 2,
    G_UNICODE_BREAK_COMBINING_MARK = 3,
    G_UNICODE_BREAK_SURROGATE = 4,
    G_UNICODE_BREAK_ZERO_WIDTH_SPACE = 5,
    G_UNICODE_BREAK_INSEPARABLE = 6,
    G_UNICODE_BREAK_NON_BREAKING_GLUE = 7,
    G_UNICODE_BREAK_CONTINGENT = 8,
    G_UNICODE_BREAK_SPACE = 9,
    G_UNICODE_BREAK_AFTER = 10,
    G_UNICODE_BREAK_BEFORE = 11,
    G_UNICODE_BREAK_BEFORE_AND_AFTER = 12,
    G_UNICODE_BREAK_HYPHEN = 13,
    G_UNICODE_BREAK_NON_STARTER = 14,
    G_UNICODE_BREAK_OPEN_PUNCTUATION = 15,
    G_UNICODE_BREAK_CLOSE_PUNCTUATION = 16,
    G_UNICODE_BREAK_QUOTATION = 17,
    G_UNICODE_BREAK_EXCLAMATION = 18,
    G_UNICODE_BREAK_IDEOGRAPHIC = 19,
    G_UNICODE_BREAK_NUMERIC = 20,
    G_UNICODE_BREAK_INFIX_SEPARATOR = 21,
    G_UNICODE_BREAK_SYMBOL = 22,
    G_UNICODE_BREAK_ALPHABETIC = 23,
    G_UNICODE_BREAK_PREFIX = 24,
    G_UNICODE_BREAK_POSTFIX = 25,
    G_UNICODE_BREAK_COMPLEX_CONTEXT = 26,
    G_UNICODE_BREAK_AMBIGUOUS = 27,
    G_UNICODE_BREAK_UNKNOWN = 28,
    G_UNICODE_BREAK_NEXT_LINE = 29,
    G_UNICODE_BREAK_WORD_JOINER = 30,
    G_UNICODE_BREAK_HANGUL_L_JAMO = 31,
    G_UNICODE_BREAK_HANGUL_V_JAMO = 32,
    G_UNICODE_BREAK_HANGUL_T_JAMO = 33,
    G_UNICODE_BREAK_HANGUL_LV_SYLLABLE = 34,
    G_UNICODE_BREAK_HANGUL_LVT_SYLLABLE = 35,
    G_UNICODE_BREAK_CLOSE_PARANTHESIS = 36,
    G_UNICODE_BREAK_CONDITIONAL_JAPANESE_STARTER = 37,
    G_UNICODE_BREAK_HEBREW_LETTER = 38,
    G_UNICODE_BREAK_REGIONAL_INDICATOR = 39,
    G_UNICODE_BREAK_EMOJI_BASE = 40,
    G_UNICODE_BREAK_EMOJI_MODIFIER = 41,
    G_UNICODE_BREAK_ZERO_WIDTH_JOINER = 42,
};
pub const G_UNICODE_SCRIPT_INVALID_CODE = -1;
pub const G_UNICODE_SCRIPT_COMMON = 0;
pub const G_UNICODE_SCRIPT_INHERITED = 1;
pub const G_UNICODE_SCRIPT_ARABIC = 2;
pub const G_UNICODE_SCRIPT_ARMENIAN = 3;
pub const G_UNICODE_SCRIPT_BENGALI = 4;
pub const G_UNICODE_SCRIPT_BOPOMOFO = 5;
pub const G_UNICODE_SCRIPT_CHEROKEE = 6;
pub const G_UNICODE_SCRIPT_COPTIC = 7;
pub const G_UNICODE_SCRIPT_CYRILLIC = 8;
pub const G_UNICODE_SCRIPT_DESERET = 9;
pub const G_UNICODE_SCRIPT_DEVANAGARI = 10;
pub const G_UNICODE_SCRIPT_ETHIOPIC = 11;
pub const G_UNICODE_SCRIPT_GEORGIAN = 12;
pub const G_UNICODE_SCRIPT_GOTHIC = 13;
pub const G_UNICODE_SCRIPT_GREEK = 14;
pub const G_UNICODE_SCRIPT_GUJARATI = 15;
pub const G_UNICODE_SCRIPT_GURMUKHI = 16;
pub const G_UNICODE_SCRIPT_HAN = 17;
pub const G_UNICODE_SCRIPT_HANGUL = 18;
pub const G_UNICODE_SCRIPT_HEBREW = 19;
pub const G_UNICODE_SCRIPT_HIRAGANA = 20;
pub const G_UNICODE_SCRIPT_KANNADA = 21;
pub const G_UNICODE_SCRIPT_KATAKANA = 22;
pub const G_UNICODE_SCRIPT_KHMER = 23;
pub const G_UNICODE_SCRIPT_LAO = 24;
pub const G_UNICODE_SCRIPT_LATIN = 25;
pub const G_UNICODE_SCRIPT_MALAYALAM = 26;
pub const G_UNICODE_SCRIPT_MONGOLIAN = 27;
pub const G_UNICODE_SCRIPT_MYANMAR = 28;
pub const G_UNICODE_SCRIPT_OGHAM = 29;
pub const G_UNICODE_SCRIPT_OLD_ITALIC = 30;
pub const G_UNICODE_SCRIPT_ORIYA = 31;
pub const G_UNICODE_SCRIPT_RUNIC = 32;
pub const G_UNICODE_SCRIPT_SINHALA = 33;
pub const G_UNICODE_SCRIPT_SYRIAC = 34;
pub const G_UNICODE_SCRIPT_TAMIL = 35;
pub const G_UNICODE_SCRIPT_TELUGU = 36;
pub const G_UNICODE_SCRIPT_THAANA = 37;
pub const G_UNICODE_SCRIPT_THAI = 38;
pub const G_UNICODE_SCRIPT_TIBETAN = 39;
pub const G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL = 40;
pub const G_UNICODE_SCRIPT_YI = 41;
pub const G_UNICODE_SCRIPT_TAGALOG = 42;
pub const G_UNICODE_SCRIPT_HANUNOO = 43;
pub const G_UNICODE_SCRIPT_BUHID = 44;
pub const G_UNICODE_SCRIPT_TAGBANWA = 45;
pub const G_UNICODE_SCRIPT_BRAILLE = 46;
pub const G_UNICODE_SCRIPT_CYPRIOT = 47;
pub const G_UNICODE_SCRIPT_LIMBU = 48;
pub const G_UNICODE_SCRIPT_OSMANYA = 49;
pub const G_UNICODE_SCRIPT_SHAVIAN = 50;
pub const G_UNICODE_SCRIPT_LINEAR_B = 51;
pub const G_UNICODE_SCRIPT_TAI_LE = 52;
pub const G_UNICODE_SCRIPT_UGARITIC = 53;
pub const G_UNICODE_SCRIPT_NEW_TAI_LUE = 54;
pub const G_UNICODE_SCRIPT_BUGINESE = 55;
pub const G_UNICODE_SCRIPT_GLAGOLITIC = 56;
pub const G_UNICODE_SCRIPT_TIFINAGH = 57;
pub const G_UNICODE_SCRIPT_SYLOTI_NAGRI = 58;
pub const G_UNICODE_SCRIPT_OLD_PERSIAN = 59;
pub const G_UNICODE_SCRIPT_KHAROSHTHI = 60;
pub const G_UNICODE_SCRIPT_UNKNOWN = 61;
pub const G_UNICODE_SCRIPT_BALINESE = 62;
pub const G_UNICODE_SCRIPT_CUNEIFORM = 63;
pub const G_UNICODE_SCRIPT_PHOENICIAN = 64;
pub const G_UNICODE_SCRIPT_PHAGS_PA = 65;
pub const G_UNICODE_SCRIPT_NKO = 66;
pub const G_UNICODE_SCRIPT_KAYAH_LI = 67;
pub const G_UNICODE_SCRIPT_LEPCHA = 68;
pub const G_UNICODE_SCRIPT_REJANG = 69;
pub const G_UNICODE_SCRIPT_SUNDANESE = 70;
pub const G_UNICODE_SCRIPT_SAURASHTRA = 71;
pub const G_UNICODE_SCRIPT_CHAM = 72;
pub const G_UNICODE_SCRIPT_OL_CHIKI = 73;
pub const G_UNICODE_SCRIPT_VAI = 74;
pub const G_UNICODE_SCRIPT_CARIAN = 75;
pub const G_UNICODE_SCRIPT_LYCIAN = 76;
pub const G_UNICODE_SCRIPT_LYDIAN = 77;
pub const G_UNICODE_SCRIPT_AVESTAN = 78;
pub const G_UNICODE_SCRIPT_BAMUM = 79;
pub const G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS = 80;
pub const G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC = 81;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI = 82;
pub const G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN = 83;
pub const G_UNICODE_SCRIPT_JAVANESE = 84;
pub const G_UNICODE_SCRIPT_KAITHI = 85;
pub const G_UNICODE_SCRIPT_LISU = 86;
pub const G_UNICODE_SCRIPT_MEETEI_MAYEK = 87;
pub const G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN = 88;
pub const G_UNICODE_SCRIPT_OLD_TURKIC = 89;
pub const G_UNICODE_SCRIPT_SAMARITAN = 90;
pub const G_UNICODE_SCRIPT_TAI_THAM = 91;
pub const G_UNICODE_SCRIPT_TAI_VIET = 92;
pub const G_UNICODE_SCRIPT_BATAK = 93;
pub const G_UNICODE_SCRIPT_BRAHMI = 94;
pub const G_UNICODE_SCRIPT_MANDAIC = 95;
pub const G_UNICODE_SCRIPT_CHAKMA = 96;
pub const G_UNICODE_SCRIPT_MEROITIC_CURSIVE = 97;
pub const G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS = 98;
pub const G_UNICODE_SCRIPT_MIAO = 99;
pub const G_UNICODE_SCRIPT_SHARADA = 100;
pub const G_UNICODE_SCRIPT_SORA_SOMPENG = 101;
pub const G_UNICODE_SCRIPT_TAKRI = 102;
pub const G_UNICODE_SCRIPT_BASSA_VAH = 103;
pub const G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN = 104;
pub const G_UNICODE_SCRIPT_DUPLOYAN = 105;
pub const G_UNICODE_SCRIPT_ELBASAN = 106;
pub const G_UNICODE_SCRIPT_GRANTHA = 107;
pub const G_UNICODE_SCRIPT_KHOJKI = 108;
pub const G_UNICODE_SCRIPT_KHUDAWADI = 109;
pub const G_UNICODE_SCRIPT_LINEAR_A = 110;
pub const G_UNICODE_SCRIPT_MAHAJANI = 111;
pub const G_UNICODE_SCRIPT_MANICHAEAN = 112;
pub const G_UNICODE_SCRIPT_MENDE_KIKAKUI = 113;
pub const G_UNICODE_SCRIPT_MODI = 114;
pub const G_UNICODE_SCRIPT_MRO = 115;
pub const G_UNICODE_SCRIPT_NABATAEAN = 116;
pub const G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN = 117;
pub const G_UNICODE_SCRIPT_OLD_PERMIC = 118;
pub const G_UNICODE_SCRIPT_PAHAWH_HMONG = 119;
pub const G_UNICODE_SCRIPT_PALMYRENE = 120;
pub const G_UNICODE_SCRIPT_PAU_CIN_HAU = 121;
pub const G_UNICODE_SCRIPT_PSALTER_PAHLAVI = 122;
pub const G_UNICODE_SCRIPT_SIDDHAM = 123;
pub const G_UNICODE_SCRIPT_TIRHUTA = 124;
pub const G_UNICODE_SCRIPT_WARANG_CITI = 125;
pub const G_UNICODE_SCRIPT_AHOM = 126;
pub const G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS = 127;
pub const G_UNICODE_SCRIPT_HATRAN = 128;
pub const G_UNICODE_SCRIPT_MULTANI = 129;
pub const G_UNICODE_SCRIPT_OLD_HUNGARIAN = 130;
pub const G_UNICODE_SCRIPT_SIGNWRITING = 131;
pub const G_UNICODE_SCRIPT_ADLAM = 132;
pub const G_UNICODE_SCRIPT_BHAIKSUKI = 133;
pub const G_UNICODE_SCRIPT_MARCHEN = 134;
pub const G_UNICODE_SCRIPT_NEWA = 135;
pub const G_UNICODE_SCRIPT_OSAGE = 136;
pub const G_UNICODE_SCRIPT_TANGUT = 137;
pub const G_UNICODE_SCRIPT_MASARAM_GONDI = 138;
pub const G_UNICODE_SCRIPT_NUSHU = 139;
pub const G_UNICODE_SCRIPT_SOYOMBO = 140;
pub const G_UNICODE_SCRIPT_ZANABAZAR_SQUARE = 141;
pub const G_UNICODE_SCRIPT_DOGRA = 142;
pub const G_UNICODE_SCRIPT_GUNJALA_GONDI = 143;
pub const G_UNICODE_SCRIPT_HANIFI_ROHINGYA = 144;
pub const G_UNICODE_SCRIPT_MAKASAR = 145;
pub const G_UNICODE_SCRIPT_MEDEFAIDRIN = 146;
pub const G_UNICODE_SCRIPT_OLD_SOGDIAN = 147;
pub const G_UNICODE_SCRIPT_SOGDIAN = 148;
pub const G_UNICODE_SCRIPT_ELYMAIC = 149;
pub const G_UNICODE_SCRIPT_NANDINAGARI = 150;
pub const G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG = 151;
pub const G_UNICODE_SCRIPT_WANCHO = 152;
pub const GUnicodeScript = extern enum {
    G_UNICODE_SCRIPT_INVALID_CODE = -1,
    G_UNICODE_SCRIPT_COMMON = 0,
    G_UNICODE_SCRIPT_INHERITED = 1,
    G_UNICODE_SCRIPT_ARABIC = 2,
    G_UNICODE_SCRIPT_ARMENIAN = 3,
    G_UNICODE_SCRIPT_BENGALI = 4,
    G_UNICODE_SCRIPT_BOPOMOFO = 5,
    G_UNICODE_SCRIPT_CHEROKEE = 6,
    G_UNICODE_SCRIPT_COPTIC = 7,
    G_UNICODE_SCRIPT_CYRILLIC = 8,
    G_UNICODE_SCRIPT_DESERET = 9,
    G_UNICODE_SCRIPT_DEVANAGARI = 10,
    G_UNICODE_SCRIPT_ETHIOPIC = 11,
    G_UNICODE_SCRIPT_GEORGIAN = 12,
    G_UNICODE_SCRIPT_GOTHIC = 13,
    G_UNICODE_SCRIPT_GREEK = 14,
    G_UNICODE_SCRIPT_GUJARATI = 15,
    G_UNICODE_SCRIPT_GURMUKHI = 16,
    G_UNICODE_SCRIPT_HAN = 17,
    G_UNICODE_SCRIPT_HANGUL = 18,
    G_UNICODE_SCRIPT_HEBREW = 19,
    G_UNICODE_SCRIPT_HIRAGANA = 20,
    G_UNICODE_SCRIPT_KANNADA = 21,
    G_UNICODE_SCRIPT_KATAKANA = 22,
    G_UNICODE_SCRIPT_KHMER = 23,
    G_UNICODE_SCRIPT_LAO = 24,
    G_UNICODE_SCRIPT_LATIN = 25,
    G_UNICODE_SCRIPT_MALAYALAM = 26,
    G_UNICODE_SCRIPT_MONGOLIAN = 27,
    G_UNICODE_SCRIPT_MYANMAR = 28,
    G_UNICODE_SCRIPT_OGHAM = 29,
    G_UNICODE_SCRIPT_OLD_ITALIC = 30,
    G_UNICODE_SCRIPT_ORIYA = 31,
    G_UNICODE_SCRIPT_RUNIC = 32,
    G_UNICODE_SCRIPT_SINHALA = 33,
    G_UNICODE_SCRIPT_SYRIAC = 34,
    G_UNICODE_SCRIPT_TAMIL = 35,
    G_UNICODE_SCRIPT_TELUGU = 36,
    G_UNICODE_SCRIPT_THAANA = 37,
    G_UNICODE_SCRIPT_THAI = 38,
    G_UNICODE_SCRIPT_TIBETAN = 39,
    G_UNICODE_SCRIPT_CANADIAN_ABORIGINAL = 40,
    G_UNICODE_SCRIPT_YI = 41,
    G_UNICODE_SCRIPT_TAGALOG = 42,
    G_UNICODE_SCRIPT_HANUNOO = 43,
    G_UNICODE_SCRIPT_BUHID = 44,
    G_UNICODE_SCRIPT_TAGBANWA = 45,
    G_UNICODE_SCRIPT_BRAILLE = 46,
    G_UNICODE_SCRIPT_CYPRIOT = 47,
    G_UNICODE_SCRIPT_LIMBU = 48,
    G_UNICODE_SCRIPT_OSMANYA = 49,
    G_UNICODE_SCRIPT_SHAVIAN = 50,
    G_UNICODE_SCRIPT_LINEAR_B = 51,
    G_UNICODE_SCRIPT_TAI_LE = 52,
    G_UNICODE_SCRIPT_UGARITIC = 53,
    G_UNICODE_SCRIPT_NEW_TAI_LUE = 54,
    G_UNICODE_SCRIPT_BUGINESE = 55,
    G_UNICODE_SCRIPT_GLAGOLITIC = 56,
    G_UNICODE_SCRIPT_TIFINAGH = 57,
    G_UNICODE_SCRIPT_SYLOTI_NAGRI = 58,
    G_UNICODE_SCRIPT_OLD_PERSIAN = 59,
    G_UNICODE_SCRIPT_KHAROSHTHI = 60,
    G_UNICODE_SCRIPT_UNKNOWN = 61,
    G_UNICODE_SCRIPT_BALINESE = 62,
    G_UNICODE_SCRIPT_CUNEIFORM = 63,
    G_UNICODE_SCRIPT_PHOENICIAN = 64,
    G_UNICODE_SCRIPT_PHAGS_PA = 65,
    G_UNICODE_SCRIPT_NKO = 66,
    G_UNICODE_SCRIPT_KAYAH_LI = 67,
    G_UNICODE_SCRIPT_LEPCHA = 68,
    G_UNICODE_SCRIPT_REJANG = 69,
    G_UNICODE_SCRIPT_SUNDANESE = 70,
    G_UNICODE_SCRIPT_SAURASHTRA = 71,
    G_UNICODE_SCRIPT_CHAM = 72,
    G_UNICODE_SCRIPT_OL_CHIKI = 73,
    G_UNICODE_SCRIPT_VAI = 74,
    G_UNICODE_SCRIPT_CARIAN = 75,
    G_UNICODE_SCRIPT_LYCIAN = 76,
    G_UNICODE_SCRIPT_LYDIAN = 77,
    G_UNICODE_SCRIPT_AVESTAN = 78,
    G_UNICODE_SCRIPT_BAMUM = 79,
    G_UNICODE_SCRIPT_EGYPTIAN_HIEROGLYPHS = 80,
    G_UNICODE_SCRIPT_IMPERIAL_ARAMAIC = 81,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PAHLAVI = 82,
    G_UNICODE_SCRIPT_INSCRIPTIONAL_PARTHIAN = 83,
    G_UNICODE_SCRIPT_JAVANESE = 84,
    G_UNICODE_SCRIPT_KAITHI = 85,
    G_UNICODE_SCRIPT_LISU = 86,
    G_UNICODE_SCRIPT_MEETEI_MAYEK = 87,
    G_UNICODE_SCRIPT_OLD_SOUTH_ARABIAN = 88,
    G_UNICODE_SCRIPT_OLD_TURKIC = 89,
    G_UNICODE_SCRIPT_SAMARITAN = 90,
    G_UNICODE_SCRIPT_TAI_THAM = 91,
    G_UNICODE_SCRIPT_TAI_VIET = 92,
    G_UNICODE_SCRIPT_BATAK = 93,
    G_UNICODE_SCRIPT_BRAHMI = 94,
    G_UNICODE_SCRIPT_MANDAIC = 95,
    G_UNICODE_SCRIPT_CHAKMA = 96,
    G_UNICODE_SCRIPT_MEROITIC_CURSIVE = 97,
    G_UNICODE_SCRIPT_MEROITIC_HIEROGLYPHS = 98,
    G_UNICODE_SCRIPT_MIAO = 99,
    G_UNICODE_SCRIPT_SHARADA = 100,
    G_UNICODE_SCRIPT_SORA_SOMPENG = 101,
    G_UNICODE_SCRIPT_TAKRI = 102,
    G_UNICODE_SCRIPT_BASSA_VAH = 103,
    G_UNICODE_SCRIPT_CAUCASIAN_ALBANIAN = 104,
    G_UNICODE_SCRIPT_DUPLOYAN = 105,
    G_UNICODE_SCRIPT_ELBASAN = 106,
    G_UNICODE_SCRIPT_GRANTHA = 107,
    G_UNICODE_SCRIPT_KHOJKI = 108,
    G_UNICODE_SCRIPT_KHUDAWADI = 109,
    G_UNICODE_SCRIPT_LINEAR_A = 110,
    G_UNICODE_SCRIPT_MAHAJANI = 111,
    G_UNICODE_SCRIPT_MANICHAEAN = 112,
    G_UNICODE_SCRIPT_MENDE_KIKAKUI = 113,
    G_UNICODE_SCRIPT_MODI = 114,
    G_UNICODE_SCRIPT_MRO = 115,
    G_UNICODE_SCRIPT_NABATAEAN = 116,
    G_UNICODE_SCRIPT_OLD_NORTH_ARABIAN = 117,
    G_UNICODE_SCRIPT_OLD_PERMIC = 118,
    G_UNICODE_SCRIPT_PAHAWH_HMONG = 119,
    G_UNICODE_SCRIPT_PALMYRENE = 120,
    G_UNICODE_SCRIPT_PAU_CIN_HAU = 121,
    G_UNICODE_SCRIPT_PSALTER_PAHLAVI = 122,
    G_UNICODE_SCRIPT_SIDDHAM = 123,
    G_UNICODE_SCRIPT_TIRHUTA = 124,
    G_UNICODE_SCRIPT_WARANG_CITI = 125,
    G_UNICODE_SCRIPT_AHOM = 126,
    G_UNICODE_SCRIPT_ANATOLIAN_HIEROGLYPHS = 127,
    G_UNICODE_SCRIPT_HATRAN = 128,
    G_UNICODE_SCRIPT_MULTANI = 129,
    G_UNICODE_SCRIPT_OLD_HUNGARIAN = 130,
    G_UNICODE_SCRIPT_SIGNWRITING = 131,
    G_UNICODE_SCRIPT_ADLAM = 132,
    G_UNICODE_SCRIPT_BHAIKSUKI = 133,
    G_UNICODE_SCRIPT_MARCHEN = 134,
    G_UNICODE_SCRIPT_NEWA = 135,
    G_UNICODE_SCRIPT_OSAGE = 136,
    G_UNICODE_SCRIPT_TANGUT = 137,
    G_UNICODE_SCRIPT_MASARAM_GONDI = 138,
    G_UNICODE_SCRIPT_NUSHU = 139,
    G_UNICODE_SCRIPT_SOYOMBO = 140,
    G_UNICODE_SCRIPT_ZANABAZAR_SQUARE = 141,
    G_UNICODE_SCRIPT_DOGRA = 142,
    G_UNICODE_SCRIPT_GUNJALA_GONDI = 143,
    G_UNICODE_SCRIPT_HANIFI_ROHINGYA = 144,
    G_UNICODE_SCRIPT_MAKASAR = 145,
    G_UNICODE_SCRIPT_MEDEFAIDRIN = 146,
    G_UNICODE_SCRIPT_OLD_SOGDIAN = 147,
    G_UNICODE_SCRIPT_SOGDIAN = 148,
    G_UNICODE_SCRIPT_ELYMAIC = 149,
    G_UNICODE_SCRIPT_NANDINAGARI = 150,
    G_UNICODE_SCRIPT_NYIAKENG_PUACHUE_HMONG = 151,
    G_UNICODE_SCRIPT_WANCHO = 152,
};
pub extern fn g_unicode_script_to_iso15924(script: GUnicodeScript) guint32;
pub extern fn g_unicode_script_from_iso15924(iso15924: guint32) GUnicodeScript;
pub extern fn g_unichar_isalnum(c: gunichar) gboolean;
pub extern fn g_unichar_isalpha(c: gunichar) gboolean;
pub extern fn g_unichar_iscntrl(c: gunichar) gboolean;
pub extern fn g_unichar_isdigit(c: gunichar) gboolean;
pub extern fn g_unichar_isgraph(c: gunichar) gboolean;
pub extern fn g_unichar_islower(c: gunichar) gboolean;
pub extern fn g_unichar_isprint(c: gunichar) gboolean;
pub extern fn g_unichar_ispunct(c: gunichar) gboolean;
pub extern fn g_unichar_isspace(c: gunichar) gboolean;
pub extern fn g_unichar_isupper(c: gunichar) gboolean;
pub extern fn g_unichar_isxdigit(c: gunichar) gboolean;
pub extern fn g_unichar_istitle(c: gunichar) gboolean;
pub extern fn g_unichar_isdefined(c: gunichar) gboolean;
pub extern fn g_unichar_iswide(c: gunichar) gboolean;
pub extern fn g_unichar_iswide_cjk(c: gunichar) gboolean;
pub extern fn g_unichar_iszerowidth(c: gunichar) gboolean;
pub extern fn g_unichar_ismark(c: gunichar) gboolean;
pub extern fn g_unichar_toupper(c: gunichar) gunichar;
pub extern fn g_unichar_tolower(c: gunichar) gunichar;
pub extern fn g_unichar_totitle(c: gunichar) gunichar;
pub extern fn g_unichar_digit_value(c: gunichar) gint;
pub extern fn g_unichar_xdigit_value(c: gunichar) gint;
pub extern fn g_unichar_type(c: gunichar) GUnicodeType;
pub extern fn g_unichar_break_type(c: gunichar) GUnicodeBreakType;
pub extern fn g_unichar_combining_class(uc: gunichar) gint;
pub extern fn g_unichar_get_mirror_char(ch: gunichar, mirrored_ch: [*c]gunichar) gboolean;
pub extern fn g_unichar_get_script(ch: gunichar) GUnicodeScript;
pub extern fn g_unichar_validate(ch: gunichar) gboolean;
pub extern fn g_unichar_compose(a: gunichar, b: gunichar, ch: [*c]gunichar) gboolean;
pub extern fn g_unichar_decompose(ch: gunichar, a: [*c]gunichar, b: [*c]gunichar) gboolean;
pub extern fn g_unichar_fully_decompose(ch: gunichar, compat: gboolean, result: [*c]gunichar, result_len: gsize) gsize;
pub extern fn g_unicode_canonical_ordering(string: [*c]gunichar, len: gsize) void;
pub extern fn g_unicode_canonical_decomposition(ch: gunichar, result_len: [*c]gsize) [*c]gunichar;
pub extern const g_utf8_skip: [*c]const gchar;
pub extern fn g_utf8_get_char(p: [*c]const gchar) gunichar;
pub extern fn g_utf8_get_char_validated(p: [*c]const gchar, max_len: gssize) gunichar;
pub extern fn g_utf8_offset_to_pointer(str: [*c]const gchar, offset: glong) [*c]gchar;
pub extern fn g_utf8_pointer_to_offset(str: [*c]const gchar, pos: [*c]const gchar) glong;
pub extern fn g_utf8_prev_char(p: [*c]const gchar) [*c]gchar;
pub extern fn g_utf8_find_next_char(p: [*c]const gchar, end: [*c]const gchar) [*c]gchar;
pub extern fn g_utf8_find_prev_char(str: [*c]const gchar, p: [*c]const gchar) [*c]gchar;
pub extern fn g_utf8_strlen(p: [*c]const gchar, max: gssize) glong;
pub extern fn g_utf8_substring(str: [*c]const gchar, start_pos: glong, end_pos: glong) [*c]gchar;
pub extern fn g_utf8_strncpy(dest: [*c]gchar, src: [*c]const gchar, n: gsize) [*c]gchar;
pub extern fn g_utf8_strchr(p: [*c]const gchar, len: gssize, c: gunichar) [*c]gchar;
pub extern fn g_utf8_strrchr(p: [*c]const gchar, len: gssize, c: gunichar) [*c]gchar;
pub extern fn g_utf8_strreverse(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_to_utf16(str: [*c]const gchar, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c]([*c]GError)) [*c]gunichar2;
pub extern fn g_utf8_to_ucs4(str: [*c]const gchar, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c]([*c]GError)) [*c]gunichar;
pub extern fn g_utf8_to_ucs4_fast(str: [*c]const gchar, len: glong, items_written: [*c]glong) [*c]gunichar;
pub extern fn g_utf16_to_ucs4(str: [*c]const gunichar2, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c]([*c]GError)) [*c]gunichar;
pub extern fn g_utf16_to_utf8(str: [*c]const gunichar2, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_ucs4_to_utf16(str: [*c]const gunichar, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c]([*c]GError)) [*c]gunichar2;
pub extern fn g_ucs4_to_utf8(str: [*c]const gunichar, len: glong, items_read: [*c]glong, items_written: [*c]glong, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_unichar_to_utf8(c: gunichar, outbuf: [*c]gchar) gint;
pub extern fn g_utf8_validate(str: [*c]const gchar, max_len: gssize, end: [*c]([*c]const gchar)) gboolean;
pub extern fn g_utf8_validate_len(str: [*c]const gchar, max_len: gsize, end: [*c]([*c]const gchar)) gboolean;
pub extern fn g_utf8_strup(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_strdown(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_casefold(str: [*c]const gchar, len: gssize) [*c]gchar;
pub const G_NORMALIZE_DEFAULT = 0;
pub const G_NORMALIZE_NFD = 0;
pub const G_NORMALIZE_DEFAULT_COMPOSE = 1;
pub const G_NORMALIZE_NFC = 1;
pub const G_NORMALIZE_ALL = 2;
pub const G_NORMALIZE_NFKD = 2;
pub const G_NORMALIZE_ALL_COMPOSE = 3;
pub const G_NORMALIZE_NFKC = 3;
pub const GNormalizeMode = extern enum {
    G_NORMALIZE_DEFAULT = 0,
    G_NORMALIZE_NFD = 0,
    G_NORMALIZE_DEFAULT_COMPOSE = 1,
    G_NORMALIZE_NFC = 1,
    G_NORMALIZE_ALL = 2,
    G_NORMALIZE_NFKD = 2,
    G_NORMALIZE_ALL_COMPOSE = 3,
    G_NORMALIZE_NFKC = 3,
};
pub extern fn g_utf8_normalize(str: [*c]const gchar, len: gssize, mode: GNormalizeMode) [*c]gchar;
pub extern fn g_utf8_collate(str1: [*c]const gchar, str2: [*c]const gchar) gint;
pub extern fn g_utf8_collate_key(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_collate_key_for_filename(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_utf8_make_valid(str: [*c]const gchar, len: gssize) [*c]gchar;
pub const struct__GString = extern struct {
    str: [*c]gchar,
    len: gsize,
    allocated_len: gsize,
};
pub const GString = struct__GString;
pub extern fn g_string_new(init: [*c]const gchar) [*c]GString;
pub extern fn g_string_new_len(init: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_sized_new(dfl_size: gsize) [*c]GString;
pub extern fn g_string_free(string: [*c]GString, free_segment: gboolean) [*c]gchar;
pub extern fn g_string_free_to_bytes(string: [*c]GString) ?*GBytes;
pub extern fn g_string_equal(v: [*c]const GString, v2: [*c]const GString) gboolean;
pub extern fn g_string_hash(str: [*c]const GString) guint;
pub extern fn g_string_assign(string: [*c]GString, rval: [*c]const gchar) [*c]GString;
pub extern fn g_string_truncate(string: [*c]GString, len: gsize) [*c]GString;
pub extern fn g_string_set_size(string: [*c]GString, len: gsize) [*c]GString;
pub extern fn g_string_insert_len(string: [*c]GString, pos: gssize, val: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_append(string: [*c]GString, val: [*c]const gchar) [*c]GString;
pub extern fn g_string_append_len(string: [*c]GString, val: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_append_c(string: [*c]GString, c: gchar) [*c]GString;
pub extern fn g_string_append_unichar(string: [*c]GString, wc: gunichar) [*c]GString;
pub extern fn g_string_prepend(string: [*c]GString, val: [*c]const gchar) [*c]GString;
pub extern fn g_string_prepend_c(string: [*c]GString, c: gchar) [*c]GString;
pub extern fn g_string_prepend_unichar(string: [*c]GString, wc: gunichar) [*c]GString;
pub extern fn g_string_prepend_len(string: [*c]GString, val: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_insert(string: [*c]GString, pos: gssize, val: [*c]const gchar) [*c]GString;
pub extern fn g_string_insert_c(string: [*c]GString, pos: gssize, c: gchar) [*c]GString;
pub extern fn g_string_insert_unichar(string: [*c]GString, pos: gssize, wc: gunichar) [*c]GString;
pub extern fn g_string_overwrite(string: [*c]GString, pos: gsize, val: [*c]const gchar) [*c]GString;
pub extern fn g_string_overwrite_len(string: [*c]GString, pos: gsize, val: [*c]const gchar, len: gssize) [*c]GString;
pub extern fn g_string_erase(string: [*c]GString, pos: gssize, len: gssize) [*c]GString;
pub extern fn g_string_ascii_down(string: [*c]GString) [*c]GString;
pub extern fn g_string_ascii_up(string: [*c]GString) [*c]GString;
pub extern fn g_string_vprintf(string: [*c]GString, format: [*c]const gchar, args: va_list) void;
pub extern fn g_string_printf(string: [*c]GString, format: [*c]const gchar, ...) void;
pub extern fn g_string_append_vprintf(string: [*c]GString, format: [*c]const gchar, args: va_list) void;
pub extern fn g_string_append_printf(string: [*c]GString, format: [*c]const gchar, ...) void;
pub extern fn g_string_append_uri_escaped(string: [*c]GString, unescaped: [*c]const gchar, reserved_chars_allowed: [*c]const gchar, allow_utf8: gboolean) [*c]GString;
pub fn g_string_append_c_inline(gstring: [*c]GString, c: gchar) [*c]GString {
    if ((gstring.?.len +% c_ulonglong(1)) < gstring.?.allocated_len) {
        gstring.?.str[(x: {
            const _ref = &gstring.?.len;
            const _tmp = _ref.*;
            _ref.* +%= 1;
            break :x _tmp;
        })] = c;
        gstring.?.str[gstring.?.len] = gchar(0);
    } else _ = g_string_insert_c(gstring, gssize(-1), c);
    return gstring;
}
pub extern fn g_string_down(string: [*c]GString) [*c]GString;
pub extern fn g_string_up(string: [*c]GString) [*c]GString;
pub const struct__GIOChannel = @OpaqueType();
pub const GIOChannel = struct__GIOChannel;
pub const G_IO_STATUS_ERROR = 0;
pub const G_IO_STATUS_NORMAL = 1;
pub const G_IO_STATUS_EOF = 2;
pub const G_IO_STATUS_AGAIN = 3;
pub const GIOStatus = extern enum {
    G_IO_STATUS_ERROR = 0,
    G_IO_STATUS_NORMAL = 1,
    G_IO_STATUS_EOF = 2,
    G_IO_STATUS_AGAIN = 3,
};
pub const G_SEEK_CUR = 0;
pub const G_SEEK_SET = 1;
pub const G_SEEK_END = 2;
pub const GSeekType = extern enum {
    G_SEEK_CUR = 0,
    G_SEEK_SET = 1,
    G_SEEK_END = 2,
};
pub const G_IO_FLAG_APPEND = 1;
pub const G_IO_FLAG_NONBLOCK = 2;
pub const G_IO_FLAG_IS_READABLE = 4;
pub const G_IO_FLAG_IS_WRITABLE = 8;
pub const G_IO_FLAG_IS_WRITEABLE = 8;
pub const G_IO_FLAG_IS_SEEKABLE = 16;
pub const G_IO_FLAG_MASK = 31;
pub const G_IO_FLAG_GET_MASK = 31;
pub const G_IO_FLAG_SET_MASK = 3;
pub const GIOFlags = extern enum {
    G_IO_FLAG_APPEND = 1,
    G_IO_FLAG_NONBLOCK = 2,
    G_IO_FLAG_IS_READABLE = 4,
    G_IO_FLAG_IS_WRITABLE = 8,
    G_IO_FLAG_IS_WRITEABLE = 8,
    G_IO_FLAG_IS_SEEKABLE = 16,
    G_IO_FLAG_MASK = 31,
    G_IO_FLAG_GET_MASK = 31,
    G_IO_FLAG_SET_MASK = 3,
};
pub const struct__GIOFuncs = extern struct {
    io_read: ?extern fn (?*GIOChannel, [*c]gchar, gsize, [*c]gsize, [*c]([*c]GError)) GIOStatus,
    io_write: ?extern fn (?*GIOChannel, [*c]const gchar, gsize, [*c]gsize, [*c]([*c]GError)) GIOStatus,
    io_seek: ?extern fn (?*GIOChannel, gint64, GSeekType, [*c]([*c]GError)) GIOStatus,
    io_close: ?extern fn (?*GIOChannel, [*c]([*c]GError)) GIOStatus,
    io_create_watch: ?extern fn (?*GIOChannel, GIOCondition) [*c]GSource,
    io_free: ?extern fn (?*GIOChannel) void,
    io_set_flags: ?extern fn (?*GIOChannel, GIOFlags, [*c]([*c]GError)) GIOStatus,
    io_get_flags: ?extern fn (?*GIOChannel) GIOFlags,
};
pub const GIOFuncs = struct__GIOFuncs;
pub const G_IO_ERROR_NONE = 0;
pub const G_IO_ERROR_AGAIN = 1;
pub const G_IO_ERROR_INVAL = 2;
pub const G_IO_ERROR_UNKNOWN = 3;
pub const GIOError = extern enum {
    G_IO_ERROR_NONE = 0,
    G_IO_ERROR_AGAIN = 1,
    G_IO_ERROR_INVAL = 2,
    G_IO_ERROR_UNKNOWN = 3,
};
pub const G_IO_CHANNEL_ERROR_FBIG = 0;
pub const G_IO_CHANNEL_ERROR_INVAL = 1;
pub const G_IO_CHANNEL_ERROR_IO = 2;
pub const G_IO_CHANNEL_ERROR_ISDIR = 3;
pub const G_IO_CHANNEL_ERROR_NOSPC = 4;
pub const G_IO_CHANNEL_ERROR_NXIO = 5;
pub const G_IO_CHANNEL_ERROR_OVERFLOW = 6;
pub const G_IO_CHANNEL_ERROR_PIPE = 7;
pub const G_IO_CHANNEL_ERROR_FAILED = 8;
pub const GIOChannelError = extern enum {
    G_IO_CHANNEL_ERROR_FBIG = 0,
    G_IO_CHANNEL_ERROR_INVAL = 1,
    G_IO_CHANNEL_ERROR_IO = 2,
    G_IO_CHANNEL_ERROR_ISDIR = 3,
    G_IO_CHANNEL_ERROR_NOSPC = 4,
    G_IO_CHANNEL_ERROR_NXIO = 5,
    G_IO_CHANNEL_ERROR_OVERFLOW = 6,
    G_IO_CHANNEL_ERROR_PIPE = 7,
    G_IO_CHANNEL_ERROR_FAILED = 8,
};
pub const GIOFunc = ?extern fn (?*GIOChannel, GIOCondition, gpointer) gboolean;
pub extern fn g_io_channel_init(channel: ?*GIOChannel) void;
pub extern fn g_io_channel_ref(channel: ?*GIOChannel) ?*GIOChannel;
pub extern fn g_io_channel_unref(channel: ?*GIOChannel) void;
pub extern fn g_io_channel_read(channel: ?*GIOChannel, buf: [*c]gchar, count: gsize, bytes_read: [*c]gsize) GIOError;
pub extern fn g_io_channel_write(channel: ?*GIOChannel, buf: [*c]const gchar, count: gsize, bytes_written: [*c]gsize) GIOError;
pub extern fn g_io_channel_seek(channel: ?*GIOChannel, offset: gint64, type_0: GSeekType) GIOError;
pub extern fn g_io_channel_close(channel: ?*GIOChannel) void;
pub extern fn g_io_channel_shutdown(channel: ?*GIOChannel, flush: gboolean, err: [*c]([*c]GError)) GIOStatus;
pub extern fn g_io_add_watch_full(channel: ?*GIOChannel, priority: gint, condition: GIOCondition, func: GIOFunc, user_data: gpointer, notify: GDestroyNotify) guint;
pub extern fn g_io_create_watch(channel: ?*GIOChannel, condition: GIOCondition) [*c]GSource;
pub extern fn g_io_add_watch(channel: ?*GIOChannel, condition: GIOCondition, func: GIOFunc, user_data: gpointer) guint;
pub extern fn g_io_channel_set_buffer_size(channel: ?*GIOChannel, size: gsize) void;
pub extern fn g_io_channel_get_buffer_size(channel: ?*GIOChannel) gsize;
pub extern fn g_io_channel_get_buffer_condition(channel: ?*GIOChannel) GIOCondition;
pub extern fn g_io_channel_set_flags(channel: ?*GIOChannel, flags: GIOFlags, @"error": [*c]([*c]GError)) GIOStatus;
pub extern fn g_io_channel_get_flags(channel: ?*GIOChannel) GIOFlags;
pub extern fn g_io_channel_set_line_term(channel: ?*GIOChannel, line_term: [*c]const gchar, length: gint) void;
pub extern fn g_io_channel_get_line_term(channel: ?*GIOChannel, length: [*c]gint) [*c]const gchar;
pub extern fn g_io_channel_set_buffered(channel: ?*GIOChannel, buffered: gboolean) void;
pub extern fn g_io_channel_get_buffered(channel: ?*GIOChannel) gboolean;
pub extern fn g_io_channel_set_encoding(channel: ?*GIOChannel, encoding: [*c]const gchar, @"error": [*c]([*c]GError)) GIOStatus;
pub extern fn g_io_channel_get_encoding(channel: ?*GIOChannel) [*c]const gchar;
pub extern fn g_io_channel_set_close_on_unref(channel: ?*GIOChannel, do_close: gboolean) void;
pub extern fn g_io_channel_get_close_on_unref(channel: ?*GIOChannel) gboolean;
pub extern fn g_io_channel_flush(channel: ?*GIOChannel, @"error": [*c]([*c]GError)) GIOStatus;
pub extern fn g_io_channel_read_line(channel: ?*GIOChannel, str_return: [*c]([*c]gchar), length: [*c]gsize, terminator_pos: [*c]gsize, @"error": [*c]([*c]GError)) GIOStatus;
pub extern fn g_io_channel_read_line_string(channel: ?*GIOChannel, buffer: [*c]GString, terminator_pos: [*c]gsize, @"error": [*c]([*c]GError)) GIOStatus;
pub extern fn g_io_channel_read_to_end(channel: ?*GIOChannel, str_return: [*c]([*c]gchar), length: [*c]gsize, @"error": [*c]([*c]GError)) GIOStatus;
pub extern fn g_io_channel_read_chars(channel: ?*GIOChannel, buf: [*c]gchar, count: gsize, bytes_read: [*c]gsize, @"error": [*c]([*c]GError)) GIOStatus;
pub extern fn g_io_channel_read_unichar(channel: ?*GIOChannel, thechar: [*c]gunichar, @"error": [*c]([*c]GError)) GIOStatus;
pub extern fn g_io_channel_write_chars(channel: ?*GIOChannel, buf: [*c]const gchar, count: gssize, bytes_written: [*c]gsize, @"error": [*c]([*c]GError)) GIOStatus;
pub extern fn g_io_channel_write_unichar(channel: ?*GIOChannel, thechar: gunichar, @"error": [*c]([*c]GError)) GIOStatus;
pub extern fn g_io_channel_seek_position(channel: ?*GIOChannel, offset: gint64, type_0: GSeekType, @"error": [*c]([*c]GError)) GIOStatus;
pub extern fn g_io_channel_new_file(filename: [*c]const gchar, mode: [*c]const gchar, @"error": [*c]([*c]GError)) ?*GIOChannel;
pub extern fn g_io_channel_error_quark() GQuark;
pub extern fn g_io_channel_error_from_errno(en: gint) GIOChannelError;
pub extern fn g_io_channel_unix_new(fd: c_int) ?*GIOChannel;
pub extern fn g_io_channel_unix_get_fd(channel: ?*GIOChannel) gint;
pub extern var g_io_watch_funcs: GSourceFuncs;
pub extern fn g_io_channel_win32_make_pollfd(channel: ?*GIOChannel, condition: GIOCondition, fd: [*c]GPollFD) void;
pub extern fn g_io_channel_win32_poll(fds: [*c]GPollFD, n_fds: gint, timeout_: gint) gint;
pub extern fn g_io_channel_win32_new_messages(hwnd: gsize) ?*GIOChannel;
pub extern fn g_io_channel_win32_new_fd(fd: gint) ?*GIOChannel;
pub extern fn g_io_channel_win32_get_fd(channel: ?*GIOChannel) gint;
pub extern fn g_io_channel_win32_new_socket(socket: gint) ?*GIOChannel;
pub extern fn g_io_channel_win32_new_stream_socket(socket: gint) ?*GIOChannel;
pub extern fn g_io_channel_win32_set_debug(channel: ?*GIOChannel, flag: gboolean) void;
pub const G_KEY_FILE_ERROR_UNKNOWN_ENCODING = 0;
pub const G_KEY_FILE_ERROR_PARSE = 1;
pub const G_KEY_FILE_ERROR_NOT_FOUND = 2;
pub const G_KEY_FILE_ERROR_KEY_NOT_FOUND = 3;
pub const G_KEY_FILE_ERROR_GROUP_NOT_FOUND = 4;
pub const G_KEY_FILE_ERROR_INVALID_VALUE = 5;
pub const GKeyFileError = extern enum {
    G_KEY_FILE_ERROR_UNKNOWN_ENCODING = 0,
    G_KEY_FILE_ERROR_PARSE = 1,
    G_KEY_FILE_ERROR_NOT_FOUND = 2,
    G_KEY_FILE_ERROR_KEY_NOT_FOUND = 3,
    G_KEY_FILE_ERROR_GROUP_NOT_FOUND = 4,
    G_KEY_FILE_ERROR_INVALID_VALUE = 5,
};
pub extern fn g_key_file_error_quark() GQuark;
pub const struct__GKeyFile = @OpaqueType();
pub const GKeyFile = struct__GKeyFile;
pub const G_KEY_FILE_NONE = 0;
pub const G_KEY_FILE_KEEP_COMMENTS = 1;
pub const G_KEY_FILE_KEEP_TRANSLATIONS = 2;
pub const GKeyFileFlags = extern enum {
    G_KEY_FILE_NONE = 0,
    G_KEY_FILE_KEEP_COMMENTS = 1,
    G_KEY_FILE_KEEP_TRANSLATIONS = 2,
};
pub extern fn g_key_file_new() ?*GKeyFile;
pub extern fn g_key_file_ref(key_file: ?*GKeyFile) ?*GKeyFile;
pub extern fn g_key_file_unref(key_file: ?*GKeyFile) void;
pub extern fn g_key_file_free(key_file: ?*GKeyFile) void;
pub extern fn g_key_file_set_list_separator(key_file: ?*GKeyFile, separator: gchar) void;
pub extern fn g_key_file_load_from_file(key_file: ?*GKeyFile, file: [*c]const gchar, flags: GKeyFileFlags, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_key_file_load_from_data(key_file: ?*GKeyFile, data: [*c]const gchar, length: gsize, flags: GKeyFileFlags, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_key_file_load_from_bytes(key_file: ?*GKeyFile, bytes: ?*GBytes, flags: GKeyFileFlags, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_key_file_load_from_dirs(key_file: ?*GKeyFile, file: [*c]const gchar, search_dirs: [*c]([*c]const gchar), full_path: [*c]([*c]gchar), flags: GKeyFileFlags, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_key_file_load_from_data_dirs(key_file: ?*GKeyFile, file: [*c]const gchar, full_path: [*c]([*c]gchar), flags: GKeyFileFlags, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_key_file_to_data(key_file: ?*GKeyFile, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_key_file_save_to_file(key_file: ?*GKeyFile, filename: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_key_file_get_start_group(key_file: ?*GKeyFile) [*c]gchar;
pub extern fn g_key_file_get_groups(key_file: ?*GKeyFile, length: [*c]gsize) [*c]([*c]gchar);
pub extern fn g_key_file_get_keys(key_file: ?*GKeyFile, group_name: [*c]const gchar, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]([*c]gchar);
pub extern fn g_key_file_has_group(key_file: ?*GKeyFile, group_name: [*c]const gchar) gboolean;
pub extern fn g_key_file_has_key(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_key_file_get_value(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_key_file_set_value(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: [*c]const gchar) void;
pub extern fn g_key_file_get_string(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_key_file_set_string(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, string: [*c]const gchar) void;
pub extern fn g_key_file_get_locale_string(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_key_file_get_locale_for_key(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar) [*c]gchar;
pub extern fn g_key_file_set_locale_string(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar, string: [*c]const gchar) void;
pub extern fn g_key_file_get_boolean(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_key_file_set_boolean(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: gboolean) void;
pub extern fn g_key_file_get_integer(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c]([*c]GError)) gint;
pub extern fn g_key_file_set_integer(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: gint) void;
pub extern fn g_key_file_get_int64(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c]([*c]GError)) gint64;
pub extern fn g_key_file_set_int64(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: gint64) void;
pub extern fn g_key_file_get_uint64(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c]([*c]GError)) guint64;
pub extern fn g_key_file_set_uint64(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: guint64) void;
pub extern fn g_key_file_get_double(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c]([*c]GError)) gdouble;
pub extern fn g_key_file_set_double(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, value: gdouble) void;
pub extern fn g_key_file_get_string_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]([*c]gchar);
pub extern fn g_key_file_set_string_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, list: [*c]const ([*c]const gchar), length: gsize) void;
pub extern fn g_key_file_get_locale_string_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]([*c]gchar);
pub extern fn g_key_file_set_locale_string_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, locale: [*c]const gchar, list: [*c]const ([*c]const gchar), length: gsize) void;
pub extern fn g_key_file_get_boolean_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]gboolean;
pub extern fn g_key_file_set_boolean_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, list: [*c]gboolean, length: gsize) void;
pub extern fn g_key_file_get_integer_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]gint;
pub extern fn g_key_file_set_double_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, list: [*c]gdouble, length: gsize) void;
pub extern fn g_key_file_get_double_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]gdouble;
pub extern fn g_key_file_set_integer_list(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, list: [*c]gint, length: gsize) void;
pub extern fn g_key_file_set_comment(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, comment: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_key_file_get_comment(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_key_file_remove_comment(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_key_file_remove_key(key_file: ?*GKeyFile, group_name: [*c]const gchar, key: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_key_file_remove_group(key_file: ?*GKeyFile, group_name: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub const struct__GMappedFile = @OpaqueType();
pub const GMappedFile = struct__GMappedFile;
pub extern fn g_mapped_file_new(filename: [*c]const gchar, writable: gboolean, @"error": [*c]([*c]GError)) ?*GMappedFile;
pub extern fn g_mapped_file_new_from_fd(fd: gint, writable: gboolean, @"error": [*c]([*c]GError)) ?*GMappedFile;
pub extern fn g_mapped_file_get_length(file: ?*GMappedFile) gsize;
pub extern fn g_mapped_file_get_contents(file: ?*GMappedFile) [*c]gchar;
pub extern fn g_mapped_file_get_bytes(file: ?*GMappedFile) ?*GBytes;
pub extern fn g_mapped_file_ref(file: ?*GMappedFile) ?*GMappedFile;
pub extern fn g_mapped_file_unref(file: ?*GMappedFile) void;
pub extern fn g_mapped_file_free(file: ?*GMappedFile) void;
pub const G_MARKUP_ERROR_BAD_UTF8 = 0;
pub const G_MARKUP_ERROR_EMPTY = 1;
pub const G_MARKUP_ERROR_PARSE = 2;
pub const G_MARKUP_ERROR_UNKNOWN_ELEMENT = 3;
pub const G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE = 4;
pub const G_MARKUP_ERROR_INVALID_CONTENT = 5;
pub const G_MARKUP_ERROR_MISSING_ATTRIBUTE = 6;
pub const GMarkupError = extern enum {
    G_MARKUP_ERROR_BAD_UTF8 = 0,
    G_MARKUP_ERROR_EMPTY = 1,
    G_MARKUP_ERROR_PARSE = 2,
    G_MARKUP_ERROR_UNKNOWN_ELEMENT = 3,
    G_MARKUP_ERROR_UNKNOWN_ATTRIBUTE = 4,
    G_MARKUP_ERROR_INVALID_CONTENT = 5,
    G_MARKUP_ERROR_MISSING_ATTRIBUTE = 6,
};
pub extern fn g_markup_error_quark() GQuark;
pub const G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1;
pub const G_MARKUP_TREAT_CDATA_AS_TEXT = 2;
pub const G_MARKUP_PREFIX_ERROR_POSITION = 4;
pub const G_MARKUP_IGNORE_QUALIFIED = 8;
pub const GMarkupParseFlags = extern enum {
    G_MARKUP_DO_NOT_USE_THIS_UNSUPPORTED_FLAG = 1,
    G_MARKUP_TREAT_CDATA_AS_TEXT = 2,
    G_MARKUP_PREFIX_ERROR_POSITION = 4,
    G_MARKUP_IGNORE_QUALIFIED = 8,
};
pub const struct__GMarkupParseContext = @OpaqueType();
pub const GMarkupParseContext = struct__GMarkupParseContext;
pub const struct__GMarkupParser = extern struct {
    start_element: ?extern fn (?*GMarkupParseContext, [*c]const gchar, [*c]([*c]const gchar), [*c]([*c]const gchar), gpointer, [*c]([*c]GError)) void,
    end_element: ?extern fn (?*GMarkupParseContext, [*c]const gchar, gpointer, [*c]([*c]GError)) void,
    text: ?extern fn (?*GMarkupParseContext, [*c]const gchar, gsize, gpointer, [*c]([*c]GError)) void,
    passthrough: ?extern fn (?*GMarkupParseContext, [*c]const gchar, gsize, gpointer, [*c]([*c]GError)) void,
    @"error": ?extern fn (?*GMarkupParseContext, [*c]GError, gpointer) void,
};
pub const GMarkupParser = struct__GMarkupParser;
pub extern fn g_markup_parse_context_new(parser: [*c]const GMarkupParser, flags: GMarkupParseFlags, user_data: gpointer, user_data_dnotify: GDestroyNotify) ?*GMarkupParseContext;
pub extern fn g_markup_parse_context_ref(context: ?*GMarkupParseContext) ?*GMarkupParseContext;
pub extern fn g_markup_parse_context_unref(context: ?*GMarkupParseContext) void;
pub extern fn g_markup_parse_context_free(context: ?*GMarkupParseContext) void;
pub extern fn g_markup_parse_context_parse(context: ?*GMarkupParseContext, text: [*c]const gchar, text_len: gssize, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_markup_parse_context_push(context: ?*GMarkupParseContext, parser: [*c]const GMarkupParser, user_data: gpointer) void;
pub extern fn g_markup_parse_context_pop(context: ?*GMarkupParseContext) gpointer;
pub extern fn g_markup_parse_context_end_parse(context: ?*GMarkupParseContext, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_markup_parse_context_get_element(context: ?*GMarkupParseContext) [*c]const gchar;
pub extern fn g_markup_parse_context_get_element_stack(context: ?*GMarkupParseContext) [*c]const GSList;
pub extern fn g_markup_parse_context_get_position(context: ?*GMarkupParseContext, line_number: [*c]gint, char_number: [*c]gint) void;
pub extern fn g_markup_parse_context_get_user_data(context: ?*GMarkupParseContext) gpointer;
pub extern fn g_markup_escape_text(text: [*c]const gchar, length: gssize) [*c]gchar;
pub extern fn g_markup_printf_escaped(format: [*c]const u8, ...) [*c]gchar;
pub extern fn g_markup_vprintf_escaped(format: [*c]const u8, args: va_list) [*c]gchar;
pub const G_MARKUP_COLLECT_INVALID = 0;
pub const G_MARKUP_COLLECT_STRING = 1;
pub const G_MARKUP_COLLECT_STRDUP = 2;
pub const G_MARKUP_COLLECT_BOOLEAN = 3;
pub const G_MARKUP_COLLECT_TRISTATE = 4;
pub const G_MARKUP_COLLECT_OPTIONAL = 65536;
pub const GMarkupCollectType = extern enum {
    G_MARKUP_COLLECT_INVALID = 0,
    G_MARKUP_COLLECT_STRING = 1,
    G_MARKUP_COLLECT_STRDUP = 2,
    G_MARKUP_COLLECT_BOOLEAN = 3,
    G_MARKUP_COLLECT_TRISTATE = 4,
    G_MARKUP_COLLECT_OPTIONAL = 65536,
};
pub extern fn g_markup_collect_attributes(element_name: [*c]const gchar, attribute_names: [*c]([*c]const gchar), attribute_values: [*c]([*c]const gchar), @"error": [*c]([*c]GError), first_type: GMarkupCollectType, first_attr: [*c]const gchar, ...) gboolean;
pub const struct__GVariantType = @OpaqueType();
pub const GVariantType = struct__GVariantType;
pub extern fn g_variant_type_string_is_valid(type_string: [*c]const gchar) gboolean;
pub extern fn g_variant_type_string_scan(string: [*c]const gchar, limit: [*c]const gchar, endptr: [*c]([*c]const gchar)) gboolean;
pub extern fn g_variant_type_free(type_0: ?*GVariantType) void;
pub extern fn g_variant_type_copy(type_0: ?*const GVariantType) ?*GVariantType;
pub extern fn g_variant_type_new(type_string: [*c]const gchar) ?*GVariantType;
pub extern fn g_variant_type_get_string_length(type_0: ?*const GVariantType) gsize;
pub extern fn g_variant_type_peek_string(type_0: ?*const GVariantType) [*c]const gchar;
pub extern fn g_variant_type_dup_string(type_0: ?*const GVariantType) [*c]gchar;
pub extern fn g_variant_type_is_definite(type_0: ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_container(type_0: ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_basic(type_0: ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_maybe(type_0: ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_array(type_0: ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_tuple(type_0: ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_dict_entry(type_0: ?*const GVariantType) gboolean;
pub extern fn g_variant_type_is_variant(type_0: ?*const GVariantType) gboolean;
pub extern fn g_variant_type_hash(type_0: gconstpointer) guint;
pub extern fn g_variant_type_equal(type1: gconstpointer, type2: gconstpointer) gboolean;
pub extern fn g_variant_type_is_subtype_of(type_0: ?*const GVariantType, supertype: ?*const GVariantType) gboolean;
pub extern fn g_variant_type_element(type_0: ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_first(type_0: ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_next(type_0: ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_n_items(type_0: ?*const GVariantType) gsize;
pub extern fn g_variant_type_key(type_0: ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_value(type_0: ?*const GVariantType) ?*const GVariantType;
pub extern fn g_variant_type_new_array(element: ?*const GVariantType) ?*GVariantType;
pub extern fn g_variant_type_new_maybe(element: ?*const GVariantType) ?*GVariantType;
pub extern fn g_variant_type_new_tuple(items: [*c]const (?*const GVariantType), length: gint) ?*GVariantType;
pub extern fn g_variant_type_new_dict_entry(key: ?*const GVariantType, value: ?*const GVariantType) ?*GVariantType;
pub extern fn g_variant_type_checked_(arg0: [*c]const gchar) ?*const GVariantType;
pub extern fn g_variant_type_string_get_depth_(type_string: [*c]const gchar) gsize;
pub const struct__GVariant = @OpaqueType();
pub const GVariant = struct__GVariant;
pub const G_VARIANT_CLASS_BOOLEAN = 98;
pub const G_VARIANT_CLASS_BYTE = 121;
pub const G_VARIANT_CLASS_INT16 = 110;
pub const G_VARIANT_CLASS_UINT16 = 113;
pub const G_VARIANT_CLASS_INT32 = 105;
pub const G_VARIANT_CLASS_UINT32 = 117;
pub const G_VARIANT_CLASS_INT64 = 120;
pub const G_VARIANT_CLASS_UINT64 = 116;
pub const G_VARIANT_CLASS_HANDLE = 104;
pub const G_VARIANT_CLASS_DOUBLE = 100;
pub const G_VARIANT_CLASS_STRING = 115;
pub const G_VARIANT_CLASS_OBJECT_PATH = 111;
pub const G_VARIANT_CLASS_SIGNATURE = 103;
pub const G_VARIANT_CLASS_VARIANT = 118;
pub const G_VARIANT_CLASS_MAYBE = 109;
pub const G_VARIANT_CLASS_ARRAY = 97;
pub const G_VARIANT_CLASS_TUPLE = 40;
pub const G_VARIANT_CLASS_DICT_ENTRY = 123;
pub const GVariantClass = extern enum {
    G_VARIANT_CLASS_BOOLEAN = 98,
    G_VARIANT_CLASS_BYTE = 121,
    G_VARIANT_CLASS_INT16 = 110,
    G_VARIANT_CLASS_UINT16 = 113,
    G_VARIANT_CLASS_INT32 = 105,
    G_VARIANT_CLASS_UINT32 = 117,
    G_VARIANT_CLASS_INT64 = 120,
    G_VARIANT_CLASS_UINT64 = 116,
    G_VARIANT_CLASS_HANDLE = 104,
    G_VARIANT_CLASS_DOUBLE = 100,
    G_VARIANT_CLASS_STRING = 115,
    G_VARIANT_CLASS_OBJECT_PATH = 111,
    G_VARIANT_CLASS_SIGNATURE = 103,
    G_VARIANT_CLASS_VARIANT = 118,
    G_VARIANT_CLASS_MAYBE = 109,
    G_VARIANT_CLASS_ARRAY = 97,
    G_VARIANT_CLASS_TUPLE = 40,
    G_VARIANT_CLASS_DICT_ENTRY = 123,
};
pub extern fn g_variant_unref(value: ?*GVariant) void;
pub extern fn g_variant_ref(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_ref_sink(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_is_floating(value: ?*GVariant) gboolean;
pub extern fn g_variant_take_ref(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_get_type(value: ?*GVariant) ?*const GVariantType;
pub extern fn g_variant_get_type_string(value: ?*GVariant) [*c]const gchar;
pub extern fn g_variant_is_of_type(value: ?*GVariant, type_0: ?*const GVariantType) gboolean;
pub extern fn g_variant_is_container(value: ?*GVariant) gboolean;
pub extern fn g_variant_classify(value: ?*GVariant) GVariantClass;
pub extern fn g_variant_new_boolean(value: gboolean) ?*GVariant;
pub extern fn g_variant_new_byte(value: guint8) ?*GVariant;
pub extern fn g_variant_new_int16(value: gint16) ?*GVariant;
pub extern fn g_variant_new_uint16(value: guint16) ?*GVariant;
pub extern fn g_variant_new_int32(value: gint32) ?*GVariant;
pub extern fn g_variant_new_uint32(value: guint32) ?*GVariant;
pub extern fn g_variant_new_int64(value: gint64) ?*GVariant;
pub extern fn g_variant_new_uint64(value: guint64) ?*GVariant;
pub extern fn g_variant_new_handle(value: gint32) ?*GVariant;
pub extern fn g_variant_new_double(value: gdouble) ?*GVariant;
pub extern fn g_variant_new_string(string: [*c]const gchar) ?*GVariant;
pub extern fn g_variant_new_take_string(string: [*c]gchar) ?*GVariant;
pub extern fn g_variant_new_printf(format_string: [*c]const gchar, ...) ?*GVariant;
pub extern fn g_variant_new_object_path(object_path: [*c]const gchar) ?*GVariant;
pub extern fn g_variant_is_object_path(string: [*c]const gchar) gboolean;
pub extern fn g_variant_new_signature(signature: [*c]const gchar) ?*GVariant;
pub extern fn g_variant_is_signature(string: [*c]const gchar) gboolean;
pub extern fn g_variant_new_variant(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_new_strv(strv: [*c]const ([*c]const gchar), length: gssize) ?*GVariant;
pub extern fn g_variant_new_objv(strv: [*c]const ([*c]const gchar), length: gssize) ?*GVariant;
pub extern fn g_variant_new_bytestring(string: [*c]const gchar) ?*GVariant;
pub extern fn g_variant_new_bytestring_array(strv: [*c]const ([*c]const gchar), length: gssize) ?*GVariant;
pub extern fn g_variant_new_fixed_array(element_type: ?*const GVariantType, elements: gconstpointer, n_elements: gsize, element_size: gsize) ?*GVariant;
pub extern fn g_variant_get_boolean(value: ?*GVariant) gboolean;
pub extern fn g_variant_get_byte(value: ?*GVariant) guint8;
pub extern fn g_variant_get_int16(value: ?*GVariant) gint16;
pub extern fn g_variant_get_uint16(value: ?*GVariant) guint16;
pub extern fn g_variant_get_int32(value: ?*GVariant) gint32;
pub extern fn g_variant_get_uint32(value: ?*GVariant) guint32;
pub extern fn g_variant_get_int64(value: ?*GVariant) gint64;
pub extern fn g_variant_get_uint64(value: ?*GVariant) guint64;
pub extern fn g_variant_get_handle(value: ?*GVariant) gint32;
pub extern fn g_variant_get_double(value: ?*GVariant) gdouble;
pub extern fn g_variant_get_variant(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_get_string(value: ?*GVariant, length: [*c]gsize) [*c]const gchar;
pub extern fn g_variant_dup_string(value: ?*GVariant, length: [*c]gsize) [*c]gchar;
pub extern fn g_variant_get_strv(value: ?*GVariant, length: [*c]gsize) [*c]([*c]const gchar);
pub extern fn g_variant_dup_strv(value: ?*GVariant, length: [*c]gsize) [*c]([*c]gchar);
pub extern fn g_variant_get_objv(value: ?*GVariant, length: [*c]gsize) [*c]([*c]const gchar);
pub extern fn g_variant_dup_objv(value: ?*GVariant, length: [*c]gsize) [*c]([*c]gchar);
pub extern fn g_variant_get_bytestring(value: ?*GVariant) [*c]const gchar;
pub extern fn g_variant_dup_bytestring(value: ?*GVariant, length: [*c]gsize) [*c]gchar;
pub extern fn g_variant_get_bytestring_array(value: ?*GVariant, length: [*c]gsize) [*c]([*c]const gchar);
pub extern fn g_variant_dup_bytestring_array(value: ?*GVariant, length: [*c]gsize) [*c]([*c]gchar);
pub extern fn g_variant_new_maybe(child_type: ?*const GVariantType, child: ?*GVariant) ?*GVariant;
pub extern fn g_variant_new_array(child_type: ?*const GVariantType, children: [*c]const (?*GVariant), n_children: gsize) ?*GVariant;
pub extern fn g_variant_new_tuple(children: [*c]const (?*GVariant), n_children: gsize) ?*GVariant;
pub extern fn g_variant_new_dict_entry(key: ?*GVariant, value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_get_maybe(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_n_children(value: ?*GVariant) gsize;
pub extern fn g_variant_get_child(value: ?*GVariant, index_: gsize, format_string: [*c]const gchar, ...) void;
pub extern fn g_variant_get_child_value(value: ?*GVariant, index_: gsize) ?*GVariant;
pub extern fn g_variant_lookup(dictionary: ?*GVariant, key: [*c]const gchar, format_string: [*c]const gchar, ...) gboolean;
pub extern fn g_variant_lookup_value(dictionary: ?*GVariant, key: [*c]const gchar, expected_type: ?*const GVariantType) ?*GVariant;
pub extern fn g_variant_get_fixed_array(value: ?*GVariant, n_elements: [*c]gsize, element_size: gsize) gconstpointer;
pub extern fn g_variant_get_size(value: ?*GVariant) gsize;
pub extern fn g_variant_get_data(value: ?*GVariant) gconstpointer;
pub extern fn g_variant_get_data_as_bytes(value: ?*GVariant) ?*GBytes;
pub extern fn g_variant_store(value: ?*GVariant, data: gpointer) void;
pub extern fn g_variant_print(value: ?*GVariant, type_annotate: gboolean) [*c]gchar;
pub extern fn g_variant_print_string(value: ?*GVariant, string: [*c]GString, type_annotate: gboolean) [*c]GString;
pub extern fn g_variant_hash(value: gconstpointer) guint;
pub extern fn g_variant_equal(one: gconstpointer, two: gconstpointer) gboolean;
pub extern fn g_variant_get_normal_form(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_is_normal_form(value: ?*GVariant) gboolean;
pub extern fn g_variant_byteswap(value: ?*GVariant) ?*GVariant;
pub extern fn g_variant_new_from_bytes(type_0: ?*const GVariantType, bytes: ?*GBytes, trusted: gboolean) ?*GVariant;
pub extern fn g_variant_new_from_data(type_0: ?*const GVariantType, data: gconstpointer, size: gsize, trusted: gboolean, notify: GDestroyNotify, user_data: gpointer) ?*GVariant;
pub const struct__GVariantIter = extern struct {
    x: [16]gsize,
};
pub const GVariantIter = struct__GVariantIter;
pub extern fn g_variant_iter_new(value: ?*GVariant) [*c]GVariantIter;
pub extern fn g_variant_iter_init(iter: [*c]GVariantIter, value: ?*GVariant) gsize;
pub extern fn g_variant_iter_copy(iter: [*c]GVariantIter) [*c]GVariantIter;
pub extern fn g_variant_iter_n_children(iter: [*c]GVariantIter) gsize;
pub extern fn g_variant_iter_free(iter: [*c]GVariantIter) void;
pub extern fn g_variant_iter_next_value(iter: [*c]GVariantIter) ?*GVariant;
pub extern fn g_variant_iter_next(iter: [*c]GVariantIter, format_string: [*c]const gchar, ...) gboolean;
pub extern fn g_variant_iter_loop(iter: [*c]GVariantIter, format_string: [*c]const gchar, ...) gboolean;
pub const struct__GVariantBuilder = extern struct {
    u: extern union {
        s: extern struct {
            partial_magic: gsize,
            type: ?*const GVariantType,
            y: [14]gsize,
        },
        x: [16]gsize,
    },
};
pub const GVariantBuilder = struct__GVariantBuilder;
pub const G_VARIANT_PARSE_ERROR_FAILED = 0;
pub const G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED = 1;
pub const G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE = 2;
pub const G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED = 3;
pub const G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END = 4;
pub const G_VARIANT_PARSE_ERROR_INVALID_CHARACTER = 5;
pub const G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING = 6;
pub const G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH = 7;
pub const G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE = 8;
pub const G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING = 9;
pub const G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE = 10;
pub const G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE = 11;
pub const G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG = 12;
pub const G_VARIANT_PARSE_ERROR_TYPE_ERROR = 13;
pub const G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN = 14;
pub const G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD = 15;
pub const G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT = 16;
pub const G_VARIANT_PARSE_ERROR_VALUE_EXPECTED = 17;
pub const GVariantParseError = extern enum {
    G_VARIANT_PARSE_ERROR_FAILED = 0,
    G_VARIANT_PARSE_ERROR_BASIC_TYPE_EXPECTED = 1,
    G_VARIANT_PARSE_ERROR_CANNOT_INFER_TYPE = 2,
    G_VARIANT_PARSE_ERROR_DEFINITE_TYPE_EXPECTED = 3,
    G_VARIANT_PARSE_ERROR_INPUT_NOT_AT_END = 4,
    G_VARIANT_PARSE_ERROR_INVALID_CHARACTER = 5,
    G_VARIANT_PARSE_ERROR_INVALID_FORMAT_STRING = 6,
    G_VARIANT_PARSE_ERROR_INVALID_OBJECT_PATH = 7,
    G_VARIANT_PARSE_ERROR_INVALID_SIGNATURE = 8,
    G_VARIANT_PARSE_ERROR_INVALID_TYPE_STRING = 9,
    G_VARIANT_PARSE_ERROR_NO_COMMON_TYPE = 10,
    G_VARIANT_PARSE_ERROR_NUMBER_OUT_OF_RANGE = 11,
    G_VARIANT_PARSE_ERROR_NUMBER_TOO_BIG = 12,
    G_VARIANT_PARSE_ERROR_TYPE_ERROR = 13,
    G_VARIANT_PARSE_ERROR_UNEXPECTED_TOKEN = 14,
    G_VARIANT_PARSE_ERROR_UNKNOWN_KEYWORD = 15,
    G_VARIANT_PARSE_ERROR_UNTERMINATED_STRING_CONSTANT = 16,
    G_VARIANT_PARSE_ERROR_VALUE_EXPECTED = 17,
};
pub extern fn g_variant_parser_get_error_quark() GQuark;
pub extern fn g_variant_parse_error_quark() GQuark;
pub extern fn g_variant_builder_new(type_0: ?*const GVariantType) [*c]GVariantBuilder;
pub extern fn g_variant_builder_unref(builder: [*c]GVariantBuilder) void;
pub extern fn g_variant_builder_ref(builder: [*c]GVariantBuilder) [*c]GVariantBuilder;
pub extern fn g_variant_builder_init(builder: [*c]GVariantBuilder, type_0: ?*const GVariantType) void;
pub extern fn g_variant_builder_end(builder: [*c]GVariantBuilder) ?*GVariant;
pub extern fn g_variant_builder_clear(builder: [*c]GVariantBuilder) void;
pub extern fn g_variant_builder_open(builder: [*c]GVariantBuilder, type_0: ?*const GVariantType) void;
pub extern fn g_variant_builder_close(builder: [*c]GVariantBuilder) void;
pub extern fn g_variant_builder_add_value(builder: [*c]GVariantBuilder, value: ?*GVariant) void;
pub extern fn g_variant_builder_add(builder: [*c]GVariantBuilder, format_string: [*c]const gchar, ...) void;
pub extern fn g_variant_builder_add_parsed(builder: [*c]GVariantBuilder, format: [*c]const gchar, ...) void;
pub extern fn g_variant_new(format_string: [*c]const gchar, ...) ?*GVariant;
pub extern fn g_variant_get(value: ?*GVariant, format_string: [*c]const gchar, ...) void;
pub extern fn g_variant_new_va(format_string: [*c]const gchar, endptr: [*c]([*c]const gchar), app: [*c]va_list) ?*GVariant;
pub extern fn g_variant_get_va(value: ?*GVariant, format_string: [*c]const gchar, endptr: [*c]([*c]const gchar), app: [*c]va_list) void;
pub extern fn g_variant_check_format_string(value: ?*GVariant, format_string: [*c]const gchar, copy_only: gboolean) gboolean;
pub extern fn g_variant_parse(type_0: ?*const GVariantType, text: [*c]const gchar, limit: [*c]const gchar, endptr: [*c]([*c]const gchar), @"error": [*c]([*c]GError)) ?*GVariant;
pub extern fn g_variant_new_parsed(format: [*c]const gchar, ...) ?*GVariant;
pub extern fn g_variant_new_parsed_va(format: [*c]const gchar, app: [*c]va_list) ?*GVariant;
pub extern fn g_variant_parse_error_print_context(@"error": [*c]GError, source_str: [*c]const gchar) [*c]gchar;
pub extern fn g_variant_compare(one: gconstpointer, two: gconstpointer) gint;
pub const struct__GVariantDict = extern struct {
    u: extern union {
        s: extern struct {
            asv: ?*GVariant,
            partial_magic: gsize,
            y: [14]gsize,
        },
        x: [16]gsize,
    },
};
pub const GVariantDict = struct__GVariantDict;
pub extern fn g_variant_dict_new(from_asv: ?*GVariant) [*c]GVariantDict;
pub extern fn g_variant_dict_init(dict: [*c]GVariantDict, from_asv: ?*GVariant) void;
pub extern fn g_variant_dict_lookup(dict: [*c]GVariantDict, key: [*c]const gchar, format_string: [*c]const gchar, ...) gboolean;
pub extern fn g_variant_dict_lookup_value(dict: [*c]GVariantDict, key: [*c]const gchar, expected_type: ?*const GVariantType) ?*GVariant;
pub extern fn g_variant_dict_contains(dict: [*c]GVariantDict, key: [*c]const gchar) gboolean;
pub extern fn g_variant_dict_insert(dict: [*c]GVariantDict, key: [*c]const gchar, format_string: [*c]const gchar, ...) void;
pub extern fn g_variant_dict_insert_value(dict: [*c]GVariantDict, key: [*c]const gchar, value: ?*GVariant) void;
pub extern fn g_variant_dict_remove(dict: [*c]GVariantDict, key: [*c]const gchar) gboolean;
pub extern fn g_variant_dict_clear(dict: [*c]GVariantDict) void;
pub extern fn g_variant_dict_end(dict: [*c]GVariantDict) ?*GVariant;
pub extern fn g_variant_dict_ref(dict: [*c]GVariantDict) [*c]GVariantDict;
pub extern fn g_variant_dict_unref(dict: [*c]GVariantDict) void;
pub extern fn g_printf_string_upper_bound(format: [*c]const gchar, args: va_list) gsize;
pub const G_LOG_FLAG_RECURSION = 1;
pub const G_LOG_FLAG_FATAL = 2;
pub const G_LOG_LEVEL_ERROR = 4;
pub const G_LOG_LEVEL_CRITICAL = 8;
pub const G_LOG_LEVEL_WARNING = 16;
pub const G_LOG_LEVEL_MESSAGE = 32;
pub const G_LOG_LEVEL_INFO = 64;
pub const G_LOG_LEVEL_DEBUG = 128;
pub const G_LOG_LEVEL_MASK = -4;
pub const GLogLevelFlags = extern enum {
    G_LOG_FLAG_RECURSION = 1,
    G_LOG_FLAG_FATAL = 2,
    G_LOG_LEVEL_ERROR = 4,
    G_LOG_LEVEL_CRITICAL = 8,
    G_LOG_LEVEL_WARNING = 16,
    G_LOG_LEVEL_MESSAGE = 32,
    G_LOG_LEVEL_INFO = 64,
    G_LOG_LEVEL_DEBUG = 128,
    G_LOG_LEVEL_MASK = -4,
};
pub const GLogFunc = ?extern fn ([*c]const gchar, GLogLevelFlags, [*c]const gchar, gpointer) void;
pub extern fn g_log_set_handler(log_domain: [*c]const gchar, log_levels: GLogLevelFlags, log_func: GLogFunc, user_data: gpointer) guint;
pub extern fn g_log_set_handler_full(log_domain: [*c]const gchar, log_levels: GLogLevelFlags, log_func: GLogFunc, user_data: gpointer, destroy: GDestroyNotify) guint;
pub extern fn g_log_remove_handler(log_domain: [*c]const gchar, handler_id: guint) void;
pub extern fn g_log_default_handler(log_domain: [*c]const gchar, log_level: GLogLevelFlags, message: [*c]const gchar, unused_data: gpointer) void;
pub extern fn g_log_set_default_handler(log_func: GLogFunc, user_data: gpointer) GLogFunc;
pub extern fn g_log(log_domain: [*c]const gchar, log_level: GLogLevelFlags, format: [*c]const gchar, ...) void;
pub extern fn g_logv(log_domain: [*c]const gchar, log_level: GLogLevelFlags, format: [*c]const gchar, args: va_list) void;
pub extern fn g_log_set_fatal_mask(log_domain: [*c]const gchar, fatal_mask: GLogLevelFlags) GLogLevelFlags;
pub extern fn g_log_set_always_fatal(fatal_mask: GLogLevelFlags) GLogLevelFlags;
pub const G_LOG_WRITER_HANDLED = 1;
pub const G_LOG_WRITER_UNHANDLED = 0;
pub const GLogWriterOutput = extern enum {
    G_LOG_WRITER_HANDLED = 1,
    G_LOG_WRITER_UNHANDLED = 0,
};
pub const struct__GLogField = extern struct {
    key: [*c]const gchar,
    value: gconstpointer,
    length: gssize,
};
pub const GLogField = struct__GLogField;
pub const GLogWriterFunc = ?extern fn (GLogLevelFlags, [*c]const GLogField, gsize, gpointer) GLogWriterOutput;
pub extern fn g_log_structured(log_domain: [*c]const gchar, log_level: GLogLevelFlags, ...) void;
pub extern fn g_log_structured_array(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize) void;
pub extern fn g_log_variant(log_domain: [*c]const gchar, log_level: GLogLevelFlags, fields: ?*GVariant) void;
pub extern fn g_log_set_writer_func(func: GLogWriterFunc, user_data: gpointer, user_data_free: GDestroyNotify) void;
pub extern fn g_log_writer_supports_color(output_fd: gint) gboolean;
pub extern fn g_log_writer_is_journald(output_fd: gint) gboolean;
pub extern fn g_log_writer_format_fields(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize, use_color: gboolean) [*c]gchar;
pub extern fn g_log_writer_journald(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize, user_data: gpointer) GLogWriterOutput;
pub extern fn g_log_writer_standard_streams(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize, user_data: gpointer) GLogWriterOutput;
pub extern fn g_log_writer_default(log_level: GLogLevelFlags, fields: [*c]const GLogField, n_fields: gsize, user_data: gpointer) GLogWriterOutput;
pub extern fn _g_log_fallback_handler(log_domain: [*c]const gchar, log_level: GLogLevelFlags, message: [*c]const gchar, unused_data: gpointer) void;
pub extern fn g_return_if_fail_warning(log_domain: [*c]const u8, pretty_function: [*c]const u8, expression: [*c]const u8) void;
pub extern fn g_warn_message(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, warnexpr: [*c]const u8) void;
pub extern fn g_assert_warning(log_domain: [*c]const u8, file: [*c]const u8, line: c_int, pretty_function: [*c]const u8, expression: [*c]const u8) void;
pub extern fn g_log_structured_standard(log_domain: [*c]const gchar, log_level: GLogLevelFlags, file: [*c]const gchar, line: [*c]const gchar, func: [*c]const gchar, message_format: [*c]const gchar, ...) void;
pub const GPrintFunc = ?extern fn ([*c]const gchar) void;
pub extern fn g_print(format: [*c]const gchar, ...) void;
pub extern fn g_set_print_handler(func: GPrintFunc) GPrintFunc;
pub extern fn g_printerr(format: [*c]const gchar, ...) void;
pub extern fn g_set_printerr_handler(func: GPrintFunc) GPrintFunc;
pub const struct__GOptionContext = @OpaqueType();
pub const GOptionContext = struct__GOptionContext;
pub const struct__GOptionGroup = @OpaqueType();
pub const GOptionGroup = struct__GOptionGroup;
pub const G_OPTION_ARG_NONE = 0;
pub const G_OPTION_ARG_STRING = 1;
pub const G_OPTION_ARG_INT = 2;
pub const G_OPTION_ARG_CALLBACK = 3;
pub const G_OPTION_ARG_FILENAME = 4;
pub const G_OPTION_ARG_STRING_ARRAY = 5;
pub const G_OPTION_ARG_FILENAME_ARRAY = 6;
pub const G_OPTION_ARG_DOUBLE = 7;
pub const G_OPTION_ARG_INT64 = 8;
pub const GOptionArg = extern enum {
    G_OPTION_ARG_NONE = 0,
    G_OPTION_ARG_STRING = 1,
    G_OPTION_ARG_INT = 2,
    G_OPTION_ARG_CALLBACK = 3,
    G_OPTION_ARG_FILENAME = 4,
    G_OPTION_ARG_STRING_ARRAY = 5,
    G_OPTION_ARG_FILENAME_ARRAY = 6,
    G_OPTION_ARG_DOUBLE = 7,
    G_OPTION_ARG_INT64 = 8,
};
pub const struct__GOptionEntry = extern struct {
    long_name: [*c]const gchar,
    short_name: gchar,
    flags: gint,
    arg: GOptionArg,
    arg_data: gpointer,
    description: [*c]const gchar,
    arg_description: [*c]const gchar,
};
pub const GOptionEntry = struct__GOptionEntry;
pub const G_OPTION_FLAG_NONE = 0;
pub const G_OPTION_FLAG_HIDDEN = 1;
pub const G_OPTION_FLAG_IN_MAIN = 2;
pub const G_OPTION_FLAG_REVERSE = 4;
pub const G_OPTION_FLAG_NO_ARG = 8;
pub const G_OPTION_FLAG_FILENAME = 16;
pub const G_OPTION_FLAG_OPTIONAL_ARG = 32;
pub const G_OPTION_FLAG_NOALIAS = 64;
pub const GOptionFlags = extern enum {
    G_OPTION_FLAG_NONE = 0,
    G_OPTION_FLAG_HIDDEN = 1,
    G_OPTION_FLAG_IN_MAIN = 2,
    G_OPTION_FLAG_REVERSE = 4,
    G_OPTION_FLAG_NO_ARG = 8,
    G_OPTION_FLAG_FILENAME = 16,
    G_OPTION_FLAG_OPTIONAL_ARG = 32,
    G_OPTION_FLAG_NOALIAS = 64,
};
pub const GOptionArgFunc = ?extern fn ([*c]const gchar, [*c]const gchar, gpointer, [*c]([*c]GError)) gboolean;
pub const GOptionParseFunc = ?extern fn (?*GOptionContext, ?*GOptionGroup, gpointer, [*c]([*c]GError)) gboolean;
pub const GOptionErrorFunc = ?extern fn (?*GOptionContext, ?*GOptionGroup, gpointer, [*c]([*c]GError)) void;
pub const G_OPTION_ERROR_UNKNOWN_OPTION = 0;
pub const G_OPTION_ERROR_BAD_VALUE = 1;
pub const G_OPTION_ERROR_FAILED = 2;
pub const GOptionError = extern enum {
    G_OPTION_ERROR_UNKNOWN_OPTION = 0,
    G_OPTION_ERROR_BAD_VALUE = 1,
    G_OPTION_ERROR_FAILED = 2,
};
pub extern fn g_option_error_quark() GQuark;
pub extern fn g_option_context_new(parameter_string: [*c]const gchar) ?*GOptionContext;
pub extern fn g_option_context_set_summary(context: ?*GOptionContext, summary: [*c]const gchar) void;
pub extern fn g_option_context_get_summary(context: ?*GOptionContext) [*c]const gchar;
pub extern fn g_option_context_set_description(context: ?*GOptionContext, description: [*c]const gchar) void;
pub extern fn g_option_context_get_description(context: ?*GOptionContext) [*c]const gchar;
pub extern fn g_option_context_free(context: ?*GOptionContext) void;
pub extern fn g_option_context_set_help_enabled(context: ?*GOptionContext, help_enabled: gboolean) void;
pub extern fn g_option_context_get_help_enabled(context: ?*GOptionContext) gboolean;
pub extern fn g_option_context_set_ignore_unknown_options(context: ?*GOptionContext, ignore_unknown: gboolean) void;
pub extern fn g_option_context_get_ignore_unknown_options(context: ?*GOptionContext) gboolean;
pub extern fn g_option_context_set_strict_posix(context: ?*GOptionContext, strict_posix: gboolean) void;
pub extern fn g_option_context_get_strict_posix(context: ?*GOptionContext) gboolean;
pub extern fn g_option_context_add_main_entries(context: ?*GOptionContext, entries: [*c]const GOptionEntry, translation_domain: [*c]const gchar) void;
pub extern fn g_option_context_parse(context: ?*GOptionContext, argc: [*c]gint, argv: [*c]([*c]([*c]gchar)), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_option_context_parse_strv(context: ?*GOptionContext, arguments: [*c]([*c]([*c]gchar)), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_option_context_set_translate_func(context: ?*GOptionContext, func: GTranslateFunc, data: gpointer, destroy_notify: GDestroyNotify) void;
pub extern fn g_option_context_set_translation_domain(context: ?*GOptionContext, domain: [*c]const gchar) void;
pub extern fn g_option_context_add_group(context: ?*GOptionContext, group: ?*GOptionGroup) void;
pub extern fn g_option_context_set_main_group(context: ?*GOptionContext, group: ?*GOptionGroup) void;
pub extern fn g_option_context_get_main_group(context: ?*GOptionContext) ?*GOptionGroup;
pub extern fn g_option_context_get_help(context: ?*GOptionContext, main_help: gboolean, group: ?*GOptionGroup) [*c]gchar;
pub extern fn g_option_group_new(name: [*c]const gchar, description: [*c]const gchar, help_description: [*c]const gchar, user_data: gpointer, destroy: GDestroyNotify) ?*GOptionGroup;
pub extern fn g_option_group_set_parse_hooks(group: ?*GOptionGroup, pre_parse_func: GOptionParseFunc, post_parse_func: GOptionParseFunc) void;
pub extern fn g_option_group_set_error_hook(group: ?*GOptionGroup, error_func: GOptionErrorFunc) void;
pub extern fn g_option_group_free(group: ?*GOptionGroup) void;
pub extern fn g_option_group_ref(group: ?*GOptionGroup) ?*GOptionGroup;
pub extern fn g_option_group_unref(group: ?*GOptionGroup) void;
pub extern fn g_option_group_add_entries(group: ?*GOptionGroup, entries: [*c]const GOptionEntry) void;
pub extern fn g_option_group_set_translate_func(group: ?*GOptionGroup, func: GTranslateFunc, data: gpointer, destroy_notify: GDestroyNotify) void;
pub extern fn g_option_group_set_translation_domain(group: ?*GOptionGroup, domain: [*c]const gchar) void;
pub const struct__GPatternSpec = @OpaqueType();
pub const GPatternSpec = struct__GPatternSpec;
pub extern fn g_pattern_spec_new(pattern: [*c]const gchar) ?*GPatternSpec;
pub extern fn g_pattern_spec_free(pspec: ?*GPatternSpec) void;
pub extern fn g_pattern_spec_equal(pspec1: ?*GPatternSpec, pspec2: ?*GPatternSpec) gboolean;
pub extern fn g_pattern_match(pspec: ?*GPatternSpec, string_length: guint, string: [*c]const gchar, string_reversed: [*c]const gchar) gboolean;
pub extern fn g_pattern_match_string(pspec: ?*GPatternSpec, string: [*c]const gchar) gboolean;
pub extern fn g_pattern_match_simple(pattern: [*c]const gchar, string: [*c]const gchar) gboolean;
pub extern fn g_spaced_primes_closest(num: guint) guint;
pub extern fn g_qsort_with_data(pbase: gconstpointer, total_elems: gint, size: gsize, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub const struct__GQueue = extern struct {
    head: [*c]GList,
    tail: [*c]GList,
    length: guint,
};
pub const GQueue = struct__GQueue;
pub extern fn g_queue_new() [*c]GQueue;
pub extern fn g_queue_free(queue: [*c]GQueue) void;
pub extern fn g_queue_free_full(queue: [*c]GQueue, free_func: GDestroyNotify) void;
pub extern fn g_queue_init(queue: [*c]GQueue) void;
pub extern fn g_queue_clear(queue: [*c]GQueue) void;
pub extern fn g_queue_is_empty(queue: [*c]GQueue) gboolean;
pub extern fn g_queue_clear_full(queue: [*c]GQueue, free_func: GDestroyNotify) void;
pub extern fn g_queue_get_length(queue: [*c]GQueue) guint;
pub extern fn g_queue_reverse(queue: [*c]GQueue) void;
pub extern fn g_queue_copy(queue: [*c]GQueue) [*c]GQueue;
pub extern fn g_queue_foreach(queue: [*c]GQueue, func: GFunc, user_data: gpointer) void;
pub extern fn g_queue_find(queue: [*c]GQueue, data: gconstpointer) [*c]GList;
pub extern fn g_queue_find_custom(queue: [*c]GQueue, data: gconstpointer, func: GCompareFunc) [*c]GList;
pub extern fn g_queue_sort(queue: [*c]GQueue, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_queue_push_head(queue: [*c]GQueue, data: gpointer) void;
pub extern fn g_queue_push_tail(queue: [*c]GQueue, data: gpointer) void;
pub extern fn g_queue_push_nth(queue: [*c]GQueue, data: gpointer, n: gint) void;
pub extern fn g_queue_pop_head(queue: [*c]GQueue) gpointer;
pub extern fn g_queue_pop_tail(queue: [*c]GQueue) gpointer;
pub extern fn g_queue_pop_nth(queue: [*c]GQueue, n: guint) gpointer;
pub extern fn g_queue_peek_head(queue: [*c]GQueue) gpointer;
pub extern fn g_queue_peek_tail(queue: [*c]GQueue) gpointer;
pub extern fn g_queue_peek_nth(queue: [*c]GQueue, n: guint) gpointer;
pub extern fn g_queue_index(queue: [*c]GQueue, data: gconstpointer) gint;
pub extern fn g_queue_remove(queue: [*c]GQueue, data: gconstpointer) gboolean;
pub extern fn g_queue_remove_all(queue: [*c]GQueue, data: gconstpointer) guint;
pub extern fn g_queue_insert_before(queue: [*c]GQueue, sibling: [*c]GList, data: gpointer) void;
pub extern fn g_queue_insert_before_link(queue: [*c]GQueue, sibling: [*c]GList, link_: [*c]GList) void;
pub extern fn g_queue_insert_after(queue: [*c]GQueue, sibling: [*c]GList, data: gpointer) void;
pub extern fn g_queue_insert_after_link(queue: [*c]GQueue, sibling: [*c]GList, link_: [*c]GList) void;
pub extern fn g_queue_insert_sorted(queue: [*c]GQueue, data: gpointer, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_queue_push_head_link(queue: [*c]GQueue, link_: [*c]GList) void;
pub extern fn g_queue_push_tail_link(queue: [*c]GQueue, link_: [*c]GList) void;
pub extern fn g_queue_push_nth_link(queue: [*c]GQueue, n: gint, link_: [*c]GList) void;
pub extern fn g_queue_pop_head_link(queue: [*c]GQueue) [*c]GList;
pub extern fn g_queue_pop_tail_link(queue: [*c]GQueue) [*c]GList;
pub extern fn g_queue_pop_nth_link(queue: [*c]GQueue, n: guint) [*c]GList;
pub extern fn g_queue_peek_head_link(queue: [*c]GQueue) [*c]GList;
pub extern fn g_queue_peek_tail_link(queue: [*c]GQueue) [*c]GList;
pub extern fn g_queue_peek_nth_link(queue: [*c]GQueue, n: guint) [*c]GList;
pub extern fn g_queue_link_index(queue: [*c]GQueue, link_: [*c]GList) gint;
pub extern fn g_queue_unlink(queue: [*c]GQueue, link_: [*c]GList) void;
pub extern fn g_queue_delete_link(queue: [*c]GQueue, link_: [*c]GList) void;
pub const struct__GRand = @OpaqueType();
pub const GRand = struct__GRand;
pub extern fn g_rand_new_with_seed(seed: guint32) ?*GRand;
pub extern fn g_rand_new_with_seed_array(seed: [*c]const guint32, seed_length: guint) ?*GRand;
pub extern fn g_rand_new() ?*GRand;
pub extern fn g_rand_free(rand_: ?*GRand) void;
pub extern fn g_rand_copy(rand_: ?*GRand) ?*GRand;
pub extern fn g_rand_set_seed(rand_: ?*GRand, seed: guint32) void;
pub extern fn g_rand_set_seed_array(rand_: ?*GRand, seed: [*c]const guint32, seed_length: guint) void;
pub extern fn g_rand_int(rand_: ?*GRand) guint32;
pub extern fn g_rand_int_range(rand_: ?*GRand, begin: gint32, end: gint32) gint32;
pub extern fn g_rand_double(rand_: ?*GRand) gdouble;
pub extern fn g_rand_double_range(rand_: ?*GRand, begin: gdouble, end: gdouble) gdouble;
pub extern fn g_random_set_seed(seed: guint32) void;
pub extern fn g_random_int() guint32;
pub extern fn g_random_int_range(begin: gint32, end: gint32) gint32;
pub extern fn g_random_double() gdouble;
pub extern fn g_random_double_range(begin: gdouble, end: gdouble) gdouble;
pub extern fn g_rc_box_alloc(block_size: gsize) gpointer;
pub extern fn g_rc_box_alloc0(block_size: gsize) gpointer;
pub extern fn g_rc_box_dup(block_size: gsize, mem_block: gconstpointer) gpointer;
pub extern fn g_rc_box_acquire(mem_block: gpointer) gpointer;
pub extern fn g_rc_box_release(mem_block: gpointer) void;
pub extern fn g_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify) void;
pub extern fn g_rc_box_get_size(mem_block: gpointer) gsize;
pub extern fn g_atomic_rc_box_alloc(block_size: gsize) gpointer;
pub extern fn g_atomic_rc_box_alloc0(block_size: gsize) gpointer;
pub extern fn g_atomic_rc_box_dup(block_size: gsize, mem_block: gconstpointer) gpointer;
pub extern fn g_atomic_rc_box_acquire(mem_block: gpointer) gpointer;
pub extern fn g_atomic_rc_box_release(mem_block: gpointer) void;
pub extern fn g_atomic_rc_box_release_full(mem_block: gpointer, clear_func: GDestroyNotify) void;
pub extern fn g_atomic_rc_box_get_size(mem_block: gpointer) gsize;
pub extern fn g_ref_count_init(rc: [*c]grefcount) void;
pub extern fn g_ref_count_inc(rc: [*c]grefcount) void;
pub extern fn g_ref_count_dec(rc: [*c]grefcount) gboolean;
pub extern fn g_ref_count_compare(rc: [*c]grefcount, val: gint) gboolean;
pub extern fn g_atomic_ref_count_init(arc: [*c]volatile gatomicrefcount) void;
pub extern fn g_atomic_ref_count_inc(arc: [*c]volatile gatomicrefcount) void;
pub extern fn g_atomic_ref_count_dec(arc: [*c]volatile gatomicrefcount) gboolean;
pub extern fn g_atomic_ref_count_compare(arc: [*c]volatile gatomicrefcount, val: gint) gboolean;
pub extern fn g_ref_string_new(str: [*c]const u8) [*c]u8;
pub extern fn g_ref_string_new_len(str: [*c]const u8, len: gssize) [*c]u8;
pub extern fn g_ref_string_new_intern(str: [*c]const u8) [*c]u8;
pub extern fn g_ref_string_acquire(str: [*c]u8) [*c]u8;
pub extern fn g_ref_string_release(str: [*c]u8) void;
pub extern fn g_ref_string_length(str: [*c]u8) gsize;
pub const GRefString = u8;
pub const G_REGEX_ERROR_COMPILE = 0;
pub const G_REGEX_ERROR_OPTIMIZE = 1;
pub const G_REGEX_ERROR_REPLACE = 2;
pub const G_REGEX_ERROR_MATCH = 3;
pub const G_REGEX_ERROR_INTERNAL = 4;
pub const G_REGEX_ERROR_STRAY_BACKSLASH = 101;
pub const G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102;
pub const G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103;
pub const G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104;
pub const G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105;
pub const G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106;
pub const G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107;
pub const G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108;
pub const G_REGEX_ERROR_NOTHING_TO_REPEAT = 109;
pub const G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112;
pub const G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113;
pub const G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114;
pub const G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115;
pub const G_REGEX_ERROR_UNTERMINATED_COMMENT = 118;
pub const G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120;
pub const G_REGEX_ERROR_MEMORY_ERROR = 121;
pub const G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125;
pub const G_REGEX_ERROR_MALFORMED_CONDITION = 126;
pub const G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127;
pub const G_REGEX_ERROR_ASSERTION_EXPECTED = 128;
pub const G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130;
pub const G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131;
pub const G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134;
pub const G_REGEX_ERROR_INVALID_CONDITION = 135;
pub const G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136;
pub const G_REGEX_ERROR_INFINITE_LOOP = 140;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142;
pub const G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143;
pub const G_REGEX_ERROR_MALFORMED_PROPERTY = 146;
pub const G_REGEX_ERROR_UNKNOWN_PROPERTY = 147;
pub const G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148;
pub const G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149;
pub const G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151;
pub const G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154;
pub const G_REGEX_ERROR_DEFINE_REPETION = 155;
pub const G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156;
pub const G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157;
pub const G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159;
pub const G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160;
pub const G_REGEX_ERROR_NUMBER_TOO_BIG = 161;
pub const G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162;
pub const G_REGEX_ERROR_MISSING_DIGIT = 163;
pub const G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164;
pub const G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165;
pub const G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166;
pub const G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168;
pub const G_REGEX_ERROR_MISSING_NAME = 169;
pub const G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171;
pub const G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172;
pub const G_REGEX_ERROR_NAME_TOO_LONG = 175;
pub const G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176;
pub const GRegexError = extern enum {
    G_REGEX_ERROR_COMPILE = 0,
    G_REGEX_ERROR_OPTIMIZE = 1,
    G_REGEX_ERROR_REPLACE = 2,
    G_REGEX_ERROR_MATCH = 3,
    G_REGEX_ERROR_INTERNAL = 4,
    G_REGEX_ERROR_STRAY_BACKSLASH = 101,
    G_REGEX_ERROR_MISSING_CONTROL_CHAR = 102,
    G_REGEX_ERROR_UNRECOGNIZED_ESCAPE = 103,
    G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER = 104,
    G_REGEX_ERROR_QUANTIFIER_TOO_BIG = 105,
    G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS = 106,
    G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS = 107,
    G_REGEX_ERROR_RANGE_OUT_OF_ORDER = 108,
    G_REGEX_ERROR_NOTHING_TO_REPEAT = 109,
    G_REGEX_ERROR_UNRECOGNIZED_CHARACTER = 112,
    G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS = 113,
    G_REGEX_ERROR_UNMATCHED_PARENTHESIS = 114,
    G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE = 115,
    G_REGEX_ERROR_UNTERMINATED_COMMENT = 118,
    G_REGEX_ERROR_EXPRESSION_TOO_LARGE = 120,
    G_REGEX_ERROR_MEMORY_ERROR = 121,
    G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND = 125,
    G_REGEX_ERROR_MALFORMED_CONDITION = 126,
    G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES = 127,
    G_REGEX_ERROR_ASSERTION_EXPECTED = 128,
    G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME = 130,
    G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED = 131,
    G_REGEX_ERROR_HEX_CODE_TOO_LARGE = 134,
    G_REGEX_ERROR_INVALID_CONDITION = 135,
    G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND = 136,
    G_REGEX_ERROR_INFINITE_LOOP = 140,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR = 142,
    G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME = 143,
    G_REGEX_ERROR_MALFORMED_PROPERTY = 146,
    G_REGEX_ERROR_UNKNOWN_PROPERTY = 147,
    G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG = 148,
    G_REGEX_ERROR_TOO_MANY_SUBPATTERNS = 149,
    G_REGEX_ERROR_INVALID_OCTAL_VALUE = 151,
    G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE = 154,
    G_REGEX_ERROR_DEFINE_REPETION = 155,
    G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS = 156,
    G_REGEX_ERROR_MISSING_BACK_REFERENCE = 157,
    G_REGEX_ERROR_INVALID_RELATIVE_REFERENCE = 158,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_FORBIDDEN = 159,
    G_REGEX_ERROR_UNKNOWN_BACKTRACKING_CONTROL_VERB = 160,
    G_REGEX_ERROR_NUMBER_TOO_BIG = 161,
    G_REGEX_ERROR_MISSING_SUBPATTERN_NAME = 162,
    G_REGEX_ERROR_MISSING_DIGIT = 163,
    G_REGEX_ERROR_INVALID_DATA_CHARACTER = 164,
    G_REGEX_ERROR_EXTRA_SUBPATTERN_NAME = 165,
    G_REGEX_ERROR_BACKTRACKING_CONTROL_VERB_ARGUMENT_REQUIRED = 166,
    G_REGEX_ERROR_INVALID_CONTROL_CHAR = 168,
    G_REGEX_ERROR_MISSING_NAME = 169,
    G_REGEX_ERROR_NOT_SUPPORTED_IN_CLASS = 171,
    G_REGEX_ERROR_TOO_MANY_FORWARD_REFERENCES = 172,
    G_REGEX_ERROR_NAME_TOO_LONG = 175,
    G_REGEX_ERROR_CHARACTER_VALUE_TOO_LARGE = 176,
};
pub extern fn g_regex_error_quark() GQuark;
pub const G_REGEX_CASELESS = 1;
pub const G_REGEX_MULTILINE = 2;
pub const G_REGEX_DOTALL = 4;
pub const G_REGEX_EXTENDED = 8;
pub const G_REGEX_ANCHORED = 16;
pub const G_REGEX_DOLLAR_ENDONLY = 32;
pub const G_REGEX_UNGREEDY = 512;
pub const G_REGEX_RAW = 2048;
pub const G_REGEX_NO_AUTO_CAPTURE = 4096;
pub const G_REGEX_OPTIMIZE = 8192;
pub const G_REGEX_FIRSTLINE = 262144;
pub const G_REGEX_DUPNAMES = 524288;
pub const G_REGEX_NEWLINE_CR = 1048576;
pub const G_REGEX_NEWLINE_LF = 2097152;
pub const G_REGEX_NEWLINE_CRLF = 3145728;
pub const G_REGEX_NEWLINE_ANYCRLF = 5242880;
pub const G_REGEX_BSR_ANYCRLF = 8388608;
pub const G_REGEX_JAVASCRIPT_COMPAT = 33554432;
pub const GRegexCompileFlags = extern enum {
    G_REGEX_CASELESS = 1,
    G_REGEX_MULTILINE = 2,
    G_REGEX_DOTALL = 4,
    G_REGEX_EXTENDED = 8,
    G_REGEX_ANCHORED = 16,
    G_REGEX_DOLLAR_ENDONLY = 32,
    G_REGEX_UNGREEDY = 512,
    G_REGEX_RAW = 2048,
    G_REGEX_NO_AUTO_CAPTURE = 4096,
    G_REGEX_OPTIMIZE = 8192,
    G_REGEX_FIRSTLINE = 262144,
    G_REGEX_DUPNAMES = 524288,
    G_REGEX_NEWLINE_CR = 1048576,
    G_REGEX_NEWLINE_LF = 2097152,
    G_REGEX_NEWLINE_CRLF = 3145728,
    G_REGEX_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_BSR_ANYCRLF = 8388608,
    G_REGEX_JAVASCRIPT_COMPAT = 33554432,
};
pub const G_REGEX_MATCH_ANCHORED = 16;
pub const G_REGEX_MATCH_NOTBOL = 128;
pub const G_REGEX_MATCH_NOTEOL = 256;
pub const G_REGEX_MATCH_NOTEMPTY = 1024;
pub const G_REGEX_MATCH_PARTIAL = 32768;
pub const G_REGEX_MATCH_NEWLINE_CR = 1048576;
pub const G_REGEX_MATCH_NEWLINE_LF = 2097152;
pub const G_REGEX_MATCH_NEWLINE_CRLF = 3145728;
pub const G_REGEX_MATCH_NEWLINE_ANY = 4194304;
pub const G_REGEX_MATCH_NEWLINE_ANYCRLF = 5242880;
pub const G_REGEX_MATCH_BSR_ANYCRLF = 8388608;
pub const G_REGEX_MATCH_BSR_ANY = 16777216;
pub const G_REGEX_MATCH_PARTIAL_SOFT = 32768;
pub const G_REGEX_MATCH_PARTIAL_HARD = 134217728;
pub const G_REGEX_MATCH_NOTEMPTY_ATSTART = 268435456;
pub const GRegexMatchFlags = extern enum {
    G_REGEX_MATCH_ANCHORED = 16,
    G_REGEX_MATCH_NOTBOL = 128,
    G_REGEX_MATCH_NOTEOL = 256,
    G_REGEX_MATCH_NOTEMPTY = 1024,
    G_REGEX_MATCH_PARTIAL = 32768,
    G_REGEX_MATCH_NEWLINE_CR = 1048576,
    G_REGEX_MATCH_NEWLINE_LF = 2097152,
    G_REGEX_MATCH_NEWLINE_CRLF = 3145728,
    G_REGEX_MATCH_NEWLINE_ANY = 4194304,
    G_REGEX_MATCH_NEWLINE_ANYCRLF = 5242880,
    G_REGEX_MATCH_BSR_ANYCRLF = 8388608,
    G_REGEX_MATCH_BSR_ANY = 16777216,
    G_REGEX_MATCH_PARTIAL_SOFT = 32768,
    G_REGEX_MATCH_PARTIAL_HARD = 134217728,
    G_REGEX_MATCH_NOTEMPTY_ATSTART = 268435456,
};
pub const struct__GRegex = @OpaqueType();
pub const GRegex = struct__GRegex;
pub const struct__GMatchInfo = @OpaqueType();
pub const GMatchInfo = struct__GMatchInfo;
pub const GRegexEvalCallback = ?extern fn (?*const GMatchInfo, [*c]GString, gpointer) gboolean;
pub extern fn g_regex_new(pattern: [*c]const gchar, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags, @"error": [*c]([*c]GError)) ?*GRegex;
pub extern fn g_regex_ref(regex: ?*GRegex) ?*GRegex;
pub extern fn g_regex_unref(regex: ?*GRegex) void;
pub extern fn g_regex_get_pattern(regex: ?*const GRegex) [*c]const gchar;
pub extern fn g_regex_get_max_backref(regex: ?*const GRegex) gint;
pub extern fn g_regex_get_capture_count(regex: ?*const GRegex) gint;
pub extern fn g_regex_get_has_cr_or_lf(regex: ?*const GRegex) gboolean;
pub extern fn g_regex_get_max_lookbehind(regex: ?*const GRegex) gint;
pub extern fn g_regex_get_string_number(regex: ?*const GRegex, name: [*c]const gchar) gint;
pub extern fn g_regex_escape_string(string: [*c]const gchar, length: gint) [*c]gchar;
pub extern fn g_regex_escape_nul(string: [*c]const gchar, length: gint) [*c]gchar;
pub extern fn g_regex_get_compile_flags(regex: ?*const GRegex) GRegexCompileFlags;
pub extern fn g_regex_get_match_flags(regex: ?*const GRegex) GRegexMatchFlags;
pub extern fn g_regex_match_simple(pattern: [*c]const gchar, string: [*c]const gchar, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags) gboolean;
pub extern fn g_regex_match(regex: ?*const GRegex, string: [*c]const gchar, match_options: GRegexMatchFlags, match_info: [*c](?*GMatchInfo)) gboolean;
pub extern fn g_regex_match_full(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, match_info: [*c](?*GMatchInfo), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_regex_match_all(regex: ?*const GRegex, string: [*c]const gchar, match_options: GRegexMatchFlags, match_info: [*c](?*GMatchInfo)) gboolean;
pub extern fn g_regex_match_all_full(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, match_info: [*c](?*GMatchInfo), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_regex_split_simple(pattern: [*c]const gchar, string: [*c]const gchar, compile_options: GRegexCompileFlags, match_options: GRegexMatchFlags) [*c]([*c]gchar);
pub extern fn g_regex_split(regex: ?*const GRegex, string: [*c]const gchar, match_options: GRegexMatchFlags) [*c]([*c]gchar);
pub extern fn g_regex_split_full(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, max_tokens: gint, @"error": [*c]([*c]GError)) [*c]([*c]gchar);
pub extern fn g_regex_replace(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, replacement: [*c]const gchar, match_options: GRegexMatchFlags, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_regex_replace_literal(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, replacement: [*c]const gchar, match_options: GRegexMatchFlags, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_regex_replace_eval(regex: ?*const GRegex, string: [*c]const gchar, string_len: gssize, start_position: gint, match_options: GRegexMatchFlags, eval: GRegexEvalCallback, user_data: gpointer, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_regex_check_replacement(replacement: [*c]const gchar, has_references: [*c]gboolean, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_match_info_get_regex(match_info: ?*const GMatchInfo) ?*GRegex;
pub extern fn g_match_info_get_string(match_info: ?*const GMatchInfo) [*c]const gchar;
pub extern fn g_match_info_ref(match_info: ?*GMatchInfo) ?*GMatchInfo;
pub extern fn g_match_info_unref(match_info: ?*GMatchInfo) void;
pub extern fn g_match_info_free(match_info: ?*GMatchInfo) void;
pub extern fn g_match_info_next(match_info: ?*GMatchInfo, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_match_info_matches(match_info: ?*const GMatchInfo) gboolean;
pub extern fn g_match_info_get_match_count(match_info: ?*const GMatchInfo) gint;
pub extern fn g_match_info_is_partial_match(match_info: ?*const GMatchInfo) gboolean;
pub extern fn g_match_info_expand_references(match_info: ?*const GMatchInfo, string_to_expand: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_match_info_fetch(match_info: ?*const GMatchInfo, match_num: gint) [*c]gchar;
pub extern fn g_match_info_fetch_pos(match_info: ?*const GMatchInfo, match_num: gint, start_pos: [*c]gint, end_pos: [*c]gint) gboolean;
pub extern fn g_match_info_fetch_named(match_info: ?*const GMatchInfo, name: [*c]const gchar) [*c]gchar;
pub extern fn g_match_info_fetch_named_pos(match_info: ?*const GMatchInfo, name: [*c]const gchar, start_pos: [*c]gint, end_pos: [*c]gint) gboolean;
pub extern fn g_match_info_fetch_all(match_info: ?*const GMatchInfo) [*c]([*c]gchar);
pub const struct__GScannerConfig = @OpaqueType();
pub const GScannerConfig = struct__GScannerConfig;
pub const G_TOKEN_EOF = 0;
pub const G_TOKEN_LEFT_PAREN = 40;
pub const G_TOKEN_RIGHT_PAREN = 41;
pub const G_TOKEN_LEFT_CURLY = 123;
pub const G_TOKEN_RIGHT_CURLY = 125;
pub const G_TOKEN_LEFT_BRACE = 91;
pub const G_TOKEN_RIGHT_BRACE = 93;
pub const G_TOKEN_EQUAL_SIGN = 61;
pub const G_TOKEN_COMMA = 44;
pub const G_TOKEN_NONE = 256;
pub const G_TOKEN_ERROR = 257;
pub const G_TOKEN_CHAR = 258;
pub const G_TOKEN_BINARY = 259;
pub const G_TOKEN_OCTAL = 260;
pub const G_TOKEN_INT = 261;
pub const G_TOKEN_HEX = 262;
pub const G_TOKEN_FLOAT = 263;
pub const G_TOKEN_STRING = 264;
pub const G_TOKEN_SYMBOL = 265;
pub const G_TOKEN_IDENTIFIER = 266;
pub const G_TOKEN_IDENTIFIER_NULL = 267;
pub const G_TOKEN_COMMENT_SINGLE = 268;
pub const G_TOKEN_COMMENT_MULTI = 269;
pub const G_TOKEN_LAST = 270;
pub const GTokenType = extern enum {
    G_TOKEN_EOF = 0,
    G_TOKEN_LEFT_PAREN = 40,
    G_TOKEN_RIGHT_PAREN = 41,
    G_TOKEN_LEFT_CURLY = 123,
    G_TOKEN_RIGHT_CURLY = 125,
    G_TOKEN_LEFT_BRACE = 91,
    G_TOKEN_RIGHT_BRACE = 93,
    G_TOKEN_EQUAL_SIGN = 61,
    G_TOKEN_COMMA = 44,
    G_TOKEN_NONE = 256,
    G_TOKEN_ERROR = 257,
    G_TOKEN_CHAR = 258,
    G_TOKEN_BINARY = 259,
    G_TOKEN_OCTAL = 260,
    G_TOKEN_INT = 261,
    G_TOKEN_HEX = 262,
    G_TOKEN_FLOAT = 263,
    G_TOKEN_STRING = 264,
    G_TOKEN_SYMBOL = 265,
    G_TOKEN_IDENTIFIER = 266,
    G_TOKEN_IDENTIFIER_NULL = 267,
    G_TOKEN_COMMENT_SINGLE = 268,
    G_TOKEN_COMMENT_MULTI = 269,
    G_TOKEN_LAST = 270,
};
pub const union__GTokenValue = extern union {
    v_symbol: gpointer,
    v_identifier: [*c]gchar,
    v_binary: gulong,
    v_octal: gulong,
    v_int: gulong,
    v_int64: guint64,
    v_float: gdouble,
    v_hex: gulong,
    v_string: [*c]gchar,
    v_comment: [*c]gchar,
    v_char: guchar,
    v_error: guint,
};
pub const GTokenValue = union__GTokenValue;
pub const GScanner = struct__GScanner;
pub const GScannerMsgFunc = ?extern fn ([*c]GScanner, [*c]gchar, gboolean) void;
pub const struct__GScanner = extern struct {
    user_data: gpointer,
    max_parse_errors: guint,
    parse_errors: guint,
    input_name: [*c]const gchar,
    qdata: ?*GData,
    config: ?*GScannerConfig,
    token: GTokenType,
    value: GTokenValue,
    line: guint,
    position: guint,
    next_token: GTokenType,
    next_value: GTokenValue,
    next_line: guint,
    next_position: guint,
    symbol_table: ?*GHashTable,
    input_fd: gint,
    text: [*c]const gchar,
    text_end: [*c]const gchar,
    buffer: [*c]gchar,
    scope_id: guint,
    msg_handler: GScannerMsgFunc,
};
pub const G_ERR_UNKNOWN = 0;
pub const G_ERR_UNEXP_EOF = 1;
pub const G_ERR_UNEXP_EOF_IN_STRING = 2;
pub const G_ERR_UNEXP_EOF_IN_COMMENT = 3;
pub const G_ERR_NON_DIGIT_IN_CONST = 4;
pub const G_ERR_DIGIT_RADIX = 5;
pub const G_ERR_FLOAT_RADIX = 6;
pub const G_ERR_FLOAT_MALFORMED = 7;
pub const GErrorType = extern enum {
    G_ERR_UNKNOWN = 0,
    G_ERR_UNEXP_EOF = 1,
    G_ERR_UNEXP_EOF_IN_STRING = 2,
    G_ERR_UNEXP_EOF_IN_COMMENT = 3,
    G_ERR_NON_DIGIT_IN_CONST = 4,
    G_ERR_DIGIT_RADIX = 5,
    G_ERR_FLOAT_RADIX = 6,
    G_ERR_FLOAT_MALFORMED = 7,
};
pub extern fn g_scanner_new(config_templ: ?*const GScannerConfig) [*c]GScanner;
pub extern fn g_scanner_destroy(scanner: [*c]GScanner) void;
pub extern fn g_scanner_input_file(scanner: [*c]GScanner, input_fd: gint) void;
pub extern fn g_scanner_sync_file_offset(scanner: [*c]GScanner) void;
pub extern fn g_scanner_input_text(scanner: [*c]GScanner, text: [*c]const gchar, text_len: guint) void;
pub extern fn g_scanner_get_next_token(scanner: [*c]GScanner) GTokenType;
pub extern fn g_scanner_peek_next_token(scanner: [*c]GScanner) GTokenType;
pub extern fn g_scanner_cur_token(scanner: [*c]GScanner) GTokenType;
pub extern fn g_scanner_cur_value(scanner: [*c]GScanner) GTokenValue;
pub extern fn g_scanner_cur_line(scanner: [*c]GScanner) guint;
pub extern fn g_scanner_cur_position(scanner: [*c]GScanner) guint;
pub extern fn g_scanner_eof(scanner: [*c]GScanner) gboolean;
pub extern fn g_scanner_set_scope(scanner: [*c]GScanner, scope_id: guint) guint;
pub extern fn g_scanner_scope_add_symbol(scanner: [*c]GScanner, scope_id: guint, symbol: [*c]const gchar, value: gpointer) void;
pub extern fn g_scanner_scope_remove_symbol(scanner: [*c]GScanner, scope_id: guint, symbol: [*c]const gchar) void;
pub extern fn g_scanner_scope_lookup_symbol(scanner: [*c]GScanner, scope_id: guint, symbol: [*c]const gchar) gpointer;
pub extern fn g_scanner_scope_foreach_symbol(scanner: [*c]GScanner, scope_id: guint, func: GHFunc, user_data: gpointer) void;
pub extern fn g_scanner_lookup_symbol(scanner: [*c]GScanner, symbol: [*c]const gchar) gpointer;
pub extern fn g_scanner_unexp_token(scanner: [*c]GScanner, expected_token: GTokenType, identifier_spec: [*c]const gchar, symbol_spec: [*c]const gchar, symbol_name: [*c]const gchar, message: [*c]const gchar, is_error: gint) void;
pub extern fn g_scanner_error(scanner: [*c]GScanner, format: [*c]const gchar, ...) void;
pub extern fn g_scanner_warn(scanner: [*c]GScanner, format: [*c]const gchar, ...) void;
pub const struct__GSequence = @OpaqueType();
pub const GSequence = struct__GSequence;
pub const struct__GSequenceNode = @OpaqueType();
pub const GSequenceIter = struct__GSequenceNode;
pub const GSequenceIterCompareFunc = ?extern fn (?*GSequenceIter, ?*GSequenceIter, gpointer) gint;
pub extern fn g_sequence_new(data_destroy: GDestroyNotify) ?*GSequence;
pub extern fn g_sequence_free(seq: ?*GSequence) void;
pub extern fn g_sequence_get_length(seq: ?*GSequence) gint;
pub extern fn g_sequence_foreach(seq: ?*GSequence, func: GFunc, user_data: gpointer) void;
pub extern fn g_sequence_foreach_range(begin: ?*GSequenceIter, end: ?*GSequenceIter, func: GFunc, user_data: gpointer) void;
pub extern fn g_sequence_sort(seq: ?*GSequence, cmp_func: GCompareDataFunc, cmp_data: gpointer) void;
pub extern fn g_sequence_sort_iter(seq: ?*GSequence, cmp_func: GSequenceIterCompareFunc, cmp_data: gpointer) void;
pub extern fn g_sequence_is_empty(seq: ?*GSequence) gboolean;
pub extern fn g_sequence_get_begin_iter(seq: ?*GSequence) ?*GSequenceIter;
pub extern fn g_sequence_get_end_iter(seq: ?*GSequence) ?*GSequenceIter;
pub extern fn g_sequence_get_iter_at_pos(seq: ?*GSequence, pos: gint) ?*GSequenceIter;
pub extern fn g_sequence_append(seq: ?*GSequence, data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_prepend(seq: ?*GSequence, data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_insert_before(iter: ?*GSequenceIter, data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_move(src: ?*GSequenceIter, dest: ?*GSequenceIter) void;
pub extern fn g_sequence_swap(a: ?*GSequenceIter, b: ?*GSequenceIter) void;
pub extern fn g_sequence_insert_sorted(seq: ?*GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_insert_sorted_iter(seq: ?*GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_sort_changed(iter: ?*GSequenceIter, cmp_func: GCompareDataFunc, cmp_data: gpointer) void;
pub extern fn g_sequence_sort_changed_iter(iter: ?*GSequenceIter, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) void;
pub extern fn g_sequence_remove(iter: ?*GSequenceIter) void;
pub extern fn g_sequence_remove_range(begin: ?*GSequenceIter, end: ?*GSequenceIter) void;
pub extern fn g_sequence_move_range(dest: ?*GSequenceIter, begin: ?*GSequenceIter, end: ?*GSequenceIter) void;
pub extern fn g_sequence_search(seq: ?*GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_search_iter(seq: ?*GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_lookup(seq: ?*GSequence, data: gpointer, cmp_func: GCompareDataFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_lookup_iter(seq: ?*GSequence, data: gpointer, iter_cmp: GSequenceIterCompareFunc, cmp_data: gpointer) ?*GSequenceIter;
pub extern fn g_sequence_get(iter: ?*GSequenceIter) gpointer;
pub extern fn g_sequence_set(iter: ?*GSequenceIter, data: gpointer) void;
pub extern fn g_sequence_iter_is_begin(iter: ?*GSequenceIter) gboolean;
pub extern fn g_sequence_iter_is_end(iter: ?*GSequenceIter) gboolean;
pub extern fn g_sequence_iter_next(iter: ?*GSequenceIter) ?*GSequenceIter;
pub extern fn g_sequence_iter_prev(iter: ?*GSequenceIter) ?*GSequenceIter;
pub extern fn g_sequence_iter_get_position(iter: ?*GSequenceIter) gint;
pub extern fn g_sequence_iter_move(iter: ?*GSequenceIter, delta: gint) ?*GSequenceIter;
pub extern fn g_sequence_iter_get_sequence(iter: ?*GSequenceIter) ?*GSequence;
pub extern fn g_sequence_iter_compare(a: ?*GSequenceIter, b: ?*GSequenceIter) gint;
pub extern fn g_sequence_range_get_midpoint(begin: ?*GSequenceIter, end: ?*GSequenceIter) ?*GSequenceIter;
pub const G_SHELL_ERROR_BAD_QUOTING = 0;
pub const G_SHELL_ERROR_EMPTY_STRING = 1;
pub const G_SHELL_ERROR_FAILED = 2;
pub const GShellError = extern enum {
    G_SHELL_ERROR_BAD_QUOTING = 0,
    G_SHELL_ERROR_EMPTY_STRING = 1,
    G_SHELL_ERROR_FAILED = 2,
};
pub extern fn g_shell_error_quark() GQuark;
pub extern fn g_shell_quote(unquoted_string: [*c]const gchar) [*c]gchar;
pub extern fn g_shell_unquote(quoted_string: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_shell_parse_argv(command_line: [*c]const gchar, argcp: [*c]gint, argvp: [*c]([*c]([*c]gchar)), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_slice_alloc(block_size: gsize) gpointer;
pub extern fn g_slice_alloc0(block_size: gsize) gpointer;
pub extern fn g_slice_copy(block_size: gsize, mem_block: gconstpointer) gpointer;
pub extern fn g_slice_free1(block_size: gsize, mem_block: gpointer) void;
pub extern fn g_slice_free_chain_with_offset(block_size: gsize, mem_chain: gpointer, next_offset: gsize) void;
pub const G_SLICE_CONFIG_ALWAYS_MALLOC = 1;
pub const G_SLICE_CONFIG_BYPASS_MAGAZINES = 2;
pub const G_SLICE_CONFIG_WORKING_SET_MSECS = 3;
pub const G_SLICE_CONFIG_COLOR_INCREMENT = 4;
pub const G_SLICE_CONFIG_CHUNK_SIZES = 5;
pub const G_SLICE_CONFIG_CONTENTION_COUNTER = 6;
pub const GSliceConfig = extern enum {
    G_SLICE_CONFIG_ALWAYS_MALLOC = 1,
    G_SLICE_CONFIG_BYPASS_MAGAZINES = 2,
    G_SLICE_CONFIG_WORKING_SET_MSECS = 3,
    G_SLICE_CONFIG_COLOR_INCREMENT = 4,
    G_SLICE_CONFIG_CHUNK_SIZES = 5,
    G_SLICE_CONFIG_CONTENTION_COUNTER = 6,
};
pub extern fn g_slice_set_config(ckey: GSliceConfig, value: gint64) void;
pub extern fn g_slice_get_config(ckey: GSliceConfig) gint64;
pub extern fn g_slice_get_config_state(ckey: GSliceConfig, address: gint64, n_values: [*c]guint) [*c]gint64;
pub const G_SPAWN_ERROR_FORK = 0;
pub const G_SPAWN_ERROR_READ = 1;
pub const G_SPAWN_ERROR_CHDIR = 2;
pub const G_SPAWN_ERROR_ACCES = 3;
pub const G_SPAWN_ERROR_PERM = 4;
pub const G_SPAWN_ERROR_TOO_BIG = 5;
pub const G_SPAWN_ERROR_2BIG = 5;
pub const G_SPAWN_ERROR_NOEXEC = 6;
pub const G_SPAWN_ERROR_NAMETOOLONG = 7;
pub const G_SPAWN_ERROR_NOENT = 8;
pub const G_SPAWN_ERROR_NOMEM = 9;
pub const G_SPAWN_ERROR_NOTDIR = 10;
pub const G_SPAWN_ERROR_LOOP = 11;
pub const G_SPAWN_ERROR_TXTBUSY = 12;
pub const G_SPAWN_ERROR_IO = 13;
pub const G_SPAWN_ERROR_NFILE = 14;
pub const G_SPAWN_ERROR_MFILE = 15;
pub const G_SPAWN_ERROR_INVAL = 16;
pub const G_SPAWN_ERROR_ISDIR = 17;
pub const G_SPAWN_ERROR_LIBBAD = 18;
pub const G_SPAWN_ERROR_FAILED = 19;
pub const GSpawnError = extern enum {
    G_SPAWN_ERROR_FORK = 0,
    G_SPAWN_ERROR_READ = 1,
    G_SPAWN_ERROR_CHDIR = 2,
    G_SPAWN_ERROR_ACCES = 3,
    G_SPAWN_ERROR_PERM = 4,
    G_SPAWN_ERROR_TOO_BIG = 5,
    G_SPAWN_ERROR_2BIG = 5,
    G_SPAWN_ERROR_NOEXEC = 6,
    G_SPAWN_ERROR_NAMETOOLONG = 7,
    G_SPAWN_ERROR_NOENT = 8,
    G_SPAWN_ERROR_NOMEM = 9,
    G_SPAWN_ERROR_NOTDIR = 10,
    G_SPAWN_ERROR_LOOP = 11,
    G_SPAWN_ERROR_TXTBUSY = 12,
    G_SPAWN_ERROR_IO = 13,
    G_SPAWN_ERROR_NFILE = 14,
    G_SPAWN_ERROR_MFILE = 15,
    G_SPAWN_ERROR_INVAL = 16,
    G_SPAWN_ERROR_ISDIR = 17,
    G_SPAWN_ERROR_LIBBAD = 18,
    G_SPAWN_ERROR_FAILED = 19,
};
pub const GSpawnChildSetupFunc = ?extern fn (gpointer) void;
pub const G_SPAWN_DEFAULT = 0;
pub const G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1;
pub const G_SPAWN_DO_NOT_REAP_CHILD = 2;
pub const G_SPAWN_SEARCH_PATH = 4;
pub const G_SPAWN_STDOUT_TO_DEV_NULL = 8;
pub const G_SPAWN_STDERR_TO_DEV_NULL = 16;
pub const G_SPAWN_CHILD_INHERITS_STDIN = 32;
pub const G_SPAWN_FILE_AND_ARGV_ZERO = 64;
pub const G_SPAWN_SEARCH_PATH_FROM_ENVP = 128;
pub const G_SPAWN_CLOEXEC_PIPES = 256;
pub const GSpawnFlags = extern enum {
    G_SPAWN_DEFAULT = 0,
    G_SPAWN_LEAVE_DESCRIPTORS_OPEN = 1,
    G_SPAWN_DO_NOT_REAP_CHILD = 2,
    G_SPAWN_SEARCH_PATH = 4,
    G_SPAWN_STDOUT_TO_DEV_NULL = 8,
    G_SPAWN_STDERR_TO_DEV_NULL = 16,
    G_SPAWN_CHILD_INHERITS_STDIN = 32,
    G_SPAWN_FILE_AND_ARGV_ZERO = 64,
    G_SPAWN_SEARCH_PATH_FROM_ENVP = 128,
    G_SPAWN_CLOEXEC_PIPES = 256,
};
pub extern fn g_spawn_error_quark() GQuark;
pub extern fn g_spawn_exit_error_quark() GQuark;
pub extern fn g_spawn_async(working_directory: [*c]const gchar, argv: [*c]([*c]gchar), envp: [*c]([*c]gchar), flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: [*c]GPid, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_spawn_async_with_pipes(working_directory: [*c]const gchar, argv: [*c]([*c]gchar), envp: [*c]([*c]gchar), flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: [*c]GPid, standard_input: [*c]gint, standard_output: [*c]gint, standard_error: [*c]gint, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_spawn_async_with_fds(working_directory: [*c]const gchar, argv: [*c]([*c]gchar), envp: [*c]([*c]gchar), flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, child_pid: [*c]GPid, stdin_fd: gint, stdout_fd: gint, stderr_fd: gint, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_spawn_sync(working_directory: [*c]const gchar, argv: [*c]([*c]gchar), envp: [*c]([*c]gchar), flags: GSpawnFlags, child_setup: GSpawnChildSetupFunc, user_data: gpointer, standard_output: [*c]([*c]gchar), standard_error: [*c]([*c]gchar), exit_status: [*c]gint, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_spawn_command_line_sync(command_line: [*c]const gchar, standard_output: [*c]([*c]gchar), standard_error: [*c]([*c]gchar), exit_status: [*c]gint, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_spawn_command_line_async(command_line: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_spawn_check_exit_status(exit_status: gint, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_spawn_close_pid(pid: GPid) void;
pub const G_ASCII_ALNUM = 1;
pub const G_ASCII_ALPHA = 2;
pub const G_ASCII_CNTRL = 4;
pub const G_ASCII_DIGIT = 8;
pub const G_ASCII_GRAPH = 16;
pub const G_ASCII_LOWER = 32;
pub const G_ASCII_PRINT = 64;
pub const G_ASCII_PUNCT = 128;
pub const G_ASCII_SPACE = 256;
pub const G_ASCII_UPPER = 512;
pub const G_ASCII_XDIGIT = 1024;
pub const GAsciiType = extern enum {
    G_ASCII_ALNUM = 1,
    G_ASCII_ALPHA = 2,
    G_ASCII_CNTRL = 4,
    G_ASCII_DIGIT = 8,
    G_ASCII_GRAPH = 16,
    G_ASCII_LOWER = 32,
    G_ASCII_PRINT = 64,
    G_ASCII_PUNCT = 128,
    G_ASCII_SPACE = 256,
    G_ASCII_UPPER = 512,
    G_ASCII_XDIGIT = 1024,
};
pub extern const g_ascii_table: [*c]const guint16;
pub extern fn g_ascii_tolower(c: gchar) gchar;
pub extern fn g_ascii_toupper(c: gchar) gchar;
pub extern fn g_ascii_digit_value(c: gchar) gint;
pub extern fn g_ascii_xdigit_value(c: gchar) gint;
pub extern fn g_strdelimit(string: [*c]gchar, delimiters: [*c]const gchar, new_delimiter: gchar) [*c]gchar;
pub extern fn g_strcanon(string: [*c]gchar, valid_chars: [*c]const gchar, substitutor: gchar) [*c]gchar;
pub extern fn g_strerror(errnum: gint) [*c]const gchar;
pub extern fn g_strsignal(signum: gint) [*c]const gchar;
pub extern fn g_strreverse(string: [*c]gchar) [*c]gchar;
pub extern fn g_strlcpy(dest: [*c]gchar, src: [*c]const gchar, dest_size: gsize) gsize;
pub extern fn g_strlcat(dest: [*c]gchar, src: [*c]const gchar, dest_size: gsize) gsize;
pub extern fn g_strstr_len(haystack: [*c]const gchar, haystack_len: gssize, needle: [*c]const gchar) [*c]gchar;
pub extern fn g_strrstr(haystack: [*c]const gchar, needle: [*c]const gchar) [*c]gchar;
pub extern fn g_strrstr_len(haystack: [*c]const gchar, haystack_len: gssize, needle: [*c]const gchar) [*c]gchar;
pub extern fn g_str_has_suffix(str: [*c]const gchar, suffix: [*c]const gchar) gboolean;
pub extern fn g_str_has_prefix(str: [*c]const gchar, prefix: [*c]const gchar) gboolean;
pub extern fn g_strtod(nptr: [*c]const gchar, endptr: [*c]([*c]gchar)) gdouble;
pub extern fn g_ascii_strtod(nptr: [*c]const gchar, endptr: [*c]([*c]gchar)) gdouble;
pub extern fn g_ascii_strtoull(nptr: [*c]const gchar, endptr: [*c]([*c]gchar), base: guint) guint64;
pub extern fn g_ascii_strtoll(nptr: [*c]const gchar, endptr: [*c]([*c]gchar), base: guint) gint64;
pub extern fn g_ascii_dtostr(buffer: [*c]gchar, buf_len: gint, d: gdouble) [*c]gchar;
pub extern fn g_ascii_formatd(buffer: [*c]gchar, buf_len: gint, format: [*c]const gchar, d: gdouble) [*c]gchar;
pub extern fn g_strchug(string: [*c]gchar) [*c]gchar;
pub extern fn g_strchomp(string: [*c]gchar) [*c]gchar;
pub extern fn g_ascii_strcasecmp(s1: [*c]const gchar, s2: [*c]const gchar) gint;
pub extern fn g_ascii_strncasecmp(s1: [*c]const gchar, s2: [*c]const gchar, n: gsize) gint;
pub extern fn g_ascii_strdown(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_ascii_strup(str: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_str_is_ascii(str: [*c]const gchar) gboolean;
pub extern fn g_strcasecmp(s1: [*c]const gchar, s2: [*c]const gchar) gint;
pub extern fn g_strncasecmp(s1: [*c]const gchar, s2: [*c]const gchar, n: guint) gint;
pub extern fn g_strdown(string: [*c]gchar) [*c]gchar;
pub extern fn g_strup(string: [*c]gchar) [*c]gchar;
pub extern fn g_strdup(str: [*c]const gchar) [*c]gchar;
pub extern fn g_strdup_printf(format: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_strdup_vprintf(format: [*c]const gchar, args: va_list) [*c]gchar;
pub extern fn g_strndup(str: [*c]const gchar, n: gsize) [*c]gchar;
pub extern fn g_strnfill(length: gsize, fill_char: gchar) [*c]gchar;
pub extern fn g_strconcat(string1: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_strjoin(separator: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_strcompress(source: [*c]const gchar) [*c]gchar;
pub extern fn g_strescape(source: [*c]const gchar, exceptions: [*c]const gchar) [*c]gchar;
pub extern fn g_memdup(mem: gconstpointer, byte_size: guint) gpointer;
pub const GStrv = [*c]([*c]gchar);
pub extern fn g_strsplit(string: [*c]const gchar, delimiter: [*c]const gchar, max_tokens: gint) [*c]([*c]gchar);
pub extern fn g_strsplit_set(string: [*c]const gchar, delimiters: [*c]const gchar, max_tokens: gint) [*c]([*c]gchar);
pub extern fn g_strjoinv(separator: [*c]const gchar, str_array: [*c]([*c]gchar)) [*c]gchar;
pub extern fn g_strfreev(str_array: [*c]([*c]gchar)) void;
pub extern fn g_strdupv(str_array: [*c]([*c]gchar)) [*c]([*c]gchar);
pub extern fn g_strv_length(str_array: [*c]([*c]gchar)) guint;
pub extern fn g_stpcpy(dest: [*c]gchar, src: [*c]const u8) [*c]gchar;
pub extern fn g_str_to_ascii(str: [*c]const gchar, from_locale: [*c]const gchar) [*c]gchar;
pub extern fn g_str_tokenize_and_fold(string: [*c]const gchar, translit_locale: [*c]const gchar, ascii_alternates: [*c]([*c]([*c]gchar))) [*c]([*c]gchar);
pub extern fn g_str_match_string(search_term: [*c]const gchar, potential_hit: [*c]const gchar, accept_alternates: gboolean) gboolean;
pub extern fn g_strv_contains(strv: [*c]const ([*c]const gchar), str: [*c]const gchar) gboolean;
pub extern fn g_strv_equal(strv1: [*c]const ([*c]const gchar), strv2: [*c]const ([*c]const gchar)) gboolean;
pub const G_NUMBER_PARSER_ERROR_INVALID = 0;
pub const G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS = 1;
pub const GNumberParserError = extern enum {
    G_NUMBER_PARSER_ERROR_INVALID = 0,
    G_NUMBER_PARSER_ERROR_OUT_OF_BOUNDS = 1,
};
pub extern fn g_number_parser_error_quark() GQuark;
pub extern fn g_ascii_string_to_signed(str: [*c]const gchar, base: guint, min: gint64, max: gint64, out_num: [*c]gint64, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_ascii_string_to_unsigned(str: [*c]const gchar, base: guint, min: guint64, max: guint64, out_num: [*c]guint64, @"error": [*c]([*c]GError)) gboolean;
pub const struct__GStringChunk = @OpaqueType();
pub const GStringChunk = struct__GStringChunk;
pub extern fn g_string_chunk_new(size: gsize) ?*GStringChunk;
pub extern fn g_string_chunk_free(chunk: ?*GStringChunk) void;
pub extern fn g_string_chunk_clear(chunk: ?*GStringChunk) void;
pub extern fn g_string_chunk_insert(chunk: ?*GStringChunk, string: [*c]const gchar) [*c]gchar;
pub extern fn g_string_chunk_insert_len(chunk: ?*GStringChunk, string: [*c]const gchar, len: gssize) [*c]gchar;
pub extern fn g_string_chunk_insert_const(chunk: ?*GStringChunk, string: [*c]const gchar) [*c]gchar;
pub extern fn memchr(_Buf: ?*const c_void, _Val: c_int, _MaxCount: c_ulonglong) ?*c_void;
pub extern fn memcmp(_Buf1: ?*const c_void, _Buf2: ?*const c_void, _Size: c_ulonglong) c_int;
pub extern fn memcpy(_Dst: ?*c_void, _Src: ?*const c_void, _Size: c_ulonglong) ?*c_void;
pub extern fn memmove(_Dst: ?*c_void, _Src: ?*const c_void, _Size: c_ulonglong) ?*c_void;
pub extern fn memset(_Dst: ?*c_void, _Val: c_int, _Size: c_ulonglong) ?*c_void;
pub extern fn strchr(_Str: [*c]const u8, _Val: c_int) [*c]u8;
pub extern fn strrchr(_Str: [*c]const u8, _Ch: c_int) [*c]u8;
pub extern fn strstr(_Str: [*c]const u8, _SubStr: [*c]const u8) [*c]u8;
pub extern fn wcschr(_Str: [*c]const c_ushort, _Ch: c_ushort) [*c]c_ushort;
pub extern fn wcsrchr(_Str: [*c]const wchar_t, _Ch: wchar_t) [*c]wchar_t;
pub extern fn wcsstr(_Str: [*c]const wchar_t, _SubStr: [*c]const wchar_t) [*c]wchar_t;
pub fn memcpy_s(_Destination: ?*c_void, _DestinationSize: rsize_t, _Source: ?*const c_void, _SourceSize: rsize_t) errno_t {
    if (_SourceSize == c_ulonglong(0)) {
        return 0;
    }
    {
        var _Expr_val: c_int = !!(_Destination != (?*c_void)(0));
        if (!(_Expr_val != 0)) {
            _errno().?.* = 22;
            _invalid_parameter_noinfo();
            return 22;
        }
    }
    {}
    if ((_Source == @ptrCast(?*const c_void, (?*c_void)(0))) or (_DestinationSize < _SourceSize)) {
        _ = memset(_Destination, 0, _DestinationSize);
        {
            var _Expr_val: c_int = !!(_Source != @ptrCast(?*const c_void, (?*c_void)(0)));
            if (!(_Expr_val != 0)) {
                _errno().?.* = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        }
        {}
        {
            var _Expr_val: c_int = !!(_DestinationSize >= _SourceSize);
            if (!(_Expr_val != 0)) {
                _errno().?.* = 34;
                _invalid_parameter_noinfo();
                return 34;
            }
        }
        {}
        return 22;
    }
    _ = memcpy(_Destination, _Source, _SourceSize);
    return 0;
}
pub fn memmove_s(_Destination: ?*c_void, _DestinationSize: rsize_t, _Source: ?*const c_void, _SourceSize: rsize_t) errno_t {
    if (_SourceSize == c_ulonglong(0)) {
        return 0;
    }
    {
        var _Expr_val: c_int = !!(_Destination != (?*c_void)(0));
        if (!(_Expr_val != 0)) {
            _errno().?.* = 22;
            _invalid_parameter_noinfo();
            return 22;
        }
    }
    {}
    {
        var _Expr_val: c_int = !!(_Source != @ptrCast(?*const c_void, (?*c_void)(0)));
        if (!(_Expr_val != 0)) {
            _errno().?.* = 22;
            _invalid_parameter_noinfo();
            return 22;
        }
    }
    {}
    {
        var _Expr_val: c_int = !!(_DestinationSize >= _SourceSize);
        if (!(_Expr_val != 0)) {
            _errno().?.* = 34;
            _invalid_parameter_noinfo();
            return 34;
        }
    }
    {}
    _ = memmove(_Destination, _Source, _SourceSize);
    return 0;
}
pub extern fn _memicmp(_Buf1: ?*const c_void, _Buf2: ?*const c_void, _Size: usize) c_int;
pub extern fn _memicmp_l(_Buf1: ?*const c_void, _Buf2: ?*const c_void, _Size: usize, _Locale: _locale_t) c_int;
pub extern fn memccpy(_Dst: ?*c_void, _Src: ?*const c_void, _Val: c_int, _Size: usize) ?*c_void;
pub extern fn memicmp(_Buf1: ?*const c_void, _Buf2: ?*const c_void, _Size: usize) c_int;
pub extern fn wcscat_s(_Destination: [*c]wchar_t, _SizeInWords: rsize_t, _Source: [*c]const wchar_t) errno_t;
pub extern fn wcscpy_s(_Destination: [*c]wchar_t, _SizeInWords: rsize_t, _Source: [*c]const wchar_t) errno_t;
pub extern fn wcsncat_s(_Destination: [*c]wchar_t, _SizeInWords: rsize_t, _Source: [*c]const wchar_t, _MaxCount: rsize_t) errno_t;
pub extern fn wcsncpy_s(_Destination: [*c]wchar_t, _SizeInWords: rsize_t, _Source: [*c]const wchar_t, _MaxCount: rsize_t) errno_t;
pub extern fn wcstok_s(_String: [*c]wchar_t, _Delimiter: [*c]const wchar_t, _Context: [*c]([*c]wchar_t)) [*c]wchar_t;
pub extern fn _wcsdup(_String: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcscat(_Destination: [*c]wchar_t, _Source: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcscmp(_String1: [*c]const c_ushort, _String2: [*c]const c_ushort) c_int;
pub extern fn wcscpy(_Destination: [*c]wchar_t, _Source: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcscspn(_String: [*c]const wchar_t, _Control: [*c]const wchar_t) usize;
pub extern fn wcslen(_String: [*c]const c_ushort) c_ulonglong;
pub extern fn wcsnlen(_Source: [*c]const wchar_t, _MaxCount: usize) usize;
pub fn wcsnlen_s(_Source: [*c]const wchar_t, _MaxCount: usize) usize {
    return if (_Source == null) c_ulonglong(0) else wcsnlen(_Source, _MaxCount);
}
pub extern fn wcsncat(_Destination: [*c]wchar_t, _Source: [*c]const wchar_t, _Count: usize) [*c]wchar_t;
pub extern fn wcsncmp(_String1: [*c]const c_ushort, _String2: [*c]const c_ushort, _MaxCount: c_ulonglong) c_int;
pub extern fn wcsncpy(_Destination: [*c]wchar_t, _Source: [*c]const wchar_t, _Count: usize) [*c]wchar_t;
pub extern fn wcspbrk(_String: [*c]const wchar_t, _Control: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcsspn(_String: [*c]const wchar_t, _Control: [*c]const wchar_t) usize;
pub extern fn wcstok(_String: [*c]wchar_t, _Delimiter: [*c]const wchar_t, _Context: [*c]([*c]wchar_t)) [*c]wchar_t;
pub fn _wcstok(_String: [*c]wchar_t, _Delimiter: [*c]const wchar_t) [*c]wchar_t {
    return wcstok(_String, _Delimiter, null);
}
pub extern fn _wcserror(_ErrorNumber: c_int) [*c]wchar_t;
pub extern fn _wcserror_s(_Buffer: [*c]wchar_t, _SizeInWords: usize, _ErrorNumber: c_int) errno_t;
pub extern fn __wcserror(_String: [*c]const wchar_t) [*c]wchar_t;
pub extern fn __wcserror_s(_Buffer: [*c]wchar_t, _SizeInWords: usize, _ErrorMessage: [*c]const wchar_t) errno_t;
pub extern fn _wcsicmp(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t) c_int;
pub extern fn _wcsicmp_l(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _Locale: _locale_t) c_int;
pub extern fn _wcsnicmp(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize) c_int;
pub extern fn _wcsnicmp_l(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _wcsnset_s(_Destination: [*c]wchar_t, _SizeInWords: usize, _Value: wchar_t, _MaxCount: usize) errno_t;
pub extern fn _wcsnset(_String: [*c]wchar_t, _Value: wchar_t, _MaxCount: usize) [*c]wchar_t;
pub extern fn _wcsrev(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn _wcsset_s(_Destination: [*c]wchar_t, _SizeInWords: usize, _Value: wchar_t) errno_t;
pub extern fn _wcsset(_String: [*c]wchar_t, _Value: wchar_t) [*c]wchar_t;
pub extern fn _wcslwr_s(_String: [*c]wchar_t, _SizeInWords: usize) errno_t;
pub extern fn _wcslwr(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn _wcslwr_s_l(_String: [*c]wchar_t, _SizeInWords: usize, _Locale: _locale_t) errno_t;
pub extern fn _wcslwr_l(_String: [*c]wchar_t, _Locale: _locale_t) [*c]wchar_t;
pub extern fn _wcsupr_s(_String: [*c]wchar_t, _Size: usize) errno_t;
pub extern fn _wcsupr(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn _wcsupr_s_l(_String: [*c]wchar_t, _Size: usize, _Locale: _locale_t) errno_t;
pub extern fn _wcsupr_l(_String: [*c]wchar_t, _Locale: _locale_t) [*c]wchar_t;
pub extern fn wcsxfrm(_Destination: [*c]wchar_t, _Source: [*c]const wchar_t, _MaxCount: usize) usize;
pub extern fn _wcsxfrm_l(_Destination: [*c]wchar_t, _Source: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn wcscoll(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t) c_int;
pub extern fn _wcscoll_l(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _Locale: _locale_t) c_int;
pub extern fn _wcsicoll(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t) c_int;
pub extern fn _wcsicoll_l(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _Locale: _locale_t) c_int;
pub extern fn _wcsncoll(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize) c_int;
pub extern fn _wcsncoll_l(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _wcsnicoll(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize) c_int;
pub extern fn _wcsnicoll_l(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn wcsdup(_String: [*c]const wchar_t) [*c]wchar_t;
pub extern fn wcsicmp(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t) c_int;
pub extern fn wcsnicmp(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t, _MaxCount: usize) c_int;
pub extern fn wcsnset(_String: [*c]wchar_t, _Value: wchar_t, _MaxCount: usize) [*c]wchar_t;
pub extern fn wcsrev(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn wcsset(_String: [*c]wchar_t, _Value: wchar_t) [*c]wchar_t;
pub extern fn wcslwr(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn wcsupr(_String: [*c]wchar_t) [*c]wchar_t;
pub extern fn wcsicoll(_String1: [*c]const wchar_t, _String2: [*c]const wchar_t) c_int;
pub extern fn strcpy_s(_Destination: [*c]u8, _SizeInBytes: rsize_t, _Source: [*c]const u8) errno_t;
pub extern fn strcat_s(_Destination: [*c]u8, _SizeInBytes: rsize_t, _Source: [*c]const u8) errno_t;
pub extern fn strerror_s(_Buffer: [*c]u8, _SizeInBytes: usize, _ErrorNumber: c_int) errno_t;
pub extern fn strncat_s(_Destination: [*c]u8, _SizeInBytes: rsize_t, _Source: [*c]const u8, _MaxCount: rsize_t) errno_t;
pub extern fn strncpy_s(_Destination: [*c]u8, _SizeInBytes: rsize_t, _Source: [*c]const u8, _MaxCount: rsize_t) errno_t;
pub extern fn strtok_s(_String: [*c]u8, _Delimiter: [*c]const u8, _Context: [*c]([*c]u8)) [*c]u8;
pub extern fn _memccpy(_Dst: ?*c_void, _Src: ?*const c_void, _Val: c_int, _MaxCount: usize) ?*c_void;
pub extern fn strcat(_Destination: [*c]u8, _Source: [*c]const u8) [*c]u8;
pub extern fn strcmp(_Str1: [*c]const u8, _Str2: [*c]const u8) c_int;
pub extern fn _strcmpi(_String1: [*c]const u8, _String2: [*c]const u8) c_int;
pub extern fn strcoll(_String1: [*c]const u8, _String2: [*c]const u8) c_int;
pub extern fn _strcoll_l(_String1: [*c]const u8, _String2: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn strcpy(_Destination: [*c]u8, _Source: [*c]const u8) [*c]u8;
pub extern fn strcspn(_Str: [*c]const u8, _Control: [*c]const u8) c_ulonglong;
pub extern fn _strdup(_Source: [*c]const u8) [*c]u8;
pub extern fn _strerror(_ErrorMessage: [*c]const u8) [*c]u8;
pub extern fn _strerror_s(_Buffer: [*c]u8, _SizeInBytes: usize, _ErrorMessage: [*c]const u8) errno_t;
pub extern fn strerror(_ErrorMessage: c_int) [*c]u8;
pub extern fn _stricmp(_String1: [*c]const u8, _String2: [*c]const u8) c_int;
pub extern fn _stricoll(_String1: [*c]const u8, _String2: [*c]const u8) c_int;
pub extern fn _stricoll_l(_String1: [*c]const u8, _String2: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn _stricmp_l(_String1: [*c]const u8, _String2: [*c]const u8, _Locale: _locale_t) c_int;
pub extern fn strlen(_Str: [*c]const u8) c_ulonglong;
pub extern fn _strlwr_s(_String: [*c]u8, _Size: usize) errno_t;
pub extern fn _strlwr(_String: [*c]u8) [*c]u8;
pub extern fn _strlwr_s_l(_String: [*c]u8, _Size: usize, _Locale: _locale_t) errno_t;
pub extern fn _strlwr_l(_String: [*c]u8, _Locale: _locale_t) [*c]u8;
pub extern fn strncat(_Destination: [*c]u8, _Source: [*c]const u8, _Count: c_ulonglong) [*c]u8;
pub extern fn strncmp(_Str1: [*c]const u8, _Str2: [*c]const u8, _MaxCount: c_ulonglong) c_int;
pub extern fn _strnicmp(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn _strnicmp_l(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _strnicoll(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn _strnicoll_l(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn _strncoll(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn _strncoll_l(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) c_int;
pub extern fn __strncnt(_String: [*c]const u8, _Count: usize) usize;
pub extern fn strncpy(_Destination: [*c]u8, _Source: [*c]const u8, _Count: c_ulonglong) [*c]u8;
pub extern fn strnlen(_String: [*c]const u8, _MaxCount: usize) usize;
pub fn strnlen_s(_String: [*c]const u8, _MaxCount: usize) usize {
    return if (_String == null) c_ulonglong(0) else strnlen(_String, _MaxCount);
}
pub extern fn _strnset_s(_String: [*c]u8, _SizeInBytes: usize, _Value: c_int, _MaxCount: usize) errno_t;
pub extern fn _strnset(_Destination: [*c]u8, _Value: c_int, _Count: usize) [*c]u8;
pub extern fn strpbrk(_Str: [*c]const u8, _Control: [*c]const u8) [*c]u8;
pub extern fn _strrev(_Str: [*c]u8) [*c]u8;
pub extern fn _strset_s(_Destination: [*c]u8, _DestinationSize: usize, _Value: c_int) errno_t;
pub extern fn _strset(_Destination: [*c]u8, _Value: c_int) [*c]u8;
pub extern fn strspn(_Str: [*c]const u8, _Control: [*c]const u8) c_ulonglong;
pub extern fn strtok(_String: [*c]u8, _Delimiter: [*c]const u8) [*c]u8;
pub extern fn _strupr_s(_String: [*c]u8, _Size: usize) errno_t;
pub extern fn _strupr(_String: [*c]u8) [*c]u8;
pub extern fn _strupr_s_l(_String: [*c]u8, _Size: usize, _Locale: _locale_t) errno_t;
pub extern fn _strupr_l(_String: [*c]u8, _Locale: _locale_t) [*c]u8;
pub extern fn strxfrm(_Destination: [*c]u8, _Source: [*c]const u8, _MaxCount: c_ulonglong) c_ulonglong;
pub extern fn _strxfrm_l(_Destination: [*c]u8, _Source: [*c]const u8, _MaxCount: usize, _Locale: _locale_t) usize;
pub extern fn strdup(_String: [*c]const u8) [*c]u8;
pub extern fn strcmpi(_String1: [*c]const u8, _String2: [*c]const u8) c_int;
pub extern fn stricmp(_String1: [*c]const u8, _String2: [*c]const u8) c_int;
pub extern fn strlwr(_String: [*c]u8) [*c]u8;
pub extern fn strnicmp(_String1: [*c]const u8, _String2: [*c]const u8, _MaxCount: usize) c_int;
pub extern fn strnset(_String: [*c]u8, _Value: c_int, _MaxCount: usize) [*c]u8;
pub extern fn strrev(_String: [*c]u8) [*c]u8;
pub extern fn strset(_String: [*c]u8, _Value: c_int) [*c]u8;
pub extern fn strupr(_String: [*c]u8) [*c]u8;
pub const struct_GTestCase = @OpaqueType();
pub const GTestCase = struct_GTestCase;
pub const struct_GTestSuite = @OpaqueType();
pub const GTestSuite = struct_GTestSuite;
pub const GTestFunc = ?extern fn () void;
pub const GTestDataFunc = ?extern fn (gconstpointer) void;
pub const GTestFixtureFunc = ?extern fn (gpointer, gconstpointer) void;
pub extern fn g_strcmp0(str1: [*c]const u8, str2: [*c]const u8) c_int;
pub extern fn g_test_minimized_result(minimized_quantity: f64, format: [*c]const u8, ...) void;
pub extern fn g_test_maximized_result(maximized_quantity: f64, format: [*c]const u8, ...) void;
pub extern fn g_test_init(argc: [*c]c_int, argv: [*c]([*c]([*c]u8)), ...) void;
pub extern fn g_test_subprocess() gboolean;
pub extern fn g_test_run() c_int;
pub extern fn g_test_add_func(testpath: [*c]const u8, test_func: GTestFunc) void;
pub extern fn g_test_add_data_func(testpath: [*c]const u8, test_data: gconstpointer, test_func: GTestDataFunc) void;
pub extern fn g_test_add_data_func_full(testpath: [*c]const u8, test_data: gpointer, test_func: GTestDataFunc, data_free_func: GDestroyNotify) void;
pub extern fn g_test_fail() void;
pub extern fn g_test_incomplete(msg: [*c]const gchar) void;
pub extern fn g_test_skip(msg: [*c]const gchar) void;
pub extern fn g_test_failed() gboolean;
pub extern fn g_test_set_nonfatal_assertions() void;
pub extern fn g_test_message(format: [*c]const u8, ...) void;
pub extern fn g_test_bug_base(uri_pattern: [*c]const u8) void;
pub extern fn g_test_bug(bug_uri_snippet: [*c]const u8) void;
pub extern fn g_test_summary(summary: [*c]const u8) void;
pub extern fn g_test_timer_start() void;
pub extern fn g_test_timer_elapsed() f64;
pub extern fn g_test_timer_last() f64;
pub extern fn g_test_queue_free(gfree_pointer: gpointer) void;
pub extern fn g_test_queue_destroy(destroy_func: GDestroyNotify, destroy_data: gpointer) void;
pub const G_TEST_TRAP_SILENCE_STDOUT = 128;
pub const G_TEST_TRAP_SILENCE_STDERR = 256;
pub const G_TEST_TRAP_INHERIT_STDIN = 512;
pub const GTestTrapFlags = extern enum {
    G_TEST_TRAP_SILENCE_STDOUT = 128,
    G_TEST_TRAP_SILENCE_STDERR = 256,
    G_TEST_TRAP_INHERIT_STDIN = 512,
};
pub extern fn g_test_trap_fork(usec_timeout: guint64, test_trap_flags: GTestTrapFlags) gboolean;
pub const G_TEST_SUBPROCESS_INHERIT_STDIN = 1;
pub const G_TEST_SUBPROCESS_INHERIT_STDOUT = 2;
pub const G_TEST_SUBPROCESS_INHERIT_STDERR = 4;
pub const GTestSubprocessFlags = extern enum {
    G_TEST_SUBPROCESS_INHERIT_STDIN = 1,
    G_TEST_SUBPROCESS_INHERIT_STDOUT = 2,
    G_TEST_SUBPROCESS_INHERIT_STDERR = 4,
};
pub extern fn g_test_trap_subprocess(test_path: [*c]const u8, usec_timeout: guint64, test_flags: GTestSubprocessFlags) void;
pub extern fn g_test_trap_has_passed() gboolean;
pub extern fn g_test_trap_reached_timeout() gboolean;
pub extern fn g_test_rand_int() gint32;
pub extern fn g_test_rand_int_range(begin: gint32, end: gint32) gint32;
pub extern fn g_test_rand_double() f64;
pub extern fn g_test_rand_double_range(range_start: f64, range_end: f64) f64;
pub extern fn g_test_create_case(test_name: [*c]const u8, data_size: gsize, test_data: gconstpointer, data_setup: GTestFixtureFunc, data_test: GTestFixtureFunc, data_teardown: GTestFixtureFunc) ?*GTestCase;
pub extern fn g_test_create_suite(suite_name: [*c]const u8) ?*GTestSuite;
pub extern fn g_test_get_root() ?*GTestSuite;
pub extern fn g_test_suite_add(suite: ?*GTestSuite, test_case: ?*GTestCase) void;
pub extern fn g_test_suite_add_suite(suite: ?*GTestSuite, nestedsuite: ?*GTestSuite) void;
pub extern fn g_test_run_suite(suite: ?*GTestSuite) c_int;
pub extern fn g_test_trap_assertions(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, assertion_flags: guint64, pattern: [*c]const u8) void;
pub extern fn g_assertion_message(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, message: [*c]const u8) void;
pub extern fn g_assertion_message_expr(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8) void;
pub extern fn g_assertion_message_cmpstr(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8, arg1: [*c]const u8, cmp: [*c]const u8, arg2: [*c]const u8) void;
pub extern fn g_assertion_message_cmpnum(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8, arg1: c_longdouble, cmp: [*c]const u8, arg2: c_longdouble, numtype: u8) void;
pub extern fn g_assertion_message_error(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8, expr: [*c]const u8, @"error": [*c]const GError, error_domain: GQuark, error_code: c_int) void;
pub extern fn g_test_add_vtable(testpath: [*c]const u8, data_size: gsize, test_data: gconstpointer, data_setup: GTestFixtureFunc, data_test: GTestFixtureFunc, data_teardown: GTestFixtureFunc) void;
pub const GTestConfig = extern struct {
    test_initialized: gboolean,
    test_quick: gboolean,
    test_perf: gboolean,
    test_verbose: gboolean,
    test_quiet: gboolean,
    test_undefined: gboolean,
};
pub extern const g_test_config_vars: [*c]const GTestConfig;
pub const G_TEST_RUN_SUCCESS = 0;
pub const G_TEST_RUN_SKIPPED = 1;
pub const G_TEST_RUN_FAILURE = 2;
pub const G_TEST_RUN_INCOMPLETE = 3;
pub const GTestResult = extern enum {
    G_TEST_RUN_SUCCESS = 0,
    G_TEST_RUN_SKIPPED = 1,
    G_TEST_RUN_FAILURE = 2,
    G_TEST_RUN_INCOMPLETE = 3,
};
pub const G_TEST_LOG_NONE = 0;
pub const G_TEST_LOG_ERROR = 1;
pub const G_TEST_LOG_START_BINARY = 2;
pub const G_TEST_LOG_LIST_CASE = 3;
pub const G_TEST_LOG_SKIP_CASE = 4;
pub const G_TEST_LOG_START_CASE = 5;
pub const G_TEST_LOG_STOP_CASE = 6;
pub const G_TEST_LOG_MIN_RESULT = 7;
pub const G_TEST_LOG_MAX_RESULT = 8;
pub const G_TEST_LOG_MESSAGE = 9;
pub const G_TEST_LOG_START_SUITE = 10;
pub const G_TEST_LOG_STOP_SUITE = 11;
pub const GTestLogType = extern enum {
    G_TEST_LOG_NONE = 0,
    G_TEST_LOG_ERROR = 1,
    G_TEST_LOG_START_BINARY = 2,
    G_TEST_LOG_LIST_CASE = 3,
    G_TEST_LOG_SKIP_CASE = 4,
    G_TEST_LOG_START_CASE = 5,
    G_TEST_LOG_STOP_CASE = 6,
    G_TEST_LOG_MIN_RESULT = 7,
    G_TEST_LOG_MAX_RESULT = 8,
    G_TEST_LOG_MESSAGE = 9,
    G_TEST_LOG_START_SUITE = 10,
    G_TEST_LOG_STOP_SUITE = 11,
};
pub const GTestLogMsg = extern struct {
    log_type: GTestLogType,
    n_strings: guint,
    strings: [*c]([*c]gchar),
    n_nums: guint,
    nums: [*c]c_longdouble,
};
pub const GTestLogBuffer = extern struct {
    data: [*c]GString,
    msgs: [*c]GSList,
};
pub extern fn g_test_log_type_name(log_type: GTestLogType) [*c]const u8;
pub extern fn g_test_log_buffer_new() [*c]GTestLogBuffer;
pub extern fn g_test_log_buffer_free(tbuffer: [*c]GTestLogBuffer) void;
pub extern fn g_test_log_buffer_push(tbuffer: [*c]GTestLogBuffer, n_bytes: guint, bytes: [*c]const guint8) void;
pub extern fn g_test_log_buffer_pop(tbuffer: [*c]GTestLogBuffer) [*c]GTestLogMsg;
pub extern fn g_test_log_msg_free(tmsg: [*c]GTestLogMsg) void;
pub const GTestLogFatalFunc = ?extern fn ([*c]const gchar, GLogLevelFlags, [*c]const gchar, gpointer) gboolean;
pub extern fn g_test_log_set_fatal_handler(log_func: GTestLogFatalFunc, user_data: gpointer) void;
pub extern fn g_test_expect_message(log_domain: [*c]const gchar, log_level: GLogLevelFlags, pattern: [*c]const gchar) void;
pub extern fn g_test_assert_expected_messages_internal(domain: [*c]const u8, file: [*c]const u8, line: c_int, func: [*c]const u8) void;
pub const G_TEST_DIST = 0;
pub const G_TEST_BUILT = 1;
pub const GTestFileType = extern enum {
    G_TEST_DIST = 0,
    G_TEST_BUILT = 1,
};
pub extern fn g_test_build_filename(file_type: GTestFileType, first_path: [*c]const gchar, ...) [*c]gchar;
pub extern fn g_test_get_dir(file_type: GTestFileType) [*c]const gchar;
pub extern fn g_test_get_filename(file_type: GTestFileType, first_path: [*c]const gchar, ...) [*c]const gchar;
pub const struct__GThreadPool = extern struct {
    func: GFunc,
    user_data: gpointer,
    exclusive: gboolean,
};
pub const GThreadPool = struct__GThreadPool;
pub extern fn g_thread_pool_new(func: GFunc, user_data: gpointer, max_threads: gint, exclusive: gboolean, @"error": [*c]([*c]GError)) [*c]GThreadPool;
pub extern fn g_thread_pool_free(pool: [*c]GThreadPool, immediate: gboolean, wait_: gboolean) void;
pub extern fn g_thread_pool_push(pool: [*c]GThreadPool, data: gpointer, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_thread_pool_unprocessed(pool: [*c]GThreadPool) guint;
pub extern fn g_thread_pool_set_sort_function(pool: [*c]GThreadPool, func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_thread_pool_move_to_front(pool: [*c]GThreadPool, data: gpointer) gboolean;
pub extern fn g_thread_pool_set_max_threads(pool: [*c]GThreadPool, max_threads: gint, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_thread_pool_get_max_threads(pool: [*c]GThreadPool) gint;
pub extern fn g_thread_pool_get_num_threads(pool: [*c]GThreadPool) guint;
pub extern fn g_thread_pool_set_max_unused_threads(max_threads: gint) void;
pub extern fn g_thread_pool_get_max_unused_threads() gint;
pub extern fn g_thread_pool_get_num_unused_threads() guint;
pub extern fn g_thread_pool_stop_unused_threads() void;
pub extern fn g_thread_pool_set_max_idle_time(interval: guint) void;
pub extern fn g_thread_pool_get_max_idle_time() guint;
pub const struct__GTimer = @OpaqueType();
pub const GTimer = struct__GTimer;
pub extern fn g_timer_new() ?*GTimer;
pub extern fn g_timer_destroy(timer: ?*GTimer) void;
pub extern fn g_timer_start(timer: ?*GTimer) void;
pub extern fn g_timer_stop(timer: ?*GTimer) void;
pub extern fn g_timer_reset(timer: ?*GTimer) void;
pub extern fn g_timer_continue(timer: ?*GTimer) void;
pub extern fn g_timer_elapsed(timer: ?*GTimer, microseconds: [*c]gulong) gdouble;
pub extern fn g_timer_is_active(timer: ?*GTimer) gboolean;
pub extern fn g_usleep(microseconds: gulong) void;
pub extern fn g_time_val_add(time_: [*c]GTimeVal, microseconds: glong) void;
pub extern fn g_time_val_from_iso8601(iso_date: [*c]const gchar, time_: [*c]GTimeVal) gboolean;
pub extern fn g_time_val_to_iso8601(time_: [*c]GTimeVal) [*c]gchar;
pub const GTrashStack = struct__GTrashStack;
pub const struct__GTrashStack = extern struct {
    next: [*c]GTrashStack,
};
pub extern fn g_trash_stack_push(stack_p: [*c]([*c]GTrashStack), data_p: gpointer) void;
pub extern fn g_trash_stack_pop(stack_p: [*c]([*c]GTrashStack)) gpointer;
pub extern fn g_trash_stack_peek(stack_p: [*c]([*c]GTrashStack)) gpointer;
pub extern fn g_trash_stack_height(stack_p: [*c]([*c]GTrashStack)) guint;
pub const struct__GTree = @OpaqueType();
pub const GTree = struct__GTree;
pub const GTraverseFunc = ?extern fn (gpointer, gpointer, gpointer) gboolean;
pub extern fn g_tree_new(key_compare_func: GCompareFunc) ?*GTree;
pub extern fn g_tree_new_with_data(key_compare_func: GCompareDataFunc, key_compare_data: gpointer) ?*GTree;
pub extern fn g_tree_new_full(key_compare_func: GCompareDataFunc, key_compare_data: gpointer, key_destroy_func: GDestroyNotify, value_destroy_func: GDestroyNotify) ?*GTree;
pub extern fn g_tree_ref(tree: ?*GTree) ?*GTree;
pub extern fn g_tree_unref(tree: ?*GTree) void;
pub extern fn g_tree_destroy(tree: ?*GTree) void;
pub extern fn g_tree_insert(tree: ?*GTree, key: gpointer, value: gpointer) void;
pub extern fn g_tree_replace(tree: ?*GTree, key: gpointer, value: gpointer) void;
pub extern fn g_tree_remove(tree: ?*GTree, key: gconstpointer) gboolean;
pub extern fn g_tree_steal(tree: ?*GTree, key: gconstpointer) gboolean;
pub extern fn g_tree_lookup(tree: ?*GTree, key: gconstpointer) gpointer;
pub extern fn g_tree_lookup_extended(tree: ?*GTree, lookup_key: gconstpointer, orig_key: [*c]gpointer, value: [*c]gpointer) gboolean;
pub extern fn g_tree_foreach(tree: ?*GTree, func: GTraverseFunc, user_data: gpointer) void;
pub extern fn g_tree_traverse(tree: ?*GTree, traverse_func: GTraverseFunc, traverse_type: GTraverseType, user_data: gpointer) void;
pub extern fn g_tree_search(tree: ?*GTree, search_func: GCompareFunc, user_data: gconstpointer) gpointer;
pub extern fn g_tree_height(tree: ?*GTree) gint;
pub extern fn g_tree_nnodes(tree: ?*GTree) gint;
pub extern fn g_uri_unescape_string(escaped_string: [*c]const u8, illegal_characters: [*c]const u8) [*c]u8;
pub extern fn g_uri_unescape_segment(escaped_string: [*c]const u8, escaped_string_end: [*c]const u8, illegal_characters: [*c]const u8) [*c]u8;
pub extern fn g_uri_parse_scheme(uri: [*c]const u8) [*c]u8;
pub extern fn g_uri_escape_string(unescaped: [*c]const u8, reserved_chars_allowed: [*c]const u8, allow_utf8: gboolean) [*c]u8;
pub extern fn g_uuid_string_is_valid(str: [*c]const gchar) gboolean;
pub extern fn g_uuid_string_random() [*c]gchar;
pub extern const glib_major_version: guint;
pub extern const glib_minor_version: guint;
pub extern const glib_micro_version: guint;
pub extern const glib_interface_age: guint;
pub extern const glib_binary_age: guint;
pub extern fn glib_check_version(required_major: guint, required_minor: guint, required_micro: guint) [*c]const gchar;
pub extern fn g_win32_ftruncate(f: gint, size: guint) gint;
pub extern fn g_win32_getlocale() [*c]gchar;
pub extern fn g_win32_error_message(@"error": gint) [*c]gchar;
pub extern fn g_win32_get_package_installation_directory(package: [*c]const gchar, dll_name: [*c]const gchar) [*c]gchar;
pub extern fn g_win32_get_package_installation_subdirectory(package: [*c]const gchar, dll_name: [*c]const gchar, subdir: [*c]const gchar) [*c]gchar;
pub extern fn g_win32_get_package_installation_directory_of_module(hmodule: gpointer) [*c]gchar;
pub extern fn g_win32_get_windows_version() guint;
pub extern fn g_win32_locale_filename_from_utf8(utf8filename: [*c]const gchar) [*c]gchar;
pub extern fn g_win32_get_command_line() [*c]([*c]gchar);
pub const G_WIN32_OS_ANY = 0;
pub const G_WIN32_OS_WORKSTATION = 1;
pub const G_WIN32_OS_SERVER = 2;
pub const GWin32OSType = extern enum {
    G_WIN32_OS_ANY = 0,
    G_WIN32_OS_WORKSTATION = 1,
    G_WIN32_OS_SERVER = 2,
};
pub extern fn g_win32_check_windows_version(major: gint, minor: gint, spver: gint, os_type: GWin32OSType) gboolean;
pub const struct__GAllocator = @OpaqueType();
pub const GAllocator = struct__GAllocator;
pub const struct__GMemChunk = @OpaqueType();
pub const GMemChunk = struct__GMemChunk;
pub extern fn g_mem_chunk_new(name: [*c]const gchar, atom_size: gint, area_size: gsize, type_0: gint) ?*GMemChunk;
pub extern fn g_mem_chunk_destroy(mem_chunk: ?*GMemChunk) void;
pub extern fn g_mem_chunk_alloc(mem_chunk: ?*GMemChunk) gpointer;
pub extern fn g_mem_chunk_alloc0(mem_chunk: ?*GMemChunk) gpointer;
pub extern fn g_mem_chunk_free(mem_chunk: ?*GMemChunk, mem: gpointer) void;
pub extern fn g_mem_chunk_clean(mem_chunk: ?*GMemChunk) void;
pub extern fn g_mem_chunk_reset(mem_chunk: ?*GMemChunk) void;
pub extern fn g_mem_chunk_print(mem_chunk: ?*GMemChunk) void;
pub extern fn g_mem_chunk_info() void;
pub extern fn g_blow_chunks() void;
pub extern fn g_allocator_new(name: [*c]const gchar, n_preallocs: guint) ?*GAllocator;
pub extern fn g_allocator_free(allocator: ?*GAllocator) void;
pub extern fn g_list_push_allocator(allocator: ?*GAllocator) void;
pub extern fn g_list_pop_allocator() void;
pub extern fn g_slist_push_allocator(allocator: ?*GAllocator) void;
pub extern fn g_slist_pop_allocator() void;
pub extern fn g_node_push_allocator(allocator: ?*GAllocator) void;
pub extern fn g_node_pop_allocator() void;
pub const struct__GCache = @OpaqueType();
pub const GCache = struct__GCache;
pub const GCacheNewFunc = ?extern fn (gpointer) gpointer;
pub const GCacheDupFunc = ?extern fn (gpointer) gpointer;
pub const GCacheDestroyFunc = ?extern fn (gpointer) void;
pub extern fn g_cache_new(value_new_func: GCacheNewFunc, value_destroy_func: GCacheDestroyFunc, key_dup_func: GCacheDupFunc, key_destroy_func: GCacheDestroyFunc, hash_key_func: GHashFunc, hash_value_func: GHashFunc, key_equal_func: GEqualFunc) ?*GCache;
pub extern fn g_cache_destroy(cache: ?*GCache) void;
pub extern fn g_cache_insert(cache: ?*GCache, key: gpointer) gpointer;
pub extern fn g_cache_remove(cache: ?*GCache, value: gconstpointer) void;
pub extern fn g_cache_key_foreach(cache: ?*GCache, func: GHFunc, user_data: gpointer) void;
pub extern fn g_cache_value_foreach(cache: ?*GCache, func: GHFunc, user_data: gpointer) void;
pub const GCompletionFunc = ?extern fn (gpointer) [*c]gchar;
pub const GCompletionStrncmpFunc = ?extern fn ([*c]const gchar, [*c]const gchar, gsize) gint;
pub const struct__GCompletion = extern struct {
    items: [*c]GList,
    func: GCompletionFunc,
    prefix: [*c]gchar,
    cache: [*c]GList,
    strncmp_func: GCompletionStrncmpFunc,
};
pub const GCompletion = struct__GCompletion;
pub extern fn g_completion_new(func: GCompletionFunc) [*c]GCompletion;
pub extern fn g_completion_add_items(cmp: [*c]GCompletion, items: [*c]GList) void;
pub extern fn g_completion_remove_items(cmp: [*c]GCompletion, items: [*c]GList) void;
pub extern fn g_completion_clear_items(cmp: [*c]GCompletion) void;
pub extern fn g_completion_complete(cmp: [*c]GCompletion, prefix: [*c]const gchar, new_prefix: [*c]([*c]gchar)) [*c]GList;
pub extern fn g_completion_complete_utf8(cmp: [*c]GCompletion, prefix: [*c]const gchar, new_prefix: [*c]([*c]gchar)) [*c]GList;
pub extern fn g_completion_set_compare(cmp: [*c]GCompletion, strncmp_func: GCompletionStrncmpFunc) void;
pub extern fn g_completion_free(cmp: [*c]GCompletion) void;
pub const struct__GRelation = @OpaqueType();
pub const GRelation = struct__GRelation;
pub const struct__GTuples = extern struct {
    len: guint,
};
pub const GTuples = struct__GTuples;
pub extern fn g_relation_new(fields: gint) ?*GRelation;
pub extern fn g_relation_destroy(relation: ?*GRelation) void;
pub extern fn g_relation_index(relation: ?*GRelation, field: gint, hash_func: GHashFunc, key_equal_func: GEqualFunc) void;
pub extern fn g_relation_insert(relation: ?*GRelation, ...) void;
pub extern fn g_relation_delete(relation: ?*GRelation, key: gconstpointer, field: gint) gint;
pub extern fn g_relation_select(relation: ?*GRelation, key: gconstpointer, field: gint) [*c]GTuples;
pub extern fn g_relation_count(relation: ?*GRelation, key: gconstpointer, field: gint) gint;
pub extern fn g_relation_exists(relation: ?*GRelation, ...) gboolean;
pub extern fn g_relation_print(relation: ?*GRelation) void;
pub extern fn g_tuples_destroy(tuples: [*c]GTuples) void;
pub extern fn g_tuples_index(tuples: [*c]GTuples, index_: gint, field: gint) gpointer;
pub const struct__GThreadFunctions = extern struct {
    mutex_new: ?extern fn () [*c]GMutex,
    mutex_lock: ?extern fn ([*c]GMutex) void,
    mutex_trylock: ?extern fn ([*c]GMutex) gboolean,
    mutex_unlock: ?extern fn ([*c]GMutex) void,
    mutex_free: ?extern fn ([*c]GMutex) void,
    cond_new: ?extern fn () [*c]GCond,
    cond_signal: ?extern fn ([*c]GCond) void,
    cond_broadcast: ?extern fn ([*c]GCond) void,
    cond_wait: ?extern fn ([*c]GCond, [*c]GMutex) void,
    cond_timed_wait: ?extern fn ([*c]GCond, [*c]GMutex, [*c]GTimeVal) gboolean,
    cond_free: ?extern fn ([*c]GCond) void,
    private_new: ?extern fn (GDestroyNotify) [*c]GPrivate,
    private_get: ?extern fn ([*c]GPrivate) gpointer,
    private_set: ?extern fn ([*c]GPrivate, gpointer) void,
    thread_create: ?extern fn (GThreadFunc, gpointer, gulong, gboolean, gboolean, GThreadPriority, gpointer, [*c]([*c]GError)) void,
    thread_yield: ?extern fn () void,
    thread_join: ?extern fn (gpointer) void,
    thread_exit: ?extern fn () void,
    thread_set_priority: ?extern fn (gpointer, GThreadPriority) void,
    thread_self: ?extern fn (gpointer) void,
    thread_equal: ?extern fn (gpointer, gpointer) gboolean,
};
pub const GThreadFunctions = struct__GThreadFunctions;
pub extern var g_thread_functions_for_glib_use: GThreadFunctions;
pub extern var g_thread_use_default_impl: gboolean;
pub extern var g_thread_gettime: ?extern fn () guint64;
pub extern fn g_thread_create(func: GThreadFunc, data: gpointer, joinable: gboolean, @"error": [*c]([*c]GError)) [*c]GThread;
pub extern fn g_thread_create_full(func: GThreadFunc, data: gpointer, stack_size: gulong, joinable: gboolean, bound: gboolean, priority: GThreadPriority, @"error": [*c]([*c]GError)) [*c]GThread;
pub extern fn g_thread_set_priority(thread: [*c]GThread, priority: GThreadPriority) void;
pub extern fn g_thread_foreach(thread_func: GFunc, user_data: gpointer) void;
pub const GStaticMutex = extern struct {
    mutex: [*c]GMutex,
};
pub extern fn g_static_mutex_init(mutex: [*c]GStaticMutex) void;
pub extern fn g_static_mutex_free(mutex: [*c]GStaticMutex) void;
pub extern fn g_static_mutex_get_mutex_impl(mutex: [*c]GStaticMutex) [*c]GMutex;
pub const struct__GStaticRecMutex = extern struct {
    mutex: GStaticMutex,
    depth: guint,
    unused: extern union {
        owner: ?*c_void,
        dummy: gdouble,
    },
};
pub const GStaticRecMutex = struct__GStaticRecMutex;
pub extern fn g_static_rec_mutex_init(mutex: [*c]GStaticRecMutex) void;
pub extern fn g_static_rec_mutex_lock(mutex: [*c]GStaticRecMutex) void;
pub extern fn g_static_rec_mutex_trylock(mutex: [*c]GStaticRecMutex) gboolean;
pub extern fn g_static_rec_mutex_unlock(mutex: [*c]GStaticRecMutex) void;
pub extern fn g_static_rec_mutex_lock_full(mutex: [*c]GStaticRecMutex, depth: guint) void;
pub extern fn g_static_rec_mutex_unlock_full(mutex: [*c]GStaticRecMutex) guint;
pub extern fn g_static_rec_mutex_free(mutex: [*c]GStaticRecMutex) void;
pub const struct__GStaticRWLock = extern struct {
    mutex: GStaticMutex,
    read_cond: [*c]GCond,
    write_cond: [*c]GCond,
    read_counter: guint,
    have_writer: gboolean,
    want_to_read: guint,
    want_to_write: guint,
};
pub const GStaticRWLock = struct__GStaticRWLock;
pub extern fn g_static_rw_lock_init(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_reader_lock(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_reader_trylock(lock: [*c]GStaticRWLock) gboolean;
pub extern fn g_static_rw_lock_reader_unlock(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_writer_lock(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_writer_trylock(lock: [*c]GStaticRWLock) gboolean;
pub extern fn g_static_rw_lock_writer_unlock(lock: [*c]GStaticRWLock) void;
pub extern fn g_static_rw_lock_free(lock: [*c]GStaticRWLock) void;
pub extern fn g_private_new(notify: GDestroyNotify) [*c]GPrivate;
pub const struct__GStaticPrivate = extern struct {
    index: guint,
};
pub const GStaticPrivate = struct__GStaticPrivate;
pub extern fn g_static_private_init(private_key: [*c]GStaticPrivate) void;
pub extern fn g_static_private_get(private_key: [*c]GStaticPrivate) gpointer;
pub extern fn g_static_private_set(private_key: [*c]GStaticPrivate, data: gpointer, notify: GDestroyNotify) void;
pub extern fn g_static_private_free(private_key: [*c]GStaticPrivate) void;
pub extern fn g_once_init_enter_impl(location: [*c]volatile gsize) gboolean;
pub extern fn g_thread_init(vtable: gpointer) void;
pub extern fn g_thread_init_with_errorcheck_mutexes(vtable: gpointer) void;
pub extern fn g_thread_get_initialized() gboolean;
pub extern var g_threads_got_initialized: gboolean;
pub extern fn g_mutex_new() [*c]GMutex;
pub extern fn g_mutex_free(mutex: [*c]GMutex) void;
pub extern fn g_cond_new() [*c]GCond;
pub extern fn g_cond_free(cond: [*c]GCond) void;
pub extern fn g_cond_timed_wait(cond: [*c]GCond, mutex: [*c]GMutex, timeval: [*c]GTimeVal) gboolean;
pub fn g_autoptr_cleanup_generic_gfree(p: ?*c_void) void {
    var pp: [*c](?*c_void) = @ptrCast([*c](?*c_void), @alignCast(@alignOf(?*c_void), p));
    g_free(pp.?.*);
}
pub fn g_autoptr_cleanup_gstring_free(string: [*c]GString) void {
    if (string != null) _ = g_string_free(string, !(0 != 0));
}
pub const GAsyncQueue_autoptr = ?*GAsyncQueue;
pub const GAsyncQueue_listautoptr = [*c]GList;
pub const GAsyncQueue_slistautoptr = [*c]GSList;
pub const GAsyncQueue_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAsyncQueue(_ptr: ?*GAsyncQueue) void {
    if (_ptr != null) g_async_queue_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GAsyncQueue(_ptr: [*c](?*GAsyncQueue)) void {
    glib_autoptr_clear_GAsyncQueue(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GAsyncQueue(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_async_queue_unref)))));
}
pub fn glib_slistautoptr_cleanup_GAsyncQueue(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_async_queue_unref)))));
}
pub fn glib_queueautoptr_cleanup_GAsyncQueue(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_async_queue_unref)))));
}
pub const GBookmarkFile_autoptr = ?*GBookmarkFile;
pub const GBookmarkFile_listautoptr = [*c]GList;
pub const GBookmarkFile_slistautoptr = [*c]GSList;
pub const GBookmarkFile_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GBookmarkFile(_ptr: ?*GBookmarkFile) void {
    if (_ptr != null) g_bookmark_file_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GBookmarkFile(_ptr: [*c](?*GBookmarkFile)) void {
    glib_autoptr_clear_GBookmarkFile(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GBookmarkFile(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_bookmark_file_free)))));
}
pub fn glib_slistautoptr_cleanup_GBookmarkFile(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_bookmark_file_free)))));
}
pub fn glib_queueautoptr_cleanup_GBookmarkFile(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_bookmark_file_free)))));
}
pub const GBytes_autoptr = ?*GBytes;
pub const GBytes_listautoptr = [*c]GList;
pub const GBytes_slistautoptr = [*c]GSList;
pub const GBytes_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GBytes(_ptr: ?*GBytes) void {
    if (_ptr != null) g_bytes_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GBytes(_ptr: [*c](?*GBytes)) void {
    glib_autoptr_clear_GBytes(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GBytes(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_bytes_unref)))));
}
pub fn glib_slistautoptr_cleanup_GBytes(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_bytes_unref)))));
}
pub fn glib_queueautoptr_cleanup_GBytes(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_bytes_unref)))));
}
pub const GChecksum_autoptr = ?*GChecksum;
pub const GChecksum_listautoptr = [*c]GList;
pub const GChecksum_slistautoptr = [*c]GSList;
pub const GChecksum_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GChecksum(_ptr: ?*GChecksum) void {
    if (_ptr != null) g_checksum_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GChecksum(_ptr: [*c](?*GChecksum)) void {
    glib_autoptr_clear_GChecksum(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GChecksum(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_checksum_free)))));
}
pub fn glib_slistautoptr_cleanup_GChecksum(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_checksum_free)))));
}
pub fn glib_queueautoptr_cleanup_GChecksum(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_checksum_free)))));
}
pub const GDateTime_autoptr = ?*GDateTime;
pub const GDateTime_listautoptr = [*c]GList;
pub const GDateTime_slistautoptr = [*c]GSList;
pub const GDateTime_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDateTime(_ptr: ?*GDateTime) void {
    if (_ptr != null) g_date_time_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GDateTime(_ptr: [*c](?*GDateTime)) void {
    glib_autoptr_clear_GDateTime(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDateTime(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_date_time_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDateTime(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_date_time_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDateTime(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_date_time_unref)))));
}
pub const GDir_autoptr = ?*GDir;
pub const GDir_listautoptr = [*c]GList;
pub const GDir_slistautoptr = [*c]GSList;
pub const GDir_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDir(_ptr: ?*GDir) void {
    if (_ptr != null) g_dir_close.?(_ptr);
}
pub fn glib_autoptr_cleanup_GDir(_ptr: [*c](?*GDir)) void {
    glib_autoptr_clear_GDir(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDir(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_dir_close)))));
}
pub fn glib_slistautoptr_cleanup_GDir(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_dir_close)))));
}
pub fn glib_queueautoptr_cleanup_GDir(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_dir_close)))));
}
pub const GError_autoptr = [*c]GError;
pub const GError_listautoptr = [*c]GList;
pub const GError_slistautoptr = [*c]GSList;
pub const GError_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GError(_ptr: [*c]GError) void {
    if (_ptr != null) g_error_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GError(_ptr: [*c]([*c]GError)) void {
    glib_autoptr_clear_GError(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GError(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_error_free)))));
}
pub fn glib_slistautoptr_cleanup_GError(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_error_free)))));
}
pub fn glib_queueautoptr_cleanup_GError(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_error_free)))));
}
pub const GHashTable_autoptr = ?*GHashTable;
pub const GHashTable_listautoptr = [*c]GList;
pub const GHashTable_slistautoptr = [*c]GSList;
pub const GHashTable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GHashTable(_ptr: ?*GHashTable) void {
    if (_ptr != null) g_hash_table_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GHashTable(_ptr: [*c](?*GHashTable)) void {
    glib_autoptr_clear_GHashTable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GHashTable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_hash_table_unref)))));
}
pub fn glib_slistautoptr_cleanup_GHashTable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_hash_table_unref)))));
}
pub fn glib_queueautoptr_cleanup_GHashTable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_hash_table_unref)))));
}
pub const GHmac_autoptr = ?*GHmac;
pub const GHmac_listautoptr = [*c]GList;
pub const GHmac_slistautoptr = [*c]GSList;
pub const GHmac_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GHmac(_ptr: ?*GHmac) void {
    if (_ptr != null) g_hmac_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GHmac(_ptr: [*c](?*GHmac)) void {
    glib_autoptr_clear_GHmac(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GHmac(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_hmac_unref)))));
}
pub fn glib_slistautoptr_cleanup_GHmac(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_hmac_unref)))));
}
pub fn glib_queueautoptr_cleanup_GHmac(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_hmac_unref)))));
}
pub const GIOChannel_autoptr = ?*GIOChannel;
pub const GIOChannel_listautoptr = [*c]GList;
pub const GIOChannel_slistautoptr = [*c]GSList;
pub const GIOChannel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GIOChannel(_ptr: ?*GIOChannel) void {
    if (_ptr != null) g_io_channel_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GIOChannel(_ptr: [*c](?*GIOChannel)) void {
    glib_autoptr_clear_GIOChannel(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GIOChannel(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_io_channel_unref)))));
}
pub fn glib_slistautoptr_cleanup_GIOChannel(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_io_channel_unref)))));
}
pub fn glib_queueautoptr_cleanup_GIOChannel(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_io_channel_unref)))));
}
pub const GKeyFile_autoptr = ?*GKeyFile;
pub const GKeyFile_listautoptr = [*c]GList;
pub const GKeyFile_slistautoptr = [*c]GSList;
pub const GKeyFile_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GKeyFile(_ptr: ?*GKeyFile) void {
    if (_ptr != null) g_key_file_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GKeyFile(_ptr: [*c](?*GKeyFile)) void {
    glib_autoptr_clear_GKeyFile(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GKeyFile(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_key_file_unref)))));
}
pub fn glib_slistautoptr_cleanup_GKeyFile(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_key_file_unref)))));
}
pub fn glib_queueautoptr_cleanup_GKeyFile(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_key_file_unref)))));
}
pub const GList_autoptr = [*c]GList;
pub const GList_listautoptr = [*c]GList;
pub const GList_slistautoptr = [*c]GSList;
pub const GList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GList(_ptr: [*c]GList) void {
    if (_ptr != null) g_list_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GList(_ptr: [*c]([*c]GList)) void {
    glib_autoptr_clear_GList(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GList(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_list_free)))));
}
pub fn glib_slistautoptr_cleanup_GList(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_list_free)))));
}
pub fn glib_queueautoptr_cleanup_GList(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_list_free)))));
}
pub const GArray_autoptr = [*c]GArray;
pub const GArray_listautoptr = [*c]GList;
pub const GArray_slistautoptr = [*c]GSList;
pub const GArray_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GArray(_ptr: [*c]GArray) void {
    if (_ptr != null) g_array_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GArray(_ptr: [*c]([*c]GArray)) void {
    glib_autoptr_clear_GArray(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GArray(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_array_unref)))));
}
pub fn glib_slistautoptr_cleanup_GArray(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_array_unref)))));
}
pub fn glib_queueautoptr_cleanup_GArray(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_array_unref)))));
}
pub const GPtrArray_autoptr = [*c]GPtrArray;
pub const GPtrArray_listautoptr = [*c]GList;
pub const GPtrArray_slistautoptr = [*c]GSList;
pub const GPtrArray_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPtrArray(_ptr: [*c]GPtrArray) void {
    if (_ptr != null) g_ptr_array_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GPtrArray(_ptr: [*c]([*c]GPtrArray)) void {
    glib_autoptr_clear_GPtrArray(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GPtrArray(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_ptr_array_unref)))));
}
pub fn glib_slistautoptr_cleanup_GPtrArray(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_ptr_array_unref)))));
}
pub fn glib_queueautoptr_cleanup_GPtrArray(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_ptr_array_unref)))));
}
pub const GByteArray_autoptr = [*c]GByteArray;
pub const GByteArray_listautoptr = [*c]GList;
pub const GByteArray_slistautoptr = [*c]GSList;
pub const GByteArray_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GByteArray(_ptr: [*c]GByteArray) void {
    if (_ptr != null) g_byte_array_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GByteArray(_ptr: [*c]([*c]GByteArray)) void {
    glib_autoptr_clear_GByteArray(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GByteArray(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_byte_array_unref)))));
}
pub fn glib_slistautoptr_cleanup_GByteArray(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_byte_array_unref)))));
}
pub fn glib_queueautoptr_cleanup_GByteArray(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_byte_array_unref)))));
}
pub const GMainContext_autoptr = ?*GMainContext;
pub const GMainContext_listautoptr = [*c]GList;
pub const GMainContext_slistautoptr = [*c]GSList;
pub const GMainContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMainContext(_ptr: ?*GMainContext) void {
    if (_ptr != null) g_main_context_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GMainContext(_ptr: [*c](?*GMainContext)) void {
    glib_autoptr_clear_GMainContext(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMainContext(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_main_context_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMainContext(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_main_context_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMainContext(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_main_context_unref)))));
}
pub const GMainLoop_autoptr = ?*GMainLoop;
pub const GMainLoop_listautoptr = [*c]GList;
pub const GMainLoop_slistautoptr = [*c]GSList;
pub const GMainLoop_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMainLoop(_ptr: ?*GMainLoop) void {
    if (_ptr != null) g_main_loop_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GMainLoop(_ptr: [*c](?*GMainLoop)) void {
    glib_autoptr_clear_GMainLoop(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMainLoop(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_main_loop_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMainLoop(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_main_loop_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMainLoop(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_main_loop_unref)))));
}
pub const GSource_autoptr = [*c]GSource;
pub const GSource_listautoptr = [*c]GList;
pub const GSource_slistautoptr = [*c]GSList;
pub const GSource_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSource(_ptr: [*c]GSource) void {
    if (_ptr != null) g_source_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GSource(_ptr: [*c]([*c]GSource)) void {
    glib_autoptr_clear_GSource(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSource(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_source_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSource(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_source_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSource(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_source_unref)))));
}
pub const GMappedFile_autoptr = ?*GMappedFile;
pub const GMappedFile_listautoptr = [*c]GList;
pub const GMappedFile_slistautoptr = [*c]GSList;
pub const GMappedFile_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMappedFile(_ptr: ?*GMappedFile) void {
    if (_ptr != null) g_mapped_file_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GMappedFile(_ptr: [*c](?*GMappedFile)) void {
    glib_autoptr_clear_GMappedFile(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMappedFile(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_mapped_file_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMappedFile(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_mapped_file_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMappedFile(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_mapped_file_unref)))));
}
pub const GMarkupParseContext_autoptr = ?*GMarkupParseContext;
pub const GMarkupParseContext_listautoptr = [*c]GList;
pub const GMarkupParseContext_slistautoptr = [*c]GSList;
pub const GMarkupParseContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMarkupParseContext(_ptr: ?*GMarkupParseContext) void {
    if (_ptr != null) g_markup_parse_context_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GMarkupParseContext(_ptr: [*c](?*GMarkupParseContext)) void {
    glib_autoptr_clear_GMarkupParseContext(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMarkupParseContext(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_markup_parse_context_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMarkupParseContext(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_markup_parse_context_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMarkupParseContext(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_markup_parse_context_unref)))));
}
pub const GNode_autoptr = [*c]GNode;
pub const GNode_listautoptr = [*c]GList;
pub const GNode_slistautoptr = [*c]GSList;
pub const GNode_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GNode(_ptr: [*c]GNode) void {
    if (_ptr != null) g_node_destroy.?(_ptr);
}
pub fn glib_autoptr_cleanup_GNode(_ptr: [*c]([*c]GNode)) void {
    glib_autoptr_clear_GNode(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GNode(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_node_destroy)))));
}
pub fn glib_slistautoptr_cleanup_GNode(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_node_destroy)))));
}
pub fn glib_queueautoptr_cleanup_GNode(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_node_destroy)))));
}
pub const GOptionContext_autoptr = ?*GOptionContext;
pub const GOptionContext_listautoptr = [*c]GList;
pub const GOptionContext_slistautoptr = [*c]GSList;
pub const GOptionContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GOptionContext(_ptr: ?*GOptionContext) void {
    if (_ptr != null) g_option_context_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GOptionContext(_ptr: [*c](?*GOptionContext)) void {
    glib_autoptr_clear_GOptionContext(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GOptionContext(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_option_context_free)))));
}
pub fn glib_slistautoptr_cleanup_GOptionContext(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_option_context_free)))));
}
pub fn glib_queueautoptr_cleanup_GOptionContext(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_option_context_free)))));
}
pub const GOptionGroup_autoptr = ?*GOptionGroup;
pub const GOptionGroup_listautoptr = [*c]GList;
pub const GOptionGroup_slistautoptr = [*c]GSList;
pub const GOptionGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GOptionGroup(_ptr: ?*GOptionGroup) void {
    if (_ptr != null) g_option_group_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GOptionGroup(_ptr: [*c](?*GOptionGroup)) void {
    glib_autoptr_clear_GOptionGroup(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GOptionGroup(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_option_group_unref)))));
}
pub fn glib_slistautoptr_cleanup_GOptionGroup(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_option_group_unref)))));
}
pub fn glib_queueautoptr_cleanup_GOptionGroup(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_option_group_unref)))));
}
pub const GPatternSpec_autoptr = ?*GPatternSpec;
pub const GPatternSpec_listautoptr = [*c]GList;
pub const GPatternSpec_slistautoptr = [*c]GSList;
pub const GPatternSpec_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPatternSpec(_ptr: ?*GPatternSpec) void {
    if (_ptr != null) g_pattern_spec_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GPatternSpec(_ptr: [*c](?*GPatternSpec)) void {
    glib_autoptr_clear_GPatternSpec(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GPatternSpec(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_pattern_spec_free)))));
}
pub fn glib_slistautoptr_cleanup_GPatternSpec(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_pattern_spec_free)))));
}
pub fn glib_queueautoptr_cleanup_GPatternSpec(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_pattern_spec_free)))));
}
pub const GQueue_autoptr = [*c]GQueue;
pub const GQueue_listautoptr = [*c]GList;
pub const GQueue_slistautoptr = [*c]GSList;
pub const GQueue_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GQueue(_ptr: [*c]GQueue) void {
    if (_ptr != null) g_queue_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GQueue(_ptr: [*c]([*c]GQueue)) void {
    glib_autoptr_clear_GQueue(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GQueue(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_queue_free)))));
}
pub fn glib_slistautoptr_cleanup_GQueue(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_queue_free)))));
}
pub fn glib_queueautoptr_cleanup_GQueue(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_queue_free)))));
}
pub fn glib_auto_cleanup_GQueue(_ptr: [*c]GQueue) void {
    g_queue_clear.?(_ptr);
}
pub const GRand_autoptr = ?*GRand;
pub const GRand_listautoptr = [*c]GList;
pub const GRand_slistautoptr = [*c]GSList;
pub const GRand_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRand(_ptr: ?*GRand) void {
    if (_ptr != null) g_rand_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GRand(_ptr: [*c](?*GRand)) void {
    glib_autoptr_clear_GRand(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GRand(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_rand_free)))));
}
pub fn glib_slistautoptr_cleanup_GRand(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_rand_free)))));
}
pub fn glib_queueautoptr_cleanup_GRand(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_rand_free)))));
}
pub const GRegex_autoptr = ?*GRegex;
pub const GRegex_listautoptr = [*c]GList;
pub const GRegex_slistautoptr = [*c]GSList;
pub const GRegex_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRegex(_ptr: ?*GRegex) void {
    if (_ptr != null) g_regex_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GRegex(_ptr: [*c](?*GRegex)) void {
    glib_autoptr_clear_GRegex(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GRegex(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_regex_unref)))));
}
pub fn glib_slistautoptr_cleanup_GRegex(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_regex_unref)))));
}
pub fn glib_queueautoptr_cleanup_GRegex(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_regex_unref)))));
}
pub const GMatchInfo_autoptr = ?*GMatchInfo;
pub const GMatchInfo_listautoptr = [*c]GList;
pub const GMatchInfo_slistautoptr = [*c]GSList;
pub const GMatchInfo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMatchInfo(_ptr: ?*GMatchInfo) void {
    if (_ptr != null) g_match_info_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GMatchInfo(_ptr: [*c](?*GMatchInfo)) void {
    glib_autoptr_clear_GMatchInfo(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMatchInfo(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_match_info_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMatchInfo(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_match_info_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMatchInfo(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_match_info_unref)))));
}
pub const GScanner_autoptr = [*c]GScanner;
pub const GScanner_listautoptr = [*c]GList;
pub const GScanner_slistautoptr = [*c]GSList;
pub const GScanner_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GScanner(_ptr: [*c]GScanner) void {
    if (_ptr != null) g_scanner_destroy.?(_ptr);
}
pub fn glib_autoptr_cleanup_GScanner(_ptr: [*c]([*c]GScanner)) void {
    glib_autoptr_clear_GScanner(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GScanner(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_scanner_destroy)))));
}
pub fn glib_slistautoptr_cleanup_GScanner(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_scanner_destroy)))));
}
pub fn glib_queueautoptr_cleanup_GScanner(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_scanner_destroy)))));
}
pub const GSequence_autoptr = ?*GSequence;
pub const GSequence_listautoptr = [*c]GList;
pub const GSequence_slistautoptr = [*c]GSList;
pub const GSequence_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSequence(_ptr: ?*GSequence) void {
    if (_ptr != null) g_sequence_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GSequence(_ptr: [*c](?*GSequence)) void {
    glib_autoptr_clear_GSequence(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSequence(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_sequence_free)))));
}
pub fn glib_slistautoptr_cleanup_GSequence(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_sequence_free)))));
}
pub fn glib_queueautoptr_cleanup_GSequence(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_sequence_free)))));
}
pub const GSList_autoptr = [*c]GSList;
pub const GSList_listautoptr = [*c]GList;
pub const GSList_slistautoptr = [*c]GSList;
pub const GSList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSList(_ptr: [*c]GSList) void {
    if (_ptr != null) g_slist_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GSList(_ptr: [*c]([*c]GSList)) void {
    glib_autoptr_clear_GSList(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSList(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_slist_free)))));
}
pub fn glib_slistautoptr_cleanup_GSList(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_slist_free)))));
}
pub fn glib_queueautoptr_cleanup_GSList(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_slist_free)))));
}
pub const GString_autoptr = [*c]GString;
pub const GString_listautoptr = [*c]GList;
pub const GString_slistautoptr = [*c]GSList;
pub const GString_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GString(_ptr: [*c]GString) void {
    if (_ptr != null) g_autoptr_cleanup_gstring_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GString(_ptr: [*c]([*c]GString)) void {
    glib_autoptr_clear_GString(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GString(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_autoptr_cleanup_gstring_free)))));
}
pub fn glib_slistautoptr_cleanup_GString(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_autoptr_cleanup_gstring_free)))));
}
pub fn glib_queueautoptr_cleanup_GString(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_autoptr_cleanup_gstring_free)))));
}
pub const GStringChunk_autoptr = ?*GStringChunk;
pub const GStringChunk_listautoptr = [*c]GList;
pub const GStringChunk_slistautoptr = [*c]GSList;
pub const GStringChunk_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GStringChunk(_ptr: ?*GStringChunk) void {
    if (_ptr != null) g_string_chunk_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GStringChunk(_ptr: [*c](?*GStringChunk)) void {
    glib_autoptr_clear_GStringChunk(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GStringChunk(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_string_chunk_free)))));
}
pub fn glib_slistautoptr_cleanup_GStringChunk(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_string_chunk_free)))));
}
pub fn glib_queueautoptr_cleanup_GStringChunk(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_string_chunk_free)))));
}
pub const GThread_autoptr = [*c]GThread;
pub const GThread_listautoptr = [*c]GList;
pub const GThread_slistautoptr = [*c]GSList;
pub const GThread_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GThread(_ptr: [*c]GThread) void {
    if (_ptr != null) g_thread_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GThread(_ptr: [*c]([*c]GThread)) void {
    glib_autoptr_clear_GThread(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GThread(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_thread_unref)))));
}
pub fn glib_slistautoptr_cleanup_GThread(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_thread_unref)))));
}
pub fn glib_queueautoptr_cleanup_GThread(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_thread_unref)))));
}
pub fn glib_auto_cleanup_GMutex(_ptr: [*c]GMutex) void {
    g_mutex_clear.?(_ptr);
}
pub const GMutexLocker_autoptr = ?*GMutexLocker;
pub const GMutexLocker_listautoptr = [*c]GList;
pub const GMutexLocker_slistautoptr = [*c]GSList;
pub const GMutexLocker_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMutexLocker(_ptr: ?*GMutexLocker) void {
    if (_ptr != null) g_mutex_locker_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GMutexLocker(_ptr: [*c](?*GMutexLocker)) void {
    glib_autoptr_clear_GMutexLocker(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMutexLocker(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_mutex_locker_free)))));
}
pub fn glib_slistautoptr_cleanup_GMutexLocker(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_mutex_locker_free)))));
}
pub fn glib_queueautoptr_cleanup_GMutexLocker(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_mutex_locker_free)))));
}
pub const GRecMutexLocker_autoptr = ?*GRecMutexLocker;
pub const GRecMutexLocker_listautoptr = [*c]GList;
pub const GRecMutexLocker_slistautoptr = [*c]GSList;
pub const GRecMutexLocker_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRecMutexLocker(_ptr: ?*GRecMutexLocker) void {
    if (_ptr != null) g_rec_mutex_locker_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GRecMutexLocker(_ptr: [*c](?*GRecMutexLocker)) void {
    glib_autoptr_clear_GRecMutexLocker(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GRecMutexLocker(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_rec_mutex_locker_free)))));
}
pub fn glib_slistautoptr_cleanup_GRecMutexLocker(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_rec_mutex_locker_free)))));
}
pub fn glib_queueautoptr_cleanup_GRecMutexLocker(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_rec_mutex_locker_free)))));
}
pub const GRWLockWriterLocker_autoptr = ?*GRWLockWriterLocker;
pub const GRWLockWriterLocker_listautoptr = [*c]GList;
pub const GRWLockWriterLocker_slistautoptr = [*c]GSList;
pub const GRWLockWriterLocker_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRWLockWriterLocker(_ptr: ?*GRWLockWriterLocker) void {
    if (_ptr != null) g_rw_lock_writer_locker_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GRWLockWriterLocker(_ptr: [*c](?*GRWLockWriterLocker)) void {
    glib_autoptr_clear_GRWLockWriterLocker(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GRWLockWriterLocker(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_rw_lock_writer_locker_free)))));
}
pub fn glib_slistautoptr_cleanup_GRWLockWriterLocker(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_rw_lock_writer_locker_free)))));
}
pub fn glib_queueautoptr_cleanup_GRWLockWriterLocker(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_rw_lock_writer_locker_free)))));
}
pub const GRWLockReaderLocker_autoptr = ?*GRWLockReaderLocker;
pub const GRWLockReaderLocker_listautoptr = [*c]GList;
pub const GRWLockReaderLocker_slistautoptr = [*c]GSList;
pub const GRWLockReaderLocker_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRWLockReaderLocker(_ptr: ?*GRWLockReaderLocker) void {
    if (_ptr != null) g_rw_lock_reader_locker_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GRWLockReaderLocker(_ptr: [*c](?*GRWLockReaderLocker)) void {
    glib_autoptr_clear_GRWLockReaderLocker(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GRWLockReaderLocker(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_rw_lock_reader_locker_free)))));
}
pub fn glib_slistautoptr_cleanup_GRWLockReaderLocker(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_rw_lock_reader_locker_free)))));
}
pub fn glib_queueautoptr_cleanup_GRWLockReaderLocker(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_rw_lock_reader_locker_free)))));
}
pub fn glib_auto_cleanup_GCond(_ptr: [*c]GCond) void {
    g_cond_clear.?(_ptr);
}
pub const GTimer_autoptr = ?*GTimer;
pub const GTimer_listautoptr = [*c]GList;
pub const GTimer_slistautoptr = [*c]GSList;
pub const GTimer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTimer(_ptr: ?*GTimer) void {
    if (_ptr != null) g_timer_destroy.?(_ptr);
}
pub fn glib_autoptr_cleanup_GTimer(_ptr: [*c](?*GTimer)) void {
    glib_autoptr_clear_GTimer(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTimer(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_timer_destroy)))));
}
pub fn glib_slistautoptr_cleanup_GTimer(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_timer_destroy)))));
}
pub fn glib_queueautoptr_cleanup_GTimer(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_timer_destroy)))));
}
pub const GTimeZone_autoptr = ?*GTimeZone;
pub const GTimeZone_listautoptr = [*c]GList;
pub const GTimeZone_slistautoptr = [*c]GSList;
pub const GTimeZone_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTimeZone(_ptr: ?*GTimeZone) void {
    if (_ptr != null) g_time_zone_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GTimeZone(_ptr: [*c](?*GTimeZone)) void {
    glib_autoptr_clear_GTimeZone(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTimeZone(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_time_zone_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTimeZone(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_time_zone_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTimeZone(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_time_zone_unref)))));
}
pub const GTree_autoptr = ?*GTree;
pub const GTree_listautoptr = [*c]GList;
pub const GTree_slistautoptr = [*c]GSList;
pub const GTree_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTree(_ptr: ?*GTree) void {
    if (_ptr != null) g_tree_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GTree(_ptr: [*c](?*GTree)) void {
    glib_autoptr_clear_GTree(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTree(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_tree_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTree(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_tree_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTree(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_tree_unref)))));
}
pub const GVariant_autoptr = ?*GVariant;
pub const GVariant_listautoptr = [*c]GList;
pub const GVariant_slistautoptr = [*c]GSList;
pub const GVariant_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariant(_ptr: ?*GVariant) void {
    if (_ptr != null) g_variant_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GVariant(_ptr: [*c](?*GVariant)) void {
    glib_autoptr_clear_GVariant(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GVariant(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_unref)))));
}
pub fn glib_slistautoptr_cleanup_GVariant(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_unref)))));
}
pub fn glib_queueautoptr_cleanup_GVariant(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_unref)))));
}
pub const GVariantBuilder_autoptr = [*c]GVariantBuilder;
pub const GVariantBuilder_listautoptr = [*c]GList;
pub const GVariantBuilder_slistautoptr = [*c]GSList;
pub const GVariantBuilder_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariantBuilder(_ptr: [*c]GVariantBuilder) void {
    if (_ptr != null) g_variant_builder_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GVariantBuilder(_ptr: [*c]([*c]GVariantBuilder)) void {
    glib_autoptr_clear_GVariantBuilder(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GVariantBuilder(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_builder_unref)))));
}
pub fn glib_slistautoptr_cleanup_GVariantBuilder(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_builder_unref)))));
}
pub fn glib_queueautoptr_cleanup_GVariantBuilder(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_builder_unref)))));
}
pub fn glib_auto_cleanup_GVariantBuilder(_ptr: [*c]GVariantBuilder) void {
    g_variant_builder_clear.?(_ptr);
}
pub const GVariantIter_autoptr = [*c]GVariantIter;
pub const GVariantIter_listautoptr = [*c]GList;
pub const GVariantIter_slistautoptr = [*c]GSList;
pub const GVariantIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariantIter(_ptr: [*c]GVariantIter) void {
    if (_ptr != null) g_variant_iter_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GVariantIter(_ptr: [*c]([*c]GVariantIter)) void {
    glib_autoptr_clear_GVariantIter(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GVariantIter(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_iter_free)))));
}
pub fn glib_slistautoptr_cleanup_GVariantIter(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_iter_free)))));
}
pub fn glib_queueautoptr_cleanup_GVariantIter(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_iter_free)))));
}
pub const GVariantDict_autoptr = [*c]GVariantDict;
pub const GVariantDict_listautoptr = [*c]GList;
pub const GVariantDict_slistautoptr = [*c]GSList;
pub const GVariantDict_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariantDict(_ptr: [*c]GVariantDict) void {
    if (_ptr != null) g_variant_dict_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GVariantDict(_ptr: [*c]([*c]GVariantDict)) void {
    glib_autoptr_clear_GVariantDict(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GVariantDict(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_dict_unref)))));
}
pub fn glib_slistautoptr_cleanup_GVariantDict(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_dict_unref)))));
}
pub fn glib_queueautoptr_cleanup_GVariantDict(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_dict_unref)))));
}
pub fn glib_auto_cleanup_GVariantDict(_ptr: [*c]GVariantDict) void {
    g_variant_dict_clear.?(_ptr);
}
pub const GVariantType_autoptr = ?*GVariantType;
pub const GVariantType_listautoptr = [*c]GList;
pub const GVariantType_slistautoptr = [*c]GSList;
pub const GVariantType_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVariantType(_ptr: ?*GVariantType) void {
    if (_ptr != null) g_variant_type_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GVariantType(_ptr: [*c](?*GVariantType)) void {
    glib_autoptr_clear_GVariantType(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GVariantType(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_type_free)))));
}
pub fn glib_slistautoptr_cleanup_GVariantType(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_type_free)))));
}
pub fn glib_queueautoptr_cleanup_GVariantType(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_variant_type_free)))));
}
pub fn glib_auto_cleanup_GStrv(_ptr: [*c]GStrv) void {
    if (_ptr.?.* != @ptrCast(GStrv, @alignCast(@alignOf([*c]gchar), (?*c_void)(0)))) g_strfreev.?(_ptr.?.*);
}
pub const GRefString_autoptr = [*c]GRefString;
pub const GRefString_listautoptr = [*c]GList;
pub const GRefString_slistautoptr = [*c]GSList;
pub const GRefString_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRefString(_ptr: [*c]GRefString) void {
    if (_ptr != null) g_ref_string_release.?(_ptr);
}
pub fn glib_autoptr_cleanup_GRefString(_ptr: [*c]([*c]GRefString)) void {
    glib_autoptr_clear_GRefString(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GRefString(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_ref_string_release)))));
}
pub fn glib_slistautoptr_cleanup_GRefString(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_ref_string_release)))));
}
pub fn glib_queueautoptr_cleanup_GRefString(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_ref_string_release)))));
}
pub const GType = gsize;
pub const struct__GValue = extern struct {
    g_type: GType,
    data: [2]extern union {
        v_int: gint,
        v_uint: guint,
        v_long: glong,
        v_ulong: gulong,
        v_int64: gint64,
        v_uint64: guint64,
        v_float: gfloat,
        v_double: gdouble,
        v_pointer: gpointer,
    },
};
pub const GValue = struct__GValue;
pub const union__GTypeCValue = @OpaqueType();
pub const GTypeCValue = union__GTypeCValue;
pub const struct__GTypePlugin = @OpaqueType();
pub const GTypePlugin = struct__GTypePlugin;
pub const struct__GTypeClass = extern struct {
    g_type: GType,
};
pub const GTypeClass = struct__GTypeClass;
pub const struct__GTypeInterface = extern struct {
    g_type: GType,
    g_instance_type: GType,
};
pub const GTypeInterface = struct__GTypeInterface;
pub const struct__GTypeInstance = extern struct {
    g_class: [*c]GTypeClass,
};
pub const GTypeInstance = struct__GTypeInstance;
pub const GBaseInitFunc = ?extern fn (gpointer) void;
pub const GBaseFinalizeFunc = ?extern fn (gpointer) void;
pub const GClassInitFunc = ?extern fn (gpointer, gpointer) void;
pub const GClassFinalizeFunc = ?extern fn (gpointer, gpointer) void;
pub const GInstanceInitFunc = ?extern fn ([*c]GTypeInstance, gpointer) void;
pub const struct__GTypeValueTable = extern struct {
    value_init: ?extern fn ([*c]GValue) void,
    value_free: ?extern fn ([*c]GValue) void,
    value_copy: ?extern fn ([*c]const GValue, [*c]GValue) void,
    value_peek_pointer: ?extern fn ([*c]const GValue) gpointer,
    collect_format: [*c]const gchar,
    collect_value: ?extern fn ([*c]GValue, guint, ?*GTypeCValue, guint) [*c]gchar,
    lcopy_format: [*c]const gchar,
    lcopy_value: ?extern fn ([*c]const GValue, guint, ?*GTypeCValue, guint) [*c]gchar,
};
pub const GTypeValueTable = struct__GTypeValueTable;
pub const struct__GTypeInfo = extern struct {
    class_size: guint16,
    base_init: GBaseInitFunc,
    base_finalize: GBaseFinalizeFunc,
    class_init: GClassInitFunc,
    class_finalize: GClassFinalizeFunc,
    class_data: gconstpointer,
    instance_size: guint16,
    n_preallocs: guint16,
    instance_init: GInstanceInitFunc,
    value_table: [*c]const GTypeValueTable,
};
pub const GTypeInfo = struct__GTypeInfo;
pub const G_TYPE_FLAG_CLASSED = 1;
pub const G_TYPE_FLAG_INSTANTIATABLE = 2;
pub const G_TYPE_FLAG_DERIVABLE = 4;
pub const G_TYPE_FLAG_DEEP_DERIVABLE = 8;
pub const GTypeFundamentalFlags = extern enum {
    G_TYPE_FLAG_CLASSED = 1,
    G_TYPE_FLAG_INSTANTIATABLE = 2,
    G_TYPE_FLAG_DERIVABLE = 4,
    G_TYPE_FLAG_DEEP_DERIVABLE = 8,
};
pub const struct__GTypeFundamentalInfo = extern struct {
    type_flags: GTypeFundamentalFlags,
};
pub const GTypeFundamentalInfo = struct__GTypeFundamentalInfo;
pub const GInterfaceInitFunc = ?extern fn (gpointer, gpointer) void;
pub const GInterfaceFinalizeFunc = ?extern fn (gpointer, gpointer) void;
pub const struct__GInterfaceInfo = extern struct {
    interface_init: GInterfaceInitFunc,
    interface_finalize: GInterfaceFinalizeFunc,
    interface_data: gpointer,
};
pub const GInterfaceInfo = struct__GInterfaceInfo;
pub const struct__GTypeQuery = extern struct {
    type: GType,
    type_name: [*c]const gchar,
    class_size: guint,
    instance_size: guint,
};
pub const GTypeQuery = struct__GTypeQuery;
pub const G_TYPE_DEBUG_NONE = 0;
pub const G_TYPE_DEBUG_OBJECTS = 1;
pub const G_TYPE_DEBUG_SIGNALS = 2;
pub const G_TYPE_DEBUG_INSTANCE_COUNT = 4;
pub const G_TYPE_DEBUG_MASK = 7;
pub const GTypeDebugFlags = extern enum {
    G_TYPE_DEBUG_NONE = 0,
    G_TYPE_DEBUG_OBJECTS = 1,
    G_TYPE_DEBUG_SIGNALS = 2,
    G_TYPE_DEBUG_INSTANCE_COUNT = 4,
    G_TYPE_DEBUG_MASK = 7,
};
pub extern fn g_type_init() void;
pub extern fn g_type_init_with_debug_flags(debug_flags: GTypeDebugFlags) void;
pub extern fn g_type_name(type_0: GType) [*c]const gchar;
pub extern fn g_type_qname(type_0: GType) GQuark;
pub extern fn g_type_from_name(name: [*c]const gchar) GType;
pub extern fn g_type_parent(type_0: GType) GType;
pub extern fn g_type_depth(type_0: GType) guint;
pub extern fn g_type_next_base(leaf_type: GType, root_type: GType) GType;
pub extern fn g_type_is_a(type_0: GType, is_a_type: GType) gboolean;
pub extern fn g_type_class_ref(type_0: GType) gpointer;
pub extern fn g_type_class_peek(type_0: GType) gpointer;
pub extern fn g_type_class_peek_static(type_0: GType) gpointer;
pub extern fn g_type_class_unref(g_class: gpointer) void;
pub extern fn g_type_class_peek_parent(g_class: gpointer) gpointer;
pub extern fn g_type_interface_peek(instance_class: gpointer, iface_type: GType) gpointer;
pub extern fn g_type_interface_peek_parent(g_iface: gpointer) gpointer;
pub extern fn g_type_default_interface_ref(g_type: GType) gpointer;
pub extern fn g_type_default_interface_peek(g_type: GType) gpointer;
pub extern fn g_type_default_interface_unref(g_iface: gpointer) void;
pub extern fn g_type_children(type_0: GType, n_children: [*c]guint) [*c]GType;
pub extern fn g_type_interfaces(type_0: GType, n_interfaces: [*c]guint) [*c]GType;
pub extern fn g_type_set_qdata(type_0: GType, quark: GQuark, data: gpointer) void;
pub extern fn g_type_get_qdata(type_0: GType, quark: GQuark) gpointer;
pub extern fn g_type_query(type_0: GType, query: [*c]GTypeQuery) void;
pub extern fn g_type_get_instance_count(type_0: GType) c_int;
pub const GTypeClassCacheFunc = ?extern fn (gpointer, [*c]GTypeClass) gboolean;
pub const GTypeInterfaceCheckFunc = ?extern fn (gpointer, gpointer) void;
pub const G_TYPE_FLAG_ABSTRACT = 16;
pub const G_TYPE_FLAG_VALUE_ABSTRACT = 32;
pub const GTypeFlags = extern enum {
    G_TYPE_FLAG_ABSTRACT = 16,
    G_TYPE_FLAG_VALUE_ABSTRACT = 32,
};
pub extern fn g_type_register_static(parent_type: GType, type_name: [*c]const gchar, info: [*c]const GTypeInfo, flags: GTypeFlags) GType;
pub extern fn g_type_register_static_simple(parent_type: GType, type_name: [*c]const gchar, class_size: guint, class_init: GClassInitFunc, instance_size: guint, instance_init: GInstanceInitFunc, flags: GTypeFlags) GType;
pub extern fn g_type_register_dynamic(parent_type: GType, type_name: [*c]const gchar, plugin: ?*GTypePlugin, flags: GTypeFlags) GType;
pub extern fn g_type_register_fundamental(type_id: GType, type_name: [*c]const gchar, info: [*c]const GTypeInfo, finfo: [*c]const GTypeFundamentalInfo, flags: GTypeFlags) GType;
pub extern fn g_type_add_interface_static(instance_type: GType, interface_type: GType, info: [*c]const GInterfaceInfo) void;
pub extern fn g_type_add_interface_dynamic(instance_type: GType, interface_type: GType, plugin: ?*GTypePlugin) void;
pub extern fn g_type_interface_add_prerequisite(interface_type: GType, prerequisite_type: GType) void;
pub extern fn g_type_interface_prerequisites(interface_type: GType, n_prerequisites: [*c]guint) [*c]GType;
pub extern fn g_type_class_add_private(g_class: gpointer, private_size: gsize) void;
pub extern fn g_type_add_instance_private(class_type: GType, private_size: gsize) gint;
pub extern fn g_type_instance_get_private(instance: [*c]GTypeInstance, private_type: GType) gpointer;
pub extern fn g_type_class_adjust_private_offset(g_class: gpointer, private_size_or_offset: [*c]gint) void;
pub extern fn g_type_add_class_private(class_type: GType, private_size: gsize) void;
pub extern fn g_type_class_get_private(klass: [*c]GTypeClass, private_type: GType) gpointer;
pub extern fn g_type_class_get_instance_private_offset(g_class: gpointer) gint;
pub extern fn g_type_ensure(type_0: GType) void;
pub extern fn g_type_get_type_registration_serial() guint;
pub extern fn g_type_get_plugin(type_0: GType) ?*GTypePlugin;
pub extern fn g_type_interface_get_plugin(instance_type: GType, interface_type: GType) ?*GTypePlugin;
pub extern fn g_type_fundamental_next() GType;
pub extern fn g_type_fundamental(type_id: GType) GType;
pub extern fn g_type_create_instance(type_0: GType) [*c]GTypeInstance;
pub extern fn g_type_free_instance(instance: [*c]GTypeInstance) void;
pub extern fn g_type_add_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc) void;
pub extern fn g_type_remove_class_cache_func(cache_data: gpointer, cache_func: GTypeClassCacheFunc) void;
pub extern fn g_type_class_unref_uncached(g_class: gpointer) void;
pub extern fn g_type_add_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc) void;
pub extern fn g_type_remove_interface_check(check_data: gpointer, check_func: GTypeInterfaceCheckFunc) void;
pub extern fn g_type_value_table_peek(type_0: GType) [*c]GTypeValueTable;
pub extern fn g_type_check_instance(instance: [*c]GTypeInstance) gboolean;
pub extern fn g_type_check_instance_cast(instance: [*c]GTypeInstance, iface_type: GType) [*c]GTypeInstance;
pub extern fn g_type_check_instance_is_a(instance: [*c]GTypeInstance, iface_type: GType) gboolean;
pub extern fn g_type_check_instance_is_fundamentally_a(instance: [*c]GTypeInstance, fundamental_type: GType) gboolean;
pub extern fn g_type_check_class_cast(g_class: [*c]GTypeClass, is_a_type: GType) [*c]GTypeClass;
pub extern fn g_type_check_class_is_a(g_class: [*c]GTypeClass, is_a_type: GType) gboolean;
pub extern fn g_type_check_is_value_type(type_0: GType) gboolean;
pub extern fn g_type_check_value(value: [*c]const GValue) gboolean;
pub extern fn g_type_check_value_holds(value: [*c]const GValue, type_0: GType) gboolean;
pub extern fn g_type_test_flags(type_0: GType, flags: guint) gboolean;
pub extern fn g_type_name_from_instance(instance: [*c]GTypeInstance) [*c]const gchar;
pub extern fn g_type_name_from_class(g_class: [*c]GTypeClass) [*c]const gchar;
pub const GValueTransform = ?extern fn ([*c]const GValue, [*c]GValue) void;
pub extern fn g_value_init(value: [*c]GValue, g_type: GType) [*c]GValue;
pub extern fn g_value_copy(src_value: [*c]const GValue, dest_value: [*c]GValue) void;
pub extern fn g_value_reset(value: [*c]GValue) [*c]GValue;
pub extern fn g_value_unset(value: [*c]GValue) void;
pub extern fn g_value_set_instance(value: [*c]GValue, instance: gpointer) void;
pub extern fn g_value_init_from_instance(value: [*c]GValue, instance: gpointer) void;
pub extern fn g_value_fits_pointer(value: [*c]const GValue) gboolean;
pub extern fn g_value_peek_pointer(value: [*c]const GValue) gpointer;
pub extern fn g_value_type_compatible(src_type: GType, dest_type: GType) gboolean;
pub extern fn g_value_type_transformable(src_type: GType, dest_type: GType) gboolean;
pub extern fn g_value_transform(src_value: [*c]const GValue, dest_value: [*c]GValue) gboolean;
pub extern fn g_value_register_transform_func(src_type: GType, dest_type: GType, transform_func: GValueTransform) void;
pub const G_PARAM_READABLE = 1;
pub const G_PARAM_WRITABLE = 2;
pub const G_PARAM_READWRITE = 3;
pub const G_PARAM_CONSTRUCT = 4;
pub const G_PARAM_CONSTRUCT_ONLY = 8;
pub const G_PARAM_LAX_VALIDATION = 16;
pub const G_PARAM_STATIC_NAME = 32;
pub const G_PARAM_PRIVATE = 32;
pub const G_PARAM_STATIC_NICK = 64;
pub const G_PARAM_STATIC_BLURB = 128;
pub const G_PARAM_EXPLICIT_NOTIFY = 1073741824;
pub const G_PARAM_DEPRECATED = -2147483648;
pub const GParamFlags = extern enum {
    G_PARAM_READABLE = 1,
    G_PARAM_WRITABLE = 2,
    G_PARAM_READWRITE = 3,
    G_PARAM_CONSTRUCT = 4,
    G_PARAM_CONSTRUCT_ONLY = 8,
    G_PARAM_LAX_VALIDATION = 16,
    G_PARAM_STATIC_NAME = 32,
    G_PARAM_PRIVATE = 32,
    G_PARAM_STATIC_NICK = 64,
    G_PARAM_STATIC_BLURB = 128,
    G_PARAM_EXPLICIT_NOTIFY = 1073741824,
    G_PARAM_DEPRECATED = -2147483648,
};
pub const struct__GParamSpec = extern struct {
    g_type_instance: GTypeInstance,
    name: [*c]const gchar,
    flags: GParamFlags,
    value_type: GType,
    owner_type: GType,
    _nick: [*c]gchar,
    _blurb: [*c]gchar,
    qdata: ?*GData,
    ref_count: guint,
    param_id: guint,
};
pub const GParamSpec = struct__GParamSpec;
pub const struct__GParamSpecClass = extern struct {
    g_type_class: GTypeClass,
    value_type: GType,
    finalize: ?extern fn ([*c]GParamSpec) void,
    value_set_default: ?extern fn ([*c]GParamSpec, [*c]GValue) void,
    value_validate: ?extern fn ([*c]GParamSpec, [*c]GValue) gboolean,
    values_cmp: ?extern fn ([*c]GParamSpec, [*c]const GValue, [*c]const GValue) gint,
    dummy: [4]gpointer,
};
pub const GParamSpecClass = struct__GParamSpecClass;
pub const struct__GParameter = extern struct {
    name: [*c]const gchar,
    value: GValue,
};
pub const GParameter = struct__GParameter;
pub const struct__GParamSpecPool = @OpaqueType();
pub const GParamSpecPool = struct__GParamSpecPool;
pub extern fn g_param_spec_ref(pspec: [*c]GParamSpec) [*c]GParamSpec;
pub extern fn g_param_spec_unref(pspec: [*c]GParamSpec) void;
pub extern fn g_param_spec_sink(pspec: [*c]GParamSpec) void;
pub extern fn g_param_spec_ref_sink(pspec: [*c]GParamSpec) [*c]GParamSpec;
pub extern fn g_param_spec_get_qdata(pspec: [*c]GParamSpec, quark: GQuark) gpointer;
pub extern fn g_param_spec_set_qdata(pspec: [*c]GParamSpec, quark: GQuark, data: gpointer) void;
pub extern fn g_param_spec_set_qdata_full(pspec: [*c]GParamSpec, quark: GQuark, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn g_param_spec_steal_qdata(pspec: [*c]GParamSpec, quark: GQuark) gpointer;
pub extern fn g_param_spec_get_redirect_target(pspec: [*c]GParamSpec) [*c]GParamSpec;
pub extern fn g_param_value_set_default(pspec: [*c]GParamSpec, value: [*c]GValue) void;
pub extern fn g_param_value_defaults(pspec: [*c]GParamSpec, value: [*c]GValue) gboolean;
pub extern fn g_param_value_validate(pspec: [*c]GParamSpec, value: [*c]GValue) gboolean;
pub extern fn g_param_value_convert(pspec: [*c]GParamSpec, src_value: [*c]const GValue, dest_value: [*c]GValue, strict_validation: gboolean) gboolean;
pub extern fn g_param_values_cmp(pspec: [*c]GParamSpec, value1: [*c]const GValue, value2: [*c]const GValue) gint;
pub extern fn g_param_spec_get_name(pspec: [*c]GParamSpec) [*c]const gchar;
pub extern fn g_param_spec_get_nick(pspec: [*c]GParamSpec) [*c]const gchar;
pub extern fn g_param_spec_get_blurb(pspec: [*c]GParamSpec) [*c]const gchar;
pub extern fn g_value_set_param(value: [*c]GValue, param: [*c]GParamSpec) void;
pub extern fn g_value_get_param(value: [*c]const GValue) [*c]GParamSpec;
pub extern fn g_value_dup_param(value: [*c]const GValue) [*c]GParamSpec;
pub extern fn g_value_take_param(value: [*c]GValue, param: [*c]GParamSpec) void;
pub extern fn g_value_set_param_take_ownership(value: [*c]GValue, param: [*c]GParamSpec) void;
pub extern fn g_param_spec_get_default_value(pspec: [*c]GParamSpec) [*c]const GValue;
pub extern fn g_param_spec_get_name_quark(pspec: [*c]GParamSpec) GQuark;
pub const struct__GParamSpecTypeInfo = extern struct {
    instance_size: guint16,
    n_preallocs: guint16,
    instance_init: ?extern fn ([*c]GParamSpec) void,
    value_type: GType,
    finalize: ?extern fn ([*c]GParamSpec) void,
    value_set_default: ?extern fn ([*c]GParamSpec, [*c]GValue) void,
    value_validate: ?extern fn ([*c]GParamSpec, [*c]GValue) gboolean,
    values_cmp: ?extern fn ([*c]GParamSpec, [*c]const GValue, [*c]const GValue) gint,
};
pub const GParamSpecTypeInfo = struct__GParamSpecTypeInfo;
pub extern fn g_param_type_register_static(name: [*c]const gchar, pspec_info: [*c]const GParamSpecTypeInfo) GType;
pub extern fn _g_param_type_register_static_constant(name: [*c]const gchar, pspec_info: [*c]const GParamSpecTypeInfo, opt_type: GType) GType;
pub extern fn g_param_spec_internal(param_type: GType, name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, flags: GParamFlags) gpointer;
pub extern fn g_param_spec_pool_new(type_prefixing: gboolean) ?*GParamSpecPool;
pub extern fn g_param_spec_pool_insert(pool: ?*GParamSpecPool, pspec: [*c]GParamSpec, owner_type: GType) void;
pub extern fn g_param_spec_pool_remove(pool: ?*GParamSpecPool, pspec: [*c]GParamSpec) void;
pub extern fn g_param_spec_pool_lookup(pool: ?*GParamSpecPool, param_name: [*c]const gchar, owner_type: GType, walk_ancestors: gboolean) [*c]GParamSpec;
pub extern fn g_param_spec_pool_list_owned(pool: ?*GParamSpecPool, owner_type: GType) [*c]GList;
pub extern fn g_param_spec_pool_list(pool: ?*GParamSpecPool, owner_type: GType, n_pspecs_p: [*c]guint) [*c]([*c]GParamSpec);
pub const struct__GClosure = @OpaqueType();
pub const GClosure = struct__GClosure;
pub const GClosureNotify = ?extern fn (gpointer, ?*GClosure) void;
pub const struct__GClosureNotifyData = extern struct {
    data: gpointer,
    notify: GClosureNotify,
};
pub const GClosureNotifyData = struct__GClosureNotifyData;
pub const GCallback = ?extern fn () void;
pub const GClosureMarshal = ?extern fn (?*GClosure, [*c]GValue, guint, [*c]const GValue, gpointer, gpointer) void;
pub const GVaClosureMarshal = ?extern fn (?*GClosure, [*c]GValue, gpointer, va_list, gpointer, c_int, [*c]GType) void;
pub const struct__GCClosure = extern struct {
    closure: GClosure,
    callback: gpointer,
};
pub const GCClosure = struct__GCClosure;
pub extern fn g_cclosure_new(callback_func: GCallback, user_data: gpointer, destroy_data: GClosureNotify) ?*GClosure;
pub extern fn g_cclosure_new_swap(callback_func: GCallback, user_data: gpointer, destroy_data: GClosureNotify) ?*GClosure;
pub extern fn g_signal_type_cclosure_new(itype: GType, struct_offset: guint) ?*GClosure;
pub extern fn g_closure_ref(closure: ?*GClosure) ?*GClosure;
pub extern fn g_closure_sink(closure: ?*GClosure) void;
pub extern fn g_closure_unref(closure: ?*GClosure) void;
pub extern fn g_closure_new_simple(sizeof_closure: guint, data: gpointer) ?*GClosure;
pub extern fn g_closure_add_finalize_notifier(closure: ?*GClosure, notify_data: gpointer, notify_func: GClosureNotify) void;
pub extern fn g_closure_remove_finalize_notifier(closure: ?*GClosure, notify_data: gpointer, notify_func: GClosureNotify) void;
pub extern fn g_closure_add_invalidate_notifier(closure: ?*GClosure, notify_data: gpointer, notify_func: GClosureNotify) void;
pub extern fn g_closure_remove_invalidate_notifier(closure: ?*GClosure, notify_data: gpointer, notify_func: GClosureNotify) void;
pub extern fn g_closure_add_marshal_guards(closure: ?*GClosure, pre_marshal_data: gpointer, pre_marshal_notify: GClosureNotify, post_marshal_data: gpointer, post_marshal_notify: GClosureNotify) void;
pub extern fn g_closure_set_marshal(closure: ?*GClosure, marshal: GClosureMarshal) void;
pub extern fn g_closure_set_meta_marshal(closure: ?*GClosure, marshal_data: gpointer, meta_marshal: GClosureMarshal) void;
pub extern fn g_closure_invalidate(closure: ?*GClosure) void;
pub extern fn g_closure_invoke(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer) void;
pub extern fn g_cclosure_marshal_generic(closure: ?*GClosure, return_gvalue: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_generic_va(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args_list: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__VOID(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__VOIDv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__BOOLEAN(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__BOOLEANv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__CHAR(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__CHARv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__UCHAR(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__UCHARv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__INT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__INTv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__UINT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__UINTv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__LONG(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__LONGv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__ULONG(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__ULONGv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__ENUM(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__ENUMv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__FLAGS(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__FLAGSv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__FLOAT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__FLOATv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__DOUBLE(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__DOUBLEv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__STRING(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__STRINGv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__PARAM(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__PARAMv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__BOXED(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__BOXEDv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__POINTER(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__POINTERv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__OBJECT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__OBJECTv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__VARIANT(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__VARIANTv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_VOID__UINT_POINTER(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_VOID__UINT_POINTERv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_BOOLEAN__FLAGS(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_BOOLEAN__FLAGSv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_STRING__OBJECT_POINTER(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_STRING__OBJECT_POINTERv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub extern fn g_cclosure_marshal_BOOLEAN__BOXED_BOXED(closure: ?*GClosure, return_value: [*c]GValue, n_param_values: guint, param_values: [*c]const GValue, invocation_hint: gpointer, marshal_data: gpointer) void;
pub extern fn g_cclosure_marshal_BOOLEAN__BOXED_BOXEDv(closure: ?*GClosure, return_value: [*c]GValue, instance: gpointer, args: va_list, marshal_data: gpointer, n_params: c_int, param_types: [*c]GType) void;
pub const G_SIGNAL_RUN_FIRST = 1;
pub const G_SIGNAL_RUN_LAST = 2;
pub const G_SIGNAL_RUN_CLEANUP = 4;
pub const G_SIGNAL_NO_RECURSE = 8;
pub const G_SIGNAL_DETAILED = 16;
pub const G_SIGNAL_ACTION = 32;
pub const G_SIGNAL_NO_HOOKS = 64;
pub const G_SIGNAL_MUST_COLLECT = 128;
pub const G_SIGNAL_DEPRECATED = 256;
pub const GSignalFlags = extern enum {
    G_SIGNAL_RUN_FIRST = 1,
    G_SIGNAL_RUN_LAST = 2,
    G_SIGNAL_RUN_CLEANUP = 4,
    G_SIGNAL_NO_RECURSE = 8,
    G_SIGNAL_DETAILED = 16,
    G_SIGNAL_ACTION = 32,
    G_SIGNAL_NO_HOOKS = 64,
    G_SIGNAL_MUST_COLLECT = 128,
    G_SIGNAL_DEPRECATED = 256,
};
pub const struct__GSignalQuery = extern struct {
    signal_id: guint,
    signal_name: [*c]const gchar,
    itype: GType,
    signal_flags: GSignalFlags,
    return_type: GType,
    n_params: guint,
    param_types: [*c]const GType,
};
pub const GSignalQuery = struct__GSignalQuery;
pub const struct__GSignalInvocationHint = extern struct {
    signal_id: guint,
    detail: GQuark,
    run_type: GSignalFlags,
};
pub const GSignalInvocationHint = struct__GSignalInvocationHint;
pub const GSignalCMarshaller = GClosureMarshal;
pub const GSignalCVaMarshaller = GVaClosureMarshal;
pub const GSignalEmissionHook = ?extern fn ([*c]GSignalInvocationHint, guint, [*c]const GValue, gpointer) gboolean;
pub const GSignalAccumulator = ?extern fn ([*c]GSignalInvocationHint, [*c]GValue, [*c]const GValue, gpointer) gboolean;
pub const G_CONNECT_AFTER = 1;
pub const G_CONNECT_SWAPPED = 2;
pub const GConnectFlags = extern enum {
    G_CONNECT_AFTER = 1,
    G_CONNECT_SWAPPED = 2,
};
pub const G_SIGNAL_MATCH_ID = 1;
pub const G_SIGNAL_MATCH_DETAIL = 2;
pub const G_SIGNAL_MATCH_CLOSURE = 4;
pub const G_SIGNAL_MATCH_FUNC = 8;
pub const G_SIGNAL_MATCH_DATA = 16;
pub const G_SIGNAL_MATCH_UNBLOCKED = 32;
pub const GSignalMatchType = extern enum {
    G_SIGNAL_MATCH_ID = 1,
    G_SIGNAL_MATCH_DETAIL = 2,
    G_SIGNAL_MATCH_CLOSURE = 4,
    G_SIGNAL_MATCH_FUNC = 8,
    G_SIGNAL_MATCH_DATA = 16,
    G_SIGNAL_MATCH_UNBLOCKED = 32,
};
pub extern fn g_signal_newv(signal_name: [*c]const gchar, itype: GType, signal_flags: GSignalFlags, class_closure: ?*GClosure, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, param_types: [*c]GType) guint;
pub extern fn g_signal_new_valist(signal_name: [*c]const gchar, itype: GType, signal_flags: GSignalFlags, class_closure: ?*GClosure, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, args: va_list) guint;
pub extern fn g_signal_new(signal_name: [*c]const gchar, itype: GType, signal_flags: GSignalFlags, class_offset: guint, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, ...) guint;
pub extern fn g_signal_new_class_handler(signal_name: [*c]const gchar, itype: GType, signal_flags: GSignalFlags, class_handler: GCallback, accumulator: GSignalAccumulator, accu_data: gpointer, c_marshaller: GSignalCMarshaller, return_type: GType, n_params: guint, ...) guint;
pub extern fn g_signal_set_va_marshaller(signal_id: guint, instance_type: GType, va_marshaller: GSignalCVaMarshaller) void;
pub extern fn g_signal_emitv(instance_and_params: [*c]const GValue, signal_id: guint, detail: GQuark, return_value: [*c]GValue) void;
pub extern fn g_signal_emit_valist(instance: gpointer, signal_id: guint, detail: GQuark, var_args: va_list) void;
pub extern fn g_signal_emit(instance: gpointer, signal_id: guint, detail: GQuark, ...) void;
pub extern fn g_signal_emit_by_name(instance: gpointer, detailed_signal: [*c]const gchar, ...) void;
pub extern fn g_signal_lookup(name: [*c]const gchar, itype: GType) guint;
pub extern fn g_signal_name(signal_id: guint) [*c]const gchar;
pub extern fn g_signal_query(signal_id: guint, query: [*c]GSignalQuery) void;
pub extern fn g_signal_list_ids(itype: GType, n_ids: [*c]guint) [*c]guint;
pub extern fn g_signal_parse_name(detailed_signal: [*c]const gchar, itype: GType, signal_id_p: [*c]guint, detail_p: [*c]GQuark, force_detail_quark: gboolean) gboolean;
pub extern fn g_signal_get_invocation_hint(instance: gpointer) [*c]GSignalInvocationHint;
pub extern fn g_signal_stop_emission(instance: gpointer, signal_id: guint, detail: GQuark) void;
pub extern fn g_signal_stop_emission_by_name(instance: gpointer, detailed_signal: [*c]const gchar) void;
pub extern fn g_signal_add_emission_hook(signal_id: guint, detail: GQuark, hook_func: GSignalEmissionHook, hook_data: gpointer, data_destroy: GDestroyNotify) gulong;
pub extern fn g_signal_remove_emission_hook(signal_id: guint, hook_id: gulong) void;
pub extern fn g_signal_has_handler_pending(instance: gpointer, signal_id: guint, detail: GQuark, may_be_blocked: gboolean) gboolean;
pub extern fn g_signal_connect_closure_by_id(instance: gpointer, signal_id: guint, detail: GQuark, closure: ?*GClosure, after: gboolean) gulong;
pub extern fn g_signal_connect_closure(instance: gpointer, detailed_signal: [*c]const gchar, closure: ?*GClosure, after: gboolean) gulong;
pub extern fn g_signal_connect_data(instance: gpointer, detailed_signal: [*c]const gchar, c_handler: GCallback, data: gpointer, destroy_data: GClosureNotify, connect_flags: GConnectFlags) gulong;
pub extern fn g_signal_handler_block(instance: gpointer, handler_id: gulong) void;
pub extern fn g_signal_handler_unblock(instance: gpointer, handler_id: gulong) void;
pub extern fn g_signal_handler_disconnect(instance: gpointer, handler_id: gulong) void;
pub extern fn g_signal_handler_is_connected(instance: gpointer, handler_id: gulong) gboolean;
pub extern fn g_signal_handler_find(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: GQuark, closure: ?*GClosure, func: gpointer, data: gpointer) gulong;
pub extern fn g_signal_handlers_block_matched(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: GQuark, closure: ?*GClosure, func: gpointer, data: gpointer) guint;
pub extern fn g_signal_handlers_unblock_matched(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: GQuark, closure: ?*GClosure, func: gpointer, data: gpointer) guint;
pub extern fn g_signal_handlers_disconnect_matched(instance: gpointer, mask: GSignalMatchType, signal_id: guint, detail: GQuark, closure: ?*GClosure, func: gpointer, data: gpointer) guint;
pub extern fn g_clear_signal_handler(handler_id_ptr: [*c]gulong, instance: gpointer) void;
pub extern fn g_signal_override_class_closure(signal_id: guint, instance_type: GType, class_closure: ?*GClosure) void;
pub extern fn g_signal_override_class_handler(signal_name: [*c]const gchar, instance_type: GType, class_handler: GCallback) void;
pub extern fn g_signal_chain_from_overridden(instance_and_params: [*c]const GValue, return_value: [*c]GValue) void;
pub extern fn g_signal_chain_from_overridden_handler(instance: gpointer, ...) void;
pub extern fn g_signal_accumulator_true_handled(ihint: [*c]GSignalInvocationHint, return_accu: [*c]GValue, handler_return: [*c]const GValue, dummy: gpointer) gboolean;
pub extern fn g_signal_accumulator_first_wins(ihint: [*c]GSignalInvocationHint, return_accu: [*c]GValue, handler_return: [*c]const GValue, dummy: gpointer) gboolean;
pub extern fn g_signal_handlers_destroy(instance: gpointer) void;
pub extern fn _g_signals_destroy(itype: GType) void;
pub extern fn g_date_get_type() GType;
pub extern fn g_strv_get_type() GType;
pub extern fn g_gstring_get_type() GType;
pub extern fn g_hash_table_get_type() GType;
pub extern fn g_array_get_type() GType;
pub extern fn g_byte_array_get_type() GType;
pub extern fn g_ptr_array_get_type() GType;
pub extern fn g_bytes_get_type() GType;
pub extern fn g_variant_type_get_gtype() GType;
pub extern fn g_regex_get_type() GType;
pub extern fn g_match_info_get_type() GType;
pub extern fn g_error_get_type() GType;
pub extern fn g_date_time_get_type() GType;
pub extern fn g_time_zone_get_type() GType;
pub extern fn g_io_channel_get_type() GType;
pub extern fn g_io_condition_get_type() GType;
pub extern fn g_variant_builder_get_type() GType;
pub extern fn g_variant_dict_get_type() GType;
pub extern fn g_key_file_get_type() GType;
pub extern fn g_main_loop_get_type() GType;
pub extern fn g_main_context_get_type() GType;
pub extern fn g_source_get_type() GType;
pub extern fn g_pollfd_get_type() GType;
pub extern fn g_thread_get_type() GType;
pub extern fn g_checksum_get_type() GType;
pub extern fn g_markup_parse_context_get_type() GType;
pub extern fn g_mapped_file_get_type() GType;
pub extern fn g_option_group_get_type() GType;
pub extern fn g_variant_get_gtype() GType;
pub const GBoxedCopyFunc = ?extern fn (gpointer) gpointer;
pub const GBoxedFreeFunc = ?extern fn (gpointer) void;
pub extern fn g_boxed_copy(boxed_type: GType, src_boxed: gconstpointer) gpointer;
pub extern fn g_boxed_free(boxed_type: GType, boxed: gpointer) void;
pub extern fn g_value_set_boxed(value: [*c]GValue, v_boxed: gconstpointer) void;
pub extern fn g_value_set_static_boxed(value: [*c]GValue, v_boxed: gconstpointer) void;
pub extern fn g_value_take_boxed(value: [*c]GValue, v_boxed: gconstpointer) void;
pub extern fn g_value_set_boxed_take_ownership(value: [*c]GValue, v_boxed: gconstpointer) void;
pub extern fn g_value_get_boxed(value: [*c]const GValue) gpointer;
pub extern fn g_value_dup_boxed(value: [*c]const GValue) gpointer;
pub extern fn g_boxed_type_register_static(name: [*c]const gchar, boxed_copy: GBoxedCopyFunc, boxed_free: GBoxedFreeFunc) GType;
pub extern fn g_closure_get_type() GType;
pub extern fn g_value_get_type() GType;
pub const struct__GObject = extern struct {
    g_type_instance: GTypeInstance,
    ref_count: guint,
    qdata: ?*GData,
};
pub const GObject = struct__GObject;
pub const struct__GObjectConstructParam = extern struct {
    pspec: [*c]GParamSpec,
    value: [*c]GValue,
};
pub const GObjectConstructParam = struct__GObjectConstructParam;
pub const struct__GObjectClass = extern struct {
    g_type_class: GTypeClass,
    construct_properties: [*c]GSList,
    constructor: ?extern fn (GType, guint, [*c]GObjectConstructParam) [*c]GObject,
    set_property: ?extern fn ([*c]GObject, guint, [*c]const GValue, [*c]GParamSpec) void,
    get_property: ?extern fn ([*c]GObject, guint, [*c]GValue, [*c]GParamSpec) void,
    dispose: ?extern fn ([*c]GObject) void,
    finalize: ?extern fn ([*c]GObject) void,
    dispatch_properties_changed: ?extern fn ([*c]GObject, guint, [*c]([*c]GParamSpec)) void,
    notify: ?extern fn ([*c]GObject, [*c]GParamSpec) void,
    constructed: ?extern fn ([*c]GObject) void,
    flags: gsize,
    pdummy: [6]gpointer,
};
pub const GObjectClass = struct__GObjectClass;
pub const GInitiallyUnowned = struct__GObject;
pub const GInitiallyUnownedClass = struct__GObjectClass;
pub const GObjectGetPropertyFunc = ?extern fn ([*c]GObject, guint, [*c]GValue, [*c]GParamSpec) void;
pub const GObjectSetPropertyFunc = ?extern fn ([*c]GObject, guint, [*c]const GValue, [*c]GParamSpec) void;
pub const GObjectFinalizeFunc = ?extern fn ([*c]GObject) void;
pub const GWeakNotify = ?extern fn (gpointer, [*c]GObject) void;
pub extern fn g_initially_unowned_get_type() GType;
pub extern fn g_object_class_install_property(oclass: [*c]GObjectClass, property_id: guint, pspec: [*c]GParamSpec) void;
pub extern fn g_object_class_find_property(oclass: [*c]GObjectClass, property_name: [*c]const gchar) [*c]GParamSpec;
pub extern fn g_object_class_list_properties(oclass: [*c]GObjectClass, n_properties: [*c]guint) [*c]([*c]GParamSpec);
pub extern fn g_object_class_override_property(oclass: [*c]GObjectClass, property_id: guint, name: [*c]const gchar) void;
pub extern fn g_object_class_install_properties(oclass: [*c]GObjectClass, n_pspecs: guint, pspecs: [*c]([*c]GParamSpec)) void;
pub extern fn g_object_interface_install_property(g_iface: gpointer, pspec: [*c]GParamSpec) void;
pub extern fn g_object_interface_find_property(g_iface: gpointer, property_name: [*c]const gchar) [*c]GParamSpec;
pub extern fn g_object_interface_list_properties(g_iface: gpointer, n_properties_p: [*c]guint) [*c]([*c]GParamSpec);
pub extern fn g_object_get_type() GType;
pub extern fn g_object_new(object_type: GType, first_property_name: [*c]const gchar, ...) gpointer;
pub extern fn g_object_new_with_properties(object_type: GType, n_properties: guint, names: [*c]([*c]const u8), values: [*c]const GValue) [*c]GObject;
pub extern fn g_object_newv(object_type: GType, n_parameters: guint, parameters: [*c]GParameter) gpointer;
pub extern fn g_object_new_valist(object_type: GType, first_property_name: [*c]const gchar, var_args: va_list) [*c]GObject;
pub extern fn g_object_set(object: gpointer, first_property_name: [*c]const gchar, ...) void;
pub extern fn g_object_get(object: gpointer, first_property_name: [*c]const gchar, ...) void;
pub extern fn g_object_connect(object: gpointer, signal_spec: [*c]const gchar, ...) gpointer;
pub extern fn g_object_disconnect(object: gpointer, signal_spec: [*c]const gchar, ...) void;
pub extern fn g_object_setv(object: [*c]GObject, n_properties: guint, names: [*c]([*c]const gchar), values: [*c]const GValue) void;
pub extern fn g_object_set_valist(object: [*c]GObject, first_property_name: [*c]const gchar, var_args: va_list) void;
pub extern fn g_object_getv(object: [*c]GObject, n_properties: guint, names: [*c]([*c]const gchar), values: [*c]GValue) void;
pub extern fn g_object_get_valist(object: [*c]GObject, first_property_name: [*c]const gchar, var_args: va_list) void;
pub extern fn g_object_set_property(object: [*c]GObject, property_name: [*c]const gchar, value: [*c]const GValue) void;
pub extern fn g_object_get_property(object: [*c]GObject, property_name: [*c]const gchar, value: [*c]GValue) void;
pub extern fn g_object_freeze_notify(object: [*c]GObject) void;
pub extern fn g_object_notify(object: [*c]GObject, property_name: [*c]const gchar) void;
pub extern fn g_object_notify_by_pspec(object: [*c]GObject, pspec: [*c]GParamSpec) void;
pub extern fn g_object_thaw_notify(object: [*c]GObject) void;
pub extern fn g_object_is_floating(object: gpointer) gboolean;
pub extern fn g_object_ref_sink(object: gpointer) gpointer;
pub extern fn g_object_ref(object: gpointer) gpointer;
pub extern fn g_object_unref(object: gpointer) void;
pub extern fn g_object_weak_ref(object: [*c]GObject, notify: GWeakNotify, data: gpointer) void;
pub extern fn g_object_weak_unref(object: [*c]GObject, notify: GWeakNotify, data: gpointer) void;
pub extern fn g_object_add_weak_pointer(object: [*c]GObject, weak_pointer_location: [*c]gpointer) void;
pub extern fn g_object_remove_weak_pointer(object: [*c]GObject, weak_pointer_location: [*c]gpointer) void;
pub const GToggleNotify = ?extern fn (gpointer, [*c]GObject, gboolean) void;
pub extern fn g_object_add_toggle_ref(object: [*c]GObject, notify: GToggleNotify, data: gpointer) void;
pub extern fn g_object_remove_toggle_ref(object: [*c]GObject, notify: GToggleNotify, data: gpointer) void;
pub extern fn g_object_get_qdata(object: [*c]GObject, quark: GQuark) gpointer;
pub extern fn g_object_set_qdata(object: [*c]GObject, quark: GQuark, data: gpointer) void;
pub extern fn g_object_set_qdata_full(object: [*c]GObject, quark: GQuark, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn g_object_steal_qdata(object: [*c]GObject, quark: GQuark) gpointer;
pub extern fn g_object_dup_qdata(object: [*c]GObject, quark: GQuark, dup_func: GDuplicateFunc, user_data: gpointer) gpointer;
pub extern fn g_object_replace_qdata(object: [*c]GObject, quark: GQuark, oldval: gpointer, newval: gpointer, destroy: GDestroyNotify, old_destroy: [*c]GDestroyNotify) gboolean;
pub extern fn g_object_get_data(object: [*c]GObject, key: [*c]const gchar) gpointer;
pub extern fn g_object_set_data(object: [*c]GObject, key: [*c]const gchar, data: gpointer) void;
pub extern fn g_object_set_data_full(object: [*c]GObject, key: [*c]const gchar, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn g_object_steal_data(object: [*c]GObject, key: [*c]const gchar) gpointer;
pub extern fn g_object_dup_data(object: [*c]GObject, key: [*c]const gchar, dup_func: GDuplicateFunc, user_data: gpointer) gpointer;
pub extern fn g_object_replace_data(object: [*c]GObject, key: [*c]const gchar, oldval: gpointer, newval: gpointer, destroy: GDestroyNotify, old_destroy: [*c]GDestroyNotify) gboolean;
pub extern fn g_object_watch_closure(object: [*c]GObject, closure: ?*GClosure) void;
pub extern fn g_cclosure_new_object(callback_func: GCallback, object: [*c]GObject) ?*GClosure;
pub extern fn g_cclosure_new_object_swap(callback_func: GCallback, object: [*c]GObject) ?*GClosure;
pub extern fn g_closure_new_object(sizeof_closure: guint, object: [*c]GObject) ?*GClosure;
pub extern fn g_value_set_object(value: [*c]GValue, v_object: gpointer) void;
pub extern fn g_value_get_object(value: [*c]const GValue) gpointer;
pub extern fn g_value_dup_object(value: [*c]const GValue) gpointer;
pub extern fn g_signal_connect_object(instance: gpointer, detailed_signal: [*c]const gchar, c_handler: GCallback, gobject: gpointer, connect_flags: GConnectFlags) gulong;
pub extern fn g_object_force_floating(object: [*c]GObject) void;
pub extern fn g_object_run_dispose(object: [*c]GObject) void;
pub extern fn g_value_take_object(value: [*c]GValue, v_object: gpointer) void;
pub extern fn g_value_set_object_take_ownership(value: [*c]GValue, v_object: gpointer) void;
pub extern fn g_object_compat_control(what: gsize, data: gpointer) gsize;
pub extern fn g_clear_object(object_ptr: [*c]([*c]GObject)) void;
pub fn g_set_object(object_ptr: [*c]([*c]GObject), new_object: [*c]GObject) gboolean {
    var old_object: [*c]GObject = object_ptr.?.*;
    if (old_object == new_object) return 0;
    if (new_object != @ptrCast([*c]GObject, @alignCast(@alignOf(GObject), (?*c_void)(0)))) _ = g_object_ref(@ptrCast(gpointer, new_object));
    object_ptr.?.* = new_object;
    if (old_object != @ptrCast([*c]GObject, @alignCast(@alignOf(GObject), (?*c_void)(0)))) g_object_unref(@ptrCast(gpointer, old_object));
    return !(0 != 0);
}
pub fn g_assert_finalize_object(object: [*c]GObject) void {
    var weak_pointer: gpointer = @ptrCast(gpointer, object);
    while (true) {
        if (gboolean) {} else g_assertion_message(([*c]gchar)(0), c"C:\\msys64\\mingw64\\include\\glib-2.0\\gobject/gobject.h", 767, c"g_assert_finalize_object", c"\'G_IS_OBJECT (weak_pointer)\' should be TRUE");
        if (!0) break;
    }
    g_object_add_weak_pointer(object, &weak_pointer);
    g_object_unref(weak_pointer);
    while (true) {
        if (weak_pointer == (?*c_void)(0)) {} else g_assertion_message(([*c]gchar)(0), c"C:\\msys64\\mingw64\\include\\glib-2.0\\gobject/gobject.h", 770, c"g_assert_finalize_object", c"\'weak_pointer\' should be NULL");
        if (!0) break;
    }
}
pub fn g_clear_weak_pointer(weak_pointer_location: [*c]gpointer) void {
    var object: [*c]GObject = @ptrCast([*c]GObject, @alignCast(@alignOf(GObject), weak_pointer_location.?.*));
    if (object != @ptrCast([*c]GObject, @alignCast(@alignOf(GObject), (?*c_void)(0)))) {
        g_object_remove_weak_pointer(object, weak_pointer_location);
        weak_pointer_location.?.* = (?*c_void)(0);
    }
}
pub fn g_set_weak_pointer(weak_pointer_location: [*c]gpointer, new_object: [*c]GObject) gboolean {
    var old_object: [*c]GObject = @ptrCast([*c]GObject, @alignCast(@alignOf(GObject), weak_pointer_location.?.*));
    if (old_object == new_object) return 0;
    if (old_object != @ptrCast([*c]GObject, @alignCast(@alignOf(GObject), (?*c_void)(0)))) g_object_remove_weak_pointer(old_object, weak_pointer_location);
    weak_pointer_location.?.* = @ptrCast(gpointer, new_object);
    if (new_object != @ptrCast([*c]GObject, @alignCast(@alignOf(GObject), (?*c_void)(0)))) g_object_add_weak_pointer(new_object, weak_pointer_location);
    return !(0 != 0);
}
pub const GWeakRef = extern struct {
    priv: extern union {
        p: gpointer,
    },
};
pub extern fn g_weak_ref_init(weak_ref: [*c]GWeakRef, object: gpointer) void;
pub extern fn g_weak_ref_clear(weak_ref: [*c]GWeakRef) void;
pub extern fn g_weak_ref_get(weak_ref: [*c]GWeakRef) gpointer;
pub extern fn g_weak_ref_set(weak_ref: [*c]GWeakRef, object: gpointer) void;
pub const struct__GBinding = @OpaqueType();
pub const GBinding = struct__GBinding;
pub const GBindingTransformFunc = ?extern fn (?*GBinding, [*c]const GValue, [*c]GValue, gpointer) gboolean;
pub const G_BINDING_DEFAULT = 0;
pub const G_BINDING_BIDIRECTIONAL = 1;
pub const G_BINDING_SYNC_CREATE = 2;
pub const G_BINDING_INVERT_BOOLEAN = 4;
pub const GBindingFlags = extern enum {
    G_BINDING_DEFAULT = 0,
    G_BINDING_BIDIRECTIONAL = 1,
    G_BINDING_SYNC_CREATE = 2,
    G_BINDING_INVERT_BOOLEAN = 4,
};
pub extern fn g_binding_flags_get_type() GType;
pub extern fn g_binding_get_type() GType;
pub extern fn g_binding_get_flags(binding: ?*GBinding) GBindingFlags;
pub extern fn g_binding_get_source(binding: ?*GBinding) [*c]GObject;
pub extern fn g_binding_get_target(binding: ?*GBinding) [*c]GObject;
pub extern fn g_binding_get_source_property(binding: ?*GBinding) [*c]const gchar;
pub extern fn g_binding_get_target_property(binding: ?*GBinding) [*c]const gchar;
pub extern fn g_binding_unbind(binding: ?*GBinding) void;
pub extern fn g_object_bind_property(source: gpointer, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags) ?*GBinding;
pub extern fn g_object_bind_property_full(source: gpointer, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags, transform_to: GBindingTransformFunc, transform_from: GBindingTransformFunc, user_data: gpointer, notify: GDestroyNotify) ?*GBinding;
pub extern fn g_object_bind_property_with_closures(source: gpointer, source_property: [*c]const gchar, target: gpointer, target_property: [*c]const gchar, flags: GBindingFlags, transform_to: ?*GClosure, transform_from: ?*GClosure) ?*GBinding;
pub const struct__GEnumValue = extern struct {
    value: gint,
    value_name: [*c]const gchar,
    value_nick: [*c]const gchar,
};
pub const GEnumValue = struct__GEnumValue;
pub const struct__GEnumClass = extern struct {
    g_type_class: GTypeClass,
    minimum: gint,
    maximum: gint,
    n_values: guint,
    values: [*c]GEnumValue,
};
pub const GEnumClass = struct__GEnumClass;
pub const struct__GFlagsValue = extern struct {
    value: guint,
    value_name: [*c]const gchar,
    value_nick: [*c]const gchar,
};
pub const GFlagsValue = struct__GFlagsValue;
pub const struct__GFlagsClass = extern struct {
    g_type_class: GTypeClass,
    mask: guint,
    n_values: guint,
    values: [*c]GFlagsValue,
};
pub const GFlagsClass = struct__GFlagsClass;
pub extern fn g_enum_get_value(enum_class: [*c]GEnumClass, value: gint) [*c]GEnumValue;
pub extern fn g_enum_get_value_by_name(enum_class: [*c]GEnumClass, name: [*c]const gchar) [*c]GEnumValue;
pub extern fn g_enum_get_value_by_nick(enum_class: [*c]GEnumClass, nick: [*c]const gchar) [*c]GEnumValue;
pub extern fn g_flags_get_first_value(flags_class: [*c]GFlagsClass, value: guint) [*c]GFlagsValue;
pub extern fn g_flags_get_value_by_name(flags_class: [*c]GFlagsClass, name: [*c]const gchar) [*c]GFlagsValue;
pub extern fn g_flags_get_value_by_nick(flags_class: [*c]GFlagsClass, nick: [*c]const gchar) [*c]GFlagsValue;
pub extern fn g_enum_to_string(g_enum_type: GType, value: gint) [*c]gchar;
pub extern fn g_flags_to_string(flags_type: GType, value: guint) [*c]gchar;
pub extern fn g_value_set_enum(value: [*c]GValue, v_enum: gint) void;
pub extern fn g_value_get_enum(value: [*c]const GValue) gint;
pub extern fn g_value_set_flags(value: [*c]GValue, v_flags: guint) void;
pub extern fn g_value_get_flags(value: [*c]const GValue) guint;
pub extern fn g_enum_register_static(name: [*c]const gchar, const_static_values: [*c]const GEnumValue) GType;
pub extern fn g_flags_register_static(name: [*c]const gchar, const_static_values: [*c]const GFlagsValue) GType;
pub extern fn g_enum_complete_type_info(g_enum_type: GType, info: [*c]GTypeInfo, const_values: [*c]const GEnumValue) void;
pub extern fn g_flags_complete_type_info(g_flags_type: GType, info: [*c]GTypeInfo, const_values: [*c]const GFlagsValue) void;
pub const struct__GParamSpecChar = extern struct {
    parent_instance: GParamSpec,
    minimum: gint8,
    maximum: gint8,
    default_value: gint8,
};
pub const GParamSpecChar = struct__GParamSpecChar;
pub const struct__GParamSpecUChar = extern struct {
    parent_instance: GParamSpec,
    minimum: guint8,
    maximum: guint8,
    default_value: guint8,
};
pub const GParamSpecUChar = struct__GParamSpecUChar;
pub const struct__GParamSpecBoolean = extern struct {
    parent_instance: GParamSpec,
    default_value: gboolean,
};
pub const GParamSpecBoolean = struct__GParamSpecBoolean;
pub const struct__GParamSpecInt = extern struct {
    parent_instance: GParamSpec,
    minimum: gint,
    maximum: gint,
    default_value: gint,
};
pub const GParamSpecInt = struct__GParamSpecInt;
pub const struct__GParamSpecUInt = extern struct {
    parent_instance: GParamSpec,
    minimum: guint,
    maximum: guint,
    default_value: guint,
};
pub const GParamSpecUInt = struct__GParamSpecUInt;
pub const struct__GParamSpecLong = extern struct {
    parent_instance: GParamSpec,
    minimum: glong,
    maximum: glong,
    default_value: glong,
};
pub const GParamSpecLong = struct__GParamSpecLong;
pub const struct__GParamSpecULong = extern struct {
    parent_instance: GParamSpec,
    minimum: gulong,
    maximum: gulong,
    default_value: gulong,
};
pub const GParamSpecULong = struct__GParamSpecULong;
pub const struct__GParamSpecInt64 = extern struct {
    parent_instance: GParamSpec,
    minimum: gint64,
    maximum: gint64,
    default_value: gint64,
};
pub const GParamSpecInt64 = struct__GParamSpecInt64;
pub const struct__GParamSpecUInt64 = extern struct {
    parent_instance: GParamSpec,
    minimum: guint64,
    maximum: guint64,
    default_value: guint64,
};
pub const GParamSpecUInt64 = struct__GParamSpecUInt64;
pub const struct__GParamSpecUnichar = extern struct {
    parent_instance: GParamSpec,
    default_value: gunichar,
};
pub const GParamSpecUnichar = struct__GParamSpecUnichar;
pub const struct__GParamSpecEnum = extern struct {
    parent_instance: GParamSpec,
    enum_class: [*c]GEnumClass,
    default_value: gint,
};
pub const GParamSpecEnum = struct__GParamSpecEnum;
pub const struct__GParamSpecFlags = extern struct {
    parent_instance: GParamSpec,
    flags_class: [*c]GFlagsClass,
    default_value: guint,
};
pub const GParamSpecFlags = struct__GParamSpecFlags;
pub const struct__GParamSpecFloat = extern struct {
    parent_instance: GParamSpec,
    minimum: gfloat,
    maximum: gfloat,
    default_value: gfloat,
    epsilon: gfloat,
};
pub const GParamSpecFloat = struct__GParamSpecFloat;
pub const struct__GParamSpecDouble = extern struct {
    parent_instance: GParamSpec,
    minimum: gdouble,
    maximum: gdouble,
    default_value: gdouble,
    epsilon: gdouble,
};
pub const GParamSpecDouble = struct__GParamSpecDouble;
pub const struct__GParamSpecString = @OpaqueType();
pub const GParamSpecString = struct__GParamSpecString;
pub const struct__GParamSpecParam = extern struct {
    parent_instance: GParamSpec,
};
pub const GParamSpecParam = struct__GParamSpecParam;
pub const struct__GParamSpecBoxed = extern struct {
    parent_instance: GParamSpec,
};
pub const GParamSpecBoxed = struct__GParamSpecBoxed;
pub const struct__GParamSpecPointer = extern struct {
    parent_instance: GParamSpec,
};
pub const GParamSpecPointer = struct__GParamSpecPointer;
pub const struct__GParamSpecValueArray = extern struct {
    parent_instance: GParamSpec,
    element_spec: [*c]GParamSpec,
    fixed_n_elements: guint,
};
pub const GParamSpecValueArray = struct__GParamSpecValueArray;
pub const struct__GParamSpecObject = extern struct {
    parent_instance: GParamSpec,
};
pub const GParamSpecObject = struct__GParamSpecObject;
pub const struct__GParamSpecOverride = extern struct {
    parent_instance: GParamSpec,
    overridden: [*c]GParamSpec,
};
pub const GParamSpecOverride = struct__GParamSpecOverride;
pub const struct__GParamSpecGType = extern struct {
    parent_instance: GParamSpec,
    is_a_type: GType,
};
pub const GParamSpecGType = struct__GParamSpecGType;
pub const struct__GParamSpecVariant = extern struct {
    parent_instance: GParamSpec,
    type: ?*GVariantType,
    default_value: ?*GVariant,
    padding: [4]gpointer,
};
pub const GParamSpecVariant = struct__GParamSpecVariant;
pub extern fn g_param_spec_char(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gint8, maximum: gint8, default_value: gint8, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_uchar(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: guint8, maximum: guint8, default_value: guint8, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_boolean(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, default_value: gboolean, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_int(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gint, maximum: gint, default_value: gint, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_uint(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: guint, maximum: guint, default_value: guint, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_long(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: glong, maximum: glong, default_value: glong, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_ulong(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gulong, maximum: gulong, default_value: gulong, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_int64(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gint64, maximum: gint64, default_value: gint64, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_uint64(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: guint64, maximum: guint64, default_value: guint64, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_unichar(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, default_value: gunichar, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_enum(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, enum_type: GType, default_value: gint, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_flags(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, flags_type: GType, default_value: guint, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_float(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gfloat, maximum: gfloat, default_value: gfloat, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_double(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, minimum: gdouble, maximum: gdouble, default_value: gdouble, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_string(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, default_value: [*c]const gchar, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_param(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, param_type: GType, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_boxed(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, boxed_type: GType, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_pointer(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_value_array(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, element_spec: [*c]GParamSpec, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_object(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, object_type: GType, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_override(name: [*c]const gchar, overridden: [*c]GParamSpec) [*c]GParamSpec;
pub extern fn g_param_spec_gtype(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, is_a_type: GType, flags: GParamFlags) [*c]GParamSpec;
pub extern fn g_param_spec_variant(name: [*c]const gchar, nick: [*c]const gchar, blurb: [*c]const gchar, type_0: ?*const GVariantType, default_value: ?*GVariant, flags: GParamFlags) [*c]GParamSpec;
pub extern var g_param_spec_types: [*c]GType;
pub extern fn g_source_set_closure(source: [*c]GSource, closure: ?*GClosure) void;
pub extern fn g_source_set_dummy_callback(source: [*c]GSource) void;
pub const struct__GTypeModule = extern struct {
    parent_instance: GObject,
    use_count: guint,
    type_infos: [*c]GSList,
    interface_infos: [*c]GSList,
    name: [*c]gchar,
};
pub const GTypeModule = struct__GTypeModule;
pub const struct__GTypeModuleClass = extern struct {
    parent_class: GObjectClass,
    load: ?extern fn ([*c]GTypeModule) gboolean,
    unload: ?extern fn ([*c]GTypeModule) void,
    reserved1: ?extern fn () void,
    reserved2: ?extern fn () void,
    reserved3: ?extern fn () void,
    reserved4: ?extern fn () void,
};
pub const GTypeModuleClass = struct__GTypeModuleClass;
pub const GTypeModule_autoptr = [*c]GTypeModule;
pub const GTypeModule_listautoptr = [*c]GList;
pub const GTypeModule_slistautoptr = [*c]GSList;
pub const GTypeModule_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTypeModule(_ptr: [*c]GTypeModule) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTypeModule(_ptr: [*c]([*c]GTypeModule)) void {
    glib_autoptr_clear_GTypeModule(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTypeModule(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTypeModule(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTypeModule(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub extern fn g_type_module_get_type() GType;
pub extern fn g_type_module_use(module: [*c]GTypeModule) gboolean;
pub extern fn g_type_module_unuse(module: [*c]GTypeModule) void;
pub extern fn g_type_module_set_name(module: [*c]GTypeModule, name: [*c]const gchar) void;
pub extern fn g_type_module_register_type(module: [*c]GTypeModule, parent_type: GType, type_name: [*c]const gchar, type_info: [*c]const GTypeInfo, flags: GTypeFlags) GType;
pub extern fn g_type_module_add_interface(module: [*c]GTypeModule, instance_type: GType, interface_type: GType, interface_info: [*c]const GInterfaceInfo) void;
pub extern fn g_type_module_register_enum(module: [*c]GTypeModule, name: [*c]const gchar, const_static_values: [*c]const GEnumValue) GType;
pub extern fn g_type_module_register_flags(module: [*c]GTypeModule, name: [*c]const gchar, const_static_values: [*c]const GFlagsValue) GType;
pub const GTypePluginUse = ?extern fn (?*GTypePlugin) void;
pub const GTypePluginUnuse = ?extern fn (?*GTypePlugin) void;
pub const GTypePluginCompleteTypeInfo = ?extern fn (?*GTypePlugin, GType, [*c]GTypeInfo, [*c]GTypeValueTable) void;
pub const GTypePluginCompleteInterfaceInfo = ?extern fn (?*GTypePlugin, GType, GType, [*c]GInterfaceInfo) void;
pub const struct__GTypePluginClass = extern struct {
    base_iface: GTypeInterface,
    use_plugin: GTypePluginUse,
    unuse_plugin: GTypePluginUnuse,
    complete_type_info: GTypePluginCompleteTypeInfo,
    complete_interface_info: GTypePluginCompleteInterfaceInfo,
};
pub const GTypePluginClass = struct__GTypePluginClass;
pub extern fn g_type_plugin_get_type() GType;
pub extern fn g_type_plugin_use(plugin: ?*GTypePlugin) void;
pub extern fn g_type_plugin_unuse(plugin: ?*GTypePlugin) void;
pub extern fn g_type_plugin_complete_type_info(plugin: ?*GTypePlugin, g_type: GType, info: [*c]GTypeInfo, value_table: [*c]GTypeValueTable) void;
pub extern fn g_type_plugin_complete_interface_info(plugin: ?*GTypePlugin, instance_type: GType, interface_type: GType, info: [*c]GInterfaceInfo) void;
pub const struct__GValueArray = extern struct {
    n_values: guint,
    values: [*c]GValue,
    n_prealloced: guint,
};
pub const GValueArray = struct__GValueArray;
pub extern fn g_value_array_get_type() GType;
pub extern fn g_value_array_get_nth(value_array: [*c]GValueArray, index_: guint) [*c]GValue;
pub extern fn g_value_array_new(n_prealloced: guint) [*c]GValueArray;
pub extern fn g_value_array_free(value_array: [*c]GValueArray) void;
pub extern fn g_value_array_copy(value_array: [*c]const GValueArray) [*c]GValueArray;
pub extern fn g_value_array_prepend(value_array: [*c]GValueArray, value: [*c]const GValue) [*c]GValueArray;
pub extern fn g_value_array_append(value_array: [*c]GValueArray, value: [*c]const GValue) [*c]GValueArray;
pub extern fn g_value_array_insert(value_array: [*c]GValueArray, index_: guint, value: [*c]const GValue) [*c]GValueArray;
pub extern fn g_value_array_remove(value_array: [*c]GValueArray, index_: guint) [*c]GValueArray;
pub extern fn g_value_array_sort(value_array: [*c]GValueArray, compare_func: GCompareFunc) [*c]GValueArray;
pub extern fn g_value_array_sort_with_data(value_array: [*c]GValueArray, compare_func: GCompareDataFunc, user_data: gpointer) [*c]GValueArray;
pub extern fn g_value_set_char(value: [*c]GValue, v_char: gchar) void;
pub extern fn g_value_get_char(value: [*c]const GValue) gchar;
pub extern fn g_value_set_schar(value: [*c]GValue, v_char: gint8) void;
pub extern fn g_value_get_schar(value: [*c]const GValue) gint8;
pub extern fn g_value_set_uchar(value: [*c]GValue, v_uchar: guchar) void;
pub extern fn g_value_get_uchar(value: [*c]const GValue) guchar;
pub extern fn g_value_set_boolean(value: [*c]GValue, v_boolean: gboolean) void;
pub extern fn g_value_get_boolean(value: [*c]const GValue) gboolean;
pub extern fn g_value_set_int(value: [*c]GValue, v_int: gint) void;
pub extern fn g_value_get_int(value: [*c]const GValue) gint;
pub extern fn g_value_set_uint(value: [*c]GValue, v_uint: guint) void;
pub extern fn g_value_get_uint(value: [*c]const GValue) guint;
pub extern fn g_value_set_long(value: [*c]GValue, v_long: glong) void;
pub extern fn g_value_get_long(value: [*c]const GValue) glong;
pub extern fn g_value_set_ulong(value: [*c]GValue, v_ulong: gulong) void;
pub extern fn g_value_get_ulong(value: [*c]const GValue) gulong;
pub extern fn g_value_set_int64(value: [*c]GValue, v_int64: gint64) void;
pub extern fn g_value_get_int64(value: [*c]const GValue) gint64;
pub extern fn g_value_set_uint64(value: [*c]GValue, v_uint64: guint64) void;
pub extern fn g_value_get_uint64(value: [*c]const GValue) guint64;
pub extern fn g_value_set_float(value: [*c]GValue, v_float: gfloat) void;
pub extern fn g_value_get_float(value: [*c]const GValue) gfloat;
pub extern fn g_value_set_double(value: [*c]GValue, v_double: gdouble) void;
pub extern fn g_value_get_double(value: [*c]const GValue) gdouble;
pub extern fn g_value_set_string(value: [*c]GValue, v_string: [*c]const gchar) void;
pub extern fn g_value_set_static_string(value: [*c]GValue, v_string: [*c]const gchar) void;
pub extern fn g_value_get_string(value: [*c]const GValue) [*c]const gchar;
pub extern fn g_value_dup_string(value: [*c]const GValue) [*c]gchar;
pub extern fn g_value_set_pointer(value: [*c]GValue, v_pointer: gpointer) void;
pub extern fn g_value_get_pointer(value: [*c]const GValue) gpointer;
pub extern fn g_gtype_get_type() GType;
pub extern fn g_value_set_gtype(value: [*c]GValue, v_gtype: GType) void;
pub extern fn g_value_get_gtype(value: [*c]const GValue) GType;
pub extern fn g_value_set_variant(value: [*c]GValue, variant: ?*GVariant) void;
pub extern fn g_value_take_variant(value: [*c]GValue, variant: ?*GVariant) void;
pub extern fn g_value_get_variant(value: [*c]const GValue) ?*GVariant;
pub extern fn g_value_dup_variant(value: [*c]const GValue) ?*GVariant;
pub extern fn g_pointer_type_register_static(name: [*c]const gchar) GType;
pub extern fn g_strdup_value_contents(value: [*c]const GValue) [*c]gchar;
pub extern fn g_value_take_string(value: [*c]GValue, v_string: [*c]gchar) void;
pub extern fn g_value_set_string_take_ownership(value: [*c]GValue, v_string: [*c]gchar) void;
pub const gchararray = [*c]gchar;
pub extern fn g_unicode_type_get_type() GType;
pub extern fn g_unicode_break_type_get_type() GType;
pub extern fn g_unicode_script_get_type() GType;
pub extern fn g_normalize_mode_get_type() GType;
pub const GClosure_autoptr = ?*GClosure;
pub const GClosure_listautoptr = [*c]GList;
pub const GClosure_slistautoptr = [*c]GSList;
pub const GClosure_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GClosure(_ptr: ?*GClosure) void {
    if (_ptr != null) g_closure_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GClosure(_ptr: [*c](?*GClosure)) void {
    glib_autoptr_clear_GClosure(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GClosure(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_closure_unref)))));
}
pub fn glib_slistautoptr_cleanup_GClosure(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_closure_unref)))));
}
pub fn glib_queueautoptr_cleanup_GClosure(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_closure_unref)))));
}
pub const GEnumClass_autoptr = [*c]GEnumClass;
pub const GEnumClass_listautoptr = [*c]GList;
pub const GEnumClass_slistautoptr = [*c]GSList;
pub const GEnumClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GEnumClass(_ptr: [*c]GEnumClass) void {
    if (_ptr != null) g_type_class_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GEnumClass(_ptr: [*c]([*c]GEnumClass)) void {
    glib_autoptr_clear_GEnumClass(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GEnumClass(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_type_class_unref)))));
}
pub fn glib_slistautoptr_cleanup_GEnumClass(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_type_class_unref)))));
}
pub fn glib_queueautoptr_cleanup_GEnumClass(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_type_class_unref)))));
}
pub const GFlagsClass_autoptr = [*c]GFlagsClass;
pub const GFlagsClass_listautoptr = [*c]GList;
pub const GFlagsClass_slistautoptr = [*c]GSList;
pub const GFlagsClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFlagsClass(_ptr: [*c]GFlagsClass) void {
    if (_ptr != null) g_type_class_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GFlagsClass(_ptr: [*c]([*c]GFlagsClass)) void {
    glib_autoptr_clear_GFlagsClass(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GFlagsClass(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_type_class_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFlagsClass(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_type_class_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFlagsClass(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_type_class_unref)))));
}
pub const GObject_autoptr = [*c]GObject;
pub const GObject_listautoptr = [*c]GList;
pub const GObject_slistautoptr = [*c]GSList;
pub const GObject_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GObject(_ptr: [*c]GObject) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GObject(_ptr: [*c]([*c]GObject)) void {
    glib_autoptr_clear_GObject(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GObject(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GObject(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GObject(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GInitiallyUnowned_autoptr = [*c]GInitiallyUnowned;
pub const GInitiallyUnowned_listautoptr = [*c]GList;
pub const GInitiallyUnowned_slistautoptr = [*c]GSList;
pub const GInitiallyUnowned_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GInitiallyUnowned(_ptr: [*c]GInitiallyUnowned) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GInitiallyUnowned(_ptr: [*c]([*c]GInitiallyUnowned)) void {
    glib_autoptr_clear_GInitiallyUnowned(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GInitiallyUnowned(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GInitiallyUnowned(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GInitiallyUnowned(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GParamSpec_autoptr = [*c]GParamSpec;
pub const GParamSpec_listautoptr = [*c]GList;
pub const GParamSpec_slistautoptr = [*c]GSList;
pub const GParamSpec_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GParamSpec(_ptr: [*c]GParamSpec) void {
    if (_ptr != null) g_param_spec_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GParamSpec(_ptr: [*c]([*c]GParamSpec)) void {
    glib_autoptr_clear_GParamSpec(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GParamSpec(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_param_spec_unref)))));
}
pub fn glib_slistautoptr_cleanup_GParamSpec(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_param_spec_unref)))));
}
pub fn glib_queueautoptr_cleanup_GParamSpec(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_param_spec_unref)))));
}
pub const GTypeClass_autoptr = [*c]GTypeClass;
pub const GTypeClass_listautoptr = [*c]GList;
pub const GTypeClass_slistautoptr = [*c]GSList;
pub const GTypeClass_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTypeClass(_ptr: [*c]GTypeClass) void {
    if (_ptr != null) g_type_class_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTypeClass(_ptr: [*c]([*c]GTypeClass)) void {
    glib_autoptr_clear_GTypeClass(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTypeClass(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_type_class_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTypeClass(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_type_class_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTypeClass(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_type_class_unref)))));
}
pub fn glib_auto_cleanup_GValue(_ptr: [*c]GValue) void {
    g_value_unset.?(_ptr);
}
pub const G_APP_INFO_CREATE_NONE = 0;
pub const G_APP_INFO_CREATE_NEEDS_TERMINAL = 1;
pub const G_APP_INFO_CREATE_SUPPORTS_URIS = 2;
pub const G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION = 4;
pub const GAppInfoCreateFlags = extern enum {
    G_APP_INFO_CREATE_NONE = 0,
    G_APP_INFO_CREATE_NEEDS_TERMINAL = 1,
    G_APP_INFO_CREATE_SUPPORTS_URIS = 2,
    G_APP_INFO_CREATE_SUPPORTS_STARTUP_NOTIFICATION = 4,
};
pub const G_CONVERTER_NO_FLAGS = 0;
pub const G_CONVERTER_INPUT_AT_END = 1;
pub const G_CONVERTER_FLUSH = 2;
pub const GConverterFlags = extern enum {
    G_CONVERTER_NO_FLAGS = 0,
    G_CONVERTER_INPUT_AT_END = 1,
    G_CONVERTER_FLUSH = 2,
};
pub const G_CONVERTER_ERROR = 0;
pub const G_CONVERTER_CONVERTED = 1;
pub const G_CONVERTER_FINISHED = 2;
pub const G_CONVERTER_FLUSHED = 3;
pub const GConverterResult = extern enum {
    G_CONVERTER_ERROR = 0,
    G_CONVERTER_CONVERTED = 1,
    G_CONVERTER_FINISHED = 2,
    G_CONVERTER_FLUSHED = 3,
};
pub const G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN = 0;
pub const G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN = 1;
pub const G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN = 2;
pub const GDataStreamByteOrder = extern enum {
    G_DATA_STREAM_BYTE_ORDER_BIG_ENDIAN = 0,
    G_DATA_STREAM_BYTE_ORDER_LITTLE_ENDIAN = 1,
    G_DATA_STREAM_BYTE_ORDER_HOST_ENDIAN = 2,
};
pub const G_DATA_STREAM_NEWLINE_TYPE_LF = 0;
pub const G_DATA_STREAM_NEWLINE_TYPE_CR = 1;
pub const G_DATA_STREAM_NEWLINE_TYPE_CR_LF = 2;
pub const G_DATA_STREAM_NEWLINE_TYPE_ANY = 3;
pub const GDataStreamNewlineType = extern enum {
    G_DATA_STREAM_NEWLINE_TYPE_LF = 0,
    G_DATA_STREAM_NEWLINE_TYPE_CR = 1,
    G_DATA_STREAM_NEWLINE_TYPE_CR_LF = 2,
    G_DATA_STREAM_NEWLINE_TYPE_ANY = 3,
};
pub const G_FILE_ATTRIBUTE_TYPE_INVALID = 0;
pub const G_FILE_ATTRIBUTE_TYPE_STRING = 1;
pub const G_FILE_ATTRIBUTE_TYPE_BYTE_STRING = 2;
pub const G_FILE_ATTRIBUTE_TYPE_BOOLEAN = 3;
pub const G_FILE_ATTRIBUTE_TYPE_UINT32 = 4;
pub const G_FILE_ATTRIBUTE_TYPE_INT32 = 5;
pub const G_FILE_ATTRIBUTE_TYPE_UINT64 = 6;
pub const G_FILE_ATTRIBUTE_TYPE_INT64 = 7;
pub const G_FILE_ATTRIBUTE_TYPE_OBJECT = 8;
pub const G_FILE_ATTRIBUTE_TYPE_STRINGV = 9;
pub const GFileAttributeType = extern enum {
    G_FILE_ATTRIBUTE_TYPE_INVALID = 0,
    G_FILE_ATTRIBUTE_TYPE_STRING = 1,
    G_FILE_ATTRIBUTE_TYPE_BYTE_STRING = 2,
    G_FILE_ATTRIBUTE_TYPE_BOOLEAN = 3,
    G_FILE_ATTRIBUTE_TYPE_UINT32 = 4,
    G_FILE_ATTRIBUTE_TYPE_INT32 = 5,
    G_FILE_ATTRIBUTE_TYPE_UINT64 = 6,
    G_FILE_ATTRIBUTE_TYPE_INT64 = 7,
    G_FILE_ATTRIBUTE_TYPE_OBJECT = 8,
    G_FILE_ATTRIBUTE_TYPE_STRINGV = 9,
};
pub const G_FILE_ATTRIBUTE_INFO_NONE = 0;
pub const G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE = 1;
pub const G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED = 2;
pub const GFileAttributeInfoFlags = extern enum {
    G_FILE_ATTRIBUTE_INFO_NONE = 0,
    G_FILE_ATTRIBUTE_INFO_COPY_WITH_FILE = 1,
    G_FILE_ATTRIBUTE_INFO_COPY_WHEN_MOVED = 2,
};
pub const G_FILE_ATTRIBUTE_STATUS_UNSET = 0;
pub const G_FILE_ATTRIBUTE_STATUS_SET = 1;
pub const G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING = 2;
pub const GFileAttributeStatus = extern enum {
    G_FILE_ATTRIBUTE_STATUS_UNSET = 0,
    G_FILE_ATTRIBUTE_STATUS_SET = 1,
    G_FILE_ATTRIBUTE_STATUS_ERROR_SETTING = 2,
};
pub const G_FILE_QUERY_INFO_NONE = 0;
pub const G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS = 1;
pub const GFileQueryInfoFlags = extern enum {
    G_FILE_QUERY_INFO_NONE = 0,
    G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS = 1,
};
pub const G_FILE_CREATE_NONE = 0;
pub const G_FILE_CREATE_PRIVATE = 1;
pub const G_FILE_CREATE_REPLACE_DESTINATION = 2;
pub const GFileCreateFlags = extern enum {
    G_FILE_CREATE_NONE = 0,
    G_FILE_CREATE_PRIVATE = 1,
    G_FILE_CREATE_REPLACE_DESTINATION = 2,
};
pub const G_FILE_MEASURE_NONE = 0;
pub const G_FILE_MEASURE_REPORT_ANY_ERROR = 2;
pub const G_FILE_MEASURE_APPARENT_SIZE = 4;
pub const G_FILE_MEASURE_NO_XDEV = 8;
pub const GFileMeasureFlags = extern enum {
    G_FILE_MEASURE_NONE = 0,
    G_FILE_MEASURE_REPORT_ANY_ERROR = 2,
    G_FILE_MEASURE_APPARENT_SIZE = 4,
    G_FILE_MEASURE_NO_XDEV = 8,
};
pub const G_MOUNT_MOUNT_NONE = 0;
pub const GMountMountFlags = extern enum {
    G_MOUNT_MOUNT_NONE = 0,
};
pub const G_MOUNT_UNMOUNT_NONE = 0;
pub const G_MOUNT_UNMOUNT_FORCE = 1;
pub const GMountUnmountFlags = extern enum {
    G_MOUNT_UNMOUNT_NONE = 0,
    G_MOUNT_UNMOUNT_FORCE = 1,
};
pub const G_DRIVE_START_NONE = 0;
pub const GDriveStartFlags = extern enum {
    G_DRIVE_START_NONE = 0,
};
pub const G_DRIVE_START_STOP_TYPE_UNKNOWN = 0;
pub const G_DRIVE_START_STOP_TYPE_SHUTDOWN = 1;
pub const G_DRIVE_START_STOP_TYPE_NETWORK = 2;
pub const G_DRIVE_START_STOP_TYPE_MULTIDISK = 3;
pub const G_DRIVE_START_STOP_TYPE_PASSWORD = 4;
pub const GDriveStartStopType = extern enum {
    G_DRIVE_START_STOP_TYPE_UNKNOWN = 0,
    G_DRIVE_START_STOP_TYPE_SHUTDOWN = 1,
    G_DRIVE_START_STOP_TYPE_NETWORK = 2,
    G_DRIVE_START_STOP_TYPE_MULTIDISK = 3,
    G_DRIVE_START_STOP_TYPE_PASSWORD = 4,
};
pub const G_FILE_COPY_NONE = 0;
pub const G_FILE_COPY_OVERWRITE = 1;
pub const G_FILE_COPY_BACKUP = 2;
pub const G_FILE_COPY_NOFOLLOW_SYMLINKS = 4;
pub const G_FILE_COPY_ALL_METADATA = 8;
pub const G_FILE_COPY_NO_FALLBACK_FOR_MOVE = 16;
pub const G_FILE_COPY_TARGET_DEFAULT_PERMS = 32;
pub const GFileCopyFlags = extern enum {
    G_FILE_COPY_NONE = 0,
    G_FILE_COPY_OVERWRITE = 1,
    G_FILE_COPY_BACKUP = 2,
    G_FILE_COPY_NOFOLLOW_SYMLINKS = 4,
    G_FILE_COPY_ALL_METADATA = 8,
    G_FILE_COPY_NO_FALLBACK_FOR_MOVE = 16,
    G_FILE_COPY_TARGET_DEFAULT_PERMS = 32,
};
pub const G_FILE_MONITOR_NONE = 0;
pub const G_FILE_MONITOR_WATCH_MOUNTS = 1;
pub const G_FILE_MONITOR_SEND_MOVED = 2;
pub const G_FILE_MONITOR_WATCH_HARD_LINKS = 4;
pub const G_FILE_MONITOR_WATCH_MOVES = 8;
pub const GFileMonitorFlags = extern enum {
    G_FILE_MONITOR_NONE = 0,
    G_FILE_MONITOR_WATCH_MOUNTS = 1,
    G_FILE_MONITOR_SEND_MOVED = 2,
    G_FILE_MONITOR_WATCH_HARD_LINKS = 4,
    G_FILE_MONITOR_WATCH_MOVES = 8,
};
pub const G_FILE_TYPE_UNKNOWN = 0;
pub const G_FILE_TYPE_REGULAR = 1;
pub const G_FILE_TYPE_DIRECTORY = 2;
pub const G_FILE_TYPE_SYMBOLIC_LINK = 3;
pub const G_FILE_TYPE_SPECIAL = 4;
pub const G_FILE_TYPE_SHORTCUT = 5;
pub const G_FILE_TYPE_MOUNTABLE = 6;
pub const GFileType = extern enum {
    G_FILE_TYPE_UNKNOWN = 0,
    G_FILE_TYPE_REGULAR = 1,
    G_FILE_TYPE_DIRECTORY = 2,
    G_FILE_TYPE_SYMBOLIC_LINK = 3,
    G_FILE_TYPE_SPECIAL = 4,
    G_FILE_TYPE_SHORTCUT = 5,
    G_FILE_TYPE_MOUNTABLE = 6,
};
pub const G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS = 0;
pub const G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL = 1;
pub const G_FILESYSTEM_PREVIEW_TYPE_NEVER = 2;
pub const GFilesystemPreviewType = extern enum {
    G_FILESYSTEM_PREVIEW_TYPE_IF_ALWAYS = 0,
    G_FILESYSTEM_PREVIEW_TYPE_IF_LOCAL = 1,
    G_FILESYSTEM_PREVIEW_TYPE_NEVER = 2,
};
pub const G_FILE_MONITOR_EVENT_CHANGED = 0;
pub const G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT = 1;
pub const G_FILE_MONITOR_EVENT_DELETED = 2;
pub const G_FILE_MONITOR_EVENT_CREATED = 3;
pub const G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED = 4;
pub const G_FILE_MONITOR_EVENT_PRE_UNMOUNT = 5;
pub const G_FILE_MONITOR_EVENT_UNMOUNTED = 6;
pub const G_FILE_MONITOR_EVENT_MOVED = 7;
pub const G_FILE_MONITOR_EVENT_RENAMED = 8;
pub const G_FILE_MONITOR_EVENT_MOVED_IN = 9;
pub const G_FILE_MONITOR_EVENT_MOVED_OUT = 10;
pub const GFileMonitorEvent = extern enum {
    G_FILE_MONITOR_EVENT_CHANGED = 0,
    G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT = 1,
    G_FILE_MONITOR_EVENT_DELETED = 2,
    G_FILE_MONITOR_EVENT_CREATED = 3,
    G_FILE_MONITOR_EVENT_ATTRIBUTE_CHANGED = 4,
    G_FILE_MONITOR_EVENT_PRE_UNMOUNT = 5,
    G_FILE_MONITOR_EVENT_UNMOUNTED = 6,
    G_FILE_MONITOR_EVENT_MOVED = 7,
    G_FILE_MONITOR_EVENT_RENAMED = 8,
    G_FILE_MONITOR_EVENT_MOVED_IN = 9,
    G_FILE_MONITOR_EVENT_MOVED_OUT = 10,
};
pub const G_IO_ERROR_FAILED = 0;
pub const G_IO_ERROR_NOT_FOUND = 1;
pub const G_IO_ERROR_EXISTS = 2;
pub const G_IO_ERROR_IS_DIRECTORY = 3;
pub const G_IO_ERROR_NOT_DIRECTORY = 4;
pub const G_IO_ERROR_NOT_EMPTY = 5;
pub const G_IO_ERROR_NOT_REGULAR_FILE = 6;
pub const G_IO_ERROR_NOT_SYMBOLIC_LINK = 7;
pub const G_IO_ERROR_NOT_MOUNTABLE_FILE = 8;
pub const G_IO_ERROR_FILENAME_TOO_LONG = 9;
pub const G_IO_ERROR_INVALID_FILENAME = 10;
pub const G_IO_ERROR_TOO_MANY_LINKS = 11;
pub const G_IO_ERROR_NO_SPACE = 12;
pub const G_IO_ERROR_INVALID_ARGUMENT = 13;
pub const G_IO_ERROR_PERMISSION_DENIED = 14;
pub const G_IO_ERROR_NOT_SUPPORTED = 15;
pub const G_IO_ERROR_NOT_MOUNTED = 16;
pub const G_IO_ERROR_ALREADY_MOUNTED = 17;
pub const G_IO_ERROR_CLOSED = 18;
pub const G_IO_ERROR_CANCELLED = 19;
pub const G_IO_ERROR_PENDING = 20;
pub const G_IO_ERROR_READ_ONLY = 21;
pub const G_IO_ERROR_CANT_CREATE_BACKUP = 22;
pub const G_IO_ERROR_WRONG_ETAG = 23;
pub const G_IO_ERROR_TIMED_OUT = 24;
pub const G_IO_ERROR_WOULD_RECURSE = 25;
pub const G_IO_ERROR_BUSY = 26;
pub const G_IO_ERROR_WOULD_BLOCK = 27;
pub const G_IO_ERROR_HOST_NOT_FOUND = 28;
pub const G_IO_ERROR_WOULD_MERGE = 29;
pub const G_IO_ERROR_FAILED_HANDLED = 30;
pub const G_IO_ERROR_TOO_MANY_OPEN_FILES = 31;
pub const G_IO_ERROR_NOT_INITIALIZED = 32;
pub const G_IO_ERROR_ADDRESS_IN_USE = 33;
pub const G_IO_ERROR_PARTIAL_INPUT = 34;
pub const G_IO_ERROR_INVALID_DATA = 35;
pub const G_IO_ERROR_DBUS_ERROR = 36;
pub const G_IO_ERROR_HOST_UNREACHABLE = 37;
pub const G_IO_ERROR_NETWORK_UNREACHABLE = 38;
pub const G_IO_ERROR_CONNECTION_REFUSED = 39;
pub const G_IO_ERROR_PROXY_FAILED = 40;
pub const G_IO_ERROR_PROXY_AUTH_FAILED = 41;
pub const G_IO_ERROR_PROXY_NEED_AUTH = 42;
pub const G_IO_ERROR_PROXY_NOT_ALLOWED = 43;
pub const G_IO_ERROR_BROKEN_PIPE = 44;
pub const G_IO_ERROR_CONNECTION_CLOSED = 44;
pub const G_IO_ERROR_NOT_CONNECTED = 45;
pub const G_IO_ERROR_MESSAGE_TOO_LARGE = 46;
pub const GIOErrorEnum = extern enum {
    G_IO_ERROR_FAILED = 0,
    G_IO_ERROR_NOT_FOUND = 1,
    G_IO_ERROR_EXISTS = 2,
    G_IO_ERROR_IS_DIRECTORY = 3,
    G_IO_ERROR_NOT_DIRECTORY = 4,
    G_IO_ERROR_NOT_EMPTY = 5,
    G_IO_ERROR_NOT_REGULAR_FILE = 6,
    G_IO_ERROR_NOT_SYMBOLIC_LINK = 7,
    G_IO_ERROR_NOT_MOUNTABLE_FILE = 8,
    G_IO_ERROR_FILENAME_TOO_LONG = 9,
    G_IO_ERROR_INVALID_FILENAME = 10,
    G_IO_ERROR_TOO_MANY_LINKS = 11,
    G_IO_ERROR_NO_SPACE = 12,
    G_IO_ERROR_INVALID_ARGUMENT = 13,
    G_IO_ERROR_PERMISSION_DENIED = 14,
    G_IO_ERROR_NOT_SUPPORTED = 15,
    G_IO_ERROR_NOT_MOUNTED = 16,
    G_IO_ERROR_ALREADY_MOUNTED = 17,
    G_IO_ERROR_CLOSED = 18,
    G_IO_ERROR_CANCELLED = 19,
    G_IO_ERROR_PENDING = 20,
    G_IO_ERROR_READ_ONLY = 21,
    G_IO_ERROR_CANT_CREATE_BACKUP = 22,
    G_IO_ERROR_WRONG_ETAG = 23,
    G_IO_ERROR_TIMED_OUT = 24,
    G_IO_ERROR_WOULD_RECURSE = 25,
    G_IO_ERROR_BUSY = 26,
    G_IO_ERROR_WOULD_BLOCK = 27,
    G_IO_ERROR_HOST_NOT_FOUND = 28,
    G_IO_ERROR_WOULD_MERGE = 29,
    G_IO_ERROR_FAILED_HANDLED = 30,
    G_IO_ERROR_TOO_MANY_OPEN_FILES = 31,
    G_IO_ERROR_NOT_INITIALIZED = 32,
    G_IO_ERROR_ADDRESS_IN_USE = 33,
    G_IO_ERROR_PARTIAL_INPUT = 34,
    G_IO_ERROR_INVALID_DATA = 35,
    G_IO_ERROR_DBUS_ERROR = 36,
    G_IO_ERROR_HOST_UNREACHABLE = 37,
    G_IO_ERROR_NETWORK_UNREACHABLE = 38,
    G_IO_ERROR_CONNECTION_REFUSED = 39,
    G_IO_ERROR_PROXY_FAILED = 40,
    G_IO_ERROR_PROXY_AUTH_FAILED = 41,
    G_IO_ERROR_PROXY_NEED_AUTH = 42,
    G_IO_ERROR_PROXY_NOT_ALLOWED = 43,
    G_IO_ERROR_BROKEN_PIPE = 44,
    G_IO_ERROR_CONNECTION_CLOSED = 44,
    G_IO_ERROR_NOT_CONNECTED = 45,
    G_IO_ERROR_MESSAGE_TOO_LARGE = 46,
};
pub const G_ASK_PASSWORD_NEED_PASSWORD = 1;
pub const G_ASK_PASSWORD_NEED_USERNAME = 2;
pub const G_ASK_PASSWORD_NEED_DOMAIN = 4;
pub const G_ASK_PASSWORD_SAVING_SUPPORTED = 8;
pub const G_ASK_PASSWORD_ANONYMOUS_SUPPORTED = 16;
pub const G_ASK_PASSWORD_TCRYPT = 32;
pub const GAskPasswordFlags = extern enum {
    G_ASK_PASSWORD_NEED_PASSWORD = 1,
    G_ASK_PASSWORD_NEED_USERNAME = 2,
    G_ASK_PASSWORD_NEED_DOMAIN = 4,
    G_ASK_PASSWORD_SAVING_SUPPORTED = 8,
    G_ASK_PASSWORD_ANONYMOUS_SUPPORTED = 16,
    G_ASK_PASSWORD_TCRYPT = 32,
};
pub const G_PASSWORD_SAVE_NEVER = 0;
pub const G_PASSWORD_SAVE_FOR_SESSION = 1;
pub const G_PASSWORD_SAVE_PERMANENTLY = 2;
pub const GPasswordSave = extern enum {
    G_PASSWORD_SAVE_NEVER = 0,
    G_PASSWORD_SAVE_FOR_SESSION = 1,
    G_PASSWORD_SAVE_PERMANENTLY = 2,
};
pub const G_MOUNT_OPERATION_HANDLED = 0;
pub const G_MOUNT_OPERATION_ABORTED = 1;
pub const G_MOUNT_OPERATION_UNHANDLED = 2;
pub const GMountOperationResult = extern enum {
    G_MOUNT_OPERATION_HANDLED = 0,
    G_MOUNT_OPERATION_ABORTED = 1,
    G_MOUNT_OPERATION_UNHANDLED = 2,
};
pub const G_OUTPUT_STREAM_SPLICE_NONE = 0;
pub const G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE = 1;
pub const G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET = 2;
pub const GOutputStreamSpliceFlags = extern enum {
    G_OUTPUT_STREAM_SPLICE_NONE = 0,
    G_OUTPUT_STREAM_SPLICE_CLOSE_SOURCE = 1,
    G_OUTPUT_STREAM_SPLICE_CLOSE_TARGET = 2,
};
pub const G_IO_STREAM_SPLICE_NONE = 0;
pub const G_IO_STREAM_SPLICE_CLOSE_STREAM1 = 1;
pub const G_IO_STREAM_SPLICE_CLOSE_STREAM2 = 2;
pub const G_IO_STREAM_SPLICE_WAIT_FOR_BOTH = 4;
pub const GIOStreamSpliceFlags = extern enum {
    G_IO_STREAM_SPLICE_NONE = 0,
    G_IO_STREAM_SPLICE_CLOSE_STREAM1 = 1,
    G_IO_STREAM_SPLICE_CLOSE_STREAM2 = 2,
    G_IO_STREAM_SPLICE_WAIT_FOR_BOTH = 4,
};
pub const G_EMBLEM_ORIGIN_UNKNOWN = 0;
pub const G_EMBLEM_ORIGIN_DEVICE = 1;
pub const G_EMBLEM_ORIGIN_LIVEMETADATA = 2;
pub const G_EMBLEM_ORIGIN_TAG = 3;
pub const GEmblemOrigin = extern enum {
    G_EMBLEM_ORIGIN_UNKNOWN = 0,
    G_EMBLEM_ORIGIN_DEVICE = 1,
    G_EMBLEM_ORIGIN_LIVEMETADATA = 2,
    G_EMBLEM_ORIGIN_TAG = 3,
};
pub const G_RESOLVER_ERROR_NOT_FOUND = 0;
pub const G_RESOLVER_ERROR_TEMPORARY_FAILURE = 1;
pub const G_RESOLVER_ERROR_INTERNAL = 2;
pub const GResolverError = extern enum {
    G_RESOLVER_ERROR_NOT_FOUND = 0,
    G_RESOLVER_ERROR_TEMPORARY_FAILURE = 1,
    G_RESOLVER_ERROR_INTERNAL = 2,
};
pub const G_RESOLVER_RECORD_SRV = 1;
pub const G_RESOLVER_RECORD_MX = 2;
pub const G_RESOLVER_RECORD_TXT = 3;
pub const G_RESOLVER_RECORD_SOA = 4;
pub const G_RESOLVER_RECORD_NS = 5;
pub const GResolverRecordType = extern enum {
    G_RESOLVER_RECORD_SRV = 1,
    G_RESOLVER_RECORD_MX = 2,
    G_RESOLVER_RECORD_TXT = 3,
    G_RESOLVER_RECORD_SOA = 4,
    G_RESOLVER_RECORD_NS = 5,
};
pub const G_RESOURCE_ERROR_NOT_FOUND = 0;
pub const G_RESOURCE_ERROR_INTERNAL = 1;
pub const GResourceError = extern enum {
    G_RESOURCE_ERROR_NOT_FOUND = 0,
    G_RESOURCE_ERROR_INTERNAL = 1,
};
pub const G_RESOURCE_FLAGS_NONE = 0;
pub const G_RESOURCE_FLAGS_COMPRESSED = 1;
pub const GResourceFlags = extern enum {
    G_RESOURCE_FLAGS_NONE = 0,
    G_RESOURCE_FLAGS_COMPRESSED = 1,
};
pub const G_RESOURCE_LOOKUP_FLAGS_NONE = 0;
pub const GResourceLookupFlags = extern enum {
    G_RESOURCE_LOOKUP_FLAGS_NONE = 0,
};
pub const G_SOCKET_FAMILY_INVALID = 0;
pub const G_SOCKET_FAMILY_UNIX = 1;
pub const G_SOCKET_FAMILY_IPV4 = 2;
pub const G_SOCKET_FAMILY_IPV6 = 23;
pub const GSocketFamily = extern enum {
    G_SOCKET_FAMILY_INVALID = 0,
    G_SOCKET_FAMILY_UNIX = 1,
    G_SOCKET_FAMILY_IPV4 = 2,
    G_SOCKET_FAMILY_IPV6 = 23,
};
pub const G_SOCKET_TYPE_INVALID = 0;
pub const G_SOCKET_TYPE_STREAM = 1;
pub const G_SOCKET_TYPE_DATAGRAM = 2;
pub const G_SOCKET_TYPE_SEQPACKET = 3;
pub const GSocketType = extern enum {
    G_SOCKET_TYPE_INVALID = 0,
    G_SOCKET_TYPE_STREAM = 1,
    G_SOCKET_TYPE_DATAGRAM = 2,
    G_SOCKET_TYPE_SEQPACKET = 3,
};
pub const G_SOCKET_MSG_NONE = 0;
pub const G_SOCKET_MSG_OOB = 1;
pub const G_SOCKET_MSG_PEEK = 2;
pub const G_SOCKET_MSG_DONTROUTE = 4;
pub const GSocketMsgFlags = extern enum {
    G_SOCKET_MSG_NONE = 0,
    G_SOCKET_MSG_OOB = 1,
    G_SOCKET_MSG_PEEK = 2,
    G_SOCKET_MSG_DONTROUTE = 4,
};
pub const G_SOCKET_PROTOCOL_UNKNOWN = -1;
pub const G_SOCKET_PROTOCOL_DEFAULT = 0;
pub const G_SOCKET_PROTOCOL_TCP = 6;
pub const G_SOCKET_PROTOCOL_UDP = 17;
pub const G_SOCKET_PROTOCOL_SCTP = 132;
pub const GSocketProtocol = extern enum {
    G_SOCKET_PROTOCOL_UNKNOWN = -1,
    G_SOCKET_PROTOCOL_DEFAULT = 0,
    G_SOCKET_PROTOCOL_TCP = 6,
    G_SOCKET_PROTOCOL_UDP = 17,
    G_SOCKET_PROTOCOL_SCTP = 132,
};
pub const G_ZLIB_COMPRESSOR_FORMAT_ZLIB = 0;
pub const G_ZLIB_COMPRESSOR_FORMAT_GZIP = 1;
pub const G_ZLIB_COMPRESSOR_FORMAT_RAW = 2;
pub const GZlibCompressorFormat = extern enum {
    G_ZLIB_COMPRESSOR_FORMAT_ZLIB = 0,
    G_ZLIB_COMPRESSOR_FORMAT_GZIP = 1,
    G_ZLIB_COMPRESSOR_FORMAT_RAW = 2,
};
pub const G_UNIX_SOCKET_ADDRESS_INVALID = 0;
pub const G_UNIX_SOCKET_ADDRESS_ANONYMOUS = 1;
pub const G_UNIX_SOCKET_ADDRESS_PATH = 2;
pub const G_UNIX_SOCKET_ADDRESS_ABSTRACT = 3;
pub const G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED = 4;
pub const GUnixSocketAddressType = extern enum {
    G_UNIX_SOCKET_ADDRESS_INVALID = 0,
    G_UNIX_SOCKET_ADDRESS_ANONYMOUS = 1,
    G_UNIX_SOCKET_ADDRESS_PATH = 2,
    G_UNIX_SOCKET_ADDRESS_ABSTRACT = 3,
    G_UNIX_SOCKET_ADDRESS_ABSTRACT_PADDED = 4,
};
pub const G_BUS_TYPE_STARTER = -1;
pub const G_BUS_TYPE_NONE = 0;
pub const G_BUS_TYPE_SYSTEM = 1;
pub const G_BUS_TYPE_SESSION = 2;
pub const GBusType = extern enum {
    G_BUS_TYPE_STARTER = -1,
    G_BUS_TYPE_NONE = 0,
    G_BUS_TYPE_SYSTEM = 1,
    G_BUS_TYPE_SESSION = 2,
};
pub const G_BUS_NAME_OWNER_FLAGS_NONE = 0;
pub const G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT = 1;
pub const G_BUS_NAME_OWNER_FLAGS_REPLACE = 2;
pub const G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE = 4;
pub const GBusNameOwnerFlags = extern enum {
    G_BUS_NAME_OWNER_FLAGS_NONE = 0,
    G_BUS_NAME_OWNER_FLAGS_ALLOW_REPLACEMENT = 1,
    G_BUS_NAME_OWNER_FLAGS_REPLACE = 2,
    G_BUS_NAME_OWNER_FLAGS_DO_NOT_QUEUE = 4,
};
pub const G_BUS_NAME_WATCHER_FLAGS_NONE = 0;
pub const G_BUS_NAME_WATCHER_FLAGS_AUTO_START = 1;
pub const GBusNameWatcherFlags = extern enum {
    G_BUS_NAME_WATCHER_FLAGS_NONE = 0,
    G_BUS_NAME_WATCHER_FLAGS_AUTO_START = 1,
};
pub const G_DBUS_PROXY_FLAGS_NONE = 0;
pub const G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = 1;
pub const G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = 2;
pub const G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = 4;
pub const G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = 8;
pub const G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION = 16;
pub const GDBusProxyFlags = extern enum {
    G_DBUS_PROXY_FLAGS_NONE = 0,
    G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES = 1,
    G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS = 2,
    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START = 4,
    G_DBUS_PROXY_FLAGS_GET_INVALIDATED_PROPERTIES = 8,
    G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START_AT_CONSTRUCTION = 16,
};
pub const G_DBUS_ERROR_FAILED = 0;
pub const G_DBUS_ERROR_NO_MEMORY = 1;
pub const G_DBUS_ERROR_SERVICE_UNKNOWN = 2;
pub const G_DBUS_ERROR_NAME_HAS_NO_OWNER = 3;
pub const G_DBUS_ERROR_NO_REPLY = 4;
pub const G_DBUS_ERROR_IO_ERROR = 5;
pub const G_DBUS_ERROR_BAD_ADDRESS = 6;
pub const G_DBUS_ERROR_NOT_SUPPORTED = 7;
pub const G_DBUS_ERROR_LIMITS_EXCEEDED = 8;
pub const G_DBUS_ERROR_ACCESS_DENIED = 9;
pub const G_DBUS_ERROR_AUTH_FAILED = 10;
pub const G_DBUS_ERROR_NO_SERVER = 11;
pub const G_DBUS_ERROR_TIMEOUT = 12;
pub const G_DBUS_ERROR_NO_NETWORK = 13;
pub const G_DBUS_ERROR_ADDRESS_IN_USE = 14;
pub const G_DBUS_ERROR_DISCONNECTED = 15;
pub const G_DBUS_ERROR_INVALID_ARGS = 16;
pub const G_DBUS_ERROR_FILE_NOT_FOUND = 17;
pub const G_DBUS_ERROR_FILE_EXISTS = 18;
pub const G_DBUS_ERROR_UNKNOWN_METHOD = 19;
pub const G_DBUS_ERROR_TIMED_OUT = 20;
pub const G_DBUS_ERROR_MATCH_RULE_NOT_FOUND = 21;
pub const G_DBUS_ERROR_MATCH_RULE_INVALID = 22;
pub const G_DBUS_ERROR_SPAWN_EXEC_FAILED = 23;
pub const G_DBUS_ERROR_SPAWN_FORK_FAILED = 24;
pub const G_DBUS_ERROR_SPAWN_CHILD_EXITED = 25;
pub const G_DBUS_ERROR_SPAWN_CHILD_SIGNALED = 26;
pub const G_DBUS_ERROR_SPAWN_FAILED = 27;
pub const G_DBUS_ERROR_SPAWN_SETUP_FAILED = 28;
pub const G_DBUS_ERROR_SPAWN_CONFIG_INVALID = 29;
pub const G_DBUS_ERROR_SPAWN_SERVICE_INVALID = 30;
pub const G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND = 31;
pub const G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID = 32;
pub const G_DBUS_ERROR_SPAWN_FILE_INVALID = 33;
pub const G_DBUS_ERROR_SPAWN_NO_MEMORY = 34;
pub const G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN = 35;
pub const G_DBUS_ERROR_INVALID_SIGNATURE = 36;
pub const G_DBUS_ERROR_INVALID_FILE_CONTENT = 37;
pub const G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN = 38;
pub const G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN = 39;
pub const G_DBUS_ERROR_OBJECT_PATH_IN_USE = 40;
pub const G_DBUS_ERROR_UNKNOWN_OBJECT = 41;
pub const G_DBUS_ERROR_UNKNOWN_INTERFACE = 42;
pub const G_DBUS_ERROR_UNKNOWN_PROPERTY = 43;
pub const G_DBUS_ERROR_PROPERTY_READ_ONLY = 44;
pub const GDBusError = extern enum {
    G_DBUS_ERROR_FAILED = 0,
    G_DBUS_ERROR_NO_MEMORY = 1,
    G_DBUS_ERROR_SERVICE_UNKNOWN = 2,
    G_DBUS_ERROR_NAME_HAS_NO_OWNER = 3,
    G_DBUS_ERROR_NO_REPLY = 4,
    G_DBUS_ERROR_IO_ERROR = 5,
    G_DBUS_ERROR_BAD_ADDRESS = 6,
    G_DBUS_ERROR_NOT_SUPPORTED = 7,
    G_DBUS_ERROR_LIMITS_EXCEEDED = 8,
    G_DBUS_ERROR_ACCESS_DENIED = 9,
    G_DBUS_ERROR_AUTH_FAILED = 10,
    G_DBUS_ERROR_NO_SERVER = 11,
    G_DBUS_ERROR_TIMEOUT = 12,
    G_DBUS_ERROR_NO_NETWORK = 13,
    G_DBUS_ERROR_ADDRESS_IN_USE = 14,
    G_DBUS_ERROR_DISCONNECTED = 15,
    G_DBUS_ERROR_INVALID_ARGS = 16,
    G_DBUS_ERROR_FILE_NOT_FOUND = 17,
    G_DBUS_ERROR_FILE_EXISTS = 18,
    G_DBUS_ERROR_UNKNOWN_METHOD = 19,
    G_DBUS_ERROR_TIMED_OUT = 20,
    G_DBUS_ERROR_MATCH_RULE_NOT_FOUND = 21,
    G_DBUS_ERROR_MATCH_RULE_INVALID = 22,
    G_DBUS_ERROR_SPAWN_EXEC_FAILED = 23,
    G_DBUS_ERROR_SPAWN_FORK_FAILED = 24,
    G_DBUS_ERROR_SPAWN_CHILD_EXITED = 25,
    G_DBUS_ERROR_SPAWN_CHILD_SIGNALED = 26,
    G_DBUS_ERROR_SPAWN_FAILED = 27,
    G_DBUS_ERROR_SPAWN_SETUP_FAILED = 28,
    G_DBUS_ERROR_SPAWN_CONFIG_INVALID = 29,
    G_DBUS_ERROR_SPAWN_SERVICE_INVALID = 30,
    G_DBUS_ERROR_SPAWN_SERVICE_NOT_FOUND = 31,
    G_DBUS_ERROR_SPAWN_PERMISSIONS_INVALID = 32,
    G_DBUS_ERROR_SPAWN_FILE_INVALID = 33,
    G_DBUS_ERROR_SPAWN_NO_MEMORY = 34,
    G_DBUS_ERROR_UNIX_PROCESS_ID_UNKNOWN = 35,
    G_DBUS_ERROR_INVALID_SIGNATURE = 36,
    G_DBUS_ERROR_INVALID_FILE_CONTENT = 37,
    G_DBUS_ERROR_SELINUX_SECURITY_CONTEXT_UNKNOWN = 38,
    G_DBUS_ERROR_ADT_AUDIT_DATA_UNKNOWN = 39,
    G_DBUS_ERROR_OBJECT_PATH_IN_USE = 40,
    G_DBUS_ERROR_UNKNOWN_OBJECT = 41,
    G_DBUS_ERROR_UNKNOWN_INTERFACE = 42,
    G_DBUS_ERROR_UNKNOWN_PROPERTY = 43,
    G_DBUS_ERROR_PROPERTY_READ_ONLY = 44,
};
pub const G_DBUS_CONNECTION_FLAGS_NONE = 0;
pub const G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT = 1;
pub const G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER = 2;
pub const G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 4;
pub const G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION = 8;
pub const G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING = 16;
pub const GDBusConnectionFlags = extern enum {
    G_DBUS_CONNECTION_FLAGS_NONE = 0,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_CLIENT = 1,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_SERVER = 2,
    G_DBUS_CONNECTION_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 4,
    G_DBUS_CONNECTION_FLAGS_MESSAGE_BUS_CONNECTION = 8,
    G_DBUS_CONNECTION_FLAGS_DELAY_MESSAGE_PROCESSING = 16,
};
pub const G_DBUS_CAPABILITY_FLAGS_NONE = 0;
pub const G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING = 1;
pub const GDBusCapabilityFlags = extern enum {
    G_DBUS_CAPABILITY_FLAGS_NONE = 0,
    G_DBUS_CAPABILITY_FLAGS_UNIX_FD_PASSING = 1,
};
pub const G_DBUS_CALL_FLAGS_NONE = 0;
pub const G_DBUS_CALL_FLAGS_NO_AUTO_START = 1;
pub const G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 2;
pub const GDBusCallFlags = extern enum {
    G_DBUS_CALL_FLAGS_NONE = 0,
    G_DBUS_CALL_FLAGS_NO_AUTO_START = 1,
    G_DBUS_CALL_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 2,
};
pub const G_DBUS_MESSAGE_TYPE_INVALID = 0;
pub const G_DBUS_MESSAGE_TYPE_METHOD_CALL = 1;
pub const G_DBUS_MESSAGE_TYPE_METHOD_RETURN = 2;
pub const G_DBUS_MESSAGE_TYPE_ERROR = 3;
pub const G_DBUS_MESSAGE_TYPE_SIGNAL = 4;
pub const GDBusMessageType = extern enum {
    G_DBUS_MESSAGE_TYPE_INVALID = 0,
    G_DBUS_MESSAGE_TYPE_METHOD_CALL = 1,
    G_DBUS_MESSAGE_TYPE_METHOD_RETURN = 2,
    G_DBUS_MESSAGE_TYPE_ERROR = 3,
    G_DBUS_MESSAGE_TYPE_SIGNAL = 4,
};
pub const G_DBUS_MESSAGE_FLAGS_NONE = 0;
pub const G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED = 1;
pub const G_DBUS_MESSAGE_FLAGS_NO_AUTO_START = 2;
pub const G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 4;
pub const GDBusMessageFlags = extern enum {
    G_DBUS_MESSAGE_FLAGS_NONE = 0,
    G_DBUS_MESSAGE_FLAGS_NO_REPLY_EXPECTED = 1,
    G_DBUS_MESSAGE_FLAGS_NO_AUTO_START = 2,
    G_DBUS_MESSAGE_FLAGS_ALLOW_INTERACTIVE_AUTHORIZATION = 4,
};
pub const G_DBUS_MESSAGE_HEADER_FIELD_INVALID = 0;
pub const G_DBUS_MESSAGE_HEADER_FIELD_PATH = 1;
pub const G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE = 2;
pub const G_DBUS_MESSAGE_HEADER_FIELD_MEMBER = 3;
pub const G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME = 4;
pub const G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL = 5;
pub const G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION = 6;
pub const G_DBUS_MESSAGE_HEADER_FIELD_SENDER = 7;
pub const G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE = 8;
pub const G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS = 9;
pub const GDBusMessageHeaderField = extern enum {
    G_DBUS_MESSAGE_HEADER_FIELD_INVALID = 0,
    G_DBUS_MESSAGE_HEADER_FIELD_PATH = 1,
    G_DBUS_MESSAGE_HEADER_FIELD_INTERFACE = 2,
    G_DBUS_MESSAGE_HEADER_FIELD_MEMBER = 3,
    G_DBUS_MESSAGE_HEADER_FIELD_ERROR_NAME = 4,
    G_DBUS_MESSAGE_HEADER_FIELD_REPLY_SERIAL = 5,
    G_DBUS_MESSAGE_HEADER_FIELD_DESTINATION = 6,
    G_DBUS_MESSAGE_HEADER_FIELD_SENDER = 7,
    G_DBUS_MESSAGE_HEADER_FIELD_SIGNATURE = 8,
    G_DBUS_MESSAGE_HEADER_FIELD_NUM_UNIX_FDS = 9,
};
pub const G_DBUS_PROPERTY_INFO_FLAGS_NONE = 0;
pub const G_DBUS_PROPERTY_INFO_FLAGS_READABLE = 1;
pub const G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE = 2;
pub const GDBusPropertyInfoFlags = extern enum {
    G_DBUS_PROPERTY_INFO_FLAGS_NONE = 0,
    G_DBUS_PROPERTY_INFO_FLAGS_READABLE = 1,
    G_DBUS_PROPERTY_INFO_FLAGS_WRITABLE = 2,
};
pub const G_DBUS_SUBTREE_FLAGS_NONE = 0;
pub const G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES = 1;
pub const GDBusSubtreeFlags = extern enum {
    G_DBUS_SUBTREE_FLAGS_NONE = 0,
    G_DBUS_SUBTREE_FLAGS_DISPATCH_TO_UNENUMERATED_NODES = 1,
};
pub const G_DBUS_SERVER_FLAGS_NONE = 0;
pub const G_DBUS_SERVER_FLAGS_RUN_IN_THREAD = 1;
pub const G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 2;
pub const GDBusServerFlags = extern enum {
    G_DBUS_SERVER_FLAGS_NONE = 0,
    G_DBUS_SERVER_FLAGS_RUN_IN_THREAD = 1,
    G_DBUS_SERVER_FLAGS_AUTHENTICATION_ALLOW_ANONYMOUS = 2,
};
pub const G_DBUS_SIGNAL_FLAGS_NONE = 0;
pub const G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = 1;
pub const G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE = 2;
pub const G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH = 4;
pub const GDBusSignalFlags = extern enum {
    G_DBUS_SIGNAL_FLAGS_NONE = 0,
    G_DBUS_SIGNAL_FLAGS_NO_MATCH_RULE = 1,
    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_NAMESPACE = 2,
    G_DBUS_SIGNAL_FLAGS_MATCH_ARG0_PATH = 4,
};
pub const G_DBUS_SEND_MESSAGE_FLAGS_NONE = 0;
pub const G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL = 1;
pub const GDBusSendMessageFlags = extern enum {
    G_DBUS_SEND_MESSAGE_FLAGS_NONE = 0,
    G_DBUS_SEND_MESSAGE_FLAGS_PRESERVE_SERIAL = 1,
};
pub const G_CREDENTIALS_TYPE_INVALID = 0;
pub const G_CREDENTIALS_TYPE_LINUX_UCRED = 1;
pub const G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED = 2;
pub const G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED = 3;
pub const G_CREDENTIALS_TYPE_SOLARIS_UCRED = 4;
pub const G_CREDENTIALS_TYPE_NETBSD_UNPCBID = 5;
pub const GCredentialsType = extern enum {
    G_CREDENTIALS_TYPE_INVALID = 0,
    G_CREDENTIALS_TYPE_LINUX_UCRED = 1,
    G_CREDENTIALS_TYPE_FREEBSD_CMSGCRED = 2,
    G_CREDENTIALS_TYPE_OPENBSD_SOCKPEERCRED = 3,
    G_CREDENTIALS_TYPE_SOLARIS_UCRED = 4,
    G_CREDENTIALS_TYPE_NETBSD_UNPCBID = 5,
};
pub const G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN = 66;
pub const G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN = 108;
pub const GDBusMessageByteOrder = extern enum {
    G_DBUS_MESSAGE_BYTE_ORDER_BIG_ENDIAN = 66,
    G_DBUS_MESSAGE_BYTE_ORDER_LITTLE_ENDIAN = 108,
};
pub const G_APPLICATION_FLAGS_NONE = 0;
pub const G_APPLICATION_IS_SERVICE = 1;
pub const G_APPLICATION_IS_LAUNCHER = 2;
pub const G_APPLICATION_HANDLES_OPEN = 4;
pub const G_APPLICATION_HANDLES_COMMAND_LINE = 8;
pub const G_APPLICATION_SEND_ENVIRONMENT = 16;
pub const G_APPLICATION_NON_UNIQUE = 32;
pub const G_APPLICATION_CAN_OVERRIDE_APP_ID = 64;
pub const G_APPLICATION_ALLOW_REPLACEMENT = 128;
pub const G_APPLICATION_REPLACE = 256;
pub const GApplicationFlags = extern enum {
    G_APPLICATION_FLAGS_NONE = 0,
    G_APPLICATION_IS_SERVICE = 1,
    G_APPLICATION_IS_LAUNCHER = 2,
    G_APPLICATION_HANDLES_OPEN = 4,
    G_APPLICATION_HANDLES_COMMAND_LINE = 8,
    G_APPLICATION_SEND_ENVIRONMENT = 16,
    G_APPLICATION_NON_UNIQUE = 32,
    G_APPLICATION_CAN_OVERRIDE_APP_ID = 64,
    G_APPLICATION_ALLOW_REPLACEMENT = 128,
    G_APPLICATION_REPLACE = 256,
};
pub const G_TLS_ERROR_UNAVAILABLE = 0;
pub const G_TLS_ERROR_MISC = 1;
pub const G_TLS_ERROR_BAD_CERTIFICATE = 2;
pub const G_TLS_ERROR_NOT_TLS = 3;
pub const G_TLS_ERROR_HANDSHAKE = 4;
pub const G_TLS_ERROR_CERTIFICATE_REQUIRED = 5;
pub const G_TLS_ERROR_EOF = 6;
pub const G_TLS_ERROR_INAPPROPRIATE_FALLBACK = 7;
pub const GTlsError = extern enum {
    G_TLS_ERROR_UNAVAILABLE = 0,
    G_TLS_ERROR_MISC = 1,
    G_TLS_ERROR_BAD_CERTIFICATE = 2,
    G_TLS_ERROR_NOT_TLS = 3,
    G_TLS_ERROR_HANDSHAKE = 4,
    G_TLS_ERROR_CERTIFICATE_REQUIRED = 5,
    G_TLS_ERROR_EOF = 6,
    G_TLS_ERROR_INAPPROPRIATE_FALLBACK = 7,
};
pub const G_TLS_CERTIFICATE_UNKNOWN_CA = 1;
pub const G_TLS_CERTIFICATE_BAD_IDENTITY = 2;
pub const G_TLS_CERTIFICATE_NOT_ACTIVATED = 4;
pub const G_TLS_CERTIFICATE_EXPIRED = 8;
pub const G_TLS_CERTIFICATE_REVOKED = 16;
pub const G_TLS_CERTIFICATE_INSECURE = 32;
pub const G_TLS_CERTIFICATE_GENERIC_ERROR = 64;
pub const G_TLS_CERTIFICATE_VALIDATE_ALL = 127;
pub const GTlsCertificateFlags = extern enum {
    G_TLS_CERTIFICATE_UNKNOWN_CA = 1,
    G_TLS_CERTIFICATE_BAD_IDENTITY = 2,
    G_TLS_CERTIFICATE_NOT_ACTIVATED = 4,
    G_TLS_CERTIFICATE_EXPIRED = 8,
    G_TLS_CERTIFICATE_REVOKED = 16,
    G_TLS_CERTIFICATE_INSECURE = 32,
    G_TLS_CERTIFICATE_GENERIC_ERROR = 64,
    G_TLS_CERTIFICATE_VALIDATE_ALL = 127,
};
pub const G_TLS_AUTHENTICATION_NONE = 0;
pub const G_TLS_AUTHENTICATION_REQUESTED = 1;
pub const G_TLS_AUTHENTICATION_REQUIRED = 2;
pub const GTlsAuthenticationMode = extern enum {
    G_TLS_AUTHENTICATION_NONE = 0,
    G_TLS_AUTHENTICATION_REQUESTED = 1,
    G_TLS_AUTHENTICATION_REQUIRED = 2,
};
pub const G_TLS_REHANDSHAKE_NEVER = 0;
pub const G_TLS_REHANDSHAKE_SAFELY = 1;
pub const G_TLS_REHANDSHAKE_UNSAFELY = 2;
pub const GTlsRehandshakeMode = extern enum {
    G_TLS_REHANDSHAKE_NEVER = 0,
    G_TLS_REHANDSHAKE_SAFELY = 1,
    G_TLS_REHANDSHAKE_UNSAFELY = 2,
};
pub const G_TLS_PASSWORD_NONE = enum__GTlsPasswordFlags.G_TLS_PASSWORD_NONE;
pub const G_TLS_PASSWORD_RETRY = enum__GTlsPasswordFlags.G_TLS_PASSWORD_RETRY;
pub const G_TLS_PASSWORD_MANY_TRIES = enum__GTlsPasswordFlags.G_TLS_PASSWORD_MANY_TRIES;
pub const G_TLS_PASSWORD_FINAL_TRY = enum__GTlsPasswordFlags.G_TLS_PASSWORD_FINAL_TRY;
pub const enum__GTlsPasswordFlags = extern enum {
    G_TLS_PASSWORD_NONE = 0,
    G_TLS_PASSWORD_RETRY = 2,
    G_TLS_PASSWORD_MANY_TRIES = 4,
    G_TLS_PASSWORD_FINAL_TRY = 8,
};
pub const GTlsPasswordFlags = enum__GTlsPasswordFlags;
pub const G_TLS_INTERACTION_UNHANDLED = 0;
pub const G_TLS_INTERACTION_HANDLED = 1;
pub const G_TLS_INTERACTION_FAILED = 2;
pub const GTlsInteractionResult = extern enum {
    G_TLS_INTERACTION_UNHANDLED = 0,
    G_TLS_INTERACTION_HANDLED = 1,
    G_TLS_INTERACTION_FAILED = 2,
};
pub const G_DBUS_INTERFACE_SKELETON_FLAGS_NONE = 0;
pub const G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD = 1;
pub const GDBusInterfaceSkeletonFlags = extern enum {
    G_DBUS_INTERFACE_SKELETON_FLAGS_NONE = 0,
    G_DBUS_INTERFACE_SKELETON_FLAGS_HANDLE_METHOD_INVOCATIONS_IN_THREAD = 1,
};
pub const G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE = 0;
pub const G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START = 1;
pub const GDBusObjectManagerClientFlags = extern enum {
    G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_NONE = 0,
    G_DBUS_OBJECT_MANAGER_CLIENT_FLAGS_DO_NOT_AUTO_START = 1,
};
pub const G_TLS_DATABASE_VERIFY_NONE = 0;
pub const GTlsDatabaseVerifyFlags = extern enum {
    G_TLS_DATABASE_VERIFY_NONE = 0,
};
pub const G_TLS_DATABASE_LOOKUP_NONE = 0;
pub const G_TLS_DATABASE_LOOKUP_KEYPAIR = 1;
pub const GTlsDatabaseLookupFlags = extern enum {
    G_TLS_DATABASE_LOOKUP_NONE = 0,
    G_TLS_DATABASE_LOOKUP_KEYPAIR = 1,
};
pub const G_TLS_CERTIFICATE_REQUEST_NONE = 0;
pub const GTlsCertificateRequestFlags = extern enum {
    G_TLS_CERTIFICATE_REQUEST_NONE = 0,
};
pub const G_IO_MODULE_SCOPE_NONE = 0;
pub const G_IO_MODULE_SCOPE_BLOCK_DUPLICATES = 1;
pub const GIOModuleScopeFlags = extern enum {
    G_IO_MODULE_SCOPE_NONE = 0,
    G_IO_MODULE_SCOPE_BLOCK_DUPLICATES = 1,
};
pub const G_SOCKET_CLIENT_RESOLVING = 0;
pub const G_SOCKET_CLIENT_RESOLVED = 1;
pub const G_SOCKET_CLIENT_CONNECTING = 2;
pub const G_SOCKET_CLIENT_CONNECTED = 3;
pub const G_SOCKET_CLIENT_PROXY_NEGOTIATING = 4;
pub const G_SOCKET_CLIENT_PROXY_NEGOTIATED = 5;
pub const G_SOCKET_CLIENT_TLS_HANDSHAKING = 6;
pub const G_SOCKET_CLIENT_TLS_HANDSHAKED = 7;
pub const G_SOCKET_CLIENT_COMPLETE = 8;
pub const GSocketClientEvent = extern enum {
    G_SOCKET_CLIENT_RESOLVING = 0,
    G_SOCKET_CLIENT_RESOLVED = 1,
    G_SOCKET_CLIENT_CONNECTING = 2,
    G_SOCKET_CLIENT_CONNECTED = 3,
    G_SOCKET_CLIENT_PROXY_NEGOTIATING = 4,
    G_SOCKET_CLIENT_PROXY_NEGOTIATED = 5,
    G_SOCKET_CLIENT_TLS_HANDSHAKING = 6,
    G_SOCKET_CLIENT_TLS_HANDSHAKED = 7,
    G_SOCKET_CLIENT_COMPLETE = 8,
};
pub const G_SOCKET_LISTENER_BINDING = 0;
pub const G_SOCKET_LISTENER_BOUND = 1;
pub const G_SOCKET_LISTENER_LISTENING = 2;
pub const G_SOCKET_LISTENER_LISTENED = 3;
pub const GSocketListenerEvent = extern enum {
    G_SOCKET_LISTENER_BINDING = 0,
    G_SOCKET_LISTENER_BOUND = 1,
    G_SOCKET_LISTENER_LISTENING = 2,
    G_SOCKET_LISTENER_LISTENED = 3,
};
pub const G_TEST_DBUS_NONE = 0;
pub const GTestDBusFlags = extern enum {
    G_TEST_DBUS_NONE = 0,
};
pub const G_SUBPROCESS_FLAGS_NONE = 0;
pub const G_SUBPROCESS_FLAGS_STDIN_PIPE = 1;
pub const G_SUBPROCESS_FLAGS_STDIN_INHERIT = 2;
pub const G_SUBPROCESS_FLAGS_STDOUT_PIPE = 4;
pub const G_SUBPROCESS_FLAGS_STDOUT_SILENCE = 8;
pub const G_SUBPROCESS_FLAGS_STDERR_PIPE = 16;
pub const G_SUBPROCESS_FLAGS_STDERR_SILENCE = 32;
pub const G_SUBPROCESS_FLAGS_STDERR_MERGE = 64;
pub const G_SUBPROCESS_FLAGS_INHERIT_FDS = 128;
pub const GSubprocessFlags = extern enum {
    G_SUBPROCESS_FLAGS_NONE = 0,
    G_SUBPROCESS_FLAGS_STDIN_PIPE = 1,
    G_SUBPROCESS_FLAGS_STDIN_INHERIT = 2,
    G_SUBPROCESS_FLAGS_STDOUT_PIPE = 4,
    G_SUBPROCESS_FLAGS_STDOUT_SILENCE = 8,
    G_SUBPROCESS_FLAGS_STDERR_PIPE = 16,
    G_SUBPROCESS_FLAGS_STDERR_SILENCE = 32,
    G_SUBPROCESS_FLAGS_STDERR_MERGE = 64,
    G_SUBPROCESS_FLAGS_INHERIT_FDS = 128,
};
pub const G_NOTIFICATION_PRIORITY_NORMAL = 0;
pub const G_NOTIFICATION_PRIORITY_LOW = 1;
pub const G_NOTIFICATION_PRIORITY_HIGH = 2;
pub const G_NOTIFICATION_PRIORITY_URGENT = 3;
pub const GNotificationPriority = extern enum {
    G_NOTIFICATION_PRIORITY_NORMAL = 0,
    G_NOTIFICATION_PRIORITY_LOW = 1,
    G_NOTIFICATION_PRIORITY_HIGH = 2,
    G_NOTIFICATION_PRIORITY_URGENT = 3,
};
pub const G_NETWORK_CONNECTIVITY_LOCAL = 1;
pub const G_NETWORK_CONNECTIVITY_LIMITED = 2;
pub const G_NETWORK_CONNECTIVITY_PORTAL = 3;
pub const G_NETWORK_CONNECTIVITY_FULL = 4;
pub const GNetworkConnectivity = extern enum {
    G_NETWORK_CONNECTIVITY_LOCAL = 1,
    G_NETWORK_CONNECTIVITY_LIMITED = 2,
    G_NETWORK_CONNECTIVITY_PORTAL = 3,
    G_NETWORK_CONNECTIVITY_FULL = 4,
};
pub const G_POLLABLE_RETURN_FAILED = 0;
pub const G_POLLABLE_RETURN_OK = 1;
pub const G_POLLABLE_RETURN_WOULD_BLOCK = -27;
pub const GPollableReturn = extern enum {
    G_POLLABLE_RETURN_FAILED = 0,
    G_POLLABLE_RETURN_OK = 1,
    G_POLLABLE_RETURN_WOULD_BLOCK = -27,
};
pub const struct__GAppLaunchContextPrivate = @OpaqueType();
pub const GAppLaunchContextPrivate = struct__GAppLaunchContextPrivate;
pub const struct__GAppLaunchContext = extern struct {
    parent_instance: GObject,
    priv: ?*GAppLaunchContextPrivate,
};
pub const GAppLaunchContext = struct__GAppLaunchContext;
pub const struct__GAppInfo = @OpaqueType();
pub const GAppInfo = struct__GAppInfo;
pub const struct__GAsyncResult = @OpaqueType();
pub const GAsyncResult = struct__GAsyncResult;
pub const struct__GAsyncInitable = @OpaqueType();
pub const GAsyncInitable = struct__GAsyncInitable;
pub const struct__GInputStreamPrivate = @OpaqueType();
pub const GInputStreamPrivate = struct__GInputStreamPrivate;
pub const struct__GInputStream = extern struct {
    parent_instance: GObject,
    priv: ?*GInputStreamPrivate,
};
pub const GInputStream = struct__GInputStream;
pub const struct__GFilterInputStream = extern struct {
    parent_instance: GInputStream,
    base_stream: [*c]GInputStream,
};
pub const GFilterInputStream = struct__GFilterInputStream;
pub const struct__GBufferedInputStreamPrivate = @OpaqueType();
pub const GBufferedInputStreamPrivate = struct__GBufferedInputStreamPrivate;
pub const struct__GBufferedInputStream = extern struct {
    parent_instance: GFilterInputStream,
    priv: ?*GBufferedInputStreamPrivate,
};
pub const GBufferedInputStream = struct__GBufferedInputStream;
pub const struct__GOutputStreamPrivate = @OpaqueType();
pub const GOutputStreamPrivate = struct__GOutputStreamPrivate;
pub const struct__GOutputStream = extern struct {
    parent_instance: GObject,
    priv: ?*GOutputStreamPrivate,
};
pub const GOutputStream = struct__GOutputStream;
pub const struct__GFilterOutputStream = extern struct {
    parent_instance: GOutputStream,
    base_stream: [*c]GOutputStream,
};
pub const GFilterOutputStream = struct__GFilterOutputStream;
pub const struct__GBufferedOutputStreamPrivate = @OpaqueType();
pub const GBufferedOutputStreamPrivate = struct__GBufferedOutputStreamPrivate;
pub const struct__GBufferedOutputStream = extern struct {
    parent_instance: GFilterOutputStream,
    priv: ?*GBufferedOutputStreamPrivate,
};
pub const GBufferedOutputStream = struct__GBufferedOutputStream;
pub const struct__GCancellablePrivate = @OpaqueType();
pub const GCancellablePrivate = struct__GCancellablePrivate;
pub const struct__GCancellable = extern struct {
    parent_instance: GObject,
    priv: ?*GCancellablePrivate,
};
pub const GCancellable = struct__GCancellable;
pub const struct__GCharsetConverter = @OpaqueType();
pub const GCharsetConverter = struct__GCharsetConverter;
pub const struct__GConverter = @OpaqueType();
pub const GConverter = struct__GConverter;
pub const struct__GConverterInputStreamPrivate = @OpaqueType();
pub const GConverterInputStreamPrivate = struct__GConverterInputStreamPrivate;
pub const struct__GConverterInputStream = extern struct {
    parent_instance: GFilterInputStream,
    priv: ?*GConverterInputStreamPrivate,
};
pub const GConverterInputStream = struct__GConverterInputStream;
pub const struct__GConverterOutputStreamPrivate = @OpaqueType();
pub const GConverterOutputStreamPrivate = struct__GConverterOutputStreamPrivate;
pub const struct__GConverterOutputStream = extern struct {
    parent_instance: GFilterOutputStream,
    priv: ?*GConverterOutputStreamPrivate,
};
pub const GConverterOutputStream = struct__GConverterOutputStream;
pub const struct__GDatagramBased = @OpaqueType();
pub const GDatagramBased = struct__GDatagramBased;
pub const struct__GDataInputStreamPrivate = @OpaqueType();
pub const GDataInputStreamPrivate = struct__GDataInputStreamPrivate;
pub const struct__GDataInputStream = extern struct {
    parent_instance: GBufferedInputStream,
    priv: ?*GDataInputStreamPrivate,
};
pub const GDataInputStream = struct__GDataInputStream;
pub const struct__GSimplePermission = @OpaqueType();
pub const GSimplePermission = struct__GSimplePermission;
pub const struct__GZlibCompressor = @OpaqueType();
pub const GZlibCompressor = struct__GZlibCompressor;
pub const struct__GZlibDecompressor = @OpaqueType();
pub const GZlibDecompressor = struct__GZlibDecompressor;
pub const struct__GSimpleActionGroupPrivate = @OpaqueType();
pub const GSimpleActionGroupPrivate = struct__GSimpleActionGroupPrivate;
pub const struct__GSimpleActionGroup = extern struct {
    parent_instance: GObject,
    priv: ?*GSimpleActionGroupPrivate,
};
pub const GSimpleActionGroup = struct__GSimpleActionGroup;
pub const struct__GRemoteActionGroup = @OpaqueType();
pub const GRemoteActionGroup = struct__GRemoteActionGroup;
pub const struct__GDBusActionGroup = @OpaqueType();
pub const GDBusActionGroup = struct__GDBusActionGroup;
pub const struct__GActionMap = @OpaqueType();
pub const GActionMap = struct__GActionMap;
pub const struct__GActionGroup = @OpaqueType();
pub const GActionGroup = struct__GActionGroup;
pub const struct__GPropertyAction = @OpaqueType();
pub const GPropertyAction = struct__GPropertyAction;
pub const struct__GSimpleAction = @OpaqueType();
pub const GSimpleAction = struct__GSimpleAction;
pub const struct__GAction = @OpaqueType();
pub const GAction = struct__GAction;
pub const struct__GApplicationPrivate = @OpaqueType();
pub const GApplicationPrivate = struct__GApplicationPrivate;
pub const struct__GApplication = extern struct {
    parent_instance: GObject,
    priv: ?*GApplicationPrivate,
};
pub const GApplication = struct__GApplication;
pub const struct__GApplicationCommandLinePrivate = @OpaqueType();
pub const GApplicationCommandLinePrivate = struct__GApplicationCommandLinePrivate;
pub const struct__GApplicationCommandLine = extern struct {
    parent_instance: GObject,
    priv: ?*GApplicationCommandLinePrivate,
};
pub const GApplicationCommandLine = struct__GApplicationCommandLine;
pub const struct__GSettingsBackend = @OpaqueType();
pub const GSettingsBackend = struct__GSettingsBackend;
pub const struct__GSettingsPrivate = @OpaqueType();
pub const GSettingsPrivate = struct__GSettingsPrivate;
pub const struct__GSettings = extern struct {
    parent_instance: GObject,
    priv: ?*GSettingsPrivate,
};
pub const GSettings = struct__GSettings;
pub const struct__GPermissionPrivate = @OpaqueType();
pub const GPermissionPrivate = struct__GPermissionPrivate;
pub const struct__GPermission = extern struct {
    parent_instance: GObject,
    priv: ?*GPermissionPrivate,
};
pub const GPermission = struct__GPermission;
pub const struct__GMenuModelPrivate = @OpaqueType();
pub const GMenuModelPrivate = struct__GMenuModelPrivate;
pub const struct__GMenuModel = extern struct {
    parent_instance: GObject,
    priv: ?*GMenuModelPrivate,
};
pub const GMenuModel = struct__GMenuModel;
pub const struct__GNotification = @OpaqueType();
pub const GNotification = struct__GNotification;
pub const struct__GDrive = @OpaqueType();
pub const GDrive = struct__GDrive;
pub const struct__GFileEnumeratorPrivate = @OpaqueType();
pub const GFileEnumeratorPrivate = struct__GFileEnumeratorPrivate;
pub const struct__GFileEnumerator = extern struct {
    parent_instance: GObject,
    priv: ?*GFileEnumeratorPrivate,
};
pub const GFileEnumerator = struct__GFileEnumerator;
pub const struct__GFileMonitorPrivate = @OpaqueType();
pub const GFileMonitorPrivate = struct__GFileMonitorPrivate;
pub const struct__GFileMonitor = extern struct {
    parent_instance: GObject,
    priv: ?*GFileMonitorPrivate,
};
pub const GFileMonitor = struct__GFileMonitor;
pub const struct__GFile = @OpaqueType();
pub const GFile = struct__GFile;
pub const struct__GFileInfo = @OpaqueType();
pub const GFileInfo = struct__GFileInfo;
pub const struct__GFileAttributeMatcher = @OpaqueType();
pub const GFileAttributeMatcher = struct__GFileAttributeMatcher;
pub const struct__GFileAttributeInfo = extern struct {
    name: [*c]u8,
    type: GFileAttributeType,
    flags: GFileAttributeInfoFlags,
};
pub const GFileAttributeInfo = struct__GFileAttributeInfo;
pub const struct__GFileAttributeInfoList = extern struct {
    infos: [*c]GFileAttributeInfo,
    n_infos: c_int,
};
pub const GFileAttributeInfoList = struct__GFileAttributeInfoList;
pub const struct__GFileDescriptorBased = @OpaqueType();
pub const GFileDescriptorBased = struct__GFileDescriptorBased;
pub const struct__GFileInputStreamPrivate = @OpaqueType();
pub const GFileInputStreamPrivate = struct__GFileInputStreamPrivate;
pub const struct__GFileInputStream = extern struct {
    parent_instance: GInputStream,
    priv: ?*GFileInputStreamPrivate,
};
pub const GFileInputStream = struct__GFileInputStream;
pub const struct__GFileOutputStreamPrivate = @OpaqueType();
pub const GFileOutputStreamPrivate = struct__GFileOutputStreamPrivate;
pub const struct__GFileOutputStream = extern struct {
    parent_instance: GOutputStream,
    priv: ?*GFileOutputStreamPrivate,
};
pub const GFileOutputStream = struct__GFileOutputStream;
pub const struct__GIOStreamPrivate = @OpaqueType();
pub const GIOStreamPrivate = struct__GIOStreamPrivate;
pub const struct__GIOStream = extern struct {
    parent_instance: GObject,
    priv: ?*GIOStreamPrivate,
};
pub const GIOStream = struct__GIOStream;
pub const struct__GFileIOStreamPrivate = @OpaqueType();
pub const GFileIOStreamPrivate = struct__GFileIOStreamPrivate;
pub const struct__GFileIOStream = extern struct {
    parent_instance: GIOStream,
    priv: ?*GFileIOStreamPrivate,
};
pub const GFileIOStream = struct__GFileIOStream;
pub const struct__GFileIcon = @OpaqueType();
pub const GFileIcon = struct__GFileIcon;
pub const struct__GFilenameCompleter = @OpaqueType();
pub const GFilenameCompleter = struct__GFilenameCompleter;
pub const struct__GIcon = @OpaqueType();
pub const GIcon = struct__GIcon;
pub const struct__GInetAddressPrivate = @OpaqueType();
pub const GInetAddressPrivate = struct__GInetAddressPrivate;
pub const struct__GInetAddress = extern struct {
    parent_instance: GObject,
    priv: ?*GInetAddressPrivate,
};
pub const GInetAddress = struct__GInetAddress;
pub const struct__GInetAddressMaskPrivate = @OpaqueType();
pub const GInetAddressMaskPrivate = struct__GInetAddressMaskPrivate;
pub const struct__GInetAddressMask = extern struct {
    parent_instance: GObject,
    priv: ?*GInetAddressMaskPrivate,
};
pub const GInetAddressMask = struct__GInetAddressMask;
pub const struct__GSocketAddress = extern struct {
    parent_instance: GObject,
};
pub const GSocketAddress = struct__GSocketAddress;
pub const struct__GInetSocketAddressPrivate = @OpaqueType();
pub const GInetSocketAddressPrivate = struct__GInetSocketAddressPrivate;
pub const struct__GInetSocketAddress = extern struct {
    parent_instance: GSocketAddress,
    priv: ?*GInetSocketAddressPrivate,
};
pub const GInetSocketAddress = struct__GInetSocketAddress;
pub const struct__GNativeSocketAddressPrivate = @OpaqueType();
pub const GNativeSocketAddressPrivate = struct__GNativeSocketAddressPrivate;
pub const struct__GNativeSocketAddress = extern struct {
    parent_instance: GSocketAddress,
    priv: ?*GNativeSocketAddressPrivate,
};
pub const GNativeSocketAddress = struct__GNativeSocketAddress;
pub const struct__GInitable = @OpaqueType();
pub const GInitable = struct__GInitable;
pub const struct__GIOModule = @OpaqueType();
pub const GIOModule = struct__GIOModule;
pub const struct__GIOExtensionPoint = @OpaqueType();
pub const GIOExtensionPoint = struct__GIOExtensionPoint;
pub const struct__GIOExtension = @OpaqueType();
pub const GIOExtension = struct__GIOExtension;
pub const struct__GIOSchedulerJob = @OpaqueType();
pub const GIOSchedulerJob = struct__GIOSchedulerJob;
pub const struct__GIOStreamAdapter = @OpaqueType();
pub const GIOStreamAdapter = struct__GIOStreamAdapter;
pub const struct__GLoadableIcon = @OpaqueType();
pub const GLoadableIcon = struct__GLoadableIcon;
pub const struct__GBytesIcon = @OpaqueType();
pub const GBytesIcon = struct__GBytesIcon;
pub const struct__GMemoryInputStreamPrivate = @OpaqueType();
pub const GMemoryInputStreamPrivate = struct__GMemoryInputStreamPrivate;
pub const struct__GMemoryInputStream = extern struct {
    parent_instance: GInputStream,
    priv: ?*GMemoryInputStreamPrivate,
};
pub const GMemoryInputStream = struct__GMemoryInputStream;
pub const struct__GMemoryOutputStreamPrivate = @OpaqueType();
pub const GMemoryOutputStreamPrivate = struct__GMemoryOutputStreamPrivate;
pub const struct__GMemoryOutputStream = extern struct {
    parent_instance: GOutputStream,
    priv: ?*GMemoryOutputStreamPrivate,
};
pub const GMemoryOutputStream = struct__GMemoryOutputStream;
pub const struct__GMount = @OpaqueType();
pub const GMount = struct__GMount;
pub const struct__GMountOperationPrivate = @OpaqueType();
pub const GMountOperationPrivate = struct__GMountOperationPrivate;
pub const struct__GMountOperation = extern struct {
    parent_instance: GObject,
    priv: ?*GMountOperationPrivate,
};
pub const GMountOperation = struct__GMountOperation;
pub const struct__GNetworkAddressPrivate = @OpaqueType();
pub const GNetworkAddressPrivate = struct__GNetworkAddressPrivate;
pub const struct__GNetworkAddress = extern struct {
    parent_instance: GObject,
    priv: ?*GNetworkAddressPrivate,
};
pub const GNetworkAddress = struct__GNetworkAddress;
pub const struct__GNetworkMonitor = @OpaqueType();
pub const GNetworkMonitor = struct__GNetworkMonitor;
pub const struct__GNetworkServicePrivate = @OpaqueType();
pub const GNetworkServicePrivate = struct__GNetworkServicePrivate;
pub const struct__GNetworkService = extern struct {
    parent_instance: GObject,
    priv: ?*GNetworkServicePrivate,
};
pub const GNetworkService = struct__GNetworkService;
pub const struct__GSimpleIOStream = @OpaqueType();
pub const GSimpleIOStream = struct__GSimpleIOStream;
pub const struct__GPollableInputStream = @OpaqueType();
pub const GPollableInputStream = struct__GPollableInputStream;
pub const struct__GPollableOutputStream = @OpaqueType();
pub const GPollableOutputStream = struct__GPollableOutputStream;
pub const struct__GResolverPrivate = @OpaqueType();
pub const GResolverPrivate = struct__GResolverPrivate;
pub const struct__GResolver = extern struct {
    parent_instance: GObject,
    priv: ?*GResolverPrivate,
};
pub const GResolver = struct__GResolver;
pub const struct__GResource = @OpaqueType();
pub const GResource = struct__GResource;
pub const struct__GSeekable = @OpaqueType();
pub const GSeekable = struct__GSeekable;
pub const struct__GSimpleAsyncResult = @OpaqueType();
pub const GSimpleAsyncResult = struct__GSimpleAsyncResult;
pub const struct__GSocketPrivate = @OpaqueType();
pub const GSocketPrivate = struct__GSocketPrivate;
pub const struct__GSocket = extern struct {
    parent_instance: GObject,
    priv: ?*GSocketPrivate,
};
pub const GSocket = struct__GSocket;
pub const struct__GSocketControlMessagePrivate = @OpaqueType();
pub const GSocketControlMessagePrivate = struct__GSocketControlMessagePrivate;
pub const struct__GSocketControlMessage = extern struct {
    parent_instance: GObject,
    priv: ?*GSocketControlMessagePrivate,
};
pub const GSocketControlMessage = struct__GSocketControlMessage;
pub const struct__GSocketClientPrivate = @OpaqueType();
pub const GSocketClientPrivate = struct__GSocketClientPrivate;
pub const struct__GSocketClient = extern struct {
    parent_instance: GObject,
    priv: ?*GSocketClientPrivate,
};
pub const GSocketClient = struct__GSocketClient;
pub const struct__GSocketConnectionPrivate = @OpaqueType();
pub const GSocketConnectionPrivate = struct__GSocketConnectionPrivate;
pub const struct__GSocketConnection = extern struct {
    parent_instance: GIOStream,
    priv: ?*GSocketConnectionPrivate,
};
pub const GSocketConnection = struct__GSocketConnection;
pub const struct__GSocketListenerPrivate = @OpaqueType();
pub const GSocketListenerPrivate = struct__GSocketListenerPrivate;
pub const struct__GSocketListener = extern struct {
    parent_instance: GObject,
    priv: ?*GSocketListenerPrivate,
};
pub const GSocketListener = struct__GSocketListener;
pub const struct__GSocketServicePrivate = @OpaqueType();
pub const GSocketServicePrivate = struct__GSocketServicePrivate;
pub const struct__GSocketService = extern struct {
    parent_instance: GSocketListener,
    priv: ?*GSocketServicePrivate,
};
pub const GSocketService = struct__GSocketService;
pub const struct__GSocketAddressEnumerator = extern struct {
    parent_instance: GObject,
};
pub const GSocketAddressEnumerator = struct__GSocketAddressEnumerator;
pub const struct__GSocketConnectable = @OpaqueType();
pub const GSocketConnectable = struct__GSocketConnectable;
pub const struct__GSrvTarget = @OpaqueType();
pub const GSrvTarget = struct__GSrvTarget;
pub const struct__GTask = @OpaqueType();
pub const GTask = struct__GTask;
pub const struct__GTcpConnectionPrivate = @OpaqueType();
pub const GTcpConnectionPrivate = struct__GTcpConnectionPrivate;
pub const struct__GTcpConnection = extern struct {
    parent_instance: GSocketConnection,
    priv: ?*GTcpConnectionPrivate,
};
pub const GTcpConnection = struct__GTcpConnection;
pub const struct__GTcpWrapperConnectionPrivate = @OpaqueType();
pub const GTcpWrapperConnectionPrivate = struct__GTcpWrapperConnectionPrivate;
pub const struct__GTcpWrapperConnection = extern struct {
    parent_instance: GTcpConnection,
    priv: ?*GTcpWrapperConnectionPrivate,
};
pub const GTcpWrapperConnection = struct__GTcpWrapperConnection;
pub const struct__GThreadedSocketServicePrivate = @OpaqueType();
pub const GThreadedSocketServicePrivate = struct__GThreadedSocketServicePrivate;
pub const struct__GThreadedSocketService = extern struct {
    parent_instance: GSocketService,
    priv: ?*GThreadedSocketServicePrivate,
};
pub const GThreadedSocketService = struct__GThreadedSocketService;
pub const struct__GDtlsConnection = @OpaqueType();
pub const GDtlsConnection = struct__GDtlsConnection;
pub const struct__GDtlsClientConnection = @OpaqueType();
pub const GDtlsClientConnection = struct__GDtlsClientConnection;
pub const struct__GDtlsServerConnection = @OpaqueType();
pub const GDtlsServerConnection = struct__GDtlsServerConnection;
pub const struct__GThemedIcon = @OpaqueType();
pub const GThemedIcon = struct__GThemedIcon;
pub const struct__GTlsCertificatePrivate = @OpaqueType();
pub const GTlsCertificatePrivate = struct__GTlsCertificatePrivate;
pub const struct__GTlsCertificate = extern struct {
    parent_instance: GObject,
    priv: ?*GTlsCertificatePrivate,
};
pub const GTlsCertificate = struct__GTlsCertificate;
pub const struct__GTlsClientConnection = @OpaqueType();
pub const GTlsClientConnection = struct__GTlsClientConnection;
pub const struct__GTlsConnectionPrivate = @OpaqueType();
pub const GTlsConnectionPrivate = struct__GTlsConnectionPrivate;
pub const struct__GTlsConnection = extern struct {
    parent_instance: GIOStream,
    priv: ?*GTlsConnectionPrivate,
};
pub const GTlsConnection = struct__GTlsConnection;
pub const struct__GTlsDatabasePrivate = @OpaqueType();
pub const GTlsDatabasePrivate = struct__GTlsDatabasePrivate;
pub const struct__GTlsDatabase = extern struct {
    parent_instance: GObject,
    priv: ?*GTlsDatabasePrivate,
};
pub const GTlsDatabase = struct__GTlsDatabase;
pub const struct__GTlsFileDatabase = @OpaqueType();
pub const GTlsFileDatabase = struct__GTlsFileDatabase;
pub const struct__GTlsInteractionPrivate = @OpaqueType();
pub const GTlsInteractionPrivate = struct__GTlsInteractionPrivate;
pub const struct__GTlsInteraction = extern struct {
    parent_instance: GObject,
    priv: ?*GTlsInteractionPrivate,
};
pub const GTlsInteraction = struct__GTlsInteraction;
pub const struct__GTlsPasswordPrivate = @OpaqueType();
pub const GTlsPasswordPrivate = struct__GTlsPasswordPrivate;
pub const struct__GTlsPassword = extern struct {
    parent_instance: GObject,
    priv: ?*GTlsPasswordPrivate,
};
pub const GTlsPassword = struct__GTlsPassword;
pub const struct__GTlsServerConnection = @OpaqueType();
pub const GTlsServerConnection = struct__GTlsServerConnection;
pub const struct__GVfs = extern struct {
    parent_instance: GObject,
};
pub const GVfs = struct__GVfs;
pub const struct__GProxyResolver = @OpaqueType();
pub const GProxyResolver = struct__GProxyResolver;
pub const struct__GProxy = @OpaqueType();
pub const GProxy = struct__GProxy;
pub const struct__GProxyAddressPrivate = @OpaqueType();
pub const GProxyAddressPrivate = struct__GProxyAddressPrivate;
pub const struct__GProxyAddress = extern struct {
    parent_instance: GInetSocketAddress,
    priv: ?*GProxyAddressPrivate,
};
pub const GProxyAddress = struct__GProxyAddress;
pub const struct__GProxyAddressEnumeratorPrivate = @OpaqueType();
pub const GProxyAddressEnumeratorPrivate = struct__GProxyAddressEnumeratorPrivate;
pub const struct__GProxyAddressEnumerator = extern struct {
    parent_instance: GSocketAddressEnumerator,
    priv: ?*GProxyAddressEnumeratorPrivate,
};
pub const GProxyAddressEnumerator = struct__GProxyAddressEnumerator;
pub const struct__GVolume = @OpaqueType();
pub const GVolume = struct__GVolume;
pub const struct__GVolumeMonitor = extern struct {
    parent_instance: GObject,
    priv: gpointer,
};
pub const GVolumeMonitor = struct__GVolumeMonitor;
pub const GAsyncReadyCallback = ?extern fn ([*c]GObject, ?*GAsyncResult, gpointer) void;
pub const GFileProgressCallback = ?extern fn (goffset, goffset, gpointer) void;
pub const GFileReadMoreCallback = ?extern fn ([*c]const u8, goffset, gpointer) gboolean;
pub const GFileMeasureProgressCallback = ?extern fn (gboolean, guint64, guint64, guint64, gpointer) void;
pub const GIOSchedulerJobFunc = ?extern fn (?*GIOSchedulerJob, [*c]GCancellable, gpointer) gboolean;
pub const GSimpleAsyncThreadFunc = ?extern fn (?*GSimpleAsyncResult, [*c]GObject, [*c]GCancellable) void;
pub const GSocketSourceFunc = ?extern fn ([*c]GSocket, GIOCondition, gpointer) gboolean;
pub const GDatagramBasedSourceFunc = ?extern fn (?*GDatagramBased, GIOCondition, gpointer) gboolean;
pub const struct__GInputVector = extern struct {
    buffer: gpointer,
    size: gsize,
};
pub const GInputVector = struct__GInputVector;
pub const struct__GInputMessage = extern struct {
    address: [*c]([*c]GSocketAddress),
    vectors: [*c]GInputVector,
    num_vectors: guint,
    bytes_received: gsize,
    flags: gint,
    control_messages: [*c]([*c]([*c]GSocketControlMessage)),
    num_control_messages: [*c]guint,
};
pub const GInputMessage = struct__GInputMessage;
pub const struct__GOutputVector = extern struct {
    buffer: gconstpointer,
    size: gsize,
};
pub const GOutputVector = struct__GOutputVector;
pub const struct__GOutputMessage = extern struct {
    address: [*c]GSocketAddress,
    vectors: [*c]GOutputVector,
    num_vectors: guint,
    bytes_sent: guint,
    control_messages: [*c]([*c]GSocketControlMessage),
    num_control_messages: guint,
};
pub const GOutputMessage = struct__GOutputMessage;
pub const struct__GCredentials = @OpaqueType();
pub const GCredentials = struct__GCredentials;
pub const struct__GUnixCredentialsMessage = @OpaqueType();
pub const GUnixCredentialsMessage = struct__GUnixCredentialsMessage;
pub const struct__GUnixFDList = @OpaqueType();
pub const GUnixFDList = struct__GUnixFDList;
pub const struct__GDBusMessage = @OpaqueType();
pub const GDBusMessage = struct__GDBusMessage;
pub const struct__GDBusConnection = @OpaqueType();
pub const GDBusConnection = struct__GDBusConnection;
pub const struct__GDBusProxyPrivate = @OpaqueType();
pub const GDBusProxyPrivate = struct__GDBusProxyPrivate;
pub const struct__GDBusProxy = extern struct {
    parent_instance: GObject,
    priv: ?*GDBusProxyPrivate,
};
pub const GDBusProxy = struct__GDBusProxy;
pub const struct__GDBusMethodInvocation = @OpaqueType();
pub const GDBusMethodInvocation = struct__GDBusMethodInvocation;
pub const struct__GDBusServer = @OpaqueType();
pub const GDBusServer = struct__GDBusServer;
pub const struct__GDBusAuthObserver = @OpaqueType();
pub const GDBusAuthObserver = struct__GDBusAuthObserver;
pub const struct__GDBusErrorEntry = extern struct {
    error_code: gint,
    dbus_error_name: [*c]const gchar,
};
pub const GDBusErrorEntry = struct__GDBusErrorEntry;
pub const GDBusInterfaceMethodCallFunc = ?extern fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c]const gchar, ?*GVariant, ?*GDBusMethodInvocation, gpointer) void;
pub const GDBusInterfaceGetPropertyFunc = ?extern fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c]([*c]GError), gpointer) ?*GVariant;
pub const GDBusInterfaceSetPropertyFunc = ?extern fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c]const gchar, ?*GVariant, [*c]([*c]GError), gpointer) gboolean;
pub const struct__GDBusInterfaceVTable = extern struct {
    method_call: GDBusInterfaceMethodCallFunc,
    get_property: GDBusInterfaceGetPropertyFunc,
    set_property: GDBusInterfaceSetPropertyFunc,
    padding: [8]gpointer,
};
pub const GDBusInterfaceVTable = struct__GDBusInterfaceVTable;
pub const GDBusSubtreeEnumerateFunc = ?extern fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, gpointer) [*c]([*c]gchar);
pub const struct__GDBusAnnotationInfo = extern struct {
    ref_count: gint,
    key: [*c]gchar,
    value: [*c]gchar,
    annotations: [*c]([*c]GDBusAnnotationInfo),
};
pub const GDBusAnnotationInfo = struct__GDBusAnnotationInfo;
pub const struct__GDBusArgInfo = extern struct {
    ref_count: gint,
    name: [*c]gchar,
    signature: [*c]gchar,
    annotations: [*c]([*c]GDBusAnnotationInfo),
};
pub const GDBusArgInfo = struct__GDBusArgInfo;
pub const struct__GDBusMethodInfo = extern struct {
    ref_count: gint,
    name: [*c]gchar,
    in_args: [*c]([*c]GDBusArgInfo),
    out_args: [*c]([*c]GDBusArgInfo),
    annotations: [*c]([*c]GDBusAnnotationInfo),
};
pub const GDBusMethodInfo = struct__GDBusMethodInfo;
pub const struct__GDBusSignalInfo = extern struct {
    ref_count: gint,
    name: [*c]gchar,
    args: [*c]([*c]GDBusArgInfo),
    annotations: [*c]([*c]GDBusAnnotationInfo),
};
pub const GDBusSignalInfo = struct__GDBusSignalInfo;
pub const struct__GDBusPropertyInfo = extern struct {
    ref_count: gint,
    name: [*c]gchar,
    signature: [*c]gchar,
    flags: GDBusPropertyInfoFlags,
    annotations: [*c]([*c]GDBusAnnotationInfo),
};
pub const GDBusPropertyInfo = struct__GDBusPropertyInfo;
pub const struct__GDBusInterfaceInfo = extern struct {
    ref_count: gint,
    name: [*c]gchar,
    methods: [*c]([*c]GDBusMethodInfo),
    signals: [*c]([*c]GDBusSignalInfo),
    properties: [*c]([*c]GDBusPropertyInfo),
    annotations: [*c]([*c]GDBusAnnotationInfo),
};
pub const GDBusInterfaceInfo = struct__GDBusInterfaceInfo;
pub const GDBusSubtreeIntrospectFunc = ?extern fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, [*c]const gchar, gpointer) [*c]([*c]GDBusInterfaceInfo);
pub const GDBusSubtreeDispatchFunc = ?extern fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c]gpointer, gpointer) [*c]const GDBusInterfaceVTable;
pub const struct__GDBusSubtreeVTable = extern struct {
    enumerate: GDBusSubtreeEnumerateFunc,
    introspect: GDBusSubtreeIntrospectFunc,
    dispatch: GDBusSubtreeDispatchFunc,
    padding: [8]gpointer,
};
pub const GDBusSubtreeVTable = struct__GDBusSubtreeVTable;
pub const GDBusNodeInfo = struct__GDBusNodeInfo;
pub const struct__GDBusNodeInfo = extern struct {
    ref_count: gint,
    path: [*c]gchar,
    interfaces: [*c]([*c]GDBusInterfaceInfo),
    nodes: [*c]([*c]GDBusNodeInfo),
    annotations: [*c]([*c]GDBusAnnotationInfo),
};
pub const GCancellableSourceFunc = ?extern fn ([*c]GCancellable, gpointer) gboolean;
pub const GPollableSourceFunc = ?extern fn ([*c]GObject, gpointer) gboolean;
pub const struct__GDBusInterface = @OpaqueType();
pub const GDBusInterface = struct__GDBusInterface;
pub const struct__GDBusInterfaceSkeletonPrivate = @OpaqueType();
pub const GDBusInterfaceSkeletonPrivate = struct__GDBusInterfaceSkeletonPrivate;
pub const struct__GDBusInterfaceSkeleton = extern struct {
    parent_instance: GObject,
    priv: ?*GDBusInterfaceSkeletonPrivate,
};
pub const GDBusInterfaceSkeleton = struct__GDBusInterfaceSkeleton;
pub const struct__GDBusObject = @OpaqueType();
pub const GDBusObject = struct__GDBusObject;
pub const struct__GDBusObjectSkeletonPrivate = @OpaqueType();
pub const GDBusObjectSkeletonPrivate = struct__GDBusObjectSkeletonPrivate;
pub const struct__GDBusObjectSkeleton = extern struct {
    parent_instance: GObject,
    priv: ?*GDBusObjectSkeletonPrivate,
};
pub const GDBusObjectSkeleton = struct__GDBusObjectSkeleton;
pub const struct__GDBusObjectProxyPrivate = @OpaqueType();
pub const GDBusObjectProxyPrivate = struct__GDBusObjectProxyPrivate;
pub const struct__GDBusObjectProxy = extern struct {
    parent_instance: GObject,
    priv: ?*GDBusObjectProxyPrivate,
};
pub const GDBusObjectProxy = struct__GDBusObjectProxy;
pub const struct__GDBusObjectManager = @OpaqueType();
pub const GDBusObjectManager = struct__GDBusObjectManager;
pub const struct__GDBusObjectManagerClientPrivate = @OpaqueType();
pub const GDBusObjectManagerClientPrivate = struct__GDBusObjectManagerClientPrivate;
pub const struct__GDBusObjectManagerClient = extern struct {
    parent_instance: GObject,
    priv: ?*GDBusObjectManagerClientPrivate,
};
pub const GDBusObjectManagerClient = struct__GDBusObjectManagerClient;
pub const struct__GDBusObjectManagerServerPrivate = @OpaqueType();
pub const GDBusObjectManagerServerPrivate = struct__GDBusObjectManagerServerPrivate;
pub const struct__GDBusObjectManagerServer = extern struct {
    parent_instance: GObject,
    priv: ?*GDBusObjectManagerServerPrivate,
};
pub const GDBusObjectManagerServer = struct__GDBusObjectManagerServer;
pub const GDBusProxyTypeFunc = ?extern fn ([*c]GDBusObjectManagerClient, [*c]const gchar, [*c]const gchar, gpointer) GType;
pub const struct__GTestDBus = @OpaqueType();
pub const GTestDBus = struct__GTestDBus;
pub const struct__GSubprocess = @OpaqueType();
pub const GSubprocess = struct__GSubprocess;
pub const struct__GSubprocessLauncher = @OpaqueType();
pub const GSubprocessLauncher = struct__GSubprocessLauncher;
pub const struct__GActionInterface = extern struct {
    g_iface: GTypeInterface,
    get_name: ?extern fn (?*GAction) [*c]const gchar,
    get_parameter_type: ?extern fn (?*GAction) ?*const GVariantType,
    get_state_type: ?extern fn (?*GAction) ?*const GVariantType,
    get_state_hint: ?extern fn (?*GAction) ?*GVariant,
    get_enabled: ?extern fn (?*GAction) gboolean,
    get_state: ?extern fn (?*GAction) ?*GVariant,
    change_state: ?extern fn (?*GAction, ?*GVariant) void,
    activate: ?extern fn (?*GAction, ?*GVariant) void,
};
pub const GActionInterface = struct__GActionInterface;
pub extern fn g_action_get_type() GType;
pub extern fn g_action_get_name(action: ?*GAction) [*c]const gchar;
pub extern fn g_action_get_parameter_type(action: ?*GAction) ?*const GVariantType;
pub extern fn g_action_get_state_type(action: ?*GAction) ?*const GVariantType;
pub extern fn g_action_get_state_hint(action: ?*GAction) ?*GVariant;
pub extern fn g_action_get_enabled(action: ?*GAction) gboolean;
pub extern fn g_action_get_state(action: ?*GAction) ?*GVariant;
pub extern fn g_action_change_state(action: ?*GAction, value: ?*GVariant) void;
pub extern fn g_action_activate(action: ?*GAction, parameter: ?*GVariant) void;
pub extern fn g_action_name_is_valid(action_name: [*c]const gchar) gboolean;
pub extern fn g_action_parse_detailed_name(detailed_name: [*c]const gchar, action_name: [*c]([*c]gchar), target_value: [*c](?*GVariant), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_action_print_detailed_name(action_name: [*c]const gchar, target_value: ?*GVariant) [*c]gchar;
pub const struct__GActionGroupInterface = extern struct {
    g_iface: GTypeInterface,
    has_action: ?extern fn (?*GActionGroup, [*c]const gchar) gboolean,
    list_actions: ?extern fn (?*GActionGroup) [*c]([*c]gchar),
    get_action_enabled: ?extern fn (?*GActionGroup, [*c]const gchar) gboolean,
    get_action_parameter_type: ?extern fn (?*GActionGroup, [*c]const gchar) ?*const GVariantType,
    get_action_state_type: ?extern fn (?*GActionGroup, [*c]const gchar) ?*const GVariantType,
    get_action_state_hint: ?extern fn (?*GActionGroup, [*c]const gchar) ?*GVariant,
    get_action_state: ?extern fn (?*GActionGroup, [*c]const gchar) ?*GVariant,
    change_action_state: ?extern fn (?*GActionGroup, [*c]const gchar, ?*GVariant) void,
    activate_action: ?extern fn (?*GActionGroup, [*c]const gchar, ?*GVariant) void,
    action_added: ?extern fn (?*GActionGroup, [*c]const gchar) void,
    action_removed: ?extern fn (?*GActionGroup, [*c]const gchar) void,
    action_enabled_changed: ?extern fn (?*GActionGroup, [*c]const gchar, gboolean) void,
    action_state_changed: ?extern fn (?*GActionGroup, [*c]const gchar, ?*GVariant) void,
    query_action: ?extern fn (?*GActionGroup, [*c]const gchar, [*c]gboolean, [*c](?*const GVariantType), [*c](?*const GVariantType), [*c](?*GVariant), [*c](?*GVariant)) gboolean,
};
pub const GActionGroupInterface = struct__GActionGroupInterface;
pub extern fn g_action_group_get_type() GType;
pub extern fn g_action_group_has_action(action_group: ?*GActionGroup, action_name: [*c]const gchar) gboolean;
pub extern fn g_action_group_list_actions(action_group: ?*GActionGroup) [*c]([*c]gchar);
pub extern fn g_action_group_get_action_parameter_type(action_group: ?*GActionGroup, action_name: [*c]const gchar) ?*const GVariantType;
pub extern fn g_action_group_get_action_state_type(action_group: ?*GActionGroup, action_name: [*c]const gchar) ?*const GVariantType;
pub extern fn g_action_group_get_action_state_hint(action_group: ?*GActionGroup, action_name: [*c]const gchar) ?*GVariant;
pub extern fn g_action_group_get_action_enabled(action_group: ?*GActionGroup, action_name: [*c]const gchar) gboolean;
pub extern fn g_action_group_get_action_state(action_group: ?*GActionGroup, action_name: [*c]const gchar) ?*GVariant;
pub extern fn g_action_group_change_action_state(action_group: ?*GActionGroup, action_name: [*c]const gchar, value: ?*GVariant) void;
pub extern fn g_action_group_activate_action(action_group: ?*GActionGroup, action_name: [*c]const gchar, parameter: ?*GVariant) void;
pub extern fn g_action_group_action_added(action_group: ?*GActionGroup, action_name: [*c]const gchar) void;
pub extern fn g_action_group_action_removed(action_group: ?*GActionGroup, action_name: [*c]const gchar) void;
pub extern fn g_action_group_action_enabled_changed(action_group: ?*GActionGroup, action_name: [*c]const gchar, enabled: gboolean) void;
pub extern fn g_action_group_action_state_changed(action_group: ?*GActionGroup, action_name: [*c]const gchar, state: ?*GVariant) void;
pub extern fn g_action_group_query_action(action_group: ?*GActionGroup, action_name: [*c]const gchar, enabled: [*c]gboolean, parameter_type: [*c](?*const GVariantType), state_type: [*c](?*const GVariantType), state_hint: [*c](?*GVariant), state: [*c](?*GVariant)) gboolean;
pub extern fn g_dbus_connection_export_action_group(connection: ?*GDBusConnection, object_path: [*c]const gchar, action_group: ?*GActionGroup, @"error": [*c]([*c]GError)) guint;
pub extern fn g_dbus_connection_unexport_action_group(connection: ?*GDBusConnection, export_id: guint) void;
pub const struct__GActionMapInterface = extern struct {
    g_iface: GTypeInterface,
    lookup_action: ?extern fn (?*GActionMap, [*c]const gchar) ?*GAction,
    add_action: ?extern fn (?*GActionMap, ?*GAction) void,
    remove_action: ?extern fn (?*GActionMap, [*c]const gchar) void,
};
pub const GActionMapInterface = struct__GActionMapInterface;
pub const struct__GActionEntry = extern struct {
    name: [*c]const gchar,
    activate: ?extern fn (?*GSimpleAction, ?*GVariant, gpointer) void,
    parameter_type: [*c]const gchar,
    state: [*c]const gchar,
    change_state: ?extern fn (?*GSimpleAction, ?*GVariant, gpointer) void,
    padding: [3]gsize,
};
pub const GActionEntry = struct__GActionEntry;
pub extern fn g_action_map_get_type() GType;
pub extern fn g_action_map_lookup_action(action_map: ?*GActionMap, action_name: [*c]const gchar) ?*GAction;
pub extern fn g_action_map_add_action(action_map: ?*GActionMap, action: ?*GAction) void;
pub extern fn g_action_map_remove_action(action_map: ?*GActionMap, action_name: [*c]const gchar) void;
pub extern fn g_action_map_add_action_entries(action_map: ?*GActionMap, entries: [*c]const GActionEntry, n_entries: gint, user_data: gpointer) void;
pub const struct__GAppLaunchContextClass = extern struct {
    parent_class: GObjectClass,
    get_display: ?extern fn ([*c]GAppLaunchContext, ?*GAppInfo, [*c]GList) [*c]u8,
    get_startup_notify_id: ?extern fn ([*c]GAppLaunchContext, ?*GAppInfo, [*c]GList) [*c]u8,
    launch_failed: ?extern fn ([*c]GAppLaunchContext, [*c]const u8) void,
    launched: ?extern fn ([*c]GAppLaunchContext, ?*GAppInfo, ?*GVariant) void,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
};
pub const GAppLaunchContextClass = struct__GAppLaunchContextClass;
pub const struct__GAppInfoIface = extern struct {
    g_iface: GTypeInterface,
    dup: ?extern fn (?*GAppInfo) ?*GAppInfo,
    equal: ?extern fn (?*GAppInfo, ?*GAppInfo) gboolean,
    get_id: ?extern fn (?*GAppInfo) [*c]const u8,
    get_name: ?extern fn (?*GAppInfo) [*c]const u8,
    get_description: ?extern fn (?*GAppInfo) [*c]const u8,
    get_executable: ?extern fn (?*GAppInfo) [*c]const u8,
    get_icon: ?extern fn (?*GAppInfo) ?*GIcon,
    launch: ?extern fn (?*GAppInfo, [*c]GList, [*c]GAppLaunchContext, [*c]([*c]GError)) gboolean,
    supports_uris: ?extern fn (?*GAppInfo) gboolean,
    supports_files: ?extern fn (?*GAppInfo) gboolean,
    launch_uris: ?extern fn (?*GAppInfo, [*c]GList, [*c]GAppLaunchContext, [*c]([*c]GError)) gboolean,
    should_show: ?extern fn (?*GAppInfo) gboolean,
    set_as_default_for_type: ?extern fn (?*GAppInfo, [*c]const u8, [*c]([*c]GError)) gboolean,
    set_as_default_for_extension: ?extern fn (?*GAppInfo, [*c]const u8, [*c]([*c]GError)) gboolean,
    add_supports_type: ?extern fn (?*GAppInfo, [*c]const u8, [*c]([*c]GError)) gboolean,
    can_remove_supports_type: ?extern fn (?*GAppInfo) gboolean,
    remove_supports_type: ?extern fn (?*GAppInfo, [*c]const u8, [*c]([*c]GError)) gboolean,
    can_delete: ?extern fn (?*GAppInfo) gboolean,
    do_delete: ?extern fn (?*GAppInfo) gboolean,
    get_commandline: ?extern fn (?*GAppInfo) [*c]const u8,
    get_display_name: ?extern fn (?*GAppInfo) [*c]const u8,
    set_as_last_used_for_type: ?extern fn (?*GAppInfo, [*c]const u8, [*c]([*c]GError)) gboolean,
    get_supported_types: ?extern fn (?*GAppInfo) [*c]([*c]const u8),
    launch_uris_async: ?extern fn (?*GAppInfo, [*c]GList, [*c]GAppLaunchContext, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    launch_uris_finish: ?extern fn (?*GAppInfo, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
};
pub const GAppInfoIface = struct__GAppInfoIface;
pub extern fn g_app_info_get_type() GType;
pub extern fn g_app_info_create_from_commandline(commandline: [*c]const u8, application_name: [*c]const u8, flags: GAppInfoCreateFlags, @"error": [*c]([*c]GError)) ?*GAppInfo;
pub extern fn g_app_info_dup(appinfo: ?*GAppInfo) ?*GAppInfo;
pub extern fn g_app_info_equal(appinfo1: ?*GAppInfo, appinfo2: ?*GAppInfo) gboolean;
pub extern fn g_app_info_get_id(appinfo: ?*GAppInfo) [*c]const u8;
pub extern fn g_app_info_get_name(appinfo: ?*GAppInfo) [*c]const u8;
pub extern fn g_app_info_get_display_name(appinfo: ?*GAppInfo) [*c]const u8;
pub extern fn g_app_info_get_description(appinfo: ?*GAppInfo) [*c]const u8;
pub extern fn g_app_info_get_executable(appinfo: ?*GAppInfo) [*c]const u8;
pub extern fn g_app_info_get_commandline(appinfo: ?*GAppInfo) [*c]const u8;
pub extern fn g_app_info_get_icon(appinfo: ?*GAppInfo) ?*GIcon;
pub extern fn g_app_info_launch(appinfo: ?*GAppInfo, files: [*c]GList, context: [*c]GAppLaunchContext, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_app_info_supports_uris(appinfo: ?*GAppInfo) gboolean;
pub extern fn g_app_info_supports_files(appinfo: ?*GAppInfo) gboolean;
pub extern fn g_app_info_launch_uris(appinfo: ?*GAppInfo, uris: [*c]GList, context: [*c]GAppLaunchContext, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_app_info_launch_uris_async(appinfo: ?*GAppInfo, uris: [*c]GList, context: [*c]GAppLaunchContext, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_app_info_launch_uris_finish(appinfo: ?*GAppInfo, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_app_info_should_show(appinfo: ?*GAppInfo) gboolean;
pub extern fn g_app_info_set_as_default_for_type(appinfo: ?*GAppInfo, content_type: [*c]const u8, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_app_info_set_as_default_for_extension(appinfo: ?*GAppInfo, extension: [*c]const u8, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_app_info_add_supports_type(appinfo: ?*GAppInfo, content_type: [*c]const u8, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_app_info_can_remove_supports_type(appinfo: ?*GAppInfo) gboolean;
pub extern fn g_app_info_remove_supports_type(appinfo: ?*GAppInfo, content_type: [*c]const u8, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_app_info_get_supported_types(appinfo: ?*GAppInfo) [*c]([*c]const u8);
pub extern fn g_app_info_can_delete(appinfo: ?*GAppInfo) gboolean;
pub extern fn g_app_info_delete(appinfo: ?*GAppInfo) gboolean;
pub extern fn g_app_info_set_as_last_used_for_type(appinfo: ?*GAppInfo, content_type: [*c]const u8, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_app_info_get_all() [*c]GList;
pub extern fn g_app_info_get_all_for_type(content_type: [*c]const u8) [*c]GList;
pub extern fn g_app_info_get_recommended_for_type(content_type: [*c]const gchar) [*c]GList;
pub extern fn g_app_info_get_fallback_for_type(content_type: [*c]const gchar) [*c]GList;
pub extern fn g_app_info_reset_type_associations(content_type: [*c]const u8) void;
pub extern fn g_app_info_get_default_for_type(content_type: [*c]const u8, must_support_uris: gboolean) ?*GAppInfo;
pub extern fn g_app_info_get_default_for_uri_scheme(uri_scheme: [*c]const u8) ?*GAppInfo;
pub extern fn g_app_info_launch_default_for_uri(uri: [*c]const u8, context: [*c]GAppLaunchContext, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_app_info_launch_default_for_uri_async(uri: [*c]const u8, context: [*c]GAppLaunchContext, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_app_info_launch_default_for_uri_finish(result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_app_launch_context_get_type() GType;
pub extern fn g_app_launch_context_new() [*c]GAppLaunchContext;
pub extern fn g_app_launch_context_setenv(context: [*c]GAppLaunchContext, variable: [*c]const u8, value: [*c]const u8) void;
pub extern fn g_app_launch_context_unsetenv(context: [*c]GAppLaunchContext, variable: [*c]const u8) void;
pub extern fn g_app_launch_context_get_environment(context: [*c]GAppLaunchContext) [*c]([*c]u8);
pub extern fn g_app_launch_context_get_display(context: [*c]GAppLaunchContext, info: ?*GAppInfo, files: [*c]GList) [*c]u8;
pub extern fn g_app_launch_context_get_startup_notify_id(context: [*c]GAppLaunchContext, info: ?*GAppInfo, files: [*c]GList) [*c]u8;
pub extern fn g_app_launch_context_launch_failed(context: [*c]GAppLaunchContext, startup_notify_id: [*c]const u8) void;
pub const struct__GAppInfoMonitor = @OpaqueType();
pub const GAppInfoMonitor = struct__GAppInfoMonitor;
pub extern fn g_app_info_monitor_get_type() GType;
pub extern fn g_app_info_monitor_get() ?*GAppInfoMonitor;
pub const struct__GApplicationClass = extern struct {
    parent_class: GObjectClass,
    startup: ?extern fn ([*c]GApplication) void,
    activate: ?extern fn ([*c]GApplication) void,
    open: ?extern fn ([*c]GApplication, [*c](?*GFile), gint, [*c]const gchar) void,
    command_line: ?extern fn ([*c]GApplication, [*c]GApplicationCommandLine) c_int,
    local_command_line: ?extern fn ([*c]GApplication, [*c]([*c]([*c]gchar)), [*c]c_int) gboolean,
    before_emit: ?extern fn ([*c]GApplication, ?*GVariant) void,
    after_emit: ?extern fn ([*c]GApplication, ?*GVariant) void,
    add_platform_data: ?extern fn ([*c]GApplication, [*c]GVariantBuilder) void,
    quit_mainloop: ?extern fn ([*c]GApplication) void,
    run_mainloop: ?extern fn ([*c]GApplication) void,
    shutdown: ?extern fn ([*c]GApplication) void,
    dbus_register: ?extern fn ([*c]GApplication, ?*GDBusConnection, [*c]const gchar, [*c]([*c]GError)) gboolean,
    dbus_unregister: ?extern fn ([*c]GApplication, ?*GDBusConnection, [*c]const gchar) void,
    handle_local_options: ?extern fn ([*c]GApplication, [*c]GVariantDict) gint,
    name_lost: ?extern fn ([*c]GApplication) gboolean,
    padding: [7]gpointer,
};
pub const GApplicationClass = struct__GApplicationClass;
pub extern fn g_application_get_type() GType;
pub extern fn g_application_id_is_valid(application_id: [*c]const gchar) gboolean;
pub extern fn g_application_new(application_id: [*c]const gchar, flags: GApplicationFlags) [*c]GApplication;
pub extern fn g_application_get_application_id(application: [*c]GApplication) [*c]const gchar;
pub extern fn g_application_set_application_id(application: [*c]GApplication, application_id: [*c]const gchar) void;
pub extern fn g_application_get_dbus_connection(application: [*c]GApplication) ?*GDBusConnection;
pub extern fn g_application_get_dbus_object_path(application: [*c]GApplication) [*c]const gchar;
pub extern fn g_application_get_inactivity_timeout(application: [*c]GApplication) guint;
pub extern fn g_application_set_inactivity_timeout(application: [*c]GApplication, inactivity_timeout: guint) void;
pub extern fn g_application_get_flags(application: [*c]GApplication) GApplicationFlags;
pub extern fn g_application_set_flags(application: [*c]GApplication, flags: GApplicationFlags) void;
pub extern fn g_application_get_resource_base_path(application: [*c]GApplication) [*c]const gchar;
pub extern fn g_application_set_resource_base_path(application: [*c]GApplication, resource_path: [*c]const gchar) void;
pub extern fn g_application_set_action_group(application: [*c]GApplication, action_group: ?*GActionGroup) void;
pub extern fn g_application_add_main_option_entries(application: [*c]GApplication, entries: [*c]const GOptionEntry) void;
pub extern fn g_application_add_main_option(application: [*c]GApplication, long_name: [*c]const u8, short_name: u8, flags: GOptionFlags, arg: GOptionArg, description: [*c]const u8, arg_description: [*c]const u8) void;
pub extern fn g_application_add_option_group(application: [*c]GApplication, group: ?*GOptionGroup) void;
pub extern fn g_application_set_option_context_parameter_string(application: [*c]GApplication, parameter_string: [*c]const gchar) void;
pub extern fn g_application_set_option_context_summary(application: [*c]GApplication, summary: [*c]const gchar) void;
pub extern fn g_application_set_option_context_description(application: [*c]GApplication, description: [*c]const gchar) void;
pub extern fn g_application_get_is_registered(application: [*c]GApplication) gboolean;
pub extern fn g_application_get_is_remote(application: [*c]GApplication) gboolean;
pub extern fn g_application_register(application: [*c]GApplication, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_application_hold(application: [*c]GApplication) void;
pub extern fn g_application_release(application: [*c]GApplication) void;
pub extern fn g_application_activate(application: [*c]GApplication) void;
pub extern fn g_application_open(application: [*c]GApplication, files: [*c](?*GFile), n_files: gint, hint: [*c]const gchar) void;
pub extern fn g_application_run(application: [*c]GApplication, argc: c_int, argv: [*c]([*c]u8)) c_int;
pub extern fn g_application_quit(application: [*c]GApplication) void;
pub extern fn g_application_get_default() [*c]GApplication;
pub extern fn g_application_set_default(application: [*c]GApplication) void;
pub extern fn g_application_mark_busy(application: [*c]GApplication) void;
pub extern fn g_application_unmark_busy(application: [*c]GApplication) void;
pub extern fn g_application_get_is_busy(application: [*c]GApplication) gboolean;
pub extern fn g_application_send_notification(application: [*c]GApplication, id: [*c]const gchar, notification: ?*GNotification) void;
pub extern fn g_application_withdraw_notification(application: [*c]GApplication, id: [*c]const gchar) void;
pub extern fn g_application_bind_busy_property(application: [*c]GApplication, object: gpointer, property: [*c]const gchar) void;
pub extern fn g_application_unbind_busy_property(application: [*c]GApplication, object: gpointer, property: [*c]const gchar) void;
pub const struct__GApplicationCommandLineClass = extern struct {
    parent_class: GObjectClass,
    print_literal: ?extern fn ([*c]GApplicationCommandLine, [*c]const gchar) void,
    printerr_literal: ?extern fn ([*c]GApplicationCommandLine, [*c]const gchar) void,
    get_stdin: ?extern fn ([*c]GApplicationCommandLine) [*c]GInputStream,
    padding: [11]gpointer,
};
pub const GApplicationCommandLineClass = struct__GApplicationCommandLineClass;
pub extern fn g_application_command_line_get_type() GType;
pub extern fn g_application_command_line_get_arguments(cmdline: [*c]GApplicationCommandLine, argc: [*c]c_int) [*c]([*c]gchar);
pub extern fn g_application_command_line_get_options_dict(cmdline: [*c]GApplicationCommandLine) [*c]GVariantDict;
pub extern fn g_application_command_line_get_stdin(cmdline: [*c]GApplicationCommandLine) [*c]GInputStream;
pub extern fn g_application_command_line_get_environ(cmdline: [*c]GApplicationCommandLine) [*c]const ([*c]const gchar);
pub extern fn g_application_command_line_getenv(cmdline: [*c]GApplicationCommandLine, name: [*c]const gchar) [*c]const gchar;
pub extern fn g_application_command_line_get_cwd(cmdline: [*c]GApplicationCommandLine) [*c]const gchar;
pub extern fn g_application_command_line_get_is_remote(cmdline: [*c]GApplicationCommandLine) gboolean;
pub extern fn g_application_command_line_print(cmdline: [*c]GApplicationCommandLine, format: [*c]const gchar, ...) void;
pub extern fn g_application_command_line_printerr(cmdline: [*c]GApplicationCommandLine, format: [*c]const gchar, ...) void;
pub extern fn g_application_command_line_get_exit_status(cmdline: [*c]GApplicationCommandLine) c_int;
pub extern fn g_application_command_line_set_exit_status(cmdline: [*c]GApplicationCommandLine, exit_status: c_int) void;
pub extern fn g_application_command_line_get_platform_data(cmdline: [*c]GApplicationCommandLine) ?*GVariant;
pub extern fn g_application_command_line_create_file_for_arg(cmdline: [*c]GApplicationCommandLine, arg: [*c]const gchar) ?*GFile;
pub const struct__GInitableIface = extern struct {
    g_iface: GTypeInterface,
    init: ?extern fn (?*GInitable, [*c]GCancellable, [*c]([*c]GError)) gboolean,
};
pub const GInitableIface = struct__GInitableIface;
pub extern fn g_initable_get_type() GType;
pub extern fn g_initable_init(initable: ?*GInitable, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_initable_new(object_type: GType, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError), first_property_name: [*c]const gchar, ...) gpointer;
pub extern fn g_initable_newv(object_type: GType, n_parameters: guint, parameters: [*c]GParameter, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gpointer;
pub extern fn g_initable_new_valist(object_type: GType, first_property_name: [*c]const gchar, var_args: va_list, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GObject;
pub const struct__GAsyncInitableIface = extern struct {
    g_iface: GTypeInterface,
    init_async: ?extern fn (?*GAsyncInitable, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    init_finish: ?extern fn (?*GAsyncInitable, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
};
pub const GAsyncInitableIface = struct__GAsyncInitableIface;
pub extern fn g_async_initable_get_type() GType;
pub extern fn g_async_initable_init_async(initable: ?*GAsyncInitable, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_async_initable_init_finish(initable: ?*GAsyncInitable, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_async_initable_new_async(object_type: GType, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer, first_property_name: [*c]const gchar, ...) void;
pub extern fn g_async_initable_newv_async(object_type: GType, n_parameters: guint, parameters: [*c]GParameter, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_async_initable_new_valist_async(object_type: GType, first_property_name: [*c]const gchar, var_args: va_list, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_async_initable_new_finish(initable: ?*GAsyncInitable, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GObject;
pub const struct__GAsyncResultIface = extern struct {
    g_iface: GTypeInterface,
    get_user_data: ?extern fn (?*GAsyncResult) gpointer,
    get_source_object: ?extern fn (?*GAsyncResult) [*c]GObject,
    is_tagged: ?extern fn (?*GAsyncResult, gpointer) gboolean,
};
pub const GAsyncResultIface = struct__GAsyncResultIface;
pub extern fn g_async_result_get_type() GType;
pub extern fn g_async_result_get_user_data(res: ?*GAsyncResult) gpointer;
pub extern fn g_async_result_get_source_object(res: ?*GAsyncResult) [*c]GObject;
pub extern fn g_async_result_legacy_propagate_error(res: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_async_result_is_tagged(res: ?*GAsyncResult, source_tag: gpointer) gboolean;
pub const struct__GInputStreamClass = extern struct {
    parent_class: GObjectClass,
    read_fn: ?extern fn ([*c]GInputStream, ?*c_void, gsize, [*c]GCancellable, [*c]([*c]GError)) gssize,
    skip: ?extern fn ([*c]GInputStream, gsize, [*c]GCancellable, [*c]([*c]GError)) gssize,
    close_fn: ?extern fn ([*c]GInputStream, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    read_async: ?extern fn ([*c]GInputStream, ?*c_void, gsize, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    read_finish: ?extern fn ([*c]GInputStream, ?*GAsyncResult, [*c]([*c]GError)) gssize,
    skip_async: ?extern fn ([*c]GInputStream, gsize, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    skip_finish: ?extern fn ([*c]GInputStream, ?*GAsyncResult, [*c]([*c]GError)) gssize,
    close_async: ?extern fn ([*c]GInputStream, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    close_finish: ?extern fn ([*c]GInputStream, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GInputStreamClass = struct__GInputStreamClass;
pub extern fn g_input_stream_get_type() GType;
pub extern fn g_input_stream_read(stream: [*c]GInputStream, buffer: ?*c_void, count: gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_input_stream_read_all(stream: [*c]GInputStream, buffer: ?*c_void, count: gsize, bytes_read: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_input_stream_read_bytes(stream: [*c]GInputStream, count: gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GBytes;
pub extern fn g_input_stream_skip(stream: [*c]GInputStream, count: gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_input_stream_close(stream: [*c]GInputStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_input_stream_read_async(stream: [*c]GInputStream, buffer: ?*c_void, count: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_input_stream_read_finish(stream: [*c]GInputStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_input_stream_read_all_async(stream: [*c]GInputStream, buffer: ?*c_void, count: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_input_stream_read_all_finish(stream: [*c]GInputStream, result: ?*GAsyncResult, bytes_read: [*c]gsize, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_input_stream_read_bytes_async(stream: [*c]GInputStream, count: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_input_stream_read_bytes_finish(stream: [*c]GInputStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GBytes;
pub extern fn g_input_stream_skip_async(stream: [*c]GInputStream, count: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_input_stream_skip_finish(stream: [*c]GInputStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_input_stream_close_async(stream: [*c]GInputStream, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_input_stream_close_finish(stream: [*c]GInputStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_input_stream_is_closed(stream: [*c]GInputStream) gboolean;
pub extern fn g_input_stream_has_pending(stream: [*c]GInputStream) gboolean;
pub extern fn g_input_stream_set_pending(stream: [*c]GInputStream, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_input_stream_clear_pending(stream: [*c]GInputStream) void;
pub const struct__GFilterInputStreamClass = extern struct {
    parent_class: GInputStreamClass,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
};
pub const GFilterInputStreamClass = struct__GFilterInputStreamClass;
pub extern fn g_filter_input_stream_get_type() GType;
pub extern fn g_filter_input_stream_get_base_stream(stream: [*c]GFilterInputStream) [*c]GInputStream;
pub extern fn g_filter_input_stream_get_close_base_stream(stream: [*c]GFilterInputStream) gboolean;
pub extern fn g_filter_input_stream_set_close_base_stream(stream: [*c]GFilterInputStream, close_base: gboolean) void;
pub const struct__GBufferedInputStreamClass = extern struct {
    parent_class: GFilterInputStreamClass,
    fill: ?extern fn ([*c]GBufferedInputStream, gssize, [*c]GCancellable, [*c]([*c]GError)) gssize,
    fill_async: ?extern fn ([*c]GBufferedInputStream, gssize, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    fill_finish: ?extern fn ([*c]GBufferedInputStream, ?*GAsyncResult, [*c]([*c]GError)) gssize,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GBufferedInputStreamClass = struct__GBufferedInputStreamClass;
pub extern fn g_buffered_input_stream_get_type() GType;
pub extern fn g_buffered_input_stream_new(base_stream: [*c]GInputStream) [*c]GInputStream;
pub extern fn g_buffered_input_stream_new_sized(base_stream: [*c]GInputStream, size: gsize) [*c]GInputStream;
pub extern fn g_buffered_input_stream_get_buffer_size(stream: [*c]GBufferedInputStream) gsize;
pub extern fn g_buffered_input_stream_set_buffer_size(stream: [*c]GBufferedInputStream, size: gsize) void;
pub extern fn g_buffered_input_stream_get_available(stream: [*c]GBufferedInputStream) gsize;
pub extern fn g_buffered_input_stream_peek(stream: [*c]GBufferedInputStream, buffer: ?*c_void, offset: gsize, count: gsize) gsize;
pub extern fn g_buffered_input_stream_peek_buffer(stream: [*c]GBufferedInputStream, count: [*c]gsize) ?*const c_void;
pub extern fn g_buffered_input_stream_fill(stream: [*c]GBufferedInputStream, count: gssize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_buffered_input_stream_fill_async(stream: [*c]GBufferedInputStream, count: gssize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_buffered_input_stream_fill_finish(stream: [*c]GBufferedInputStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_buffered_input_stream_read_byte(stream: [*c]GBufferedInputStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) c_int;
pub const struct__GOutputStreamClass = extern struct {
    parent_class: GObjectClass,
    write_fn: ?extern fn ([*c]GOutputStream, ?*const c_void, gsize, [*c]GCancellable, [*c]([*c]GError)) gssize,
    splice: ?extern fn ([*c]GOutputStream, [*c]GInputStream, GOutputStreamSpliceFlags, [*c]GCancellable, [*c]([*c]GError)) gssize,
    flush: ?extern fn ([*c]GOutputStream, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    close_fn: ?extern fn ([*c]GOutputStream, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    write_async: ?extern fn ([*c]GOutputStream, ?*const c_void, gsize, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    write_finish: ?extern fn ([*c]GOutputStream, ?*GAsyncResult, [*c]([*c]GError)) gssize,
    splice_async: ?extern fn ([*c]GOutputStream, [*c]GInputStream, GOutputStreamSpliceFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    splice_finish: ?extern fn ([*c]GOutputStream, ?*GAsyncResult, [*c]([*c]GError)) gssize,
    flush_async: ?extern fn ([*c]GOutputStream, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    flush_finish: ?extern fn ([*c]GOutputStream, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    close_async: ?extern fn ([*c]GOutputStream, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    close_finish: ?extern fn ([*c]GOutputStream, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    writev_fn: ?extern fn ([*c]GOutputStream, [*c]const GOutputVector, gsize, [*c]gsize, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    writev_async: ?extern fn ([*c]GOutputStream, [*c]const GOutputVector, gsize, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    writev_finish: ?extern fn ([*c]GOutputStream, ?*GAsyncResult, [*c]gsize, [*c]([*c]GError)) gboolean,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
    _g_reserved6: ?extern fn () void,
    _g_reserved7: ?extern fn () void,
    _g_reserved8: ?extern fn () void,
};
pub const GOutputStreamClass = struct__GOutputStreamClass;
pub extern fn g_output_stream_get_type() GType;
pub extern fn g_output_stream_write(stream: [*c]GOutputStream, buffer: ?*const c_void, count: gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_output_stream_write_all(stream: [*c]GOutputStream, buffer: ?*const c_void, count: gsize, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_output_stream_writev(stream: [*c]GOutputStream, vectors: [*c]const GOutputVector, n_vectors: gsize, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_output_stream_writev_all(stream: [*c]GOutputStream, vectors: [*c]GOutputVector, n_vectors: gsize, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_output_stream_printf(stream: [*c]GOutputStream, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError), format: [*c]const gchar, ...) gboolean;
pub extern fn g_output_stream_vprintf(stream: [*c]GOutputStream, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError), format: [*c]const gchar, args: va_list) gboolean;
pub extern fn g_output_stream_write_bytes(stream: [*c]GOutputStream, bytes: ?*GBytes, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_output_stream_splice(stream: [*c]GOutputStream, source: [*c]GInputStream, flags: GOutputStreamSpliceFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_output_stream_flush(stream: [*c]GOutputStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_output_stream_close(stream: [*c]GOutputStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_output_stream_write_async(stream: [*c]GOutputStream, buffer: ?*const c_void, count: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_write_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_output_stream_write_all_async(stream: [*c]GOutputStream, buffer: ?*const c_void, count: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_write_all_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, bytes_written: [*c]gsize, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_output_stream_writev_async(stream: [*c]GOutputStream, vectors: [*c]const GOutputVector, n_vectors: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_writev_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, bytes_written: [*c]gsize, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_output_stream_writev_all_async(stream: [*c]GOutputStream, vectors: [*c]GOutputVector, n_vectors: gsize, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_writev_all_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, bytes_written: [*c]gsize, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_output_stream_write_bytes_async(stream: [*c]GOutputStream, bytes: ?*GBytes, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_write_bytes_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_output_stream_splice_async(stream: [*c]GOutputStream, source: [*c]GInputStream, flags: GOutputStreamSpliceFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_splice_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_output_stream_flush_async(stream: [*c]GOutputStream, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_flush_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_output_stream_close_async(stream: [*c]GOutputStream, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_output_stream_close_finish(stream: [*c]GOutputStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_output_stream_is_closed(stream: [*c]GOutputStream) gboolean;
pub extern fn g_output_stream_is_closing(stream: [*c]GOutputStream) gboolean;
pub extern fn g_output_stream_has_pending(stream: [*c]GOutputStream) gboolean;
pub extern fn g_output_stream_set_pending(stream: [*c]GOutputStream, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_output_stream_clear_pending(stream: [*c]GOutputStream) void;
pub const struct__GFilterOutputStreamClass = extern struct {
    parent_class: GOutputStreamClass,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
};
pub const GFilterOutputStreamClass = struct__GFilterOutputStreamClass;
pub extern fn g_filter_output_stream_get_type() GType;
pub extern fn g_filter_output_stream_get_base_stream(stream: [*c]GFilterOutputStream) [*c]GOutputStream;
pub extern fn g_filter_output_stream_get_close_base_stream(stream: [*c]GFilterOutputStream) gboolean;
pub extern fn g_filter_output_stream_set_close_base_stream(stream: [*c]GFilterOutputStream, close_base: gboolean) void;
pub const struct__GBufferedOutputStreamClass = extern struct {
    parent_class: GFilterOutputStreamClass,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
};
pub const GBufferedOutputStreamClass = struct__GBufferedOutputStreamClass;
pub extern fn g_buffered_output_stream_get_type() GType;
pub extern fn g_buffered_output_stream_new(base_stream: [*c]GOutputStream) [*c]GOutputStream;
pub extern fn g_buffered_output_stream_new_sized(base_stream: [*c]GOutputStream, size: gsize) [*c]GOutputStream;
pub extern fn g_buffered_output_stream_get_buffer_size(stream: [*c]GBufferedOutputStream) gsize;
pub extern fn g_buffered_output_stream_set_buffer_size(stream: [*c]GBufferedOutputStream, size: gsize) void;
pub extern fn g_buffered_output_stream_get_auto_grow(stream: [*c]GBufferedOutputStream) gboolean;
pub extern fn g_buffered_output_stream_set_auto_grow(stream: [*c]GBufferedOutputStream, auto_grow: gboolean) void;
pub extern fn g_bytes_icon_get_type() GType;
pub extern fn g_bytes_icon_new(bytes: ?*GBytes) ?*GIcon;
pub extern fn g_bytes_icon_get_bytes(icon: ?*GBytesIcon) ?*GBytes;
pub const struct__GCancellableClass = extern struct {
    parent_class: GObjectClass,
    cancelled: ?extern fn ([*c]GCancellable) void,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GCancellableClass = struct__GCancellableClass;
pub extern fn g_cancellable_get_type() GType;
pub extern fn g_cancellable_new() [*c]GCancellable;
pub extern fn g_cancellable_is_cancelled(cancellable: [*c]GCancellable) gboolean;
pub extern fn g_cancellable_set_error_if_cancelled(cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_cancellable_get_fd(cancellable: [*c]GCancellable) c_int;
pub extern fn g_cancellable_make_pollfd(cancellable: [*c]GCancellable, pollfd: [*c]GPollFD) gboolean;
pub extern fn g_cancellable_release_fd(cancellable: [*c]GCancellable) void;
pub extern fn g_cancellable_source_new(cancellable: [*c]GCancellable) [*c]GSource;
pub extern fn g_cancellable_get_current() [*c]GCancellable;
pub extern fn g_cancellable_push_current(cancellable: [*c]GCancellable) void;
pub extern fn g_cancellable_pop_current(cancellable: [*c]GCancellable) void;
pub extern fn g_cancellable_reset(cancellable: [*c]GCancellable) void;
pub extern fn g_cancellable_connect(cancellable: [*c]GCancellable, callback: GCallback, data: gpointer, data_destroy_func: GDestroyNotify) gulong;
pub extern fn g_cancellable_disconnect(cancellable: [*c]GCancellable, handler_id: gulong) void;
pub extern fn g_cancellable_cancel(cancellable: [*c]GCancellable) void;
pub const struct__GConverterIface = extern struct {
    g_iface: GTypeInterface,
    convert: ?extern fn (?*GConverter, ?*const c_void, gsize, ?*c_void, gsize, GConverterFlags, [*c]gsize, [*c]gsize, [*c]([*c]GError)) GConverterResult,
    reset: ?extern fn (?*GConverter) void,
};
pub const GConverterIface = struct__GConverterIface;
pub extern fn g_converter_get_type() GType;
pub extern fn g_converter_convert(converter: ?*GConverter, inbuf: ?*const c_void, inbuf_size: gsize, outbuf: ?*c_void, outbuf_size: gsize, flags: GConverterFlags, bytes_read: [*c]gsize, bytes_written: [*c]gsize, @"error": [*c]([*c]GError)) GConverterResult;
pub extern fn g_converter_reset(converter: ?*GConverter) void;
pub const struct__GCharsetConverterClass = extern struct {
    parent_class: GObjectClass,
};
pub const GCharsetConverterClass = struct__GCharsetConverterClass;
pub extern fn g_charset_converter_get_type() GType;
pub extern fn g_charset_converter_new(to_charset: [*c]const gchar, from_charset: [*c]const gchar, @"error": [*c]([*c]GError)) ?*GCharsetConverter;
pub extern fn g_charset_converter_set_use_fallback(converter: ?*GCharsetConverter, use_fallback: gboolean) void;
pub extern fn g_charset_converter_get_use_fallback(converter: ?*GCharsetConverter) gboolean;
pub extern fn g_charset_converter_get_num_fallbacks(converter: ?*GCharsetConverter) guint;
pub extern fn g_content_type_equals(type1: [*c]const gchar, type2: [*c]const gchar) gboolean;
pub extern fn g_content_type_is_a(type_0: [*c]const gchar, supertype: [*c]const gchar) gboolean;
pub extern fn g_content_type_is_mime_type(type_0: [*c]const gchar, mime_type: [*c]const gchar) gboolean;
pub extern fn g_content_type_is_unknown(type_0: [*c]const gchar) gboolean;
pub extern fn g_content_type_get_description(type_0: [*c]const gchar) [*c]gchar;
pub extern fn g_content_type_get_mime_type(type_0: [*c]const gchar) [*c]gchar;
pub extern fn g_content_type_get_icon(type_0: [*c]const gchar) ?*GIcon;
pub extern fn g_content_type_get_symbolic_icon(type_0: [*c]const gchar) ?*GIcon;
pub extern fn g_content_type_get_generic_icon_name(type_0: [*c]const gchar) [*c]gchar;
pub extern fn g_content_type_can_be_executable(type_0: [*c]const gchar) gboolean;
pub extern fn g_content_type_from_mime_type(mime_type: [*c]const gchar) [*c]gchar;
pub extern fn g_content_type_guess(filename: [*c]const gchar, data: [*c]const guchar, data_size: gsize, result_uncertain: [*c]gboolean) [*c]gchar;
pub extern fn g_content_type_guess_for_tree(root: ?*GFile) [*c]([*c]gchar);
pub extern fn g_content_types_get_registered() [*c]GList;
pub extern fn g_content_type_get_mime_dirs() [*c]const ([*c]const gchar);
pub extern fn g_content_type_set_mime_dirs(dirs: [*c]const ([*c]const gchar)) void;
pub const struct__GConverterInputStreamClass = extern struct {
    parent_class: GFilterInputStreamClass,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GConverterInputStreamClass = struct__GConverterInputStreamClass;
pub extern fn g_converter_input_stream_get_type() GType;
pub extern fn g_converter_input_stream_new(base_stream: [*c]GInputStream, converter: ?*GConverter) [*c]GInputStream;
pub extern fn g_converter_input_stream_get_converter(converter_stream: [*c]GConverterInputStream) ?*GConverter;
pub const struct__GConverterOutputStreamClass = extern struct {
    parent_class: GFilterOutputStreamClass,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GConverterOutputStreamClass = struct__GConverterOutputStreamClass;
pub extern fn g_converter_output_stream_get_type() GType;
pub extern fn g_converter_output_stream_new(base_stream: [*c]GOutputStream, converter: ?*GConverter) [*c]GOutputStream;
pub extern fn g_converter_output_stream_get_converter(converter_stream: [*c]GConverterOutputStream) ?*GConverter;
pub const struct__GCredentialsClass = @OpaqueType();
pub const GCredentialsClass = struct__GCredentialsClass;
pub extern fn g_credentials_get_type() GType;
pub extern fn g_credentials_new() ?*GCredentials;
pub extern fn g_credentials_to_string(credentials: ?*GCredentials) [*c]gchar;
pub extern fn g_credentials_get_native(credentials: ?*GCredentials, native_type: GCredentialsType) gpointer;
pub extern fn g_credentials_set_native(credentials: ?*GCredentials, native_type: GCredentialsType, native: gpointer) void;
pub extern fn g_credentials_is_same_user(credentials: ?*GCredentials, other_credentials: ?*GCredentials, @"error": [*c]([*c]GError)) gboolean;
pub const struct__GDatagramBasedInterface = extern struct {
    g_iface: GTypeInterface,
    receive_messages: ?extern fn (?*GDatagramBased, [*c]GInputMessage, guint, gint, gint64, [*c]GCancellable, [*c]([*c]GError)) gint,
    send_messages: ?extern fn (?*GDatagramBased, [*c]GOutputMessage, guint, gint, gint64, [*c]GCancellable, [*c]([*c]GError)) gint,
    create_source: ?extern fn (?*GDatagramBased, GIOCondition, [*c]GCancellable) [*c]GSource,
    condition_check: ?extern fn (?*GDatagramBased, GIOCondition) GIOCondition,
    condition_wait: ?extern fn (?*GDatagramBased, GIOCondition, gint64, [*c]GCancellable, [*c]([*c]GError)) gboolean,
};
pub const GDatagramBasedInterface = struct__GDatagramBasedInterface;
pub extern fn g_datagram_based_get_type() GType;
pub extern fn g_datagram_based_receive_messages(datagram_based: ?*GDatagramBased, messages: [*c]GInputMessage, num_messages: guint, flags: gint, timeout: gint64, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gint;
pub extern fn g_datagram_based_send_messages(datagram_based: ?*GDatagramBased, messages: [*c]GOutputMessage, num_messages: guint, flags: gint, timeout: gint64, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gint;
pub extern fn g_datagram_based_create_source(datagram_based: ?*GDatagramBased, condition: GIOCondition, cancellable: [*c]GCancellable) [*c]GSource;
pub extern fn g_datagram_based_condition_check(datagram_based: ?*GDatagramBased, condition: GIOCondition) GIOCondition;
pub extern fn g_datagram_based_condition_wait(datagram_based: ?*GDatagramBased, condition: GIOCondition, timeout: gint64, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub const struct__GDataInputStreamClass = extern struct {
    parent_class: GBufferedInputStreamClass,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GDataInputStreamClass = struct__GDataInputStreamClass;
pub extern fn g_data_input_stream_get_type() GType;
pub extern fn g_data_input_stream_new(base_stream: [*c]GInputStream) [*c]GDataInputStream;
pub extern fn g_data_input_stream_set_byte_order(stream: [*c]GDataInputStream, order: GDataStreamByteOrder) void;
pub extern fn g_data_input_stream_get_byte_order(stream: [*c]GDataInputStream) GDataStreamByteOrder;
pub extern fn g_data_input_stream_set_newline_type(stream: [*c]GDataInputStream, type_0: GDataStreamNewlineType) void;
pub extern fn g_data_input_stream_get_newline_type(stream: [*c]GDataInputStream) GDataStreamNewlineType;
pub extern fn g_data_input_stream_read_byte(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) guchar;
pub extern fn g_data_input_stream_read_int16(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gint16;
pub extern fn g_data_input_stream_read_uint16(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) guint16;
pub extern fn g_data_input_stream_read_int32(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gint32;
pub extern fn g_data_input_stream_read_uint32(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) guint32;
pub extern fn g_data_input_stream_read_int64(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gint64;
pub extern fn g_data_input_stream_read_uint64(stream: [*c]GDataInputStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) guint64;
pub extern fn g_data_input_stream_read_line(stream: [*c]GDataInputStream, length: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]u8;
pub extern fn g_data_input_stream_read_line_utf8(stream: [*c]GDataInputStream, length: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]u8;
pub extern fn g_data_input_stream_read_line_async(stream: [*c]GDataInputStream, io_priority: gint, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_data_input_stream_read_line_finish(stream: [*c]GDataInputStream, result: ?*GAsyncResult, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]u8;
pub extern fn g_data_input_stream_read_line_finish_utf8(stream: [*c]GDataInputStream, result: ?*GAsyncResult, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]u8;
pub extern fn g_data_input_stream_read_until(stream: [*c]GDataInputStream, stop_chars: [*c]const gchar, length: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]u8;
pub extern fn g_data_input_stream_read_until_async(stream: [*c]GDataInputStream, stop_chars: [*c]const gchar, io_priority: gint, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_data_input_stream_read_until_finish(stream: [*c]GDataInputStream, result: ?*GAsyncResult, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]u8;
pub extern fn g_data_input_stream_read_upto(stream: [*c]GDataInputStream, stop_chars: [*c]const gchar, stop_chars_len: gssize, length: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]u8;
pub extern fn g_data_input_stream_read_upto_async(stream: [*c]GDataInputStream, stop_chars: [*c]const gchar, stop_chars_len: gssize, io_priority: gint, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_data_input_stream_read_upto_finish(stream: [*c]GDataInputStream, result: ?*GAsyncResult, length: [*c]gsize, @"error": [*c]([*c]GError)) [*c]u8;
pub const struct__GDataOutputStreamPrivate = @OpaqueType();
pub const GDataOutputStreamPrivate = struct__GDataOutputStreamPrivate;
pub const struct__GDataOutputStream = extern struct {
    parent_instance: GFilterOutputStream,
    priv: ?*GDataOutputStreamPrivate,
};
pub const GDataOutputStream = struct__GDataOutputStream;
pub const struct__GDataOutputStreamClass = extern struct {
    parent_class: GFilterOutputStreamClass,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GDataOutputStreamClass = struct__GDataOutputStreamClass;
pub extern fn g_data_output_stream_get_type() GType;
pub extern fn g_data_output_stream_new(base_stream: [*c]GOutputStream) [*c]GDataOutputStream;
pub extern fn g_data_output_stream_set_byte_order(stream: [*c]GDataOutputStream, order: GDataStreamByteOrder) void;
pub extern fn g_data_output_stream_get_byte_order(stream: [*c]GDataOutputStream) GDataStreamByteOrder;
pub extern fn g_data_output_stream_put_byte(stream: [*c]GDataOutputStream, data: guchar, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_data_output_stream_put_int16(stream: [*c]GDataOutputStream, data: gint16, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_data_output_stream_put_uint16(stream: [*c]GDataOutputStream, data: guint16, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_data_output_stream_put_int32(stream: [*c]GDataOutputStream, data: gint32, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_data_output_stream_put_uint32(stream: [*c]GDataOutputStream, data: guint32, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_data_output_stream_put_int64(stream: [*c]GDataOutputStream, data: gint64, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_data_output_stream_put_uint64(stream: [*c]GDataOutputStream, data: guint64, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_data_output_stream_put_string(stream: [*c]GDataOutputStream, str: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dbus_address_escape_value(string: [*c]const gchar) [*c]gchar;
pub extern fn g_dbus_is_address(string: [*c]const gchar) gboolean;
pub extern fn g_dbus_is_supported_address(string: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dbus_address_get_stream(address: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_address_get_stream_finish(res: ?*GAsyncResult, out_guid: [*c]([*c]gchar), @"error": [*c]([*c]GError)) [*c]GIOStream;
pub extern fn g_dbus_address_get_stream_sync(address: [*c]const gchar, out_guid: [*c]([*c]gchar), cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GIOStream;
pub extern fn g_dbus_address_get_for_bus_sync(bus_type: GBusType, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_dbus_auth_observer_get_type() GType;
pub extern fn g_dbus_auth_observer_new() ?*GDBusAuthObserver;
pub extern fn g_dbus_auth_observer_authorize_authenticated_peer(observer: ?*GDBusAuthObserver, stream: [*c]GIOStream, credentials: ?*GCredentials) gboolean;
pub extern fn g_dbus_auth_observer_allow_mechanism(observer: ?*GDBusAuthObserver, mechanism: [*c]const gchar) gboolean;
pub extern fn g_dbus_connection_get_type() GType;
pub extern fn g_bus_get(bus_type: GBusType, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_bus_get_finish(res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GDBusConnection;
pub extern fn g_bus_get_sync(bus_type: GBusType, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GDBusConnection;
pub extern fn g_dbus_connection_new(stream: [*c]GIOStream, guid: [*c]const gchar, flags: GDBusConnectionFlags, observer: ?*GDBusAuthObserver, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_new_finish(res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GDBusConnection;
pub extern fn g_dbus_connection_new_sync(stream: [*c]GIOStream, guid: [*c]const gchar, flags: GDBusConnectionFlags, observer: ?*GDBusAuthObserver, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GDBusConnection;
pub extern fn g_dbus_connection_new_for_address(address: [*c]const gchar, flags: GDBusConnectionFlags, observer: ?*GDBusAuthObserver, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_new_for_address_finish(res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GDBusConnection;
pub extern fn g_dbus_connection_new_for_address_sync(address: [*c]const gchar, flags: GDBusConnectionFlags, observer: ?*GDBusAuthObserver, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GDBusConnection;
pub extern fn g_dbus_connection_start_message_processing(connection: ?*GDBusConnection) void;
pub extern fn g_dbus_connection_is_closed(connection: ?*GDBusConnection) gboolean;
pub extern fn g_dbus_connection_get_stream(connection: ?*GDBusConnection) [*c]GIOStream;
pub extern fn g_dbus_connection_get_guid(connection: ?*GDBusConnection) [*c]const gchar;
pub extern fn g_dbus_connection_get_unique_name(connection: ?*GDBusConnection) [*c]const gchar;
pub extern fn g_dbus_connection_get_peer_credentials(connection: ?*GDBusConnection) ?*GCredentials;
pub extern fn g_dbus_connection_get_last_serial(connection: ?*GDBusConnection) guint32;
pub extern fn g_dbus_connection_get_exit_on_close(connection: ?*GDBusConnection) gboolean;
pub extern fn g_dbus_connection_set_exit_on_close(connection: ?*GDBusConnection, exit_on_close: gboolean) void;
pub extern fn g_dbus_connection_get_capabilities(connection: ?*GDBusConnection) GDBusCapabilityFlags;
pub extern fn g_dbus_connection_get_flags(connection: ?*GDBusConnection) GDBusConnectionFlags;
pub extern fn g_dbus_connection_close(connection: ?*GDBusConnection, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_close_finish(connection: ?*GDBusConnection, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dbus_connection_close_sync(connection: ?*GDBusConnection, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dbus_connection_flush(connection: ?*GDBusConnection, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_flush_finish(connection: ?*GDBusConnection, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dbus_connection_flush_sync(connection: ?*GDBusConnection, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dbus_connection_send_message(connection: ?*GDBusConnection, message: ?*GDBusMessage, flags: GDBusSendMessageFlags, out_serial: [*c]volatile guint32, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dbus_connection_send_message_with_reply(connection: ?*GDBusConnection, message: ?*GDBusMessage, flags: GDBusSendMessageFlags, timeout_msec: gint, out_serial: [*c]volatile guint32, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_send_message_with_reply_finish(connection: ?*GDBusConnection, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GDBusMessage;
pub extern fn g_dbus_connection_send_message_with_reply_sync(connection: ?*GDBusConnection, message: ?*GDBusMessage, flags: GDBusSendMessageFlags, timeout_msec: gint, out_serial: [*c]volatile guint32, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GDBusMessage;
pub extern fn g_dbus_connection_emit_signal(connection: ?*GDBusConnection, destination_bus_name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, signal_name: [*c]const gchar, parameters: ?*GVariant, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dbus_connection_call(connection: ?*GDBusConnection, bus_name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, method_name: [*c]const gchar, parameters: ?*GVariant, reply_type: ?*const GVariantType, flags: GDBusCallFlags, timeout_msec: gint, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_call_finish(connection: ?*GDBusConnection, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GVariant;
pub extern fn g_dbus_connection_call_sync(connection: ?*GDBusConnection, bus_name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, method_name: [*c]const gchar, parameters: ?*GVariant, reply_type: ?*const GVariantType, flags: GDBusCallFlags, timeout_msec: gint, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GVariant;
pub extern fn g_dbus_connection_call_with_unix_fd_list(connection: ?*GDBusConnection, bus_name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, method_name: [*c]const gchar, parameters: ?*GVariant, reply_type: ?*const GVariantType, flags: GDBusCallFlags, timeout_msec: gint, fd_list: ?*GUnixFDList, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_connection_call_with_unix_fd_list_finish(connection: ?*GDBusConnection, out_fd_list: [*c](?*GUnixFDList), res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GVariant;
pub extern fn g_dbus_connection_call_with_unix_fd_list_sync(connection: ?*GDBusConnection, bus_name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, method_name: [*c]const gchar, parameters: ?*GVariant, reply_type: ?*const GVariantType, flags: GDBusCallFlags, timeout_msec: gint, fd_list: ?*GUnixFDList, out_fd_list: [*c](?*GUnixFDList), cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GVariant;
pub extern fn g_dbus_connection_register_object(connection: ?*GDBusConnection, object_path: [*c]const gchar, interface_info: [*c]GDBusInterfaceInfo, vtable: [*c]const GDBusInterfaceVTable, user_data: gpointer, user_data_free_func: GDestroyNotify, @"error": [*c]([*c]GError)) guint;
pub extern fn g_dbus_connection_register_object_with_closures(connection: ?*GDBusConnection, object_path: [*c]const gchar, interface_info: [*c]GDBusInterfaceInfo, method_call_closure: ?*GClosure, get_property_closure: ?*GClosure, set_property_closure: ?*GClosure, @"error": [*c]([*c]GError)) guint;
pub extern fn g_dbus_connection_unregister_object(connection: ?*GDBusConnection, registration_id: guint) gboolean;
pub extern fn g_dbus_connection_register_subtree(connection: ?*GDBusConnection, object_path: [*c]const gchar, vtable: [*c]const GDBusSubtreeVTable, flags: GDBusSubtreeFlags, user_data: gpointer, user_data_free_func: GDestroyNotify, @"error": [*c]([*c]GError)) guint;
pub extern fn g_dbus_connection_unregister_subtree(connection: ?*GDBusConnection, registration_id: guint) gboolean;
pub const GDBusSignalCallback = ?extern fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, [*c]const gchar, [*c]const gchar, ?*GVariant, gpointer) void;
pub extern fn g_dbus_connection_signal_subscribe(connection: ?*GDBusConnection, sender: [*c]const gchar, interface_name: [*c]const gchar, member: [*c]const gchar, object_path: [*c]const gchar, arg0: [*c]const gchar, flags: GDBusSignalFlags, callback: GDBusSignalCallback, user_data: gpointer, user_data_free_func: GDestroyNotify) guint;
pub extern fn g_dbus_connection_signal_unsubscribe(connection: ?*GDBusConnection, subscription_id: guint) void;
pub const GDBusMessageFilterFunction = ?extern fn (?*GDBusConnection, ?*GDBusMessage, gboolean, gpointer) ?*GDBusMessage;
pub extern fn g_dbus_connection_add_filter(connection: ?*GDBusConnection, filter_function: GDBusMessageFilterFunction, user_data: gpointer, user_data_free_func: GDestroyNotify) guint;
pub extern fn g_dbus_connection_remove_filter(connection: ?*GDBusConnection, filter_id: guint) void;
pub extern fn g_dbus_error_quark() GQuark;
pub extern fn g_dbus_error_is_remote_error(@"error": [*c]const GError) gboolean;
pub extern fn g_dbus_error_get_remote_error(@"error": [*c]const GError) [*c]gchar;
pub extern fn g_dbus_error_strip_remote_error(@"error": [*c]GError) gboolean;
pub extern fn g_dbus_error_register_error(error_domain: GQuark, error_code: gint, dbus_error_name: [*c]const gchar) gboolean;
pub extern fn g_dbus_error_unregister_error(error_domain: GQuark, error_code: gint, dbus_error_name: [*c]const gchar) gboolean;
pub extern fn g_dbus_error_register_error_domain(error_domain_quark_name: [*c]const gchar, quark_volatile: [*c]volatile gsize, entries: [*c]const GDBusErrorEntry, num_entries: guint) void;
pub extern fn g_dbus_error_new_for_dbus_error(dbus_error_name: [*c]const gchar, dbus_error_message: [*c]const gchar) [*c]GError;
pub extern fn g_dbus_error_set_dbus_error(@"error": [*c]([*c]GError), dbus_error_name: [*c]const gchar, dbus_error_message: [*c]const gchar, format: [*c]const gchar, ...) void;
pub extern fn g_dbus_error_set_dbus_error_valist(@"error": [*c]([*c]GError), dbus_error_name: [*c]const gchar, dbus_error_message: [*c]const gchar, format: [*c]const gchar, var_args: va_list) void;
pub extern fn g_dbus_error_encode_gerror(@"error": [*c]const GError) [*c]gchar;
pub extern fn g_dbus_annotation_info_lookup(annotations: [*c]([*c]GDBusAnnotationInfo), name: [*c]const gchar) [*c]const gchar;
pub extern fn g_dbus_interface_info_lookup_method(info: [*c]GDBusInterfaceInfo, name: [*c]const gchar) [*c]GDBusMethodInfo;
pub extern fn g_dbus_interface_info_lookup_signal(info: [*c]GDBusInterfaceInfo, name: [*c]const gchar) [*c]GDBusSignalInfo;
pub extern fn g_dbus_interface_info_lookup_property(info: [*c]GDBusInterfaceInfo, name: [*c]const gchar) [*c]GDBusPropertyInfo;
pub extern fn g_dbus_interface_info_cache_build(info: [*c]GDBusInterfaceInfo) void;
pub extern fn g_dbus_interface_info_cache_release(info: [*c]GDBusInterfaceInfo) void;
pub extern fn g_dbus_interface_info_generate_xml(info: [*c]GDBusInterfaceInfo, indent: guint, string_builder: [*c]GString) void;
pub extern fn g_dbus_node_info_new_for_xml(xml_data: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]GDBusNodeInfo;
pub extern fn g_dbus_node_info_lookup_interface(info: [*c]GDBusNodeInfo, name: [*c]const gchar) [*c]GDBusInterfaceInfo;
pub extern fn g_dbus_node_info_generate_xml(info: [*c]GDBusNodeInfo, indent: guint, string_builder: [*c]GString) void;
pub extern fn g_dbus_node_info_ref(info: [*c]GDBusNodeInfo) [*c]GDBusNodeInfo;
pub extern fn g_dbus_interface_info_ref(info: [*c]GDBusInterfaceInfo) [*c]GDBusInterfaceInfo;
pub extern fn g_dbus_method_info_ref(info: [*c]GDBusMethodInfo) [*c]GDBusMethodInfo;
pub extern fn g_dbus_signal_info_ref(info: [*c]GDBusSignalInfo) [*c]GDBusSignalInfo;
pub extern fn g_dbus_property_info_ref(info: [*c]GDBusPropertyInfo) [*c]GDBusPropertyInfo;
pub extern fn g_dbus_arg_info_ref(info: [*c]GDBusArgInfo) [*c]GDBusArgInfo;
pub extern fn g_dbus_annotation_info_ref(info: [*c]GDBusAnnotationInfo) [*c]GDBusAnnotationInfo;
pub extern fn g_dbus_node_info_unref(info: [*c]GDBusNodeInfo) void;
pub extern fn g_dbus_interface_info_unref(info: [*c]GDBusInterfaceInfo) void;
pub extern fn g_dbus_method_info_unref(info: [*c]GDBusMethodInfo) void;
pub extern fn g_dbus_signal_info_unref(info: [*c]GDBusSignalInfo) void;
pub extern fn g_dbus_property_info_unref(info: [*c]GDBusPropertyInfo) void;
pub extern fn g_dbus_arg_info_unref(info: [*c]GDBusArgInfo) void;
pub extern fn g_dbus_annotation_info_unref(info: [*c]GDBusAnnotationInfo) void;
pub extern fn g_dbus_node_info_get_type() GType;
pub extern fn g_dbus_interface_info_get_type() GType;
pub extern fn g_dbus_method_info_get_type() GType;
pub extern fn g_dbus_signal_info_get_type() GType;
pub extern fn g_dbus_property_info_get_type() GType;
pub extern fn g_dbus_arg_info_get_type() GType;
pub extern fn g_dbus_annotation_info_get_type() GType;
pub extern fn g_dbus_message_get_type() GType;
pub extern fn g_dbus_message_new() ?*GDBusMessage;
pub extern fn g_dbus_message_new_signal(path: [*c]const gchar, interface_: [*c]const gchar, signal_0: [*c]const gchar) ?*GDBusMessage;
pub extern fn g_dbus_message_new_method_call(name: [*c]const gchar, path: [*c]const gchar, interface_: [*c]const gchar, method: [*c]const gchar) ?*GDBusMessage;
pub extern fn g_dbus_message_new_method_reply(method_call_message: ?*GDBusMessage) ?*GDBusMessage;
pub extern fn g_dbus_message_new_method_error(method_call_message: ?*GDBusMessage, error_name: [*c]const gchar, error_message_format: [*c]const gchar, ...) ?*GDBusMessage;
pub extern fn g_dbus_message_new_method_error_valist(method_call_message: ?*GDBusMessage, error_name: [*c]const gchar, error_message_format: [*c]const gchar, var_args: va_list) ?*GDBusMessage;
pub extern fn g_dbus_message_new_method_error_literal(method_call_message: ?*GDBusMessage, error_name: [*c]const gchar, error_message: [*c]const gchar) ?*GDBusMessage;
pub extern fn g_dbus_message_print(message: ?*GDBusMessage, indent: guint) [*c]gchar;
pub extern fn g_dbus_message_get_locked(message: ?*GDBusMessage) gboolean;
pub extern fn g_dbus_message_lock(message: ?*GDBusMessage) void;
pub extern fn g_dbus_message_copy(message: ?*GDBusMessage, @"error": [*c]([*c]GError)) ?*GDBusMessage;
pub extern fn g_dbus_message_get_byte_order(message: ?*GDBusMessage) GDBusMessageByteOrder;
pub extern fn g_dbus_message_set_byte_order(message: ?*GDBusMessage, byte_order: GDBusMessageByteOrder) void;
pub extern fn g_dbus_message_get_message_type(message: ?*GDBusMessage) GDBusMessageType;
pub extern fn g_dbus_message_set_message_type(message: ?*GDBusMessage, type_0: GDBusMessageType) void;
pub extern fn g_dbus_message_get_flags(message: ?*GDBusMessage) GDBusMessageFlags;
pub extern fn g_dbus_message_set_flags(message: ?*GDBusMessage, flags: GDBusMessageFlags) void;
pub extern fn g_dbus_message_get_serial(message: ?*GDBusMessage) guint32;
pub extern fn g_dbus_message_set_serial(message: ?*GDBusMessage, serial: guint32) void;
pub extern fn g_dbus_message_get_header(message: ?*GDBusMessage, header_field: GDBusMessageHeaderField) ?*GVariant;
pub extern fn g_dbus_message_set_header(message: ?*GDBusMessage, header_field: GDBusMessageHeaderField, value: ?*GVariant) void;
pub extern fn g_dbus_message_get_header_fields(message: ?*GDBusMessage) [*c]guchar;
pub extern fn g_dbus_message_get_body(message: ?*GDBusMessage) ?*GVariant;
pub extern fn g_dbus_message_set_body(message: ?*GDBusMessage, body: ?*GVariant) void;
pub extern fn g_dbus_message_get_unix_fd_list(message: ?*GDBusMessage) ?*GUnixFDList;
pub extern fn g_dbus_message_set_unix_fd_list(message: ?*GDBusMessage, fd_list: ?*GUnixFDList) void;
pub extern fn g_dbus_message_get_reply_serial(message: ?*GDBusMessage) guint32;
pub extern fn g_dbus_message_set_reply_serial(message: ?*GDBusMessage, value: guint32) void;
pub extern fn g_dbus_message_get_interface(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_interface(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_member(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_member(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_path(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_path(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_sender(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_sender(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_destination(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_destination(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_error_name(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_error_name(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_signature(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_set_signature(message: ?*GDBusMessage, value: [*c]const gchar) void;
pub extern fn g_dbus_message_get_num_unix_fds(message: ?*GDBusMessage) guint32;
pub extern fn g_dbus_message_set_num_unix_fds(message: ?*GDBusMessage, value: guint32) void;
pub extern fn g_dbus_message_get_arg0(message: ?*GDBusMessage) [*c]const gchar;
pub extern fn g_dbus_message_new_from_blob(blob: [*c]guchar, blob_len: gsize, capabilities: GDBusCapabilityFlags, @"error": [*c]([*c]GError)) ?*GDBusMessage;
pub extern fn g_dbus_message_bytes_needed(blob: [*c]guchar, blob_len: gsize, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_dbus_message_to_blob(message: ?*GDBusMessage, out_size: [*c]gsize, capabilities: GDBusCapabilityFlags, @"error": [*c]([*c]GError)) [*c]guchar;
pub extern fn g_dbus_message_to_gerror(message: ?*GDBusMessage, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dbus_method_invocation_get_type() GType;
pub extern fn g_dbus_method_invocation_get_sender(invocation: ?*GDBusMethodInvocation) [*c]const gchar;
pub extern fn g_dbus_method_invocation_get_object_path(invocation: ?*GDBusMethodInvocation) [*c]const gchar;
pub extern fn g_dbus_method_invocation_get_interface_name(invocation: ?*GDBusMethodInvocation) [*c]const gchar;
pub extern fn g_dbus_method_invocation_get_method_name(invocation: ?*GDBusMethodInvocation) [*c]const gchar;
pub extern fn g_dbus_method_invocation_get_method_info(invocation: ?*GDBusMethodInvocation) [*c]const GDBusMethodInfo;
pub extern fn g_dbus_method_invocation_get_property_info(invocation: ?*GDBusMethodInvocation) [*c]const GDBusPropertyInfo;
pub extern fn g_dbus_method_invocation_get_connection(invocation: ?*GDBusMethodInvocation) ?*GDBusConnection;
pub extern fn g_dbus_method_invocation_get_message(invocation: ?*GDBusMethodInvocation) ?*GDBusMessage;
pub extern fn g_dbus_method_invocation_get_parameters(invocation: ?*GDBusMethodInvocation) ?*GVariant;
pub extern fn g_dbus_method_invocation_get_user_data(invocation: ?*GDBusMethodInvocation) gpointer;
pub extern fn g_dbus_method_invocation_return_value(invocation: ?*GDBusMethodInvocation, parameters: ?*GVariant) void;
pub extern fn g_dbus_method_invocation_return_value_with_unix_fd_list(invocation: ?*GDBusMethodInvocation, parameters: ?*GVariant, fd_list: ?*GUnixFDList) void;
pub extern fn g_dbus_method_invocation_return_error(invocation: ?*GDBusMethodInvocation, domain: GQuark, code: gint, format: [*c]const gchar, ...) void;
pub extern fn g_dbus_method_invocation_return_error_valist(invocation: ?*GDBusMethodInvocation, domain: GQuark, code: gint, format: [*c]const gchar, var_args: va_list) void;
pub extern fn g_dbus_method_invocation_return_error_literal(invocation: ?*GDBusMethodInvocation, domain: GQuark, code: gint, message: [*c]const gchar) void;
pub extern fn g_dbus_method_invocation_return_gerror(invocation: ?*GDBusMethodInvocation, @"error": [*c]const GError) void;
pub extern fn g_dbus_method_invocation_take_error(invocation: ?*GDBusMethodInvocation, @"error": [*c]GError) void;
pub extern fn g_dbus_method_invocation_return_dbus_error(invocation: ?*GDBusMethodInvocation, error_name: [*c]const gchar, error_message: [*c]const gchar) void;
pub const GBusAcquiredCallback = ?extern fn (?*GDBusConnection, [*c]const gchar, gpointer) void;
pub const GBusNameAcquiredCallback = ?extern fn (?*GDBusConnection, [*c]const gchar, gpointer) void;
pub const GBusNameLostCallback = ?extern fn (?*GDBusConnection, [*c]const gchar, gpointer) void;
pub extern fn g_bus_own_name(bus_type: GBusType, name: [*c]const gchar, flags: GBusNameOwnerFlags, bus_acquired_handler: GBusAcquiredCallback, name_acquired_handler: GBusNameAcquiredCallback, name_lost_handler: GBusNameLostCallback, user_data: gpointer, user_data_free_func: GDestroyNotify) guint;
pub extern fn g_bus_own_name_on_connection(connection: ?*GDBusConnection, name: [*c]const gchar, flags: GBusNameOwnerFlags, name_acquired_handler: GBusNameAcquiredCallback, name_lost_handler: GBusNameLostCallback, user_data: gpointer, user_data_free_func: GDestroyNotify) guint;
pub extern fn g_bus_own_name_with_closures(bus_type: GBusType, name: [*c]const gchar, flags: GBusNameOwnerFlags, bus_acquired_closure: ?*GClosure, name_acquired_closure: ?*GClosure, name_lost_closure: ?*GClosure) guint;
pub extern fn g_bus_own_name_on_connection_with_closures(connection: ?*GDBusConnection, name: [*c]const gchar, flags: GBusNameOwnerFlags, name_acquired_closure: ?*GClosure, name_lost_closure: ?*GClosure) guint;
pub extern fn g_bus_unown_name(owner_id: guint) void;
pub const GBusNameAppearedCallback = ?extern fn (?*GDBusConnection, [*c]const gchar, [*c]const gchar, gpointer) void;
pub const GBusNameVanishedCallback = ?extern fn (?*GDBusConnection, [*c]const gchar, gpointer) void;
pub extern fn g_bus_watch_name(bus_type: GBusType, name: [*c]const gchar, flags: GBusNameWatcherFlags, name_appeared_handler: GBusNameAppearedCallback, name_vanished_handler: GBusNameVanishedCallback, user_data: gpointer, user_data_free_func: GDestroyNotify) guint;
pub extern fn g_bus_watch_name_on_connection(connection: ?*GDBusConnection, name: [*c]const gchar, flags: GBusNameWatcherFlags, name_appeared_handler: GBusNameAppearedCallback, name_vanished_handler: GBusNameVanishedCallback, user_data: gpointer, user_data_free_func: GDestroyNotify) guint;
pub extern fn g_bus_watch_name_with_closures(bus_type: GBusType, name: [*c]const gchar, flags: GBusNameWatcherFlags, name_appeared_closure: ?*GClosure, name_vanished_closure: ?*GClosure) guint;
pub extern fn g_bus_watch_name_on_connection_with_closures(connection: ?*GDBusConnection, name: [*c]const gchar, flags: GBusNameWatcherFlags, name_appeared_closure: ?*GClosure, name_vanished_closure: ?*GClosure) guint;
pub extern fn g_bus_unwatch_name(watcher_id: guint) void;
pub const struct__GDBusProxyClass = extern struct {
    parent_class: GObjectClass,
    g_properties_changed: ?extern fn ([*c]GDBusProxy, ?*GVariant, [*c]const ([*c]const gchar)) void,
    g_signal: ?extern fn ([*c]GDBusProxy, [*c]const gchar, [*c]const gchar, ?*GVariant) void,
    padding: [32]gpointer,
};
pub const GDBusProxyClass = struct__GDBusProxyClass;
pub extern fn g_dbus_proxy_get_type() GType;
pub extern fn g_dbus_proxy_new(connection: ?*GDBusConnection, flags: GDBusProxyFlags, info: [*c]GDBusInterfaceInfo, name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_proxy_new_finish(res: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GDBusProxy;
pub extern fn g_dbus_proxy_new_sync(connection: ?*GDBusConnection, flags: GDBusProxyFlags, info: [*c]GDBusInterfaceInfo, name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GDBusProxy;
pub extern fn g_dbus_proxy_new_for_bus(bus_type: GBusType, flags: GDBusProxyFlags, info: [*c]GDBusInterfaceInfo, name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_proxy_new_for_bus_finish(res: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GDBusProxy;
pub extern fn g_dbus_proxy_new_for_bus_sync(bus_type: GBusType, flags: GDBusProxyFlags, info: [*c]GDBusInterfaceInfo, name: [*c]const gchar, object_path: [*c]const gchar, interface_name: [*c]const gchar, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GDBusProxy;
pub extern fn g_dbus_proxy_get_connection(proxy: [*c]GDBusProxy) ?*GDBusConnection;
pub extern fn g_dbus_proxy_get_flags(proxy: [*c]GDBusProxy) GDBusProxyFlags;
pub extern fn g_dbus_proxy_get_name(proxy: [*c]GDBusProxy) [*c]const gchar;
pub extern fn g_dbus_proxy_get_name_owner(proxy: [*c]GDBusProxy) [*c]gchar;
pub extern fn g_dbus_proxy_get_object_path(proxy: [*c]GDBusProxy) [*c]const gchar;
pub extern fn g_dbus_proxy_get_interface_name(proxy: [*c]GDBusProxy) [*c]const gchar;
pub extern fn g_dbus_proxy_get_default_timeout(proxy: [*c]GDBusProxy) gint;
pub extern fn g_dbus_proxy_set_default_timeout(proxy: [*c]GDBusProxy, timeout_msec: gint) void;
pub extern fn g_dbus_proxy_get_interface_info(proxy: [*c]GDBusProxy) [*c]GDBusInterfaceInfo;
pub extern fn g_dbus_proxy_set_interface_info(proxy: [*c]GDBusProxy, info: [*c]GDBusInterfaceInfo) void;
pub extern fn g_dbus_proxy_get_cached_property(proxy: [*c]GDBusProxy, property_name: [*c]const gchar) ?*GVariant;
pub extern fn g_dbus_proxy_set_cached_property(proxy: [*c]GDBusProxy, property_name: [*c]const gchar, value: ?*GVariant) void;
pub extern fn g_dbus_proxy_get_cached_property_names(proxy: [*c]GDBusProxy) [*c]([*c]gchar);
pub extern fn g_dbus_proxy_call(proxy: [*c]GDBusProxy, method_name: [*c]const gchar, parameters: ?*GVariant, flags: GDBusCallFlags, timeout_msec: gint, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_proxy_call_finish(proxy: [*c]GDBusProxy, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GVariant;
pub extern fn g_dbus_proxy_call_sync(proxy: [*c]GDBusProxy, method_name: [*c]const gchar, parameters: ?*GVariant, flags: GDBusCallFlags, timeout_msec: gint, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GVariant;
pub extern fn g_dbus_proxy_call_with_unix_fd_list(proxy: [*c]GDBusProxy, method_name: [*c]const gchar, parameters: ?*GVariant, flags: GDBusCallFlags, timeout_msec: gint, fd_list: ?*GUnixFDList, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_proxy_call_with_unix_fd_list_finish(proxy: [*c]GDBusProxy, out_fd_list: [*c](?*GUnixFDList), res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GVariant;
pub extern fn g_dbus_proxy_call_with_unix_fd_list_sync(proxy: [*c]GDBusProxy, method_name: [*c]const gchar, parameters: ?*GVariant, flags: GDBusCallFlags, timeout_msec: gint, fd_list: ?*GUnixFDList, out_fd_list: [*c](?*GUnixFDList), cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GVariant;
pub extern fn g_dbus_server_get_type() GType;
pub extern fn g_dbus_server_new_sync(address: [*c]const gchar, flags: GDBusServerFlags, guid: [*c]const gchar, observer: ?*GDBusAuthObserver, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GDBusServer;
pub extern fn g_dbus_server_get_client_address(server: ?*GDBusServer) [*c]const gchar;
pub extern fn g_dbus_server_get_guid(server: ?*GDBusServer) [*c]const gchar;
pub extern fn g_dbus_server_get_flags(server: ?*GDBusServer) GDBusServerFlags;
pub extern fn g_dbus_server_start(server: ?*GDBusServer) void;
pub extern fn g_dbus_server_stop(server: ?*GDBusServer) void;
pub extern fn g_dbus_server_is_active(server: ?*GDBusServer) gboolean;
pub extern fn g_dbus_is_guid(string: [*c]const gchar) gboolean;
pub extern fn g_dbus_generate_guid() [*c]gchar;
pub extern fn g_dbus_is_name(string: [*c]const gchar) gboolean;
pub extern fn g_dbus_is_unique_name(string: [*c]const gchar) gboolean;
pub extern fn g_dbus_is_member_name(string: [*c]const gchar) gboolean;
pub extern fn g_dbus_is_interface_name(string: [*c]const gchar) gboolean;
pub extern fn g_dbus_gvariant_to_gvalue(value: ?*GVariant, out_gvalue: [*c]GValue) void;
pub extern fn g_dbus_gvalue_to_gvariant(gvalue: [*c]const GValue, type_0: ?*const GVariantType) ?*GVariant;
pub const struct__GDriveIface = extern struct {
    g_iface: GTypeInterface,
    changed: ?extern fn (?*GDrive) void,
    disconnected: ?extern fn (?*GDrive) void,
    eject_button: ?extern fn (?*GDrive) void,
    get_name: ?extern fn (?*GDrive) [*c]u8,
    get_icon: ?extern fn (?*GDrive) ?*GIcon,
    has_volumes: ?extern fn (?*GDrive) gboolean,
    get_volumes: ?extern fn (?*GDrive) [*c]GList,
    is_media_removable: ?extern fn (?*GDrive) gboolean,
    has_media: ?extern fn (?*GDrive) gboolean,
    is_media_check_automatic: ?extern fn (?*GDrive) gboolean,
    can_eject: ?extern fn (?*GDrive) gboolean,
    can_poll_for_media: ?extern fn (?*GDrive) gboolean,
    eject: ?extern fn (?*GDrive, GMountUnmountFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    eject_finish: ?extern fn (?*GDrive, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    poll_for_media: ?extern fn (?*GDrive, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    poll_for_media_finish: ?extern fn (?*GDrive, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    get_identifier: ?extern fn (?*GDrive, [*c]const u8) [*c]u8,
    enumerate_identifiers: ?extern fn (?*GDrive) [*c]([*c]u8),
    get_start_stop_type: ?extern fn (?*GDrive) GDriveStartStopType,
    can_start: ?extern fn (?*GDrive) gboolean,
    can_start_degraded: ?extern fn (?*GDrive) gboolean,
    start: ?extern fn (?*GDrive, GDriveStartFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    start_finish: ?extern fn (?*GDrive, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    can_stop: ?extern fn (?*GDrive) gboolean,
    stop: ?extern fn (?*GDrive, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    stop_finish: ?extern fn (?*GDrive, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    stop_button: ?extern fn (?*GDrive) void,
    eject_with_operation: ?extern fn (?*GDrive, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    eject_with_operation_finish: ?extern fn (?*GDrive, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    get_sort_key: ?extern fn (?*GDrive) [*c]const gchar,
    get_symbolic_icon: ?extern fn (?*GDrive) ?*GIcon,
    is_removable: ?extern fn (?*GDrive) gboolean,
};
pub const GDriveIface = struct__GDriveIface;
pub extern fn g_drive_get_type() GType;
pub extern fn g_drive_get_name(drive: ?*GDrive) [*c]u8;
pub extern fn g_drive_get_icon(drive: ?*GDrive) ?*GIcon;
pub extern fn g_drive_get_symbolic_icon(drive: ?*GDrive) ?*GIcon;
pub extern fn g_drive_has_volumes(drive: ?*GDrive) gboolean;
pub extern fn g_drive_get_volumes(drive: ?*GDrive) [*c]GList;
pub extern fn g_drive_is_removable(drive: ?*GDrive) gboolean;
pub extern fn g_drive_is_media_removable(drive: ?*GDrive) gboolean;
pub extern fn g_drive_has_media(drive: ?*GDrive) gboolean;
pub extern fn g_drive_is_media_check_automatic(drive: ?*GDrive) gboolean;
pub extern fn g_drive_can_poll_for_media(drive: ?*GDrive) gboolean;
pub extern fn g_drive_can_eject(drive: ?*GDrive) gboolean;
pub extern fn g_drive_eject(drive: ?*GDrive, flags: GMountUnmountFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_drive_eject_finish(drive: ?*GDrive, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_drive_poll_for_media(drive: ?*GDrive, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_drive_poll_for_media_finish(drive: ?*GDrive, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_drive_get_identifier(drive: ?*GDrive, kind: [*c]const u8) [*c]u8;
pub extern fn g_drive_enumerate_identifiers(drive: ?*GDrive) [*c]([*c]u8);
pub extern fn g_drive_get_start_stop_type(drive: ?*GDrive) GDriveStartStopType;
pub extern fn g_drive_can_start(drive: ?*GDrive) gboolean;
pub extern fn g_drive_can_start_degraded(drive: ?*GDrive) gboolean;
pub extern fn g_drive_start(drive: ?*GDrive, flags: GDriveStartFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_drive_start_finish(drive: ?*GDrive, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_drive_can_stop(drive: ?*GDrive) gboolean;
pub extern fn g_drive_stop(drive: ?*GDrive, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_drive_stop_finish(drive: ?*GDrive, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_drive_eject_with_operation(drive: ?*GDrive, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_drive_eject_with_operation_finish(drive: ?*GDrive, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_drive_get_sort_key(drive: ?*GDrive) [*c]const gchar;
pub const struct__GDtlsConnectionInterface = extern struct {
    g_iface: GTypeInterface,
    accept_certificate: ?extern fn (?*GDtlsConnection, [*c]GTlsCertificate, GTlsCertificateFlags) gboolean,
    handshake: ?extern fn (?*GDtlsConnection, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    handshake_async: ?extern fn (?*GDtlsConnection, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    handshake_finish: ?extern fn (?*GDtlsConnection, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    shutdown: ?extern fn (?*GDtlsConnection, gboolean, gboolean, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    shutdown_async: ?extern fn (?*GDtlsConnection, gboolean, gboolean, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    shutdown_finish: ?extern fn (?*GDtlsConnection, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    set_advertised_protocols: ?extern fn (?*GDtlsConnection, [*c]const ([*c]const gchar)) void,
    get_negotiated_protocol: ?extern fn (?*GDtlsConnection) [*c]const gchar,
};
pub const GDtlsConnectionInterface = struct__GDtlsConnectionInterface;
pub extern fn g_dtls_connection_get_type() GType;
pub extern fn g_dtls_connection_set_database(conn: ?*GDtlsConnection, database: [*c]GTlsDatabase) void;
pub extern fn g_dtls_connection_get_database(conn: ?*GDtlsConnection) [*c]GTlsDatabase;
pub extern fn g_dtls_connection_set_certificate(conn: ?*GDtlsConnection, certificate: [*c]GTlsCertificate) void;
pub extern fn g_dtls_connection_get_certificate(conn: ?*GDtlsConnection) [*c]GTlsCertificate;
pub extern fn g_dtls_connection_set_interaction(conn: ?*GDtlsConnection, interaction: [*c]GTlsInteraction) void;
pub extern fn g_dtls_connection_get_interaction(conn: ?*GDtlsConnection) [*c]GTlsInteraction;
pub extern fn g_dtls_connection_get_peer_certificate(conn: ?*GDtlsConnection) [*c]GTlsCertificate;
pub extern fn g_dtls_connection_get_peer_certificate_errors(conn: ?*GDtlsConnection) GTlsCertificateFlags;
pub extern fn g_dtls_connection_set_require_close_notify(conn: ?*GDtlsConnection, require_close_notify: gboolean) void;
pub extern fn g_dtls_connection_get_require_close_notify(conn: ?*GDtlsConnection) gboolean;
pub extern fn g_dtls_connection_set_rehandshake_mode(conn: ?*GDtlsConnection, mode: GTlsRehandshakeMode) void;
pub extern fn g_dtls_connection_get_rehandshake_mode(conn: ?*GDtlsConnection) GTlsRehandshakeMode;
pub extern fn g_dtls_connection_handshake(conn: ?*GDtlsConnection, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dtls_connection_handshake_async(conn: ?*GDtlsConnection, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dtls_connection_handshake_finish(conn: ?*GDtlsConnection, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dtls_connection_shutdown(conn: ?*GDtlsConnection, shutdown_read: gboolean, shutdown_write: gboolean, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dtls_connection_shutdown_async(conn: ?*GDtlsConnection, shutdown_read: gboolean, shutdown_write: gboolean, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dtls_connection_shutdown_finish(conn: ?*GDtlsConnection, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dtls_connection_close(conn: ?*GDtlsConnection, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dtls_connection_close_async(conn: ?*GDtlsConnection, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dtls_connection_close_finish(conn: ?*GDtlsConnection, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dtls_connection_emit_accept_certificate(conn: ?*GDtlsConnection, peer_cert: [*c]GTlsCertificate, errors: GTlsCertificateFlags) gboolean;
pub extern fn g_dtls_connection_set_advertised_protocols(conn: ?*GDtlsConnection, protocols: [*c]const ([*c]const gchar)) void;
pub extern fn g_dtls_connection_get_negotiated_protocol(conn: ?*GDtlsConnection) [*c]const gchar;
pub const struct__GDtlsClientConnectionInterface = extern struct {
    g_iface: GTypeInterface,
};
pub const GDtlsClientConnectionInterface = struct__GDtlsClientConnectionInterface;
pub extern fn g_dtls_client_connection_get_type() GType;
pub extern fn g_dtls_client_connection_new(base_socket: ?*GDatagramBased, server_identity: ?*GSocketConnectable, @"error": [*c]([*c]GError)) ?*GDatagramBased;
pub extern fn g_dtls_client_connection_get_validation_flags(conn: ?*GDtlsClientConnection) GTlsCertificateFlags;
pub extern fn g_dtls_client_connection_set_validation_flags(conn: ?*GDtlsClientConnection, flags: GTlsCertificateFlags) void;
pub extern fn g_dtls_client_connection_get_server_identity(conn: ?*GDtlsClientConnection) ?*GSocketConnectable;
pub extern fn g_dtls_client_connection_set_server_identity(conn: ?*GDtlsClientConnection, identity: ?*GSocketConnectable) void;
pub extern fn g_dtls_client_connection_get_accepted_cas(conn: ?*GDtlsClientConnection) [*c]GList;
pub const struct__GDtlsServerConnectionInterface = extern struct {
    g_iface: GTypeInterface,
};
pub const GDtlsServerConnectionInterface = struct__GDtlsServerConnectionInterface;
pub extern fn g_dtls_server_connection_get_type() GType;
pub extern fn g_dtls_server_connection_new(base_socket: ?*GDatagramBased, certificate: [*c]GTlsCertificate, @"error": [*c]([*c]GError)) ?*GDatagramBased;
pub const struct__GIconIface = extern struct {
    g_iface: GTypeInterface,
    hash: ?extern fn (?*GIcon) guint,
    equal: ?extern fn (?*GIcon, ?*GIcon) gboolean,
    to_tokens: ?extern fn (?*GIcon, [*c]GPtrArray, [*c]gint) gboolean,
    from_tokens: ?extern fn ([*c]([*c]gchar), gint, gint, [*c]([*c]GError)) ?*GIcon,
    serialize: ?extern fn (?*GIcon) ?*GVariant,
};
pub const GIconIface = struct__GIconIface;
pub extern fn g_icon_get_type() GType;
pub extern fn g_icon_hash(icon: gconstpointer) guint;
pub extern fn g_icon_equal(icon1: ?*GIcon, icon2: ?*GIcon) gboolean;
pub extern fn g_icon_to_string(icon: ?*GIcon) [*c]gchar;
pub extern fn g_icon_new_for_string(str: [*c]const gchar, @"error": [*c]([*c]GError)) ?*GIcon;
pub extern fn g_icon_serialize(icon: ?*GIcon) ?*GVariant;
pub extern fn g_icon_deserialize(value: ?*GVariant) ?*GIcon;
pub const struct__GEmblem = @OpaqueType();
pub const GEmblem = struct__GEmblem;
pub const struct__GEmblemClass = @OpaqueType();
pub const GEmblemClass = struct__GEmblemClass;
pub extern fn g_emblem_get_type() GType;
pub extern fn g_emblem_new(icon: ?*GIcon) ?*GEmblem;
pub extern fn g_emblem_new_with_origin(icon: ?*GIcon, origin: GEmblemOrigin) ?*GEmblem;
pub extern fn g_emblem_get_icon(emblem: ?*GEmblem) ?*GIcon;
pub extern fn g_emblem_get_origin(emblem: ?*GEmblem) GEmblemOrigin;
pub const struct__GEmblemedIconPrivate = @OpaqueType();
pub const GEmblemedIconPrivate = struct__GEmblemedIconPrivate;
pub const struct__GEmblemedIcon = extern struct {
    parent_instance: GObject,
    priv: ?*GEmblemedIconPrivate,
};
pub const GEmblemedIcon = struct__GEmblemedIcon;
pub const struct__GEmblemedIconClass = extern struct {
    parent_class: GObjectClass,
};
pub const GEmblemedIconClass = struct__GEmblemedIconClass;
pub extern fn g_emblemed_icon_get_type() GType;
pub extern fn g_emblemed_icon_new(icon: ?*GIcon, emblem: ?*GEmblem) ?*GIcon;
pub extern fn g_emblemed_icon_get_icon(emblemed: [*c]GEmblemedIcon) ?*GIcon;
pub extern fn g_emblemed_icon_get_emblems(emblemed: [*c]GEmblemedIcon) [*c]GList;
pub extern fn g_emblemed_icon_add_emblem(emblemed: [*c]GEmblemedIcon, emblem: ?*GEmblem) void;
pub extern fn g_emblemed_icon_clear_emblems(emblemed: [*c]GEmblemedIcon) void;
pub extern fn g_file_attribute_info_list_get_type() GType;
pub extern fn g_file_attribute_info_list_new() [*c]GFileAttributeInfoList;
pub extern fn g_file_attribute_info_list_ref(list: [*c]GFileAttributeInfoList) [*c]GFileAttributeInfoList;
pub extern fn g_file_attribute_info_list_unref(list: [*c]GFileAttributeInfoList) void;
pub extern fn g_file_attribute_info_list_dup(list: [*c]GFileAttributeInfoList) [*c]GFileAttributeInfoList;
pub extern fn g_file_attribute_info_list_lookup(list: [*c]GFileAttributeInfoList, name: [*c]const u8) [*c]const GFileAttributeInfo;
pub extern fn g_file_attribute_info_list_add(list: [*c]GFileAttributeInfoList, name: [*c]const u8, type_0: GFileAttributeType, flags: GFileAttributeInfoFlags) void;
pub const struct__GFileEnumeratorClass = extern struct {
    parent_class: GObjectClass,
    next_file: ?extern fn ([*c]GFileEnumerator, [*c]GCancellable, [*c]([*c]GError)) ?*GFileInfo,
    close_fn: ?extern fn ([*c]GFileEnumerator, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    next_files_async: ?extern fn ([*c]GFileEnumerator, c_int, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    next_files_finish: ?extern fn ([*c]GFileEnumerator, ?*GAsyncResult, [*c]([*c]GError)) [*c]GList,
    close_async: ?extern fn ([*c]GFileEnumerator, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    close_finish: ?extern fn ([*c]GFileEnumerator, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
    _g_reserved6: ?extern fn () void,
    _g_reserved7: ?extern fn () void,
};
pub const GFileEnumeratorClass = struct__GFileEnumeratorClass;
pub extern fn g_file_enumerator_get_type() GType;
pub extern fn g_file_enumerator_next_file(enumerator: [*c]GFileEnumerator, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GFileInfo;
pub extern fn g_file_enumerator_close(enumerator: [*c]GFileEnumerator, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_enumerator_next_files_async(enumerator: [*c]GFileEnumerator, num_files: c_int, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_enumerator_next_files_finish(enumerator: [*c]GFileEnumerator, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GList;
pub extern fn g_file_enumerator_close_async(enumerator: [*c]GFileEnumerator, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_enumerator_close_finish(enumerator: [*c]GFileEnumerator, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_enumerator_is_closed(enumerator: [*c]GFileEnumerator) gboolean;
pub extern fn g_file_enumerator_has_pending(enumerator: [*c]GFileEnumerator) gboolean;
pub extern fn g_file_enumerator_set_pending(enumerator: [*c]GFileEnumerator, pending: gboolean) void;
pub extern fn g_file_enumerator_get_container(enumerator: [*c]GFileEnumerator) ?*GFile;
pub extern fn g_file_enumerator_get_child(enumerator: [*c]GFileEnumerator, info: ?*GFileInfo) ?*GFile;
pub extern fn g_file_enumerator_iterate(direnum: [*c]GFileEnumerator, out_info: [*c](?*GFileInfo), out_child: [*c](?*GFile), cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub const struct__GFileIface = extern struct {
    g_iface: GTypeInterface,
    dup: ?extern fn (?*GFile) ?*GFile,
    hash: ?extern fn (?*GFile) guint,
    equal: ?extern fn (?*GFile, ?*GFile) gboolean,
    is_native: ?extern fn (?*GFile) gboolean,
    has_uri_scheme: ?extern fn (?*GFile, [*c]const u8) gboolean,
    get_uri_scheme: ?extern fn (?*GFile) [*c]u8,
    get_basename: ?extern fn (?*GFile) [*c]u8,
    get_path: ?extern fn (?*GFile) [*c]u8,
    get_uri: ?extern fn (?*GFile) [*c]u8,
    get_parse_name: ?extern fn (?*GFile) [*c]u8,
    get_parent: ?extern fn (?*GFile) ?*GFile,
    prefix_matches: ?extern fn (?*GFile, ?*GFile) gboolean,
    get_relative_path: ?extern fn (?*GFile, ?*GFile) [*c]u8,
    resolve_relative_path: ?extern fn (?*GFile, [*c]const u8) ?*GFile,
    get_child_for_display_name: ?extern fn (?*GFile, [*c]const u8, [*c]([*c]GError)) ?*GFile,
    enumerate_children: ?extern fn (?*GFile, [*c]const u8, GFileQueryInfoFlags, [*c]GCancellable, [*c]([*c]GError)) [*c]GFileEnumerator,
    enumerate_children_async: ?extern fn (?*GFile, [*c]const u8, GFileQueryInfoFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    enumerate_children_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) [*c]GFileEnumerator,
    query_info: ?extern fn (?*GFile, [*c]const u8, GFileQueryInfoFlags, [*c]GCancellable, [*c]([*c]GError)) ?*GFileInfo,
    query_info_async: ?extern fn (?*GFile, [*c]const u8, GFileQueryInfoFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    query_info_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) ?*GFileInfo,
    query_filesystem_info: ?extern fn (?*GFile, [*c]const u8, [*c]GCancellable, [*c]([*c]GError)) ?*GFileInfo,
    query_filesystem_info_async: ?extern fn (?*GFile, [*c]const u8, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    query_filesystem_info_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) ?*GFileInfo,
    find_enclosing_mount: ?extern fn (?*GFile, [*c]GCancellable, [*c]([*c]GError)) ?*GMount,
    find_enclosing_mount_async: ?extern fn (?*GFile, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    find_enclosing_mount_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) ?*GMount,
    set_display_name: ?extern fn (?*GFile, [*c]const u8, [*c]GCancellable, [*c]([*c]GError)) ?*GFile,
    set_display_name_async: ?extern fn (?*GFile, [*c]const u8, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    set_display_name_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) ?*GFile,
    query_settable_attributes: ?extern fn (?*GFile, [*c]GCancellable, [*c]([*c]GError)) [*c]GFileAttributeInfoList,
    _query_settable_attributes_async: ?extern fn () void,
    _query_settable_attributes_finish: ?extern fn () void,
    query_writable_namespaces: ?extern fn (?*GFile, [*c]GCancellable, [*c]([*c]GError)) [*c]GFileAttributeInfoList,
    _query_writable_namespaces_async: ?extern fn () void,
    _query_writable_namespaces_finish: ?extern fn () void,
    set_attribute: ?extern fn (?*GFile, [*c]const u8, GFileAttributeType, gpointer, GFileQueryInfoFlags, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    set_attributes_from_info: ?extern fn (?*GFile, ?*GFileInfo, GFileQueryInfoFlags, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    set_attributes_async: ?extern fn (?*GFile, ?*GFileInfo, GFileQueryInfoFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    set_attributes_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c](?*GFileInfo), [*c]([*c]GError)) gboolean,
    read_fn: ?extern fn (?*GFile, [*c]GCancellable, [*c]([*c]GError)) [*c]GFileInputStream,
    read_async: ?extern fn (?*GFile, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    read_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) [*c]GFileInputStream,
    append_to: ?extern fn (?*GFile, GFileCreateFlags, [*c]GCancellable, [*c]([*c]GError)) [*c]GFileOutputStream,
    append_to_async: ?extern fn (?*GFile, GFileCreateFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    append_to_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) [*c]GFileOutputStream,
    create: ?extern fn (?*GFile, GFileCreateFlags, [*c]GCancellable, [*c]([*c]GError)) [*c]GFileOutputStream,
    create_async: ?extern fn (?*GFile, GFileCreateFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    create_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) [*c]GFileOutputStream,
    replace: ?extern fn (?*GFile, [*c]const u8, gboolean, GFileCreateFlags, [*c]GCancellable, [*c]([*c]GError)) [*c]GFileOutputStream,
    replace_async: ?extern fn (?*GFile, [*c]const u8, gboolean, GFileCreateFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    replace_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) [*c]GFileOutputStream,
    delete_file: ?extern fn (?*GFile, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    delete_file_async: ?extern fn (?*GFile, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    delete_file_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    trash: ?extern fn (?*GFile, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    trash_async: ?extern fn (?*GFile, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    trash_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    make_directory: ?extern fn (?*GFile, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    make_directory_async: ?extern fn (?*GFile, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    make_directory_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    make_symbolic_link: ?extern fn (?*GFile, [*c]const u8, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    _make_symbolic_link_async: ?extern fn () void,
    _make_symbolic_link_finish: ?extern fn () void,
    copy: ?extern fn (?*GFile, ?*GFile, GFileCopyFlags, [*c]GCancellable, GFileProgressCallback, gpointer, [*c]([*c]GError)) gboolean,
    copy_async: ?extern fn (?*GFile, ?*GFile, GFileCopyFlags, c_int, [*c]GCancellable, GFileProgressCallback, gpointer, GAsyncReadyCallback, gpointer) void,
    copy_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    move: ?extern fn (?*GFile, ?*GFile, GFileCopyFlags, [*c]GCancellable, GFileProgressCallback, gpointer, [*c]([*c]GError)) gboolean,
    _move_async: ?extern fn () void,
    _move_finish: ?extern fn () void,
    mount_mountable: ?extern fn (?*GFile, GMountMountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    mount_mountable_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) ?*GFile,
    unmount_mountable: ?extern fn (?*GFile, GMountUnmountFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    unmount_mountable_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    eject_mountable: ?extern fn (?*GFile, GMountUnmountFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    eject_mountable_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    mount_enclosing_volume: ?extern fn (?*GFile, GMountMountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    mount_enclosing_volume_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    monitor_dir: ?extern fn (?*GFile, GFileMonitorFlags, [*c]GCancellable, [*c]([*c]GError)) [*c]GFileMonitor,
    monitor_file: ?extern fn (?*GFile, GFileMonitorFlags, [*c]GCancellable, [*c]([*c]GError)) [*c]GFileMonitor,
    open_readwrite: ?extern fn (?*GFile, [*c]GCancellable, [*c]([*c]GError)) [*c]GFileIOStream,
    open_readwrite_async: ?extern fn (?*GFile, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    open_readwrite_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) [*c]GFileIOStream,
    create_readwrite: ?extern fn (?*GFile, GFileCreateFlags, [*c]GCancellable, [*c]([*c]GError)) [*c]GFileIOStream,
    create_readwrite_async: ?extern fn (?*GFile, GFileCreateFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    create_readwrite_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) [*c]GFileIOStream,
    replace_readwrite: ?extern fn (?*GFile, [*c]const u8, gboolean, GFileCreateFlags, [*c]GCancellable, [*c]([*c]GError)) [*c]GFileIOStream,
    replace_readwrite_async: ?extern fn (?*GFile, [*c]const u8, gboolean, GFileCreateFlags, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    replace_readwrite_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) [*c]GFileIOStream,
    start_mountable: ?extern fn (?*GFile, GDriveStartFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    start_mountable_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    stop_mountable: ?extern fn (?*GFile, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    stop_mountable_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    supports_thread_contexts: gboolean,
    unmount_mountable_with_operation: ?extern fn (?*GFile, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    unmount_mountable_with_operation_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    eject_mountable_with_operation: ?extern fn (?*GFile, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    eject_mountable_with_operation_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    poll_mountable: ?extern fn (?*GFile, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    poll_mountable_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    measure_disk_usage: ?extern fn (?*GFile, GFileMeasureFlags, [*c]GCancellable, GFileMeasureProgressCallback, gpointer, [*c]guint64, [*c]guint64, [*c]guint64, [*c]([*c]GError)) gboolean,
    measure_disk_usage_async: ?extern fn (?*GFile, GFileMeasureFlags, gint, [*c]GCancellable, GFileMeasureProgressCallback, gpointer, GAsyncReadyCallback, gpointer) void,
    measure_disk_usage_finish: ?extern fn (?*GFile, ?*GAsyncResult, [*c]guint64, [*c]guint64, [*c]guint64, [*c]([*c]GError)) gboolean,
};
pub const GFileIface = struct__GFileIface;
pub extern fn g_file_get_type() GType;
pub extern fn g_file_new_for_path(path: [*c]const u8) ?*GFile;
pub extern fn g_file_new_for_uri(uri: [*c]const u8) ?*GFile;
pub extern fn g_file_new_for_commandline_arg(arg: [*c]const u8) ?*GFile;
pub extern fn g_file_new_for_commandline_arg_and_cwd(arg: [*c]const gchar, cwd: [*c]const gchar) ?*GFile;
pub extern fn g_file_new_tmp(tmpl: [*c]const u8, iostream: [*c]([*c]GFileIOStream), @"error": [*c]([*c]GError)) ?*GFile;
pub extern fn g_file_parse_name(parse_name: [*c]const u8) ?*GFile;
pub extern fn g_file_new_build_filename(first_element: [*c]const gchar, ...) ?*GFile;
pub extern fn g_file_dup(file: ?*GFile) ?*GFile;
pub extern fn g_file_hash(file: gconstpointer) guint;
pub extern fn g_file_equal(file1: ?*GFile, file2: ?*GFile) gboolean;
pub extern fn g_file_get_basename(file: ?*GFile) [*c]u8;
pub extern fn g_file_get_path(file: ?*GFile) [*c]u8;
pub extern fn g_file_peek_path(file: ?*GFile) [*c]const u8;
pub extern fn g_file_get_uri(file: ?*GFile) [*c]u8;
pub extern fn g_file_get_parse_name(file: ?*GFile) [*c]u8;
pub extern fn g_file_get_parent(file: ?*GFile) ?*GFile;
pub extern fn g_file_has_parent(file: ?*GFile, parent: ?*GFile) gboolean;
pub extern fn g_file_get_child(file: ?*GFile, name: [*c]const u8) ?*GFile;
pub extern fn g_file_get_child_for_display_name(file: ?*GFile, display_name: [*c]const u8, @"error": [*c]([*c]GError)) ?*GFile;
pub extern fn g_file_has_prefix(file: ?*GFile, prefix: ?*GFile) gboolean;
pub extern fn g_file_get_relative_path(parent: ?*GFile, descendant: ?*GFile) [*c]u8;
pub extern fn g_file_resolve_relative_path(file: ?*GFile, relative_path: [*c]const u8) ?*GFile;
pub extern fn g_file_is_native(file: ?*GFile) gboolean;
pub extern fn g_file_has_uri_scheme(file: ?*GFile, uri_scheme: [*c]const u8) gboolean;
pub extern fn g_file_get_uri_scheme(file: ?*GFile) [*c]u8;
pub extern fn g_file_read(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GFileInputStream;
pub extern fn g_file_read_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_read_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GFileInputStream;
pub extern fn g_file_append_to(file: ?*GFile, flags: GFileCreateFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GFileOutputStream;
pub extern fn g_file_create(file: ?*GFile, flags: GFileCreateFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GFileOutputStream;
pub extern fn g_file_replace(file: ?*GFile, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GFileOutputStream;
pub extern fn g_file_append_to_async(file: ?*GFile, flags: GFileCreateFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_append_to_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GFileOutputStream;
pub extern fn g_file_create_async(file: ?*GFile, flags: GFileCreateFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_create_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GFileOutputStream;
pub extern fn g_file_replace_async(file: ?*GFile, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_replace_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GFileOutputStream;
pub extern fn g_file_open_readwrite(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GFileIOStream;
pub extern fn g_file_open_readwrite_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_open_readwrite_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GFileIOStream;
pub extern fn g_file_create_readwrite(file: ?*GFile, flags: GFileCreateFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GFileIOStream;
pub extern fn g_file_create_readwrite_async(file: ?*GFile, flags: GFileCreateFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_create_readwrite_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GFileIOStream;
pub extern fn g_file_replace_readwrite(file: ?*GFile, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GFileIOStream;
pub extern fn g_file_replace_readwrite_async(file: ?*GFile, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_replace_readwrite_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GFileIOStream;
pub extern fn g_file_query_exists(file: ?*GFile, cancellable: [*c]GCancellable) gboolean;
pub extern fn g_file_query_file_type(file: ?*GFile, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable) GFileType;
pub extern fn g_file_query_info(file: ?*GFile, attributes: [*c]const u8, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GFileInfo;
pub extern fn g_file_query_info_async(file: ?*GFile, attributes: [*c]const u8, flags: GFileQueryInfoFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_query_info_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GFileInfo;
pub extern fn g_file_query_filesystem_info(file: ?*GFile, attributes: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GFileInfo;
pub extern fn g_file_query_filesystem_info_async(file: ?*GFile, attributes: [*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_query_filesystem_info_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GFileInfo;
pub extern fn g_file_find_enclosing_mount(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GMount;
pub extern fn g_file_find_enclosing_mount_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_find_enclosing_mount_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GMount;
pub extern fn g_file_enumerate_children(file: ?*GFile, attributes: [*c]const u8, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GFileEnumerator;
pub extern fn g_file_enumerate_children_async(file: ?*GFile, attributes: [*c]const u8, flags: GFileQueryInfoFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_enumerate_children_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GFileEnumerator;
pub extern fn g_file_set_display_name(file: ?*GFile, display_name: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GFile;
pub extern fn g_file_set_display_name_async(file: ?*GFile, display_name: [*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_set_display_name_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GFile;
pub extern fn g_file_delete(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_delete_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_delete_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_trash(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_trash_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_trash_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_copy(source: ?*GFile, destination: ?*GFile, flags: GFileCopyFlags, cancellable: [*c]GCancellable, progress_callback: GFileProgressCallback, progress_callback_data: gpointer, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_copy_async(source: ?*GFile, destination: ?*GFile, flags: GFileCopyFlags, io_priority: c_int, cancellable: [*c]GCancellable, progress_callback: GFileProgressCallback, progress_callback_data: gpointer, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_copy_finish(file: ?*GFile, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_move(source: ?*GFile, destination: ?*GFile, flags: GFileCopyFlags, cancellable: [*c]GCancellable, progress_callback: GFileProgressCallback, progress_callback_data: gpointer, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_make_directory(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_make_directory_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_make_directory_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_make_directory_with_parents(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_make_symbolic_link(file: ?*GFile, symlink_value: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_query_settable_attributes(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GFileAttributeInfoList;
pub extern fn g_file_query_writable_namespaces(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GFileAttributeInfoList;
pub extern fn g_file_set_attribute(file: ?*GFile, attribute: [*c]const u8, type_0: GFileAttributeType, value_p: gpointer, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_set_attributes_from_info(file: ?*GFile, info: ?*GFileInfo, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_set_attributes_async(file: ?*GFile, info: ?*GFileInfo, flags: GFileQueryInfoFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_set_attributes_finish(file: ?*GFile, result: ?*GAsyncResult, info: [*c](?*GFileInfo), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_set_attribute_string(file: ?*GFile, attribute: [*c]const u8, value: [*c]const u8, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_set_attribute_byte_string(file: ?*GFile, attribute: [*c]const u8, value: [*c]const u8, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_set_attribute_uint32(file: ?*GFile, attribute: [*c]const u8, value: guint32, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_set_attribute_int32(file: ?*GFile, attribute: [*c]const u8, value: gint32, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_set_attribute_uint64(file: ?*GFile, attribute: [*c]const u8, value: guint64, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_set_attribute_int64(file: ?*GFile, attribute: [*c]const u8, value: gint64, flags: GFileQueryInfoFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_mount_enclosing_volume(location: ?*GFile, flags: GMountMountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_mount_enclosing_volume_finish(location: ?*GFile, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_mount_mountable(file: ?*GFile, flags: GMountMountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_mount_mountable_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GFile;
pub extern fn g_file_unmount_mountable(file: ?*GFile, flags: GMountUnmountFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_unmount_mountable_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_unmount_mountable_with_operation(file: ?*GFile, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_unmount_mountable_with_operation_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_eject_mountable(file: ?*GFile, flags: GMountUnmountFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_eject_mountable_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_eject_mountable_with_operation(file: ?*GFile, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_eject_mountable_with_operation_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_copy_attributes(source: ?*GFile, destination: ?*GFile, flags: GFileCopyFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_monitor_directory(file: ?*GFile, flags: GFileMonitorFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GFileMonitor;
pub extern fn g_file_monitor_file(file: ?*GFile, flags: GFileMonitorFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GFileMonitor;
pub extern fn g_file_monitor(file: ?*GFile, flags: GFileMonitorFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GFileMonitor;
pub extern fn g_file_measure_disk_usage(file: ?*GFile, flags: GFileMeasureFlags, cancellable: [*c]GCancellable, progress_callback: GFileMeasureProgressCallback, progress_data: gpointer, disk_usage: [*c]guint64, num_dirs: [*c]guint64, num_files: [*c]guint64, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_measure_disk_usage_async(file: ?*GFile, flags: GFileMeasureFlags, io_priority: gint, cancellable: [*c]GCancellable, progress_callback: GFileMeasureProgressCallback, progress_data: gpointer, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_measure_disk_usage_finish(file: ?*GFile, result: ?*GAsyncResult, disk_usage: [*c]guint64, num_dirs: [*c]guint64, num_files: [*c]guint64, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_start_mountable(file: ?*GFile, flags: GDriveStartFlags, start_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_start_mountable_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_stop_mountable(file: ?*GFile, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_stop_mountable_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_poll_mountable(file: ?*GFile, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_poll_mountable_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_query_default_handler(file: ?*GFile, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GAppInfo;
pub extern fn g_file_query_default_handler_async(file: ?*GFile, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_query_default_handler_finish(file: ?*GFile, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GAppInfo;
pub extern fn g_file_load_contents(file: ?*GFile, cancellable: [*c]GCancellable, contents: [*c]([*c]u8), length: [*c]gsize, etag_out: [*c]([*c]u8), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_load_contents_async(file: ?*GFile, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_load_contents_finish(file: ?*GFile, res: ?*GAsyncResult, contents: [*c]([*c]u8), length: [*c]gsize, etag_out: [*c]([*c]u8), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_load_partial_contents_async(file: ?*GFile, cancellable: [*c]GCancellable, read_more_callback: GFileReadMoreCallback, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_load_partial_contents_finish(file: ?*GFile, res: ?*GAsyncResult, contents: [*c]([*c]u8), length: [*c]gsize, etag_out: [*c]([*c]u8), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_replace_contents(file: ?*GFile, contents: [*c]const u8, length: gsize, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, new_etag: [*c]([*c]u8), cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_replace_contents_async(file: ?*GFile, contents: [*c]const u8, length: gsize, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_replace_contents_bytes_async(file: ?*GFile, contents: ?*GBytes, etag: [*c]const u8, make_backup: gboolean, flags: GFileCreateFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_replace_contents_finish(file: ?*GFile, res: ?*GAsyncResult, new_etag: [*c]([*c]u8), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_file_supports_thread_contexts(file: ?*GFile) gboolean;
pub extern fn g_file_load_bytes(file: ?*GFile, cancellable: [*c]GCancellable, etag_out: [*c]([*c]gchar), @"error": [*c]([*c]GError)) ?*GBytes;
pub extern fn g_file_load_bytes_async(file: ?*GFile, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_load_bytes_finish(file: ?*GFile, result: ?*GAsyncResult, etag_out: [*c]([*c]gchar), @"error": [*c]([*c]GError)) ?*GBytes;
pub const struct__GFileIconClass = @OpaqueType();
pub const GFileIconClass = struct__GFileIconClass;
pub extern fn g_file_icon_get_type() GType;
pub extern fn g_file_icon_new(file: ?*GFile) ?*GIcon;
pub extern fn g_file_icon_get_file(icon: ?*GFileIcon) ?*GFile;
pub const struct__GFileInfoClass = @OpaqueType();
pub const GFileInfoClass = struct__GFileInfoClass;
pub extern fn g_file_info_get_type() GType;
pub extern fn g_file_info_new() ?*GFileInfo;
pub extern fn g_file_info_dup(other: ?*GFileInfo) ?*GFileInfo;
pub extern fn g_file_info_copy_into(src_info: ?*GFileInfo, dest_info: ?*GFileInfo) void;
pub extern fn g_file_info_has_attribute(info: ?*GFileInfo, attribute: [*c]const u8) gboolean;
pub extern fn g_file_info_has_namespace(info: ?*GFileInfo, name_space: [*c]const u8) gboolean;
pub extern fn g_file_info_list_attributes(info: ?*GFileInfo, name_space: [*c]const u8) [*c]([*c]u8);
pub extern fn g_file_info_get_attribute_data(info: ?*GFileInfo, attribute: [*c]const u8, type_0: [*c]GFileAttributeType, value_pp: [*c]gpointer, status: [*c]GFileAttributeStatus) gboolean;
pub extern fn g_file_info_get_attribute_type(info: ?*GFileInfo, attribute: [*c]const u8) GFileAttributeType;
pub extern fn g_file_info_remove_attribute(info: ?*GFileInfo, attribute: [*c]const u8) void;
pub extern fn g_file_info_get_attribute_status(info: ?*GFileInfo, attribute: [*c]const u8) GFileAttributeStatus;
pub extern fn g_file_info_set_attribute_status(info: ?*GFileInfo, attribute: [*c]const u8, status: GFileAttributeStatus) gboolean;
pub extern fn g_file_info_get_attribute_as_string(info: ?*GFileInfo, attribute: [*c]const u8) [*c]u8;
pub extern fn g_file_info_get_attribute_string(info: ?*GFileInfo, attribute: [*c]const u8) [*c]const u8;
pub extern fn g_file_info_get_attribute_byte_string(info: ?*GFileInfo, attribute: [*c]const u8) [*c]const u8;
pub extern fn g_file_info_get_attribute_boolean(info: ?*GFileInfo, attribute: [*c]const u8) gboolean;
pub extern fn g_file_info_get_attribute_uint32(info: ?*GFileInfo, attribute: [*c]const u8) guint32;
pub extern fn g_file_info_get_attribute_int32(info: ?*GFileInfo, attribute: [*c]const u8) gint32;
pub extern fn g_file_info_get_attribute_uint64(info: ?*GFileInfo, attribute: [*c]const u8) guint64;
pub extern fn g_file_info_get_attribute_int64(info: ?*GFileInfo, attribute: [*c]const u8) gint64;
pub extern fn g_file_info_get_attribute_object(info: ?*GFileInfo, attribute: [*c]const u8) [*c]GObject;
pub extern fn g_file_info_get_attribute_stringv(info: ?*GFileInfo, attribute: [*c]const u8) [*c]([*c]u8);
pub extern fn g_file_info_set_attribute(info: ?*GFileInfo, attribute: [*c]const u8, type_0: GFileAttributeType, value_p: gpointer) void;
pub extern fn g_file_info_set_attribute_string(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: [*c]const u8) void;
pub extern fn g_file_info_set_attribute_byte_string(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: [*c]const u8) void;
pub extern fn g_file_info_set_attribute_boolean(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: gboolean) void;
pub extern fn g_file_info_set_attribute_uint32(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: guint32) void;
pub extern fn g_file_info_set_attribute_int32(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: gint32) void;
pub extern fn g_file_info_set_attribute_uint64(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: guint64) void;
pub extern fn g_file_info_set_attribute_int64(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: gint64) void;
pub extern fn g_file_info_set_attribute_object(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: [*c]GObject) void;
pub extern fn g_file_info_set_attribute_stringv(info: ?*GFileInfo, attribute: [*c]const u8, attr_value: [*c]([*c]u8)) void;
pub extern fn g_file_info_clear_status(info: ?*GFileInfo) void;
pub extern fn g_file_info_get_deletion_date(info: ?*GFileInfo) ?*GDateTime;
pub extern fn g_file_info_get_file_type(info: ?*GFileInfo) GFileType;
pub extern fn g_file_info_get_is_hidden(info: ?*GFileInfo) gboolean;
pub extern fn g_file_info_get_is_backup(info: ?*GFileInfo) gboolean;
pub extern fn g_file_info_get_is_symlink(info: ?*GFileInfo) gboolean;
pub extern fn g_file_info_get_name(info: ?*GFileInfo) [*c]const u8;
pub extern fn g_file_info_get_display_name(info: ?*GFileInfo) [*c]const u8;
pub extern fn g_file_info_get_edit_name(info: ?*GFileInfo) [*c]const u8;
pub extern fn g_file_info_get_icon(info: ?*GFileInfo) ?*GIcon;
pub extern fn g_file_info_get_symbolic_icon(info: ?*GFileInfo) ?*GIcon;
pub extern fn g_file_info_get_content_type(info: ?*GFileInfo) [*c]const u8;
pub extern fn g_file_info_get_size(info: ?*GFileInfo) goffset;
pub extern fn g_file_info_get_modification_time(info: ?*GFileInfo, result: [*c]GTimeVal) void;
pub extern fn g_file_info_get_modification_date_time(info: ?*GFileInfo) ?*GDateTime;
pub extern fn g_file_info_get_symlink_target(info: ?*GFileInfo) [*c]const u8;
pub extern fn g_file_info_get_etag(info: ?*GFileInfo) [*c]const u8;
pub extern fn g_file_info_get_sort_order(info: ?*GFileInfo) gint32;
pub extern fn g_file_info_set_attribute_mask(info: ?*GFileInfo, mask: ?*GFileAttributeMatcher) void;
pub extern fn g_file_info_unset_attribute_mask(info: ?*GFileInfo) void;
pub extern fn g_file_info_set_file_type(info: ?*GFileInfo, type_0: GFileType) void;
pub extern fn g_file_info_set_is_hidden(info: ?*GFileInfo, is_hidden: gboolean) void;
pub extern fn g_file_info_set_is_symlink(info: ?*GFileInfo, is_symlink: gboolean) void;
pub extern fn g_file_info_set_name(info: ?*GFileInfo, name: [*c]const u8) void;
pub extern fn g_file_info_set_display_name(info: ?*GFileInfo, display_name: [*c]const u8) void;
pub extern fn g_file_info_set_edit_name(info: ?*GFileInfo, edit_name: [*c]const u8) void;
pub extern fn g_file_info_set_icon(info: ?*GFileInfo, icon: ?*GIcon) void;
pub extern fn g_file_info_set_symbolic_icon(info: ?*GFileInfo, icon: ?*GIcon) void;
pub extern fn g_file_info_set_content_type(info: ?*GFileInfo, content_type: [*c]const u8) void;
pub extern fn g_file_info_set_size(info: ?*GFileInfo, size: goffset) void;
pub extern fn g_file_info_set_modification_time(info: ?*GFileInfo, mtime: [*c]GTimeVal) void;
pub extern fn g_file_info_set_modification_date_time(info: ?*GFileInfo, mtime: ?*GDateTime) void;
pub extern fn g_file_info_set_symlink_target(info: ?*GFileInfo, symlink_target: [*c]const u8) void;
pub extern fn g_file_info_set_sort_order(info: ?*GFileInfo, sort_order: gint32) void;
pub extern fn g_file_attribute_matcher_get_type() GType;
pub extern fn g_file_attribute_matcher_new(attributes: [*c]const u8) ?*GFileAttributeMatcher;
pub extern fn g_file_attribute_matcher_ref(matcher: ?*GFileAttributeMatcher) ?*GFileAttributeMatcher;
pub extern fn g_file_attribute_matcher_unref(matcher: ?*GFileAttributeMatcher) void;
pub extern fn g_file_attribute_matcher_subtract(matcher: ?*GFileAttributeMatcher, subtract: ?*GFileAttributeMatcher) ?*GFileAttributeMatcher;
pub extern fn g_file_attribute_matcher_matches(matcher: ?*GFileAttributeMatcher, attribute: [*c]const u8) gboolean;
pub extern fn g_file_attribute_matcher_matches_only(matcher: ?*GFileAttributeMatcher, attribute: [*c]const u8) gboolean;
pub extern fn g_file_attribute_matcher_enumerate_namespace(matcher: ?*GFileAttributeMatcher, ns: [*c]const u8) gboolean;
pub extern fn g_file_attribute_matcher_enumerate_next(matcher: ?*GFileAttributeMatcher) [*c]const u8;
pub extern fn g_file_attribute_matcher_to_string(matcher: ?*GFileAttributeMatcher) [*c]u8;
pub const struct__GFileInputStreamClass = extern struct {
    parent_class: GInputStreamClass,
    tell: ?extern fn ([*c]GFileInputStream) goffset,
    can_seek: ?extern fn ([*c]GFileInputStream) gboolean,
    seek: ?extern fn ([*c]GFileInputStream, goffset, GSeekType, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    query_info: ?extern fn ([*c]GFileInputStream, [*c]const u8, [*c]GCancellable, [*c]([*c]GError)) ?*GFileInfo,
    query_info_async: ?extern fn ([*c]GFileInputStream, [*c]const u8, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    query_info_finish: ?extern fn ([*c]GFileInputStream, ?*GAsyncResult, [*c]([*c]GError)) ?*GFileInfo,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GFileInputStreamClass = struct__GFileInputStreamClass;
pub extern fn g_file_input_stream_get_type() GType;
pub extern fn g_file_input_stream_query_info(stream: [*c]GFileInputStream, attributes: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GFileInfo;
pub extern fn g_file_input_stream_query_info_async(stream: [*c]GFileInputStream, attributes: [*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_input_stream_query_info_finish(stream: [*c]GFileInputStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GFileInfo;
pub extern fn g_io_error_quark() GQuark;
pub extern fn g_io_error_from_errno(err_no: gint) GIOErrorEnum;
pub extern fn g_io_error_from_win32_error(error_code: gint) GIOErrorEnum;
pub const struct__GIOStreamClass = extern struct {
    parent_class: GObjectClass,
    get_input_stream: ?extern fn ([*c]GIOStream) [*c]GInputStream,
    get_output_stream: ?extern fn ([*c]GIOStream) [*c]GOutputStream,
    close_fn: ?extern fn ([*c]GIOStream, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    close_async: ?extern fn ([*c]GIOStream, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    close_finish: ?extern fn ([*c]GIOStream, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
    _g_reserved6: ?extern fn () void,
    _g_reserved7: ?extern fn () void,
    _g_reserved8: ?extern fn () void,
    _g_reserved9: ?extern fn () void,
    _g_reserved10: ?extern fn () void,
};
pub const GIOStreamClass = struct__GIOStreamClass;
pub extern fn g_io_stream_get_type() GType;
pub extern fn g_io_stream_get_input_stream(stream: [*c]GIOStream) [*c]GInputStream;
pub extern fn g_io_stream_get_output_stream(stream: [*c]GIOStream) [*c]GOutputStream;
pub extern fn g_io_stream_splice_async(stream1: [*c]GIOStream, stream2: [*c]GIOStream, flags: GIOStreamSpliceFlags, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_io_stream_splice_finish(result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_io_stream_close(stream: [*c]GIOStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_io_stream_close_async(stream: [*c]GIOStream, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_io_stream_close_finish(stream: [*c]GIOStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_io_stream_is_closed(stream: [*c]GIOStream) gboolean;
pub extern fn g_io_stream_has_pending(stream: [*c]GIOStream) gboolean;
pub extern fn g_io_stream_set_pending(stream: [*c]GIOStream, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_io_stream_clear_pending(stream: [*c]GIOStream) void;
pub const struct__GFileIOStreamClass = extern struct {
    parent_class: GIOStreamClass,
    tell: ?extern fn ([*c]GFileIOStream) goffset,
    can_seek: ?extern fn ([*c]GFileIOStream) gboolean,
    seek: ?extern fn ([*c]GFileIOStream, goffset, GSeekType, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    can_truncate: ?extern fn ([*c]GFileIOStream) gboolean,
    truncate_fn: ?extern fn ([*c]GFileIOStream, goffset, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    query_info: ?extern fn ([*c]GFileIOStream, [*c]const u8, [*c]GCancellable, [*c]([*c]GError)) ?*GFileInfo,
    query_info_async: ?extern fn ([*c]GFileIOStream, [*c]const u8, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    query_info_finish: ?extern fn ([*c]GFileIOStream, ?*GAsyncResult, [*c]([*c]GError)) ?*GFileInfo,
    get_etag: ?extern fn ([*c]GFileIOStream) [*c]u8,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GFileIOStreamClass = struct__GFileIOStreamClass;
pub extern fn g_file_io_stream_get_type() GType;
pub extern fn g_file_io_stream_query_info(stream: [*c]GFileIOStream, attributes: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GFileInfo;
pub extern fn g_file_io_stream_query_info_async(stream: [*c]GFileIOStream, attributes: [*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_io_stream_query_info_finish(stream: [*c]GFileIOStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GFileInfo;
pub extern fn g_file_io_stream_get_etag(stream: [*c]GFileIOStream) [*c]u8;
pub const struct__GFileMonitorClass = extern struct {
    parent_class: GObjectClass,
    changed: ?extern fn ([*c]GFileMonitor, ?*GFile, ?*GFile, GFileMonitorEvent) void,
    cancel: ?extern fn ([*c]GFileMonitor) gboolean,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GFileMonitorClass = struct__GFileMonitorClass;
pub extern fn g_file_monitor_get_type() GType;
pub extern fn g_file_monitor_cancel(monitor: [*c]GFileMonitor) gboolean;
pub extern fn g_file_monitor_is_cancelled(monitor: [*c]GFileMonitor) gboolean;
pub extern fn g_file_monitor_set_rate_limit(monitor: [*c]GFileMonitor, limit_msecs: gint) void;
pub extern fn g_file_monitor_emit_event(monitor: [*c]GFileMonitor, child: ?*GFile, other_file: ?*GFile, event_type: GFileMonitorEvent) void;
pub const struct__GFilenameCompleterClass = extern struct {
    parent_class: GObjectClass,
    got_completion_data: ?extern fn (?*GFilenameCompleter) void,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
};
pub const GFilenameCompleterClass = struct__GFilenameCompleterClass;
pub extern fn g_filename_completer_get_type() GType;
pub extern fn g_filename_completer_new() ?*GFilenameCompleter;
pub extern fn g_filename_completer_get_completion_suffix(completer: ?*GFilenameCompleter, initial_text: [*c]const u8) [*c]u8;
pub extern fn g_filename_completer_get_completions(completer: ?*GFilenameCompleter, initial_text: [*c]const u8) [*c]([*c]u8);
pub extern fn g_filename_completer_set_dirs_only(completer: ?*GFilenameCompleter, dirs_only: gboolean) void;
pub const struct__GFileOutputStreamClass = extern struct {
    parent_class: GOutputStreamClass,
    tell: ?extern fn ([*c]GFileOutputStream) goffset,
    can_seek: ?extern fn ([*c]GFileOutputStream) gboolean,
    seek: ?extern fn ([*c]GFileOutputStream, goffset, GSeekType, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    can_truncate: ?extern fn ([*c]GFileOutputStream) gboolean,
    truncate_fn: ?extern fn ([*c]GFileOutputStream, goffset, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    query_info: ?extern fn ([*c]GFileOutputStream, [*c]const u8, [*c]GCancellable, [*c]([*c]GError)) ?*GFileInfo,
    query_info_async: ?extern fn ([*c]GFileOutputStream, [*c]const u8, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    query_info_finish: ?extern fn ([*c]GFileOutputStream, ?*GAsyncResult, [*c]([*c]GError)) ?*GFileInfo,
    get_etag: ?extern fn ([*c]GFileOutputStream) [*c]u8,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GFileOutputStreamClass = struct__GFileOutputStreamClass;
pub extern fn g_file_output_stream_get_type() GType;
pub extern fn g_file_output_stream_query_info(stream: [*c]GFileOutputStream, attributes: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GFileInfo;
pub extern fn g_file_output_stream_query_info_async(stream: [*c]GFileOutputStream, attributes: [*c]const u8, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_file_output_stream_query_info_finish(stream: [*c]GFileOutputStream, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GFileInfo;
pub extern fn g_file_output_stream_get_etag(stream: [*c]GFileOutputStream) [*c]u8;
pub const struct__GInetAddressClass = extern struct {
    parent_class: GObjectClass,
    to_string: ?extern fn ([*c]GInetAddress) [*c]gchar,
    to_bytes: ?extern fn ([*c]GInetAddress) [*c]const guint8,
};
pub const GInetAddressClass = struct__GInetAddressClass;
pub extern fn g_inet_address_get_type() GType;
pub extern fn g_inet_address_new_from_string(string: [*c]const gchar) [*c]GInetAddress;
pub extern fn g_inet_address_new_from_bytes(bytes: [*c]const guint8, family: GSocketFamily) [*c]GInetAddress;
pub extern fn g_inet_address_new_loopback(family: GSocketFamily) [*c]GInetAddress;
pub extern fn g_inet_address_new_any(family: GSocketFamily) [*c]GInetAddress;
pub extern fn g_inet_address_equal(address: [*c]GInetAddress, other_address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_to_string(address: [*c]GInetAddress) [*c]gchar;
pub extern fn g_inet_address_to_bytes(address: [*c]GInetAddress) [*c]const guint8;
pub extern fn g_inet_address_get_native_size(address: [*c]GInetAddress) gsize;
pub extern fn g_inet_address_get_family(address: [*c]GInetAddress) GSocketFamily;
pub extern fn g_inet_address_get_is_any(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_loopback(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_link_local(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_site_local(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_multicast(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_mc_global(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_mc_link_local(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_mc_node_local(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_mc_org_local(address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_get_is_mc_site_local(address: [*c]GInetAddress) gboolean;
pub const struct__GInetAddressMaskClass = extern struct {
    parent_class: GObjectClass,
};
pub const GInetAddressMaskClass = struct__GInetAddressMaskClass;
pub extern fn g_inet_address_mask_get_type() GType;
pub extern fn g_inet_address_mask_new(addr: [*c]GInetAddress, length: guint, @"error": [*c]([*c]GError)) [*c]GInetAddressMask;
pub extern fn g_inet_address_mask_new_from_string(mask_string: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]GInetAddressMask;
pub extern fn g_inet_address_mask_to_string(mask: [*c]GInetAddressMask) [*c]gchar;
pub extern fn g_inet_address_mask_get_family(mask: [*c]GInetAddressMask) GSocketFamily;
pub extern fn g_inet_address_mask_get_address(mask: [*c]GInetAddressMask) [*c]GInetAddress;
pub extern fn g_inet_address_mask_get_length(mask: [*c]GInetAddressMask) guint;
pub extern fn g_inet_address_mask_matches(mask: [*c]GInetAddressMask, address: [*c]GInetAddress) gboolean;
pub extern fn g_inet_address_mask_equal(mask: [*c]GInetAddressMask, mask2: [*c]GInetAddressMask) gboolean;
pub const struct__GSocketAddressClass = extern struct {
    parent_class: GObjectClass,
    get_family: ?extern fn ([*c]GSocketAddress) GSocketFamily,
    get_native_size: ?extern fn ([*c]GSocketAddress) gssize,
    to_native: ?extern fn ([*c]GSocketAddress, gpointer, gsize, [*c]([*c]GError)) gboolean,
};
pub const GSocketAddressClass = struct__GSocketAddressClass;
pub extern fn g_socket_address_get_type() GType;
pub extern fn g_socket_address_get_family(address: [*c]GSocketAddress) GSocketFamily;
pub extern fn g_socket_address_new_from_native(native: gpointer, len: gsize) [*c]GSocketAddress;
pub extern fn g_socket_address_to_native(address: [*c]GSocketAddress, dest: gpointer, destlen: gsize, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_address_get_native_size(address: [*c]GSocketAddress) gssize;
pub const struct__GInetSocketAddressClass = extern struct {
    parent_class: GSocketAddressClass,
};
pub const GInetSocketAddressClass = struct__GInetSocketAddressClass;
pub extern fn g_inet_socket_address_get_type() GType;
pub extern fn g_inet_socket_address_new(address: [*c]GInetAddress, port: guint16) [*c]GSocketAddress;
pub extern fn g_inet_socket_address_new_from_string(address: [*c]const u8, port: guint) [*c]GSocketAddress;
pub extern fn g_inet_socket_address_get_address(address: [*c]GInetSocketAddress) [*c]GInetAddress;
pub extern fn g_inet_socket_address_get_port(address: [*c]GInetSocketAddress) guint16;
pub extern fn g_inet_socket_address_get_flowinfo(address: [*c]GInetSocketAddress) guint32;
pub extern fn g_inet_socket_address_get_scope_id(address: [*c]GInetSocketAddress) guint32;
pub extern fn g_app_info_create_flags_get_type() GType;
pub extern fn g_converter_flags_get_type() GType;
pub extern fn g_converter_result_get_type() GType;
pub extern fn g_data_stream_byte_order_get_type() GType;
pub extern fn g_data_stream_newline_type_get_type() GType;
pub extern fn g_file_attribute_type_get_type() GType;
pub extern fn g_file_attribute_info_flags_get_type() GType;
pub extern fn g_file_attribute_status_get_type() GType;
pub extern fn g_file_query_info_flags_get_type() GType;
pub extern fn g_file_create_flags_get_type() GType;
pub extern fn g_file_measure_flags_get_type() GType;
pub extern fn g_mount_mount_flags_get_type() GType;
pub extern fn g_mount_unmount_flags_get_type() GType;
pub extern fn g_drive_start_flags_get_type() GType;
pub extern fn g_drive_start_stop_type_get_type() GType;
pub extern fn g_file_copy_flags_get_type() GType;
pub extern fn g_file_monitor_flags_get_type() GType;
pub extern fn g_file_type_get_type() GType;
pub extern fn g_filesystem_preview_type_get_type() GType;
pub extern fn g_file_monitor_event_get_type() GType;
pub extern fn g_io_error_enum_get_type() GType;
pub extern fn g_ask_password_flags_get_type() GType;
pub extern fn g_password_save_get_type() GType;
pub extern fn g_mount_operation_result_get_type() GType;
pub extern fn g_output_stream_splice_flags_get_type() GType;
pub extern fn g_io_stream_splice_flags_get_type() GType;
pub extern fn g_emblem_origin_get_type() GType;
pub extern fn g_resolver_error_get_type() GType;
pub extern fn g_resolver_record_type_get_type() GType;
pub extern fn g_resource_error_get_type() GType;
pub extern fn g_resource_flags_get_type() GType;
pub extern fn g_resource_lookup_flags_get_type() GType;
pub extern fn g_socket_family_get_type() GType;
pub extern fn g_socket_type_get_type() GType;
pub extern fn g_socket_msg_flags_get_type() GType;
pub extern fn g_socket_protocol_get_type() GType;
pub extern fn g_zlib_compressor_format_get_type() GType;
pub extern fn g_unix_socket_address_type_get_type() GType;
pub extern fn g_bus_type_get_type() GType;
pub extern fn g_bus_name_owner_flags_get_type() GType;
pub extern fn g_bus_name_watcher_flags_get_type() GType;
pub extern fn g_dbus_proxy_flags_get_type() GType;
pub extern fn g_dbus_error_get_type() GType;
pub extern fn g_dbus_connection_flags_get_type() GType;
pub extern fn g_dbus_capability_flags_get_type() GType;
pub extern fn g_dbus_call_flags_get_type() GType;
pub extern fn g_dbus_message_type_get_type() GType;
pub extern fn g_dbus_message_flags_get_type() GType;
pub extern fn g_dbus_message_header_field_get_type() GType;
pub extern fn g_dbus_property_info_flags_get_type() GType;
pub extern fn g_dbus_subtree_flags_get_type() GType;
pub extern fn g_dbus_server_flags_get_type() GType;
pub extern fn g_dbus_signal_flags_get_type() GType;
pub extern fn g_dbus_send_message_flags_get_type() GType;
pub extern fn g_credentials_type_get_type() GType;
pub extern fn g_dbus_message_byte_order_get_type() GType;
pub extern fn g_application_flags_get_type() GType;
pub extern fn g_tls_error_get_type() GType;
pub extern fn g_tls_certificate_flags_get_type() GType;
pub extern fn g_tls_authentication_mode_get_type() GType;
pub extern fn g_tls_rehandshake_mode_get_type() GType;
pub extern fn g_tls_password_flags_get_type() GType;
pub extern fn g_tls_interaction_result_get_type() GType;
pub extern fn g_dbus_interface_skeleton_flags_get_type() GType;
pub extern fn g_dbus_object_manager_client_flags_get_type() GType;
pub extern fn g_tls_database_verify_flags_get_type() GType;
pub extern fn g_tls_database_lookup_flags_get_type() GType;
pub extern fn g_tls_certificate_request_flags_get_type() GType;
pub extern fn g_io_module_scope_flags_get_type() GType;
pub extern fn g_socket_client_event_get_type() GType;
pub extern fn g_socket_listener_event_get_type() GType;
pub extern fn g_test_dbus_flags_get_type() GType;
pub extern fn g_subprocess_flags_get_type() GType;
pub extern fn g_notification_priority_get_type() GType;
pub extern fn g_network_connectivity_get_type() GType;
pub extern fn g_pollable_return_get_type() GType;
pub extern fn g_resolver_name_lookup_flags_get_type() GType;
pub extern fn g_settings_bind_flags_get_type() GType;
pub const G_MODULE_BIND_LAZY = 1;
pub const G_MODULE_BIND_LOCAL = 2;
pub const G_MODULE_BIND_MASK = 3;
pub const GModuleFlags = extern enum {
    G_MODULE_BIND_LAZY = 1,
    G_MODULE_BIND_LOCAL = 2,
    G_MODULE_BIND_MASK = 3,
};
pub const struct__GModule = @OpaqueType();
pub const GModule = struct__GModule;
pub const GModuleCheckInit = ?extern fn (?*GModule) [*c]const gchar;
pub const GModuleUnload = ?extern fn (?*GModule) void;
pub extern fn g_module_supported() gboolean;
pub extern fn g_module_open(file_name: [*c]const gchar, flags: GModuleFlags) ?*GModule;
pub extern fn g_module_close(module: ?*GModule) gboolean;
pub extern fn g_module_make_resident(module: ?*GModule) void;
pub extern fn g_module_error() [*c]const gchar;
pub extern fn g_module_symbol(module: ?*GModule, symbol_name: [*c]const gchar, symbol: [*c]gpointer) gboolean;
pub extern fn g_module_name(module: ?*GModule) [*c]const gchar;
pub extern fn g_module_build_path(directory: [*c]const gchar, module_name: [*c]const gchar) [*c]gchar;
pub const struct__GIOModuleScope = @OpaqueType();
pub const GIOModuleScope = struct__GIOModuleScope;
pub extern fn g_io_module_scope_new(flags: GIOModuleScopeFlags) ?*GIOModuleScope;
pub extern fn g_io_module_scope_free(scope: ?*GIOModuleScope) void;
pub extern fn g_io_module_scope_block(scope: ?*GIOModuleScope, basename: [*c]const gchar) void;
pub const struct__GIOModuleClass = @OpaqueType();
pub const GIOModuleClass = struct__GIOModuleClass;
pub extern fn g_io_module_get_type() GType;
pub extern fn g_io_module_new(filename: [*c]const gchar) ?*GIOModule;
pub extern fn g_io_modules_scan_all_in_directory(dirname: [*c]const u8) void;
pub extern fn g_io_modules_load_all_in_directory(dirname: [*c]const gchar) [*c]GList;
pub extern fn g_io_modules_scan_all_in_directory_with_scope(dirname: [*c]const gchar, scope: ?*GIOModuleScope) void;
pub extern fn g_io_modules_load_all_in_directory_with_scope(dirname: [*c]const gchar, scope: ?*GIOModuleScope) [*c]GList;
pub extern fn g_io_extension_point_register(name: [*c]const u8) ?*GIOExtensionPoint;
pub extern fn g_io_extension_point_lookup(name: [*c]const u8) ?*GIOExtensionPoint;
pub extern fn g_io_extension_point_set_required_type(extension_point: ?*GIOExtensionPoint, type_0: GType) void;
pub extern fn g_io_extension_point_get_required_type(extension_point: ?*GIOExtensionPoint) GType;
pub extern fn g_io_extension_point_get_extensions(extension_point: ?*GIOExtensionPoint) [*c]GList;
pub extern fn g_io_extension_point_get_extension_by_name(extension_point: ?*GIOExtensionPoint, name: [*c]const u8) ?*GIOExtension;
pub extern fn g_io_extension_point_implement(extension_point_name: [*c]const u8, type_0: GType, extension_name: [*c]const u8, priority: gint) ?*GIOExtension;
pub extern fn g_io_extension_get_type(extension: ?*GIOExtension) GType;
pub extern fn g_io_extension_get_name(extension: ?*GIOExtension) [*c]const u8;
pub extern fn g_io_extension_get_priority(extension: ?*GIOExtension) gint;
pub extern fn g_io_extension_ref_class(extension: ?*GIOExtension) [*c]GTypeClass;
pub extern fn g_io_module_load(module: ?*GIOModule) void;
pub extern fn g_io_module_unload(module: ?*GIOModule) void;
pub extern fn g_io_module_query() [*c]([*c]u8);
pub extern fn g_io_scheduler_push_job(job_func: GIOSchedulerJobFunc, user_data: gpointer, notify: GDestroyNotify, io_priority: gint, cancellable: [*c]GCancellable) void;
pub extern fn g_io_scheduler_cancel_all_jobs() void;
pub extern fn g_io_scheduler_job_send_to_mainloop(job: ?*GIOSchedulerJob, func: GSourceFunc, user_data: gpointer, notify: GDestroyNotify) gboolean;
pub extern fn g_io_scheduler_job_send_to_mainloop_async(job: ?*GIOSchedulerJob, func: GSourceFunc, user_data: gpointer, notify: GDestroyNotify) void;
pub const struct__GLoadableIconIface = extern struct {
    g_iface: GTypeInterface,
    load: ?extern fn (?*GLoadableIcon, c_int, [*c]([*c]u8), [*c]GCancellable, [*c]([*c]GError)) [*c]GInputStream,
    load_async: ?extern fn (?*GLoadableIcon, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    load_finish: ?extern fn (?*GLoadableIcon, ?*GAsyncResult, [*c]([*c]u8), [*c]([*c]GError)) [*c]GInputStream,
};
pub const GLoadableIconIface = struct__GLoadableIconIface;
pub extern fn g_loadable_icon_get_type() GType;
pub extern fn g_loadable_icon_load(icon: ?*GLoadableIcon, size: c_int, type_0: [*c]([*c]u8), cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GInputStream;
pub extern fn g_loadable_icon_load_async(icon: ?*GLoadableIcon, size: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_loadable_icon_load_finish(icon: ?*GLoadableIcon, res: ?*GAsyncResult, type_0: [*c]([*c]u8), @"error": [*c]([*c]GError)) [*c]GInputStream;
pub const struct__GMemoryInputStreamClass = extern struct {
    parent_class: GInputStreamClass,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GMemoryInputStreamClass = struct__GMemoryInputStreamClass;
pub extern fn g_memory_input_stream_get_type() GType;
pub extern fn g_memory_input_stream_new() [*c]GInputStream;
pub extern fn g_memory_input_stream_new_from_data(data: ?*const c_void, len: gssize, destroy: GDestroyNotify) [*c]GInputStream;
pub extern fn g_memory_input_stream_new_from_bytes(bytes: ?*GBytes) [*c]GInputStream;
pub extern fn g_memory_input_stream_add_data(stream: [*c]GMemoryInputStream, data: ?*const c_void, len: gssize, destroy: GDestroyNotify) void;
pub extern fn g_memory_input_stream_add_bytes(stream: [*c]GMemoryInputStream, bytes: ?*GBytes) void;
pub const struct__GMemoryOutputStreamClass = extern struct {
    parent_class: GOutputStreamClass,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GMemoryOutputStreamClass = struct__GMemoryOutputStreamClass;
pub const GReallocFunc = ?extern fn (gpointer, gsize) gpointer;
pub extern fn g_memory_output_stream_get_type() GType;
pub extern fn g_memory_output_stream_new(data: gpointer, size: gsize, realloc_function: GReallocFunc, destroy_function: GDestroyNotify) [*c]GOutputStream;
pub extern fn g_memory_output_stream_new_resizable() [*c]GOutputStream;
pub extern fn g_memory_output_stream_get_data(ostream: [*c]GMemoryOutputStream) gpointer;
pub extern fn g_memory_output_stream_get_size(ostream: [*c]GMemoryOutputStream) gsize;
pub extern fn g_memory_output_stream_get_data_size(ostream: [*c]GMemoryOutputStream) gsize;
pub extern fn g_memory_output_stream_steal_data(ostream: [*c]GMemoryOutputStream) gpointer;
pub extern fn g_memory_output_stream_steal_as_bytes(ostream: [*c]GMemoryOutputStream) ?*GBytes;
pub const struct__GMountIface = extern struct {
    g_iface: GTypeInterface,
    changed: ?extern fn (?*GMount) void,
    unmounted: ?extern fn (?*GMount) void,
    get_root: ?extern fn (?*GMount) ?*GFile,
    get_name: ?extern fn (?*GMount) [*c]u8,
    get_icon: ?extern fn (?*GMount) ?*GIcon,
    get_uuid: ?extern fn (?*GMount) [*c]u8,
    get_volume: ?extern fn (?*GMount) ?*GVolume,
    get_drive: ?extern fn (?*GMount) ?*GDrive,
    can_unmount: ?extern fn (?*GMount) gboolean,
    can_eject: ?extern fn (?*GMount) gboolean,
    unmount: ?extern fn (?*GMount, GMountUnmountFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    unmount_finish: ?extern fn (?*GMount, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    eject: ?extern fn (?*GMount, GMountUnmountFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    eject_finish: ?extern fn (?*GMount, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    remount: ?extern fn (?*GMount, GMountMountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    remount_finish: ?extern fn (?*GMount, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    guess_content_type: ?extern fn (?*GMount, gboolean, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    guess_content_type_finish: ?extern fn (?*GMount, ?*GAsyncResult, [*c]([*c]GError)) [*c]([*c]gchar),
    guess_content_type_sync: ?extern fn (?*GMount, gboolean, [*c]GCancellable, [*c]([*c]GError)) [*c]([*c]gchar),
    pre_unmount: ?extern fn (?*GMount) void,
    unmount_with_operation: ?extern fn (?*GMount, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    unmount_with_operation_finish: ?extern fn (?*GMount, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    eject_with_operation: ?extern fn (?*GMount, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    eject_with_operation_finish: ?extern fn (?*GMount, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    get_default_location: ?extern fn (?*GMount) ?*GFile,
    get_sort_key: ?extern fn (?*GMount) [*c]const gchar,
    get_symbolic_icon: ?extern fn (?*GMount) ?*GIcon,
};
pub const GMountIface = struct__GMountIface;
pub extern fn g_mount_get_type() GType;
pub extern fn g_mount_get_root(mount: ?*GMount) ?*GFile;
pub extern fn g_mount_get_default_location(mount: ?*GMount) ?*GFile;
pub extern fn g_mount_get_name(mount: ?*GMount) [*c]u8;
pub extern fn g_mount_get_icon(mount: ?*GMount) ?*GIcon;
pub extern fn g_mount_get_symbolic_icon(mount: ?*GMount) ?*GIcon;
pub extern fn g_mount_get_uuid(mount: ?*GMount) [*c]u8;
pub extern fn g_mount_get_volume(mount: ?*GMount) ?*GVolume;
pub extern fn g_mount_get_drive(mount: ?*GMount) ?*GDrive;
pub extern fn g_mount_can_unmount(mount: ?*GMount) gboolean;
pub extern fn g_mount_can_eject(mount: ?*GMount) gboolean;
pub extern fn g_mount_unmount(mount: ?*GMount, flags: GMountUnmountFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_mount_unmount_finish(mount: ?*GMount, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_mount_eject(mount: ?*GMount, flags: GMountUnmountFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_mount_eject_finish(mount: ?*GMount, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_mount_remount(mount: ?*GMount, flags: GMountMountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_mount_remount_finish(mount: ?*GMount, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_mount_guess_content_type(mount: ?*GMount, force_rescan: gboolean, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_mount_guess_content_type_finish(mount: ?*GMount, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]([*c]gchar);
pub extern fn g_mount_guess_content_type_sync(mount: ?*GMount, force_rescan: gboolean, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]([*c]gchar);
pub extern fn g_mount_is_shadowed(mount: ?*GMount) gboolean;
pub extern fn g_mount_shadow(mount: ?*GMount) void;
pub extern fn g_mount_unshadow(mount: ?*GMount) void;
pub extern fn g_mount_unmount_with_operation(mount: ?*GMount, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_mount_unmount_with_operation_finish(mount: ?*GMount, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_mount_eject_with_operation(mount: ?*GMount, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_mount_eject_with_operation_finish(mount: ?*GMount, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_mount_get_sort_key(mount: ?*GMount) [*c]const gchar;
pub const struct__GMountOperationClass = extern struct {
    parent_class: GObjectClass,
    ask_password: ?extern fn ([*c]GMountOperation, [*c]const u8, [*c]const u8, [*c]const u8, GAskPasswordFlags) void,
    ask_question: ?extern fn ([*c]GMountOperation, [*c]const u8, [*c]([*c]const u8)) void,
    reply: ?extern fn ([*c]GMountOperation, GMountOperationResult) void,
    aborted: ?extern fn ([*c]GMountOperation) void,
    show_processes: ?extern fn ([*c]GMountOperation, [*c]const gchar, [*c]GArray, [*c]([*c]const gchar)) void,
    show_unmount_progress: ?extern fn ([*c]GMountOperation, [*c]const gchar, gint64, gint64) void,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
    _g_reserved6: ?extern fn () void,
    _g_reserved7: ?extern fn () void,
    _g_reserved8: ?extern fn () void,
    _g_reserved9: ?extern fn () void,
};
pub const GMountOperationClass = struct__GMountOperationClass;
pub extern fn g_mount_operation_get_type() GType;
pub extern fn g_mount_operation_new() [*c]GMountOperation;
pub extern fn g_mount_operation_get_username(op: [*c]GMountOperation) [*c]const u8;
pub extern fn g_mount_operation_set_username(op: [*c]GMountOperation, username: [*c]const u8) void;
pub extern fn g_mount_operation_get_password(op: [*c]GMountOperation) [*c]const u8;
pub extern fn g_mount_operation_set_password(op: [*c]GMountOperation, password: [*c]const u8) void;
pub extern fn g_mount_operation_get_anonymous(op: [*c]GMountOperation) gboolean;
pub extern fn g_mount_operation_set_anonymous(op: [*c]GMountOperation, anonymous: gboolean) void;
pub extern fn g_mount_operation_get_domain(op: [*c]GMountOperation) [*c]const u8;
pub extern fn g_mount_operation_set_domain(op: [*c]GMountOperation, domain: [*c]const u8) void;
pub extern fn g_mount_operation_get_password_save(op: [*c]GMountOperation) GPasswordSave;
pub extern fn g_mount_operation_set_password_save(op: [*c]GMountOperation, save: GPasswordSave) void;
pub extern fn g_mount_operation_get_choice(op: [*c]GMountOperation) c_int;
pub extern fn g_mount_operation_set_choice(op: [*c]GMountOperation, choice: c_int) void;
pub extern fn g_mount_operation_reply(op: [*c]GMountOperation, result: GMountOperationResult) void;
pub extern fn g_mount_operation_get_is_tcrypt_hidden_volume(op: [*c]GMountOperation) gboolean;
pub extern fn g_mount_operation_set_is_tcrypt_hidden_volume(op: [*c]GMountOperation, hidden_volume: gboolean) void;
pub extern fn g_mount_operation_get_is_tcrypt_system_volume(op: [*c]GMountOperation) gboolean;
pub extern fn g_mount_operation_set_is_tcrypt_system_volume(op: [*c]GMountOperation, system_volume: gboolean) void;
pub extern fn g_mount_operation_get_pim(op: [*c]GMountOperation) guint;
pub extern fn g_mount_operation_set_pim(op: [*c]GMountOperation, pim: guint) void;
pub const struct__GNativeSocketAddressClass = extern struct {
    parent_class: GSocketAddressClass,
};
pub const GNativeSocketAddressClass = struct__GNativeSocketAddressClass;
pub extern fn g_native_socket_address_get_type() GType;
pub extern fn g_native_socket_address_new(native: gpointer, len: gsize) [*c]GSocketAddress;
pub const struct__GVolumeMonitorClass = extern struct {
    parent_class: GObjectClass,
    volume_added: ?extern fn ([*c]GVolumeMonitor, ?*GVolume) void,
    volume_removed: ?extern fn ([*c]GVolumeMonitor, ?*GVolume) void,
    volume_changed: ?extern fn ([*c]GVolumeMonitor, ?*GVolume) void,
    mount_added: ?extern fn ([*c]GVolumeMonitor, ?*GMount) void,
    mount_removed: ?extern fn ([*c]GVolumeMonitor, ?*GMount) void,
    mount_pre_unmount: ?extern fn ([*c]GVolumeMonitor, ?*GMount) void,
    mount_changed: ?extern fn ([*c]GVolumeMonitor, ?*GMount) void,
    drive_connected: ?extern fn ([*c]GVolumeMonitor, ?*GDrive) void,
    drive_disconnected: ?extern fn ([*c]GVolumeMonitor, ?*GDrive) void,
    drive_changed: ?extern fn ([*c]GVolumeMonitor, ?*GDrive) void,
    is_supported: ?extern fn () gboolean,
    get_connected_drives: ?extern fn ([*c]GVolumeMonitor) [*c]GList,
    get_volumes: ?extern fn ([*c]GVolumeMonitor) [*c]GList,
    get_mounts: ?extern fn ([*c]GVolumeMonitor) [*c]GList,
    get_volume_for_uuid: ?extern fn ([*c]GVolumeMonitor, [*c]const u8) ?*GVolume,
    get_mount_for_uuid: ?extern fn ([*c]GVolumeMonitor, [*c]const u8) ?*GMount,
    adopt_orphan_mount: ?extern fn (?*GMount, [*c]GVolumeMonitor) ?*GVolume,
    drive_eject_button: ?extern fn ([*c]GVolumeMonitor, ?*GDrive) void,
    drive_stop_button: ?extern fn ([*c]GVolumeMonitor, ?*GDrive) void,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
    _g_reserved6: ?extern fn () void,
};
pub const GVolumeMonitorClass = struct__GVolumeMonitorClass;
pub extern fn g_volume_monitor_get_type() GType;
pub extern fn g_volume_monitor_get() [*c]GVolumeMonitor;
pub extern fn g_volume_monitor_get_connected_drives(volume_monitor: [*c]GVolumeMonitor) [*c]GList;
pub extern fn g_volume_monitor_get_volumes(volume_monitor: [*c]GVolumeMonitor) [*c]GList;
pub extern fn g_volume_monitor_get_mounts(volume_monitor: [*c]GVolumeMonitor) [*c]GList;
pub extern fn g_volume_monitor_get_volume_for_uuid(volume_monitor: [*c]GVolumeMonitor, uuid: [*c]const u8) ?*GVolume;
pub extern fn g_volume_monitor_get_mount_for_uuid(volume_monitor: [*c]GVolumeMonitor, uuid: [*c]const u8) ?*GMount;
pub extern fn g_volume_monitor_adopt_orphan_mount(mount: ?*GMount) ?*GVolume;
pub const struct__GNativeVolumeMonitor = extern struct {
    parent_instance: GVolumeMonitor,
};
pub const GNativeVolumeMonitor = struct__GNativeVolumeMonitor;
pub const struct__GNativeVolumeMonitorClass = extern struct {
    parent_class: GVolumeMonitorClass,
    get_mount_for_mount_path: ?extern fn ([*c]const u8, [*c]GCancellable) ?*GMount,
};
pub const GNativeVolumeMonitorClass = struct__GNativeVolumeMonitorClass;
pub extern fn g_native_volume_monitor_get_type() GType;
pub const struct__GNetworkAddressClass = extern struct {
    parent_class: GObjectClass,
};
pub const GNetworkAddressClass = struct__GNetworkAddressClass;
pub extern fn g_network_address_get_type() GType;
pub extern fn g_network_address_new(hostname: [*c]const gchar, port: guint16) ?*GSocketConnectable;
pub extern fn g_network_address_new_loopback(port: guint16) ?*GSocketConnectable;
pub extern fn g_network_address_parse(host_and_port: [*c]const gchar, default_port: guint16, @"error": [*c]([*c]GError)) ?*GSocketConnectable;
pub extern fn g_network_address_parse_uri(uri: [*c]const gchar, default_port: guint16, @"error": [*c]([*c]GError)) ?*GSocketConnectable;
pub extern fn g_network_address_get_hostname(addr: [*c]GNetworkAddress) [*c]const gchar;
pub extern fn g_network_address_get_port(addr: [*c]GNetworkAddress) guint16;
pub extern fn g_network_address_get_scheme(addr: [*c]GNetworkAddress) [*c]const gchar;
pub const struct__GNetworkMonitorInterface = extern struct {
    g_iface: GTypeInterface,
    network_changed: ?extern fn (?*GNetworkMonitor, gboolean) void,
    can_reach: ?extern fn (?*GNetworkMonitor, ?*GSocketConnectable, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    can_reach_async: ?extern fn (?*GNetworkMonitor, ?*GSocketConnectable, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    can_reach_finish: ?extern fn (?*GNetworkMonitor, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
};
pub const GNetworkMonitorInterface = struct__GNetworkMonitorInterface;
pub extern fn g_network_monitor_get_type() GType;
pub extern fn g_network_monitor_get_default() ?*GNetworkMonitor;
pub extern fn g_network_monitor_get_network_available(monitor: ?*GNetworkMonitor) gboolean;
pub extern fn g_network_monitor_get_network_metered(monitor: ?*GNetworkMonitor) gboolean;
pub extern fn g_network_monitor_get_connectivity(monitor: ?*GNetworkMonitor) GNetworkConnectivity;
pub extern fn g_network_monitor_can_reach(monitor: ?*GNetworkMonitor, connectable: ?*GSocketConnectable, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_network_monitor_can_reach_async(monitor: ?*GNetworkMonitor, connectable: ?*GSocketConnectable, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_network_monitor_can_reach_finish(monitor: ?*GNetworkMonitor, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub const struct__GNetworkServiceClass = extern struct {
    parent_class: GObjectClass,
};
pub const GNetworkServiceClass = struct__GNetworkServiceClass;
pub extern fn g_network_service_get_type() GType;
pub extern fn g_network_service_new(service: [*c]const gchar, protocol: [*c]const gchar, domain: [*c]const gchar) ?*GSocketConnectable;
pub extern fn g_network_service_get_service(srv: [*c]GNetworkService) [*c]const gchar;
pub extern fn g_network_service_get_protocol(srv: [*c]GNetworkService) [*c]const gchar;
pub extern fn g_network_service_get_domain(srv: [*c]GNetworkService) [*c]const gchar;
pub extern fn g_network_service_get_scheme(srv: [*c]GNetworkService) [*c]const gchar;
pub extern fn g_network_service_set_scheme(srv: [*c]GNetworkService, scheme: [*c]const gchar) void;
pub const struct__GPermissionClass = extern struct {
    parent_class: GObjectClass,
    acquire: ?extern fn ([*c]GPermission, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    acquire_async: ?extern fn ([*c]GPermission, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    acquire_finish: ?extern fn ([*c]GPermission, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    release: ?extern fn ([*c]GPermission, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    release_async: ?extern fn ([*c]GPermission, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    release_finish: ?extern fn ([*c]GPermission, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    reserved: [16]gpointer,
};
pub const GPermissionClass = struct__GPermissionClass;
pub extern fn g_permission_get_type() GType;
pub extern fn g_permission_acquire(permission: [*c]GPermission, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_permission_acquire_async(permission: [*c]GPermission, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_permission_acquire_finish(permission: [*c]GPermission, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_permission_release(permission: [*c]GPermission, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_permission_release_async(permission: [*c]GPermission, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_permission_release_finish(permission: [*c]GPermission, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_permission_get_allowed(permission: [*c]GPermission) gboolean;
pub extern fn g_permission_get_can_acquire(permission: [*c]GPermission) gboolean;
pub extern fn g_permission_get_can_release(permission: [*c]GPermission) gboolean;
pub extern fn g_permission_impl_update(permission: [*c]GPermission, allowed: gboolean, can_acquire: gboolean, can_release: gboolean) void;
pub const struct__GPollableInputStreamInterface = extern struct {
    g_iface: GTypeInterface,
    can_poll: ?extern fn (?*GPollableInputStream) gboolean,
    is_readable: ?extern fn (?*GPollableInputStream) gboolean,
    create_source: ?extern fn (?*GPollableInputStream, [*c]GCancellable) [*c]GSource,
    read_nonblocking: ?extern fn (?*GPollableInputStream, ?*c_void, gsize, [*c]([*c]GError)) gssize,
};
pub const GPollableInputStreamInterface = struct__GPollableInputStreamInterface;
pub extern fn g_pollable_input_stream_get_type() GType;
pub extern fn g_pollable_input_stream_can_poll(stream: ?*GPollableInputStream) gboolean;
pub extern fn g_pollable_input_stream_is_readable(stream: ?*GPollableInputStream) gboolean;
pub extern fn g_pollable_input_stream_create_source(stream: ?*GPollableInputStream, cancellable: [*c]GCancellable) [*c]GSource;
pub extern fn g_pollable_input_stream_read_nonblocking(stream: ?*GPollableInputStream, buffer: ?*c_void, count: gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub const struct__GPollableOutputStreamInterface = extern struct {
    g_iface: GTypeInterface,
    can_poll: ?extern fn (?*GPollableOutputStream) gboolean,
    is_writable: ?extern fn (?*GPollableOutputStream) gboolean,
    create_source: ?extern fn (?*GPollableOutputStream, [*c]GCancellable) [*c]GSource,
    write_nonblocking: ?extern fn (?*GPollableOutputStream, ?*const c_void, gsize, [*c]([*c]GError)) gssize,
    writev_nonblocking: ?extern fn (?*GPollableOutputStream, [*c]const GOutputVector, gsize, [*c]gsize, [*c]([*c]GError)) GPollableReturn,
};
pub const GPollableOutputStreamInterface = struct__GPollableOutputStreamInterface;
pub extern fn g_pollable_output_stream_get_type() GType;
pub extern fn g_pollable_output_stream_can_poll(stream: ?*GPollableOutputStream) gboolean;
pub extern fn g_pollable_output_stream_is_writable(stream: ?*GPollableOutputStream) gboolean;
pub extern fn g_pollable_output_stream_create_source(stream: ?*GPollableOutputStream, cancellable: [*c]GCancellable) [*c]GSource;
pub extern fn g_pollable_output_stream_write_nonblocking(stream: ?*GPollableOutputStream, buffer: ?*const c_void, count: gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_pollable_output_stream_writev_nonblocking(stream: ?*GPollableOutputStream, vectors: [*c]const GOutputVector, n_vectors: gsize, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) GPollableReturn;
pub extern fn g_pollable_source_new(pollable_stream: [*c]GObject) [*c]GSource;
pub extern fn g_pollable_source_new_full(pollable_stream: gpointer, child_source: [*c]GSource, cancellable: [*c]GCancellable) [*c]GSource;
pub extern fn g_pollable_stream_read(stream: [*c]GInputStream, buffer: ?*c_void, count: gsize, blocking: gboolean, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_pollable_stream_write(stream: [*c]GOutputStream, buffer: ?*const c_void, count: gsize, blocking: gboolean, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_pollable_stream_write_all(stream: [*c]GOutputStream, buffer: ?*const c_void, count: gsize, blocking: gboolean, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_property_action_get_type() GType;
pub extern fn g_property_action_new(name: [*c]const gchar, object: gpointer, property_name: [*c]const gchar) ?*GPropertyAction;
pub const struct__GProxyInterface = extern struct {
    g_iface: GTypeInterface,
    connect: ?extern fn (?*GProxy, [*c]GIOStream, [*c]GProxyAddress, [*c]GCancellable, [*c]([*c]GError)) [*c]GIOStream,
    connect_async: ?extern fn (?*GProxy, [*c]GIOStream, [*c]GProxyAddress, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    connect_finish: ?extern fn (?*GProxy, ?*GAsyncResult, [*c]([*c]GError)) [*c]GIOStream,
    supports_hostname: ?extern fn (?*GProxy) gboolean,
};
pub const GProxyInterface = struct__GProxyInterface;
pub extern fn g_proxy_get_type() GType;
pub extern fn g_proxy_get_default_for_protocol(protocol: [*c]const gchar) ?*GProxy;
pub extern fn g_proxy_connect(proxy: ?*GProxy, connection: [*c]GIOStream, proxy_address: [*c]GProxyAddress, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GIOStream;
pub extern fn g_proxy_connect_async(proxy: ?*GProxy, connection: [*c]GIOStream, proxy_address: [*c]GProxyAddress, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_proxy_connect_finish(proxy: ?*GProxy, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GIOStream;
pub extern fn g_proxy_supports_hostname(proxy: ?*GProxy) gboolean;
pub const struct__GProxyAddressClass = extern struct {
    parent_class: GInetSocketAddressClass,
};
pub const GProxyAddressClass = struct__GProxyAddressClass;
pub extern fn g_proxy_address_get_type() GType;
pub extern fn g_proxy_address_new(inetaddr: [*c]GInetAddress, port: guint16, protocol: [*c]const gchar, dest_hostname: [*c]const gchar, dest_port: guint16, username: [*c]const gchar, password: [*c]const gchar) [*c]GSocketAddress;
pub extern fn g_proxy_address_get_protocol(proxy: [*c]GProxyAddress) [*c]const gchar;
pub extern fn g_proxy_address_get_destination_protocol(proxy: [*c]GProxyAddress) [*c]const gchar;
pub extern fn g_proxy_address_get_destination_hostname(proxy: [*c]GProxyAddress) [*c]const gchar;
pub extern fn g_proxy_address_get_destination_port(proxy: [*c]GProxyAddress) guint16;
pub extern fn g_proxy_address_get_username(proxy: [*c]GProxyAddress) [*c]const gchar;
pub extern fn g_proxy_address_get_password(proxy: [*c]GProxyAddress) [*c]const gchar;
pub extern fn g_proxy_address_get_uri(proxy: [*c]GProxyAddress) [*c]const gchar;
pub const struct__GSocketAddressEnumeratorClass = extern struct {
    parent_class: GObjectClass,
    next: ?extern fn ([*c]GSocketAddressEnumerator, [*c]GCancellable, [*c]([*c]GError)) [*c]GSocketAddress,
    next_async: ?extern fn ([*c]GSocketAddressEnumerator, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    next_finish: ?extern fn ([*c]GSocketAddressEnumerator, ?*GAsyncResult, [*c]([*c]GError)) [*c]GSocketAddress,
};
pub const GSocketAddressEnumeratorClass = struct__GSocketAddressEnumeratorClass;
pub extern fn g_socket_address_enumerator_get_type() GType;
pub extern fn g_socket_address_enumerator_next(enumerator: [*c]GSocketAddressEnumerator, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GSocketAddress;
pub extern fn g_socket_address_enumerator_next_async(enumerator: [*c]GSocketAddressEnumerator, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_address_enumerator_next_finish(enumerator: [*c]GSocketAddressEnumerator, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GSocketAddress;
pub const struct__GProxyAddressEnumeratorClass = extern struct {
    parent_class: GSocketAddressEnumeratorClass,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
    _g_reserved6: ?extern fn () void,
    _g_reserved7: ?extern fn () void,
};
pub const GProxyAddressEnumeratorClass = struct__GProxyAddressEnumeratorClass;
pub extern fn g_proxy_address_enumerator_get_type() GType;
pub const struct__GProxyResolverInterface = extern struct {
    g_iface: GTypeInterface,
    is_supported: ?extern fn (?*GProxyResolver) gboolean,
    lookup: ?extern fn (?*GProxyResolver, [*c]const gchar, [*c]GCancellable, [*c]([*c]GError)) [*c]([*c]gchar),
    lookup_async: ?extern fn (?*GProxyResolver, [*c]const gchar, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    lookup_finish: ?extern fn (?*GProxyResolver, ?*GAsyncResult, [*c]([*c]GError)) [*c]([*c]gchar),
};
pub const GProxyResolverInterface = struct__GProxyResolverInterface;
pub extern fn g_proxy_resolver_get_type() GType;
pub extern fn g_proxy_resolver_get_default() ?*GProxyResolver;
pub extern fn g_proxy_resolver_is_supported(resolver: ?*GProxyResolver) gboolean;
pub extern fn g_proxy_resolver_lookup(resolver: ?*GProxyResolver, uri: [*c]const gchar, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]([*c]gchar);
pub extern fn g_proxy_resolver_lookup_async(resolver: ?*GProxyResolver, uri: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_proxy_resolver_lookup_finish(resolver: ?*GProxyResolver, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]([*c]gchar);
pub const G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT = 0;
pub const G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY = 1;
pub const G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY = 2;
pub const GResolverNameLookupFlags = extern enum {
    G_RESOLVER_NAME_LOOKUP_FLAGS_DEFAULT = 0,
    G_RESOLVER_NAME_LOOKUP_FLAGS_IPV4_ONLY = 1,
    G_RESOLVER_NAME_LOOKUP_FLAGS_IPV6_ONLY = 2,
};
pub const struct__GResolverClass = extern struct {
    parent_class: GObjectClass,
    reload: ?extern fn ([*c]GResolver) void,
    lookup_by_name: ?extern fn ([*c]GResolver, [*c]const gchar, [*c]GCancellable, [*c]([*c]GError)) [*c]GList,
    lookup_by_name_async: ?extern fn ([*c]GResolver, [*c]const gchar, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    lookup_by_name_finish: ?extern fn ([*c]GResolver, ?*GAsyncResult, [*c]([*c]GError)) [*c]GList,
    lookup_by_address: ?extern fn ([*c]GResolver, [*c]GInetAddress, [*c]GCancellable, [*c]([*c]GError)) [*c]gchar,
    lookup_by_address_async: ?extern fn ([*c]GResolver, [*c]GInetAddress, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    lookup_by_address_finish: ?extern fn ([*c]GResolver, ?*GAsyncResult, [*c]([*c]GError)) [*c]gchar,
    lookup_service: ?extern fn ([*c]GResolver, [*c]const gchar, [*c]GCancellable, [*c]([*c]GError)) [*c]GList,
    lookup_service_async: ?extern fn ([*c]GResolver, [*c]const gchar, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    lookup_service_finish: ?extern fn ([*c]GResolver, ?*GAsyncResult, [*c]([*c]GError)) [*c]GList,
    lookup_records: ?extern fn ([*c]GResolver, [*c]const gchar, GResolverRecordType, [*c]GCancellable, [*c]([*c]GError)) [*c]GList,
    lookup_records_async: ?extern fn ([*c]GResolver, [*c]const gchar, GResolverRecordType, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    lookup_records_finish: ?extern fn ([*c]GResolver, ?*GAsyncResult, [*c]([*c]GError)) [*c]GList,
    lookup_by_name_with_flags_async: ?extern fn ([*c]GResolver, [*c]const gchar, GResolverNameLookupFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    lookup_by_name_with_flags_finish: ?extern fn ([*c]GResolver, ?*GAsyncResult, [*c]([*c]GError)) [*c]GList,
    lookup_by_name_with_flags: ?extern fn ([*c]GResolver, [*c]const gchar, GResolverNameLookupFlags, [*c]GCancellable, [*c]([*c]GError)) [*c]GList,
};
pub const GResolverClass = struct__GResolverClass;
pub extern fn g_resolver_get_type() GType;
pub extern fn g_resolver_get_default() [*c]GResolver;
pub extern fn g_resolver_set_default(resolver: [*c]GResolver) void;
pub extern fn g_resolver_lookup_by_name(resolver: [*c]GResolver, hostname: [*c]const gchar, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GList;
pub extern fn g_resolver_lookup_by_name_async(resolver: [*c]GResolver, hostname: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_resolver_lookup_by_name_finish(resolver: [*c]GResolver, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GList;
pub extern fn g_resolver_lookup_by_name_with_flags_async(resolver: [*c]GResolver, hostname: [*c]const gchar, flags: GResolverNameLookupFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_resolver_lookup_by_name_with_flags_finish(resolver: [*c]GResolver, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GList;
pub extern fn g_resolver_lookup_by_name_with_flags(resolver: [*c]GResolver, hostname: [*c]const gchar, flags: GResolverNameLookupFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GList;
pub extern fn g_resolver_free_addresses(addresses: [*c]GList) void;
pub extern fn g_resolver_lookup_by_address(resolver: [*c]GResolver, address: [*c]GInetAddress, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_resolver_lookup_by_address_async(resolver: [*c]GResolver, address: [*c]GInetAddress, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_resolver_lookup_by_address_finish(resolver: [*c]GResolver, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]gchar;
pub extern fn g_resolver_lookup_service(resolver: [*c]GResolver, service: [*c]const gchar, protocol: [*c]const gchar, domain: [*c]const gchar, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GList;
pub extern fn g_resolver_lookup_service_async(resolver: [*c]GResolver, service: [*c]const gchar, protocol: [*c]const gchar, domain: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_resolver_lookup_service_finish(resolver: [*c]GResolver, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GList;
pub extern fn g_resolver_lookup_records(resolver: [*c]GResolver, rrname: [*c]const gchar, record_type: GResolverRecordType, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GList;
pub extern fn g_resolver_lookup_records_async(resolver: [*c]GResolver, rrname: [*c]const gchar, record_type: GResolverRecordType, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_resolver_lookup_records_finish(resolver: [*c]GResolver, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GList;
pub extern fn g_resolver_free_targets(targets: [*c]GList) void;
pub extern fn g_resolver_error_quark() GQuark;
pub extern fn g_resource_error_quark() GQuark;
pub const GStaticResource = struct__GStaticResource;
pub const struct__GStaticResource = extern struct {
    data: [*c]const guint8,
    data_len: gsize,
    resource: ?*GResource,
    next: [*c]GStaticResource,
    padding: gpointer,
};
pub extern fn g_resource_get_type() GType;
pub extern fn g_resource_new_from_data(data: ?*GBytes, @"error": [*c]([*c]GError)) ?*GResource;
pub extern fn g_resource_ref(resource: ?*GResource) ?*GResource;
pub extern fn g_resource_unref(resource: ?*GResource) void;
pub extern fn g_resource_load(filename: [*c]const gchar, @"error": [*c]([*c]GError)) ?*GResource;
pub extern fn g_resource_open_stream(resource: ?*GResource, path: [*c]const u8, lookup_flags: GResourceLookupFlags, @"error": [*c]([*c]GError)) [*c]GInputStream;
pub extern fn g_resource_lookup_data(resource: ?*GResource, path: [*c]const u8, lookup_flags: GResourceLookupFlags, @"error": [*c]([*c]GError)) ?*GBytes;
pub extern fn g_resource_enumerate_children(resource: ?*GResource, path: [*c]const u8, lookup_flags: GResourceLookupFlags, @"error": [*c]([*c]GError)) [*c]([*c]u8);
pub extern fn g_resource_get_info(resource: ?*GResource, path: [*c]const u8, lookup_flags: GResourceLookupFlags, size: [*c]gsize, flags: [*c]guint32, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_resources_register(resource: ?*GResource) void;
pub extern fn g_resources_unregister(resource: ?*GResource) void;
pub extern fn g_resources_open_stream(path: [*c]const u8, lookup_flags: GResourceLookupFlags, @"error": [*c]([*c]GError)) [*c]GInputStream;
pub extern fn g_resources_lookup_data(path: [*c]const u8, lookup_flags: GResourceLookupFlags, @"error": [*c]([*c]GError)) ?*GBytes;
pub extern fn g_resources_enumerate_children(path: [*c]const u8, lookup_flags: GResourceLookupFlags, @"error": [*c]([*c]GError)) [*c]([*c]u8);
pub extern fn g_resources_get_info(path: [*c]const u8, lookup_flags: GResourceLookupFlags, size: [*c]gsize, flags: [*c]guint32, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_static_resource_init(static_resource: [*c]GStaticResource) void;
pub extern fn g_static_resource_fini(static_resource: [*c]GStaticResource) void;
pub extern fn g_static_resource_get_resource(static_resource: [*c]GStaticResource) ?*GResource;
pub const struct__GSeekableIface = extern struct {
    g_iface: GTypeInterface,
    tell: ?extern fn (?*GSeekable) goffset,
    can_seek: ?extern fn (?*GSeekable) gboolean,
    seek: ?extern fn (?*GSeekable, goffset, GSeekType, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    can_truncate: ?extern fn (?*GSeekable) gboolean,
    truncate_fn: ?extern fn (?*GSeekable, goffset, [*c]GCancellable, [*c]([*c]GError)) gboolean,
};
pub const GSeekableIface = struct__GSeekableIface;
pub extern fn g_seekable_get_type() GType;
pub extern fn g_seekable_tell(seekable: ?*GSeekable) goffset;
pub extern fn g_seekable_can_seek(seekable: ?*GSeekable) gboolean;
pub extern fn g_seekable_seek(seekable: ?*GSeekable, offset: goffset, type_0: GSeekType, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_seekable_can_truncate(seekable: ?*GSeekable) gboolean;
pub extern fn g_seekable_truncate(seekable: ?*GSeekable, offset: goffset, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub const struct__GSettingsSchemaSource = @OpaqueType();
pub const GSettingsSchemaSource = struct__GSettingsSchemaSource;
pub const struct__GSettingsSchema = @OpaqueType();
pub const GSettingsSchema = struct__GSettingsSchema;
pub const struct__GSettingsSchemaKey = @OpaqueType();
pub const GSettingsSchemaKey = struct__GSettingsSchemaKey;
pub extern fn g_settings_schema_source_get_type() GType;
pub extern fn g_settings_schema_source_get_default() ?*GSettingsSchemaSource;
pub extern fn g_settings_schema_source_ref(source: ?*GSettingsSchemaSource) ?*GSettingsSchemaSource;
pub extern fn g_settings_schema_source_unref(source: ?*GSettingsSchemaSource) void;
pub extern fn g_settings_schema_source_new_from_directory(directory: [*c]const gchar, parent: ?*GSettingsSchemaSource, trusted: gboolean, @"error": [*c]([*c]GError)) ?*GSettingsSchemaSource;
pub extern fn g_settings_schema_source_lookup(source: ?*GSettingsSchemaSource, schema_id: [*c]const gchar, recursive: gboolean) ?*GSettingsSchema;
pub extern fn g_settings_schema_source_list_schemas(source: ?*GSettingsSchemaSource, recursive: gboolean, non_relocatable: [*c]([*c]([*c]gchar)), relocatable: [*c]([*c]([*c]gchar))) void;
pub extern fn g_settings_schema_get_type() GType;
pub extern fn g_settings_schema_ref(schema: ?*GSettingsSchema) ?*GSettingsSchema;
pub extern fn g_settings_schema_unref(schema: ?*GSettingsSchema) void;
pub extern fn g_settings_schema_get_id(schema: ?*GSettingsSchema) [*c]const gchar;
pub extern fn g_settings_schema_get_path(schema: ?*GSettingsSchema) [*c]const gchar;
pub extern fn g_settings_schema_get_key(schema: ?*GSettingsSchema, name: [*c]const gchar) ?*GSettingsSchemaKey;
pub extern fn g_settings_schema_has_key(schema: ?*GSettingsSchema, name: [*c]const gchar) gboolean;
pub extern fn g_settings_schema_list_keys(schema: ?*GSettingsSchema) [*c]([*c]gchar);
pub extern fn g_settings_schema_list_children(schema: ?*GSettingsSchema) [*c]([*c]gchar);
pub extern fn g_settings_schema_key_get_type() GType;
pub extern fn g_settings_schema_key_ref(key: ?*GSettingsSchemaKey) ?*GSettingsSchemaKey;
pub extern fn g_settings_schema_key_unref(key: ?*GSettingsSchemaKey) void;
pub extern fn g_settings_schema_key_get_value_type(key: ?*GSettingsSchemaKey) ?*const GVariantType;
pub extern fn g_settings_schema_key_get_default_value(key: ?*GSettingsSchemaKey) ?*GVariant;
pub extern fn g_settings_schema_key_get_range(key: ?*GSettingsSchemaKey) ?*GVariant;
pub extern fn g_settings_schema_key_range_check(key: ?*GSettingsSchemaKey, value: ?*GVariant) gboolean;
pub extern fn g_settings_schema_key_get_name(key: ?*GSettingsSchemaKey) [*c]const gchar;
pub extern fn g_settings_schema_key_get_summary(key: ?*GSettingsSchemaKey) [*c]const gchar;
pub extern fn g_settings_schema_key_get_description(key: ?*GSettingsSchemaKey) [*c]const gchar;
pub const struct__GSettingsClass = extern struct {
    parent_class: GObjectClass,
    writable_changed: ?extern fn ([*c]GSettings, [*c]const gchar) void,
    changed: ?extern fn ([*c]GSettings, [*c]const gchar) void,
    writable_change_event: ?extern fn ([*c]GSettings, GQuark) gboolean,
    change_event: ?extern fn ([*c]GSettings, [*c]const GQuark, gint) gboolean,
    padding: [20]gpointer,
};
pub const GSettingsClass = struct__GSettingsClass;
pub extern fn g_settings_get_type() GType;
pub extern fn g_settings_list_schemas() [*c]const ([*c]const gchar);
pub extern fn g_settings_list_relocatable_schemas() [*c]const ([*c]const gchar);
pub extern fn g_settings_new(schema_id: [*c]const gchar) [*c]GSettings;
pub extern fn g_settings_new_with_path(schema_id: [*c]const gchar, path: [*c]const gchar) [*c]GSettings;
pub extern fn g_settings_new_with_backend(schema_id: [*c]const gchar, backend: ?*GSettingsBackend) [*c]GSettings;
pub extern fn g_settings_new_with_backend_and_path(schema_id: [*c]const gchar, backend: ?*GSettingsBackend, path: [*c]const gchar) [*c]GSettings;
pub extern fn g_settings_new_full(schema: ?*GSettingsSchema, backend: ?*GSettingsBackend, path: [*c]const gchar) [*c]GSettings;
pub extern fn g_settings_list_children(settings: [*c]GSettings) [*c]([*c]gchar);
pub extern fn g_settings_list_keys(settings: [*c]GSettings) [*c]([*c]gchar);
pub extern fn g_settings_get_range(settings: [*c]GSettings, key: [*c]const gchar) ?*GVariant;
pub extern fn g_settings_range_check(settings: [*c]GSettings, key: [*c]const gchar, value: ?*GVariant) gboolean;
pub extern fn g_settings_set_value(settings: [*c]GSettings, key: [*c]const gchar, value: ?*GVariant) gboolean;
pub extern fn g_settings_get_value(settings: [*c]GSettings, key: [*c]const gchar) ?*GVariant;
pub extern fn g_settings_get_user_value(settings: [*c]GSettings, key: [*c]const gchar) ?*GVariant;
pub extern fn g_settings_get_default_value(settings: [*c]GSettings, key: [*c]const gchar) ?*GVariant;
pub extern fn g_settings_set(settings: [*c]GSettings, key: [*c]const gchar, format: [*c]const gchar, ...) gboolean;
pub extern fn g_settings_get(settings: [*c]GSettings, key: [*c]const gchar, format: [*c]const gchar, ...) void;
pub extern fn g_settings_reset(settings: [*c]GSettings, key: [*c]const gchar) void;
pub extern fn g_settings_get_int(settings: [*c]GSettings, key: [*c]const gchar) gint;
pub extern fn g_settings_set_int(settings: [*c]GSettings, key: [*c]const gchar, value: gint) gboolean;
pub extern fn g_settings_get_int64(settings: [*c]GSettings, key: [*c]const gchar) gint64;
pub extern fn g_settings_set_int64(settings: [*c]GSettings, key: [*c]const gchar, value: gint64) gboolean;
pub extern fn g_settings_get_uint(settings: [*c]GSettings, key: [*c]const gchar) guint;
pub extern fn g_settings_set_uint(settings: [*c]GSettings, key: [*c]const gchar, value: guint) gboolean;
pub extern fn g_settings_get_uint64(settings: [*c]GSettings, key: [*c]const gchar) guint64;
pub extern fn g_settings_set_uint64(settings: [*c]GSettings, key: [*c]const gchar, value: guint64) gboolean;
pub extern fn g_settings_get_string(settings: [*c]GSettings, key: [*c]const gchar) [*c]gchar;
pub extern fn g_settings_set_string(settings: [*c]GSettings, key: [*c]const gchar, value: [*c]const gchar) gboolean;
pub extern fn g_settings_get_boolean(settings: [*c]GSettings, key: [*c]const gchar) gboolean;
pub extern fn g_settings_set_boolean(settings: [*c]GSettings, key: [*c]const gchar, value: gboolean) gboolean;
pub extern fn g_settings_get_double(settings: [*c]GSettings, key: [*c]const gchar) gdouble;
pub extern fn g_settings_set_double(settings: [*c]GSettings, key: [*c]const gchar, value: gdouble) gboolean;
pub extern fn g_settings_get_strv(settings: [*c]GSettings, key: [*c]const gchar) [*c]([*c]gchar);
pub extern fn g_settings_set_strv(settings: [*c]GSettings, key: [*c]const gchar, value: [*c]const ([*c]const gchar)) gboolean;
pub extern fn g_settings_get_enum(settings: [*c]GSettings, key: [*c]const gchar) gint;
pub extern fn g_settings_set_enum(settings: [*c]GSettings, key: [*c]const gchar, value: gint) gboolean;
pub extern fn g_settings_get_flags(settings: [*c]GSettings, key: [*c]const gchar) guint;
pub extern fn g_settings_set_flags(settings: [*c]GSettings, key: [*c]const gchar, value: guint) gboolean;
pub extern fn g_settings_get_child(settings: [*c]GSettings, name: [*c]const gchar) [*c]GSettings;
pub extern fn g_settings_is_writable(settings: [*c]GSettings, name: [*c]const gchar) gboolean;
pub extern fn g_settings_delay(settings: [*c]GSettings) void;
pub extern fn g_settings_apply(settings: [*c]GSettings) void;
pub extern fn g_settings_revert(settings: [*c]GSettings) void;
pub extern fn g_settings_get_has_unapplied(settings: [*c]GSettings) gboolean;
pub extern fn g_settings_sync() void;
pub const GSettingsBindSetMapping = ?extern fn ([*c]const GValue, ?*const GVariantType, gpointer) ?*GVariant;
pub const GSettingsBindGetMapping = ?extern fn ([*c]GValue, ?*GVariant, gpointer) gboolean;
pub const GSettingsGetMapping = ?extern fn (?*GVariant, [*c]gpointer, gpointer) gboolean;
pub const G_SETTINGS_BIND_DEFAULT = 0;
pub const G_SETTINGS_BIND_GET = 1;
pub const G_SETTINGS_BIND_SET = 2;
pub const G_SETTINGS_BIND_NO_SENSITIVITY = 4;
pub const G_SETTINGS_BIND_GET_NO_CHANGES = 8;
pub const G_SETTINGS_BIND_INVERT_BOOLEAN = 16;
pub const GSettingsBindFlags = extern enum {
    G_SETTINGS_BIND_DEFAULT = 0,
    G_SETTINGS_BIND_GET = 1,
    G_SETTINGS_BIND_SET = 2,
    G_SETTINGS_BIND_NO_SENSITIVITY = 4,
    G_SETTINGS_BIND_GET_NO_CHANGES = 8,
    G_SETTINGS_BIND_INVERT_BOOLEAN = 16,
};
pub extern fn g_settings_bind(settings: [*c]GSettings, key: [*c]const gchar, object: gpointer, property: [*c]const gchar, flags: GSettingsBindFlags) void;
pub extern fn g_settings_bind_with_mapping(settings: [*c]GSettings, key: [*c]const gchar, object: gpointer, property: [*c]const gchar, flags: GSettingsBindFlags, get_mapping: GSettingsBindGetMapping, set_mapping: GSettingsBindSetMapping, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn g_settings_bind_writable(settings: [*c]GSettings, key: [*c]const gchar, object: gpointer, property: [*c]const gchar, inverted: gboolean) void;
pub extern fn g_settings_unbind(object: gpointer, property: [*c]const gchar) void;
pub extern fn g_settings_create_action(settings: [*c]GSettings, key: [*c]const gchar) ?*GAction;
pub extern fn g_settings_get_mapped(settings: [*c]GSettings, key: [*c]const gchar, mapping: GSettingsGetMapping, user_data: gpointer) gpointer;
pub extern fn g_simple_action_get_type() GType;
pub extern fn g_simple_action_new(name: [*c]const gchar, parameter_type: ?*const GVariantType) ?*GSimpleAction;
pub extern fn g_simple_action_new_stateful(name: [*c]const gchar, parameter_type: ?*const GVariantType, state: ?*GVariant) ?*GSimpleAction;
pub extern fn g_simple_action_set_enabled(simple: ?*GSimpleAction, enabled: gboolean) void;
pub extern fn g_simple_action_set_state(simple: ?*GSimpleAction, value: ?*GVariant) void;
pub extern fn g_simple_action_set_state_hint(simple: ?*GSimpleAction, state_hint: ?*GVariant) void;
pub const struct__GSimpleActionGroupClass = extern struct {
    parent_class: GObjectClass,
    padding: [12]gpointer,
};
pub const GSimpleActionGroupClass = struct__GSimpleActionGroupClass;
pub extern fn g_simple_action_group_get_type() GType;
pub extern fn g_simple_action_group_new() [*c]GSimpleActionGroup;
pub extern fn g_simple_action_group_lookup(simple: [*c]GSimpleActionGroup, action_name: [*c]const gchar) ?*GAction;
pub extern fn g_simple_action_group_insert(simple: [*c]GSimpleActionGroup, action: ?*GAction) void;
pub extern fn g_simple_action_group_remove(simple: [*c]GSimpleActionGroup, action_name: [*c]const gchar) void;
pub extern fn g_simple_action_group_add_entries(simple: [*c]GSimpleActionGroup, entries: [*c]const GActionEntry, n_entries: gint, user_data: gpointer) void;
pub const struct__GSimpleAsyncResultClass = @OpaqueType();
pub const GSimpleAsyncResultClass = struct__GSimpleAsyncResultClass;
pub extern fn g_simple_async_result_get_type() GType;
pub extern fn g_simple_async_result_new(source_object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, source_tag: gpointer) ?*GSimpleAsyncResult;
pub extern fn g_simple_async_result_new_error(source_object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, domain: GQuark, code: gint, format: [*c]const u8, ...) ?*GSimpleAsyncResult;
pub extern fn g_simple_async_result_new_from_error(source_object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, @"error": [*c]const GError) ?*GSimpleAsyncResult;
pub extern fn g_simple_async_result_new_take_error(source_object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, @"error": [*c]GError) ?*GSimpleAsyncResult;
pub extern fn g_simple_async_result_set_op_res_gpointer(simple: ?*GSimpleAsyncResult, op_res: gpointer, destroy_op_res: GDestroyNotify) void;
pub extern fn g_simple_async_result_get_op_res_gpointer(simple: ?*GSimpleAsyncResult) gpointer;
pub extern fn g_simple_async_result_set_op_res_gssize(simple: ?*GSimpleAsyncResult, op_res: gssize) void;
pub extern fn g_simple_async_result_get_op_res_gssize(simple: ?*GSimpleAsyncResult) gssize;
pub extern fn g_simple_async_result_set_op_res_gboolean(simple: ?*GSimpleAsyncResult, op_res: gboolean) void;
pub extern fn g_simple_async_result_get_op_res_gboolean(simple: ?*GSimpleAsyncResult) gboolean;
pub extern fn g_simple_async_result_set_check_cancellable(simple: ?*GSimpleAsyncResult, check_cancellable: [*c]GCancellable) void;
pub extern fn g_simple_async_result_get_source_tag(simple: ?*GSimpleAsyncResult) gpointer;
pub extern fn g_simple_async_result_set_handle_cancellation(simple: ?*GSimpleAsyncResult, handle_cancellation: gboolean) void;
pub extern fn g_simple_async_result_complete(simple: ?*GSimpleAsyncResult) void;
pub extern fn g_simple_async_result_complete_in_idle(simple: ?*GSimpleAsyncResult) void;
pub extern fn g_simple_async_result_run_in_thread(simple: ?*GSimpleAsyncResult, func: GSimpleAsyncThreadFunc, io_priority: c_int, cancellable: [*c]GCancellable) void;
pub extern fn g_simple_async_result_set_from_error(simple: ?*GSimpleAsyncResult, @"error": [*c]const GError) void;
pub extern fn g_simple_async_result_take_error(simple: ?*GSimpleAsyncResult, @"error": [*c]GError) void;
pub extern fn g_simple_async_result_propagate_error(simple: ?*GSimpleAsyncResult, dest: [*c]([*c]GError)) gboolean;
pub extern fn g_simple_async_result_set_error(simple: ?*GSimpleAsyncResult, domain: GQuark, code: gint, format: [*c]const u8, ...) void;
pub extern fn g_simple_async_result_set_error_va(simple: ?*GSimpleAsyncResult, domain: GQuark, code: gint, format: [*c]const u8, args: va_list) void;
pub extern fn g_simple_async_result_is_valid(result: ?*GAsyncResult, source: [*c]GObject, source_tag: gpointer) gboolean;
pub extern fn g_simple_async_report_error_in_idle(object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, domain: GQuark, code: gint, format: [*c]const u8, ...) void;
pub extern fn g_simple_async_report_gerror_in_idle(object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, @"error": [*c]const GError) void;
pub extern fn g_simple_async_report_take_gerror_in_idle(object: [*c]GObject, callback: GAsyncReadyCallback, user_data: gpointer, @"error": [*c]GError) void;
pub extern fn g_simple_io_stream_get_type() GType;
pub extern fn g_simple_io_stream_new(input_stream: [*c]GInputStream, output_stream: [*c]GOutputStream) [*c]GIOStream;
pub extern fn g_simple_permission_get_type() GType;
pub extern fn g_simple_permission_new(allowed: gboolean) [*c]GPermission;
pub const struct__GSocketClientClass = extern struct {
    parent_class: GObjectClass,
    event: ?extern fn ([*c]GSocketClient, GSocketClientEvent, ?*GSocketConnectable, [*c]GIOStream) void,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
};
pub const GSocketClientClass = struct__GSocketClientClass;
pub extern fn g_socket_client_get_type() GType;
pub extern fn g_socket_client_new() [*c]GSocketClient;
pub extern fn g_socket_client_get_family(client: [*c]GSocketClient) GSocketFamily;
pub extern fn g_socket_client_set_family(client: [*c]GSocketClient, family: GSocketFamily) void;
pub extern fn g_socket_client_get_socket_type(client: [*c]GSocketClient) GSocketType;
pub extern fn g_socket_client_set_socket_type(client: [*c]GSocketClient, type_0: GSocketType) void;
pub extern fn g_socket_client_get_protocol(client: [*c]GSocketClient) GSocketProtocol;
pub extern fn g_socket_client_set_protocol(client: [*c]GSocketClient, protocol: GSocketProtocol) void;
pub extern fn g_socket_client_get_local_address(client: [*c]GSocketClient) [*c]GSocketAddress;
pub extern fn g_socket_client_set_local_address(client: [*c]GSocketClient, address: [*c]GSocketAddress) void;
pub extern fn g_socket_client_get_timeout(client: [*c]GSocketClient) guint;
pub extern fn g_socket_client_set_timeout(client: [*c]GSocketClient, timeout: guint) void;
pub extern fn g_socket_client_get_enable_proxy(client: [*c]GSocketClient) gboolean;
pub extern fn g_socket_client_set_enable_proxy(client: [*c]GSocketClient, enable: gboolean) void;
pub extern fn g_socket_client_get_tls(client: [*c]GSocketClient) gboolean;
pub extern fn g_socket_client_set_tls(client: [*c]GSocketClient, tls: gboolean) void;
pub extern fn g_socket_client_get_tls_validation_flags(client: [*c]GSocketClient) GTlsCertificateFlags;
pub extern fn g_socket_client_set_tls_validation_flags(client: [*c]GSocketClient, flags: GTlsCertificateFlags) void;
pub extern fn g_socket_client_get_proxy_resolver(client: [*c]GSocketClient) ?*GProxyResolver;
pub extern fn g_socket_client_set_proxy_resolver(client: [*c]GSocketClient, proxy_resolver: ?*GProxyResolver) void;
pub extern fn g_socket_client_connect(client: [*c]GSocketClient, connectable: ?*GSocketConnectable, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_to_host(client: [*c]GSocketClient, host_and_port: [*c]const gchar, default_port: guint16, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_to_service(client: [*c]GSocketClient, domain: [*c]const gchar, service: [*c]const gchar, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_to_uri(client: [*c]GSocketClient, uri: [*c]const gchar, default_port: guint16, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_async(client: [*c]GSocketClient, connectable: ?*GSocketConnectable, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_client_connect_finish(client: [*c]GSocketClient, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_to_host_async(client: [*c]GSocketClient, host_and_port: [*c]const gchar, default_port: guint16, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_client_connect_to_host_finish(client: [*c]GSocketClient, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_to_service_async(client: [*c]GSocketClient, domain: [*c]const gchar, service: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_client_connect_to_service_finish(client: [*c]GSocketClient, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GSocketConnection;
pub extern fn g_socket_client_connect_to_uri_async(client: [*c]GSocketClient, uri: [*c]const gchar, default_port: guint16, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_client_connect_to_uri_finish(client: [*c]GSocketClient, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GSocketConnection;
pub extern fn g_socket_client_add_application_proxy(client: [*c]GSocketClient, protocol: [*c]const gchar) void;
pub const struct__GSocketConnectableIface = extern struct {
    g_iface: GTypeInterface,
    enumerate: ?extern fn (?*GSocketConnectable) [*c]GSocketAddressEnumerator,
    proxy_enumerate: ?extern fn (?*GSocketConnectable) [*c]GSocketAddressEnumerator,
    to_string: ?extern fn (?*GSocketConnectable) [*c]gchar,
};
pub const GSocketConnectableIface = struct__GSocketConnectableIface;
pub extern fn g_socket_connectable_get_type() GType;
pub extern fn g_socket_connectable_enumerate(connectable: ?*GSocketConnectable) [*c]GSocketAddressEnumerator;
pub extern fn g_socket_connectable_proxy_enumerate(connectable: ?*GSocketConnectable) [*c]GSocketAddressEnumerator;
pub extern fn g_socket_connectable_to_string(connectable: ?*GSocketConnectable) [*c]gchar;
pub const struct__GSocketClass = extern struct {
    parent_class: GObjectClass,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
    _g_reserved6: ?extern fn () void,
    _g_reserved7: ?extern fn () void,
    _g_reserved8: ?extern fn () void,
    _g_reserved9: ?extern fn () void,
    _g_reserved10: ?extern fn () void,
};
pub const GSocketClass = struct__GSocketClass;
pub extern fn g_socket_get_type() GType;
pub extern fn g_socket_new(family: GSocketFamily, type_0: GSocketType, protocol: GSocketProtocol, @"error": [*c]([*c]GError)) [*c]GSocket;
pub extern fn g_socket_new_from_fd(fd: gint, @"error": [*c]([*c]GError)) [*c]GSocket;
pub extern fn g_socket_get_fd(socket: [*c]GSocket) c_int;
pub extern fn g_socket_get_family(socket: [*c]GSocket) GSocketFamily;
pub extern fn g_socket_get_socket_type(socket: [*c]GSocket) GSocketType;
pub extern fn g_socket_get_protocol(socket: [*c]GSocket) GSocketProtocol;
pub extern fn g_socket_get_local_address(socket: [*c]GSocket, @"error": [*c]([*c]GError)) [*c]GSocketAddress;
pub extern fn g_socket_get_remote_address(socket: [*c]GSocket, @"error": [*c]([*c]GError)) [*c]GSocketAddress;
pub extern fn g_socket_set_blocking(socket: [*c]GSocket, blocking: gboolean) void;
pub extern fn g_socket_get_blocking(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_set_keepalive(socket: [*c]GSocket, keepalive: gboolean) void;
pub extern fn g_socket_get_keepalive(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_get_listen_backlog(socket: [*c]GSocket) gint;
pub extern fn g_socket_set_listen_backlog(socket: [*c]GSocket, backlog: gint) void;
pub extern fn g_socket_get_timeout(socket: [*c]GSocket) guint;
pub extern fn g_socket_set_timeout(socket: [*c]GSocket, timeout: guint) void;
pub extern fn g_socket_get_ttl(socket: [*c]GSocket) guint;
pub extern fn g_socket_set_ttl(socket: [*c]GSocket, ttl: guint) void;
pub extern fn g_socket_get_broadcast(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_set_broadcast(socket: [*c]GSocket, broadcast: gboolean) void;
pub extern fn g_socket_get_multicast_loopback(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_set_multicast_loopback(socket: [*c]GSocket, loopback: gboolean) void;
pub extern fn g_socket_get_multicast_ttl(socket: [*c]GSocket) guint;
pub extern fn g_socket_set_multicast_ttl(socket: [*c]GSocket, ttl: guint) void;
pub extern fn g_socket_is_connected(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_bind(socket: [*c]GSocket, address: [*c]GSocketAddress, allow_reuse: gboolean, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_join_multicast_group(socket: [*c]GSocket, group: [*c]GInetAddress, source_specific: gboolean, iface: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_leave_multicast_group(socket: [*c]GSocket, group: [*c]GInetAddress, source_specific: gboolean, iface: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_join_multicast_group_ssm(socket: [*c]GSocket, group: [*c]GInetAddress, source_specific: [*c]GInetAddress, iface: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_leave_multicast_group_ssm(socket: [*c]GSocket, group: [*c]GInetAddress, source_specific: [*c]GInetAddress, iface: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_connect(socket: [*c]GSocket, address: [*c]GSocketAddress, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_check_connect_result(socket: [*c]GSocket, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_get_available_bytes(socket: [*c]GSocket) gssize;
pub extern fn g_socket_condition_check(socket: [*c]GSocket, condition: GIOCondition) GIOCondition;
pub extern fn g_socket_condition_wait(socket: [*c]GSocket, condition: GIOCondition, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_condition_timed_wait(socket: [*c]GSocket, condition: GIOCondition, timeout_us: gint64, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_accept(socket: [*c]GSocket, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GSocket;
pub extern fn g_socket_listen(socket: [*c]GSocket, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_receive(socket: [*c]GSocket, buffer: [*c]gchar, size: gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_socket_receive_from(socket: [*c]GSocket, address: [*c]([*c]GSocketAddress), buffer: [*c]gchar, size: gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_socket_send(socket: [*c]GSocket, buffer: [*c]const gchar, size: gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_socket_send_to(socket: [*c]GSocket, address: [*c]GSocketAddress, buffer: [*c]const gchar, size: gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_socket_receive_message(socket: [*c]GSocket, address: [*c]([*c]GSocketAddress), vectors: [*c]GInputVector, num_vectors: gint, messages: [*c]([*c]([*c]GSocketControlMessage)), num_messages: [*c]gint, flags: [*c]gint, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_socket_send_message(socket: [*c]GSocket, address: [*c]GSocketAddress, vectors: [*c]GOutputVector, num_vectors: gint, messages: [*c]([*c]GSocketControlMessage), num_messages: gint, flags: gint, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_socket_receive_messages(socket: [*c]GSocket, messages: [*c]GInputMessage, num_messages: guint, flags: gint, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gint;
pub extern fn g_socket_send_messages(socket: [*c]GSocket, messages: [*c]GOutputMessage, num_messages: guint, flags: gint, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gint;
pub extern fn g_socket_close(socket: [*c]GSocket, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_shutdown(socket: [*c]GSocket, shutdown_read: gboolean, shutdown_write: gboolean, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_is_closed(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_create_source(socket: [*c]GSocket, condition: GIOCondition, cancellable: [*c]GCancellable) [*c]GSource;
pub extern fn g_socket_speaks_ipv4(socket: [*c]GSocket) gboolean;
pub extern fn g_socket_get_credentials(socket: [*c]GSocket, @"error": [*c]([*c]GError)) ?*GCredentials;
pub extern fn g_socket_receive_with_blocking(socket: [*c]GSocket, buffer: [*c]gchar, size: gsize, blocking: gboolean, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_socket_send_with_blocking(socket: [*c]GSocket, buffer: [*c]const gchar, size: gsize, blocking: gboolean, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_socket_send_message_with_timeout(socket: [*c]GSocket, address: [*c]GSocketAddress, vectors: [*c]const GOutputVector, num_vectors: gint, messages: [*c]([*c]GSocketControlMessage), num_messages: gint, flags: gint, timeout_us: gint64, bytes_written: [*c]gsize, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) GPollableReturn;
pub extern fn g_socket_get_option(socket: [*c]GSocket, level: gint, optname: gint, value: [*c]gint, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_set_option(socket: [*c]GSocket, level: gint, optname: gint, value: gint, @"error": [*c]([*c]GError)) gboolean;
pub const struct__GSocketConnectionClass = extern struct {
    parent_class: GIOStreamClass,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
    _g_reserved6: ?extern fn () void,
};
pub const GSocketConnectionClass = struct__GSocketConnectionClass;
pub extern fn g_socket_connection_get_type() GType;
pub extern fn g_socket_connection_is_connected(connection: [*c]GSocketConnection) gboolean;
pub extern fn g_socket_connection_connect(connection: [*c]GSocketConnection, address: [*c]GSocketAddress, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_connection_connect_async(connection: [*c]GSocketConnection, address: [*c]GSocketAddress, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_connection_connect_finish(connection: [*c]GSocketConnection, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_connection_get_socket(connection: [*c]GSocketConnection) [*c]GSocket;
pub extern fn g_socket_connection_get_local_address(connection: [*c]GSocketConnection, @"error": [*c]([*c]GError)) [*c]GSocketAddress;
pub extern fn g_socket_connection_get_remote_address(connection: [*c]GSocketConnection, @"error": [*c]([*c]GError)) [*c]GSocketAddress;
pub extern fn g_socket_connection_factory_register_type(g_type: GType, family: GSocketFamily, type_0: GSocketType, protocol: gint) void;
pub extern fn g_socket_connection_factory_lookup_type(family: GSocketFamily, type_0: GSocketType, protocol_id: gint) GType;
pub extern fn g_socket_connection_factory_create_connection(socket: [*c]GSocket) [*c]GSocketConnection;
pub const struct__GSocketControlMessageClass = extern struct {
    parent_class: GObjectClass,
    get_size: ?extern fn ([*c]GSocketControlMessage) gsize,
    get_level: ?extern fn ([*c]GSocketControlMessage) c_int,
    get_type: ?extern fn ([*c]GSocketControlMessage) c_int,
    serialize: ?extern fn ([*c]GSocketControlMessage, gpointer) void,
    deserialize: ?extern fn (c_int, c_int, gsize, gpointer) [*c]GSocketControlMessage,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GSocketControlMessageClass = struct__GSocketControlMessageClass;
pub extern fn g_socket_control_message_get_type() GType;
pub extern fn g_socket_control_message_get_size(message: [*c]GSocketControlMessage) gsize;
pub extern fn g_socket_control_message_get_level(message: [*c]GSocketControlMessage) c_int;
pub extern fn g_socket_control_message_get_msg_type(message: [*c]GSocketControlMessage) c_int;
pub extern fn g_socket_control_message_serialize(message: [*c]GSocketControlMessage, data: gpointer) void;
pub extern fn g_socket_control_message_deserialize(level: c_int, type_0: c_int, size: gsize, data: gpointer) [*c]GSocketControlMessage;
pub const struct__GSocketListenerClass = extern struct {
    parent_class: GObjectClass,
    changed: ?extern fn ([*c]GSocketListener) void,
    event: ?extern fn ([*c]GSocketListener, GSocketListenerEvent, [*c]GSocket) void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
    _g_reserved6: ?extern fn () void,
};
pub const GSocketListenerClass = struct__GSocketListenerClass;
pub extern fn g_socket_listener_get_type() GType;
pub extern fn g_socket_listener_new() [*c]GSocketListener;
pub extern fn g_socket_listener_set_backlog(listener: [*c]GSocketListener, listen_backlog: c_int) void;
pub extern fn g_socket_listener_add_socket(listener: [*c]GSocketListener, socket: [*c]GSocket, source_object: [*c]GObject, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_listener_add_address(listener: [*c]GSocketListener, address: [*c]GSocketAddress, type_0: GSocketType, protocol: GSocketProtocol, source_object: [*c]GObject, effective_address: [*c]([*c]GSocketAddress), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_listener_add_inet_port(listener: [*c]GSocketListener, port: guint16, source_object: [*c]GObject, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_socket_listener_add_any_inet_port(listener: [*c]GSocketListener, source_object: [*c]GObject, @"error": [*c]([*c]GError)) guint16;
pub extern fn g_socket_listener_accept_socket(listener: [*c]GSocketListener, source_object: [*c]([*c]GObject), cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GSocket;
pub extern fn g_socket_listener_accept_socket_async(listener: [*c]GSocketListener, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_listener_accept_socket_finish(listener: [*c]GSocketListener, result: ?*GAsyncResult, source_object: [*c]([*c]GObject), @"error": [*c]([*c]GError)) [*c]GSocket;
pub extern fn g_socket_listener_accept(listener: [*c]GSocketListener, source_object: [*c]([*c]GObject), cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GSocketConnection;
pub extern fn g_socket_listener_accept_async(listener: [*c]GSocketListener, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_socket_listener_accept_finish(listener: [*c]GSocketListener, result: ?*GAsyncResult, source_object: [*c]([*c]GObject), @"error": [*c]([*c]GError)) [*c]GSocketConnection;
pub extern fn g_socket_listener_close(listener: [*c]GSocketListener) void;
pub const struct__GSocketServiceClass = extern struct {
    parent_class: GSocketListenerClass,
    incoming: ?extern fn ([*c]GSocketService, [*c]GSocketConnection, [*c]GObject) gboolean,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
    _g_reserved6: ?extern fn () void,
};
pub const GSocketServiceClass = struct__GSocketServiceClass;
pub extern fn g_socket_service_get_type() GType;
pub extern fn g_socket_service_new() [*c]GSocketService;
pub extern fn g_socket_service_start(service: [*c]GSocketService) void;
pub extern fn g_socket_service_stop(service: [*c]GSocketService) void;
pub extern fn g_socket_service_is_active(service: [*c]GSocketService) gboolean;
pub extern fn g_srv_target_get_type() GType;
pub extern fn g_srv_target_new(hostname: [*c]const gchar, port: guint16, priority: guint16, weight: guint16) ?*GSrvTarget;
pub extern fn g_srv_target_copy(target: ?*GSrvTarget) ?*GSrvTarget;
pub extern fn g_srv_target_free(target: ?*GSrvTarget) void;
pub extern fn g_srv_target_get_hostname(target: ?*GSrvTarget) [*c]const gchar;
pub extern fn g_srv_target_get_port(target: ?*GSrvTarget) guint16;
pub extern fn g_srv_target_get_priority(target: ?*GSrvTarget) guint16;
pub extern fn g_srv_target_get_weight(target: ?*GSrvTarget) guint16;
pub extern fn g_srv_target_list_sort(targets: [*c]GList) [*c]GList;
pub const struct__GSimpleProxyResolverPrivate = @OpaqueType();
pub const GSimpleProxyResolverPrivate = struct__GSimpleProxyResolverPrivate;
pub const struct__GSimpleProxyResolver = extern struct {
    parent_instance: GObject,
    priv: ?*GSimpleProxyResolverPrivate,
};
pub const GSimpleProxyResolver = struct__GSimpleProxyResolver;
pub const struct__GSimpleProxyResolverClass = extern struct {
    parent_class: GObjectClass,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GSimpleProxyResolverClass = struct__GSimpleProxyResolverClass;
pub extern fn g_simple_proxy_resolver_get_type() GType;
pub extern fn g_simple_proxy_resolver_new(default_proxy: [*c]const gchar, ignore_hosts: [*c]([*c]gchar)) ?*GProxyResolver;
pub extern fn g_simple_proxy_resolver_set_default_proxy(resolver: [*c]GSimpleProxyResolver, default_proxy: [*c]const gchar) void;
pub extern fn g_simple_proxy_resolver_set_ignore_hosts(resolver: [*c]GSimpleProxyResolver, ignore_hosts: [*c]([*c]gchar)) void;
pub extern fn g_simple_proxy_resolver_set_uri_proxy(resolver: [*c]GSimpleProxyResolver, uri_scheme: [*c]const gchar, proxy: [*c]const gchar) void;
pub const struct__GTaskClass = @OpaqueType();
pub const GTaskClass = struct__GTaskClass;
pub extern fn g_task_get_type() GType;
pub extern fn g_task_new(source_object: gpointer, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, callback_data: gpointer) ?*GTask;
pub extern fn g_task_report_error(source_object: gpointer, callback: GAsyncReadyCallback, callback_data: gpointer, source_tag: gpointer, @"error": [*c]GError) void;
pub extern fn g_task_report_new_error(source_object: gpointer, callback: GAsyncReadyCallback, callback_data: gpointer, source_tag: gpointer, domain: GQuark, code: gint, format: [*c]const u8, ...) void;
pub extern fn g_task_set_task_data(task: ?*GTask, task_data: gpointer, task_data_destroy: GDestroyNotify) void;
pub extern fn g_task_set_priority(task: ?*GTask, priority: gint) void;
pub extern fn g_task_set_check_cancellable(task: ?*GTask, check_cancellable: gboolean) void;
pub extern fn g_task_set_source_tag(task: ?*GTask, source_tag: gpointer) void;
pub extern fn g_task_set_name(task: ?*GTask, name: [*c]const gchar) void;
pub extern fn g_task_get_source_object(task: ?*GTask) gpointer;
pub extern fn g_task_get_task_data(task: ?*GTask) gpointer;
pub extern fn g_task_get_priority(task: ?*GTask) gint;
pub extern fn g_task_get_context(task: ?*GTask) ?*GMainContext;
pub extern fn g_task_get_cancellable(task: ?*GTask) [*c]GCancellable;
pub extern fn g_task_get_check_cancellable(task: ?*GTask) gboolean;
pub extern fn g_task_get_source_tag(task: ?*GTask) gpointer;
pub extern fn g_task_get_name(task: ?*GTask) [*c]const gchar;
pub extern fn g_task_is_valid(result: gpointer, source_object: gpointer) gboolean;
pub const GTaskThreadFunc = ?extern fn (?*GTask, gpointer, gpointer, [*c]GCancellable) void;
pub extern fn g_task_run_in_thread(task: ?*GTask, task_func: GTaskThreadFunc) void;
pub extern fn g_task_run_in_thread_sync(task: ?*GTask, task_func: GTaskThreadFunc) void;
pub extern fn g_task_set_return_on_cancel(task: ?*GTask, return_on_cancel: gboolean) gboolean;
pub extern fn g_task_get_return_on_cancel(task: ?*GTask) gboolean;
pub extern fn g_task_attach_source(task: ?*GTask, source: [*c]GSource, callback: GSourceFunc) void;
pub extern fn g_task_return_pointer(task: ?*GTask, result: gpointer, result_destroy: GDestroyNotify) void;
pub extern fn g_task_return_boolean(task: ?*GTask, result: gboolean) void;
pub extern fn g_task_return_int(task: ?*GTask, result: gssize) void;
pub extern fn g_task_return_error(task: ?*GTask, @"error": [*c]GError) void;
pub extern fn g_task_return_new_error(task: ?*GTask, domain: GQuark, code: gint, format: [*c]const u8, ...) void;
pub extern fn g_task_return_error_if_cancelled(task: ?*GTask) gboolean;
pub extern fn g_task_propagate_pointer(task: ?*GTask, @"error": [*c]([*c]GError)) gpointer;
pub extern fn g_task_propagate_boolean(task: ?*GTask, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_task_propagate_int(task: ?*GTask, @"error": [*c]([*c]GError)) gssize;
pub extern fn g_task_had_error(task: ?*GTask) gboolean;
pub extern fn g_task_get_completed(task: ?*GTask) gboolean;
pub extern fn g_subprocess_get_type() GType;
pub extern fn g_subprocess_new(flags: GSubprocessFlags, @"error": [*c]([*c]GError), argv0: [*c]const gchar, ...) ?*GSubprocess;
pub extern fn g_subprocess_newv(argv: [*c]const ([*c]const gchar), flags: GSubprocessFlags, @"error": [*c]([*c]GError)) ?*GSubprocess;
pub extern fn g_subprocess_get_stdin_pipe(subprocess: ?*GSubprocess) [*c]GOutputStream;
pub extern fn g_subprocess_get_stdout_pipe(subprocess: ?*GSubprocess) [*c]GInputStream;
pub extern fn g_subprocess_get_stderr_pipe(subprocess: ?*GSubprocess) [*c]GInputStream;
pub extern fn g_subprocess_get_identifier(subprocess: ?*GSubprocess) [*c]const gchar;
pub extern fn g_subprocess_force_exit(subprocess: ?*GSubprocess) void;
pub extern fn g_subprocess_wait(subprocess: ?*GSubprocess, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_subprocess_wait_async(subprocess: ?*GSubprocess, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_subprocess_wait_finish(subprocess: ?*GSubprocess, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_subprocess_wait_check(subprocess: ?*GSubprocess, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_subprocess_wait_check_async(subprocess: ?*GSubprocess, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_subprocess_wait_check_finish(subprocess: ?*GSubprocess, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_subprocess_get_status(subprocess: ?*GSubprocess) gint;
pub extern fn g_subprocess_get_successful(subprocess: ?*GSubprocess) gboolean;
pub extern fn g_subprocess_get_if_exited(subprocess: ?*GSubprocess) gboolean;
pub extern fn g_subprocess_get_exit_status(subprocess: ?*GSubprocess) gint;
pub extern fn g_subprocess_get_if_signaled(subprocess: ?*GSubprocess) gboolean;
pub extern fn g_subprocess_get_term_sig(subprocess: ?*GSubprocess) gint;
pub extern fn g_subprocess_communicate(subprocess: ?*GSubprocess, stdin_buf: ?*GBytes, cancellable: [*c]GCancellable, stdout_buf: [*c](?*GBytes), stderr_buf: [*c](?*GBytes), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_subprocess_communicate_async(subprocess: ?*GSubprocess, stdin_buf: ?*GBytes, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_subprocess_communicate_finish(subprocess: ?*GSubprocess, result: ?*GAsyncResult, stdout_buf: [*c](?*GBytes), stderr_buf: [*c](?*GBytes), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_subprocess_communicate_utf8(subprocess: ?*GSubprocess, stdin_buf: [*c]const u8, cancellable: [*c]GCancellable, stdout_buf: [*c]([*c]u8), stderr_buf: [*c]([*c]u8), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_subprocess_communicate_utf8_async(subprocess: ?*GSubprocess, stdin_buf: [*c]const u8, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_subprocess_communicate_utf8_finish(subprocess: ?*GSubprocess, result: ?*GAsyncResult, stdout_buf: [*c]([*c]u8), stderr_buf: [*c]([*c]u8), @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_subprocess_launcher_get_type() GType;
pub extern fn g_subprocess_launcher_new(flags: GSubprocessFlags) ?*GSubprocessLauncher;
pub extern fn g_subprocess_launcher_spawn(self: ?*GSubprocessLauncher, @"error": [*c]([*c]GError), argv0: [*c]const gchar, ...) ?*GSubprocess;
pub extern fn g_subprocess_launcher_spawnv(self: ?*GSubprocessLauncher, argv: [*c]const ([*c]const gchar), @"error": [*c]([*c]GError)) ?*GSubprocess;
pub extern fn g_subprocess_launcher_set_environ(self: ?*GSubprocessLauncher, env: [*c]([*c]gchar)) void;
pub extern fn g_subprocess_launcher_setenv(self: ?*GSubprocessLauncher, variable: [*c]const gchar, value: [*c]const gchar, overwrite: gboolean) void;
pub extern fn g_subprocess_launcher_unsetenv(self: ?*GSubprocessLauncher, variable: [*c]const gchar) void;
pub extern fn g_subprocess_launcher_getenv(self: ?*GSubprocessLauncher, variable: [*c]const gchar) [*c]const gchar;
pub extern fn g_subprocess_launcher_set_cwd(self: ?*GSubprocessLauncher, cwd: [*c]const gchar) void;
pub extern fn g_subprocess_launcher_set_flags(self: ?*GSubprocessLauncher, flags: GSubprocessFlags) void;
pub const struct__GTcpConnectionClass = extern struct {
    parent_class: GSocketConnectionClass,
};
pub const GTcpConnectionClass = struct__GTcpConnectionClass;
pub extern fn g_tcp_connection_get_type() GType;
pub extern fn g_tcp_connection_set_graceful_disconnect(connection: [*c]GTcpConnection, graceful_disconnect: gboolean) void;
pub extern fn g_tcp_connection_get_graceful_disconnect(connection: [*c]GTcpConnection) gboolean;
pub const struct__GTcpWrapperConnectionClass = extern struct {
    parent_class: GTcpConnectionClass,
};
pub const GTcpWrapperConnectionClass = struct__GTcpWrapperConnectionClass;
pub extern fn g_tcp_wrapper_connection_get_type() GType;
pub extern fn g_tcp_wrapper_connection_new(base_io_stream: [*c]GIOStream, socket: [*c]GSocket) [*c]GSocketConnection;
pub extern fn g_tcp_wrapper_connection_get_base_io_stream(conn: [*c]GTcpWrapperConnection) [*c]GIOStream;
pub extern fn g_test_dbus_get_type() GType;
pub extern fn g_test_dbus_new(flags: GTestDBusFlags) ?*GTestDBus;
pub extern fn g_test_dbus_get_flags(self: ?*GTestDBus) GTestDBusFlags;
pub extern fn g_test_dbus_get_bus_address(self: ?*GTestDBus) [*c]const gchar;
pub extern fn g_test_dbus_add_service_dir(self: ?*GTestDBus, path: [*c]const gchar) void;
pub extern fn g_test_dbus_up(self: ?*GTestDBus) void;
pub extern fn g_test_dbus_stop(self: ?*GTestDBus) void;
pub extern fn g_test_dbus_down(self: ?*GTestDBus) void;
pub extern fn g_test_dbus_unset() void;
pub const struct__GThemedIconClass = @OpaqueType();
pub const GThemedIconClass = struct__GThemedIconClass;
pub extern fn g_themed_icon_get_type() GType;
pub extern fn g_themed_icon_new(iconname: [*c]const u8) ?*GIcon;
pub extern fn g_themed_icon_new_with_default_fallbacks(iconname: [*c]const u8) ?*GIcon;
pub extern fn g_themed_icon_new_from_names(iconnames: [*c]([*c]u8), len: c_int) ?*GIcon;
pub extern fn g_themed_icon_prepend_name(icon: ?*GThemedIcon, iconname: [*c]const u8) void;
pub extern fn g_themed_icon_append_name(icon: ?*GThemedIcon, iconname: [*c]const u8) void;
pub extern fn g_themed_icon_get_names(icon: ?*GThemedIcon) [*c]const ([*c]const gchar);
pub const struct__GThreadedSocketServiceClass = extern struct {
    parent_class: GSocketServiceClass,
    run: ?extern fn ([*c]GThreadedSocketService, [*c]GSocketConnection, [*c]GObject) gboolean,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
};
pub const GThreadedSocketServiceClass = struct__GThreadedSocketServiceClass;
pub extern fn g_threaded_socket_service_get_type() GType;
pub extern fn g_threaded_socket_service_new(max_threads: c_int) [*c]GSocketService;
pub const struct__GTlsBackend = @OpaqueType();
pub const GTlsBackend = struct__GTlsBackend;
pub const struct__GTlsBackendInterface = extern struct {
    g_iface: GTypeInterface,
    supports_tls: ?extern fn (?*GTlsBackend) gboolean,
    get_certificate_type: ?extern fn () GType,
    get_client_connection_type: ?extern fn () GType,
    get_server_connection_type: ?extern fn () GType,
    get_file_database_type: ?extern fn () GType,
    get_default_database: ?extern fn (?*GTlsBackend) [*c]GTlsDatabase,
    supports_dtls: ?extern fn (?*GTlsBackend) gboolean,
    get_dtls_client_connection_type: ?extern fn () GType,
    get_dtls_server_connection_type: ?extern fn () GType,
};
pub const GTlsBackendInterface = struct__GTlsBackendInterface;
pub extern fn g_tls_backend_get_type() GType;
pub extern fn g_tls_backend_get_default() ?*GTlsBackend;
pub extern fn g_tls_backend_get_default_database(backend: ?*GTlsBackend) [*c]GTlsDatabase;
pub extern fn g_tls_backend_set_default_database(backend: ?*GTlsBackend, database: [*c]GTlsDatabase) void;
pub extern fn g_tls_backend_supports_tls(backend: ?*GTlsBackend) gboolean;
pub extern fn g_tls_backend_supports_dtls(backend: ?*GTlsBackend) gboolean;
pub extern fn g_tls_backend_get_certificate_type(backend: ?*GTlsBackend) GType;
pub extern fn g_tls_backend_get_client_connection_type(backend: ?*GTlsBackend) GType;
pub extern fn g_tls_backend_get_server_connection_type(backend: ?*GTlsBackend) GType;
pub extern fn g_tls_backend_get_file_database_type(backend: ?*GTlsBackend) GType;
pub extern fn g_tls_backend_get_dtls_client_connection_type(backend: ?*GTlsBackend) GType;
pub extern fn g_tls_backend_get_dtls_server_connection_type(backend: ?*GTlsBackend) GType;
pub const struct__GTlsCertificateClass = extern struct {
    parent_class: GObjectClass,
    verify: ?extern fn ([*c]GTlsCertificate, ?*GSocketConnectable, [*c]GTlsCertificate) GTlsCertificateFlags,
    padding: [8]gpointer,
};
pub const GTlsCertificateClass = struct__GTlsCertificateClass;
pub extern fn g_tls_certificate_get_type() GType;
pub extern fn g_tls_certificate_new_from_pem(data: [*c]const gchar, length: gssize, @"error": [*c]([*c]GError)) [*c]GTlsCertificate;
pub extern fn g_tls_certificate_new_from_file(file: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]GTlsCertificate;
pub extern fn g_tls_certificate_new_from_files(cert_file: [*c]const gchar, key_file: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]GTlsCertificate;
pub extern fn g_tls_certificate_list_new_from_file(file: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]GList;
pub extern fn g_tls_certificate_get_issuer(cert: [*c]GTlsCertificate) [*c]GTlsCertificate;
pub extern fn g_tls_certificate_verify(cert: [*c]GTlsCertificate, identity: ?*GSocketConnectable, trusted_ca: [*c]GTlsCertificate) GTlsCertificateFlags;
pub extern fn g_tls_certificate_is_same(cert_one: [*c]GTlsCertificate, cert_two: [*c]GTlsCertificate) gboolean;
pub const struct__GTlsConnectionClass = extern struct {
    parent_class: GIOStreamClass,
    accept_certificate: ?extern fn ([*c]GTlsConnection, [*c]GTlsCertificate, GTlsCertificateFlags) gboolean,
    handshake: ?extern fn ([*c]GTlsConnection, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    handshake_async: ?extern fn ([*c]GTlsConnection, c_int, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    handshake_finish: ?extern fn ([*c]GTlsConnection, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    padding: [8]gpointer,
};
pub const GTlsConnectionClass = struct__GTlsConnectionClass;
pub extern fn g_tls_connection_get_type() GType;
pub extern fn g_tls_connection_set_use_system_certdb(conn: [*c]GTlsConnection, use_system_certdb: gboolean) void;
pub extern fn g_tls_connection_get_use_system_certdb(conn: [*c]GTlsConnection) gboolean;
pub extern fn g_tls_connection_set_database(conn: [*c]GTlsConnection, database: [*c]GTlsDatabase) void;
pub extern fn g_tls_connection_get_database(conn: [*c]GTlsConnection) [*c]GTlsDatabase;
pub extern fn g_tls_connection_set_certificate(conn: [*c]GTlsConnection, certificate: [*c]GTlsCertificate) void;
pub extern fn g_tls_connection_get_certificate(conn: [*c]GTlsConnection) [*c]GTlsCertificate;
pub extern fn g_tls_connection_set_interaction(conn: [*c]GTlsConnection, interaction: [*c]GTlsInteraction) void;
pub extern fn g_tls_connection_get_interaction(conn: [*c]GTlsConnection) [*c]GTlsInteraction;
pub extern fn g_tls_connection_get_peer_certificate(conn: [*c]GTlsConnection) [*c]GTlsCertificate;
pub extern fn g_tls_connection_get_peer_certificate_errors(conn: [*c]GTlsConnection) GTlsCertificateFlags;
pub extern fn g_tls_connection_set_require_close_notify(conn: [*c]GTlsConnection, require_close_notify: gboolean) void;
pub extern fn g_tls_connection_get_require_close_notify(conn: [*c]GTlsConnection) gboolean;
pub extern fn g_tls_connection_set_rehandshake_mode(conn: [*c]GTlsConnection, mode: GTlsRehandshakeMode) void;
pub extern fn g_tls_connection_get_rehandshake_mode(conn: [*c]GTlsConnection) GTlsRehandshakeMode;
pub extern fn g_tls_connection_set_advertised_protocols(conn: [*c]GTlsConnection, protocols: [*c]const ([*c]const gchar)) void;
pub extern fn g_tls_connection_get_negotiated_protocol(conn: [*c]GTlsConnection) [*c]const gchar;
pub extern fn g_tls_connection_handshake(conn: [*c]GTlsConnection, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_tls_connection_handshake_async(conn: [*c]GTlsConnection, io_priority: c_int, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_connection_handshake_finish(conn: [*c]GTlsConnection, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_tls_error_quark() GQuark;
pub extern fn g_tls_connection_emit_accept_certificate(conn: [*c]GTlsConnection, peer_cert: [*c]GTlsCertificate, errors: GTlsCertificateFlags) gboolean;
pub const struct__GTlsClientConnectionInterface = extern struct {
    g_iface: GTypeInterface,
    copy_session_state: ?extern fn (?*GTlsClientConnection, ?*GTlsClientConnection) void,
};
pub const GTlsClientConnectionInterface = struct__GTlsClientConnectionInterface;
pub extern fn g_tls_client_connection_get_type() GType;
pub extern fn g_tls_client_connection_new(base_io_stream: [*c]GIOStream, server_identity: ?*GSocketConnectable, @"error": [*c]([*c]GError)) [*c]GIOStream;
pub extern fn g_tls_client_connection_get_validation_flags(conn: ?*GTlsClientConnection) GTlsCertificateFlags;
pub extern fn g_tls_client_connection_set_validation_flags(conn: ?*GTlsClientConnection, flags: GTlsCertificateFlags) void;
pub extern fn g_tls_client_connection_get_server_identity(conn: ?*GTlsClientConnection) ?*GSocketConnectable;
pub extern fn g_tls_client_connection_set_server_identity(conn: ?*GTlsClientConnection, identity: ?*GSocketConnectable) void;
pub extern fn g_tls_client_connection_get_use_ssl3(conn: ?*GTlsClientConnection) gboolean;
pub extern fn g_tls_client_connection_set_use_ssl3(conn: ?*GTlsClientConnection, use_ssl3: gboolean) void;
pub extern fn g_tls_client_connection_get_accepted_cas(conn: ?*GTlsClientConnection) [*c]GList;
pub extern fn g_tls_client_connection_copy_session_state(conn: ?*GTlsClientConnection, source: ?*GTlsClientConnection) void;
pub const struct__GTlsDatabaseClass = extern struct {
    parent_class: GObjectClass,
    verify_chain: ?extern fn ([*c]GTlsDatabase, [*c]GTlsCertificate, [*c]const gchar, ?*GSocketConnectable, [*c]GTlsInteraction, GTlsDatabaseVerifyFlags, [*c]GCancellable, [*c]([*c]GError)) GTlsCertificateFlags,
    verify_chain_async: ?extern fn ([*c]GTlsDatabase, [*c]GTlsCertificate, [*c]const gchar, ?*GSocketConnectable, [*c]GTlsInteraction, GTlsDatabaseVerifyFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    verify_chain_finish: ?extern fn ([*c]GTlsDatabase, ?*GAsyncResult, [*c]([*c]GError)) GTlsCertificateFlags,
    create_certificate_handle: ?extern fn ([*c]GTlsDatabase, [*c]GTlsCertificate) [*c]gchar,
    lookup_certificate_for_handle: ?extern fn ([*c]GTlsDatabase, [*c]const gchar, [*c]GTlsInteraction, GTlsDatabaseLookupFlags, [*c]GCancellable, [*c]([*c]GError)) [*c]GTlsCertificate,
    lookup_certificate_for_handle_async: ?extern fn ([*c]GTlsDatabase, [*c]const gchar, [*c]GTlsInteraction, GTlsDatabaseLookupFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    lookup_certificate_for_handle_finish: ?extern fn ([*c]GTlsDatabase, ?*GAsyncResult, [*c]([*c]GError)) [*c]GTlsCertificate,
    lookup_certificate_issuer: ?extern fn ([*c]GTlsDatabase, [*c]GTlsCertificate, [*c]GTlsInteraction, GTlsDatabaseLookupFlags, [*c]GCancellable, [*c]([*c]GError)) [*c]GTlsCertificate,
    lookup_certificate_issuer_async: ?extern fn ([*c]GTlsDatabase, [*c]GTlsCertificate, [*c]GTlsInteraction, GTlsDatabaseLookupFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    lookup_certificate_issuer_finish: ?extern fn ([*c]GTlsDatabase, ?*GAsyncResult, [*c]([*c]GError)) [*c]GTlsCertificate,
    lookup_certificates_issued_by: ?extern fn ([*c]GTlsDatabase, [*c]GByteArray, [*c]GTlsInteraction, GTlsDatabaseLookupFlags, [*c]GCancellable, [*c]([*c]GError)) [*c]GList,
    lookup_certificates_issued_by_async: ?extern fn ([*c]GTlsDatabase, [*c]GByteArray, [*c]GTlsInteraction, GTlsDatabaseLookupFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    lookup_certificates_issued_by_finish: ?extern fn ([*c]GTlsDatabase, ?*GAsyncResult, [*c]([*c]GError)) [*c]GList,
    padding: [16]gpointer,
};
pub const GTlsDatabaseClass = struct__GTlsDatabaseClass;
pub extern fn g_tls_database_get_type() GType;
pub extern fn g_tls_database_verify_chain(self: [*c]GTlsDatabase, chain: [*c]GTlsCertificate, purpose: [*c]const gchar, identity: ?*GSocketConnectable, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseVerifyFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) GTlsCertificateFlags;
pub extern fn g_tls_database_verify_chain_async(self: [*c]GTlsDatabase, chain: [*c]GTlsCertificate, purpose: [*c]const gchar, identity: ?*GSocketConnectable, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseVerifyFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_database_verify_chain_finish(self: [*c]GTlsDatabase, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) GTlsCertificateFlags;
pub extern fn g_tls_database_create_certificate_handle(self: [*c]GTlsDatabase, certificate: [*c]GTlsCertificate) [*c]gchar;
pub extern fn g_tls_database_lookup_certificate_for_handle(self: [*c]GTlsDatabase, handle: [*c]const gchar, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GTlsCertificate;
pub extern fn g_tls_database_lookup_certificate_for_handle_async(self: [*c]GTlsDatabase, handle: [*c]const gchar, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_database_lookup_certificate_for_handle_finish(self: [*c]GTlsDatabase, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GTlsCertificate;
pub extern fn g_tls_database_lookup_certificate_issuer(self: [*c]GTlsDatabase, certificate: [*c]GTlsCertificate, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GTlsCertificate;
pub extern fn g_tls_database_lookup_certificate_issuer_async(self: [*c]GTlsDatabase, certificate: [*c]GTlsCertificate, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_database_lookup_certificate_issuer_finish(self: [*c]GTlsDatabase, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GTlsCertificate;
pub extern fn g_tls_database_lookup_certificates_issued_by(self: [*c]GTlsDatabase, issuer_raw_dn: [*c]GByteArray, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) [*c]GList;
pub extern fn g_tls_database_lookup_certificates_issued_by_async(self: [*c]GTlsDatabase, issuer_raw_dn: [*c]GByteArray, interaction: [*c]GTlsInteraction, flags: GTlsDatabaseLookupFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_database_lookup_certificates_issued_by_finish(self: [*c]GTlsDatabase, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) [*c]GList;
pub const struct__GTlsFileDatabaseInterface = extern struct {
    g_iface: GTypeInterface,
    padding: [8]gpointer,
};
pub const GTlsFileDatabaseInterface = struct__GTlsFileDatabaseInterface;
pub extern fn g_tls_file_database_get_type() GType;
pub extern fn g_tls_file_database_new(anchors: [*c]const gchar, @"error": [*c]([*c]GError)) [*c]GTlsDatabase;
pub const struct__GTlsInteractionClass = extern struct {
    parent_class: GObjectClass,
    ask_password: ?extern fn ([*c]GTlsInteraction, [*c]GTlsPassword, [*c]GCancellable, [*c]([*c]GError)) GTlsInteractionResult,
    ask_password_async: ?extern fn ([*c]GTlsInteraction, [*c]GTlsPassword, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    ask_password_finish: ?extern fn ([*c]GTlsInteraction, ?*GAsyncResult, [*c]([*c]GError)) GTlsInteractionResult,
    request_certificate: ?extern fn ([*c]GTlsInteraction, [*c]GTlsConnection, GTlsCertificateRequestFlags, [*c]GCancellable, [*c]([*c]GError)) GTlsInteractionResult,
    request_certificate_async: ?extern fn ([*c]GTlsInteraction, [*c]GTlsConnection, GTlsCertificateRequestFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    request_certificate_finish: ?extern fn ([*c]GTlsInteraction, ?*GAsyncResult, [*c]([*c]GError)) GTlsInteractionResult,
    padding: [21]gpointer,
};
pub const GTlsInteractionClass = struct__GTlsInteractionClass;
pub extern fn g_tls_interaction_get_type() GType;
pub extern fn g_tls_interaction_invoke_ask_password(interaction: [*c]GTlsInteraction, password: [*c]GTlsPassword, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) GTlsInteractionResult;
pub extern fn g_tls_interaction_ask_password(interaction: [*c]GTlsInteraction, password: [*c]GTlsPassword, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) GTlsInteractionResult;
pub extern fn g_tls_interaction_ask_password_async(interaction: [*c]GTlsInteraction, password: [*c]GTlsPassword, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_interaction_ask_password_finish(interaction: [*c]GTlsInteraction, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) GTlsInteractionResult;
pub extern fn g_tls_interaction_invoke_request_certificate(interaction: [*c]GTlsInteraction, connection: [*c]GTlsConnection, flags: GTlsCertificateRequestFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) GTlsInteractionResult;
pub extern fn g_tls_interaction_request_certificate(interaction: [*c]GTlsInteraction, connection: [*c]GTlsConnection, flags: GTlsCertificateRequestFlags, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) GTlsInteractionResult;
pub extern fn g_tls_interaction_request_certificate_async(interaction: [*c]GTlsInteraction, connection: [*c]GTlsConnection, flags: GTlsCertificateRequestFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_tls_interaction_request_certificate_finish(interaction: [*c]GTlsInteraction, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) GTlsInteractionResult;
pub const struct__GTlsServerConnectionInterface = extern struct {
    g_iface: GTypeInterface,
};
pub const GTlsServerConnectionInterface = struct__GTlsServerConnectionInterface;
pub extern fn g_tls_server_connection_get_type() GType;
pub extern fn g_tls_server_connection_new(base_io_stream: [*c]GIOStream, certificate: [*c]GTlsCertificate, @"error": [*c]([*c]GError)) [*c]GIOStream;
pub const struct__GTlsPasswordClass = extern struct {
    parent_class: GObjectClass,
    get_value: ?extern fn ([*c]GTlsPassword, [*c]gsize) [*c]const guchar,
    set_value: ?extern fn ([*c]GTlsPassword, [*c]guchar, gssize, GDestroyNotify) void,
    get_default_warning: ?extern fn ([*c]GTlsPassword) [*c]const gchar,
    padding: [4]gpointer,
};
pub const GTlsPasswordClass = struct__GTlsPasswordClass;
pub extern fn g_tls_password_get_type() GType;
pub extern fn g_tls_password_new(flags: GTlsPasswordFlags, description: [*c]const gchar) [*c]GTlsPassword;
pub extern fn g_tls_password_get_value(password: [*c]GTlsPassword, length: [*c]gsize) [*c]const guchar;
pub extern fn g_tls_password_set_value(password: [*c]GTlsPassword, value: [*c]const guchar, length: gssize) void;
pub extern fn g_tls_password_set_value_full(password: [*c]GTlsPassword, value: [*c]guchar, length: gssize, destroy: GDestroyNotify) void;
pub extern fn g_tls_password_get_flags(password: [*c]GTlsPassword) GTlsPasswordFlags;
pub extern fn g_tls_password_set_flags(password: [*c]GTlsPassword, flags: GTlsPasswordFlags) void;
pub extern fn g_tls_password_get_description(password: [*c]GTlsPassword) [*c]const gchar;
pub extern fn g_tls_password_set_description(password: [*c]GTlsPassword, description: [*c]const gchar) void;
pub extern fn g_tls_password_get_warning(password: [*c]GTlsPassword) [*c]const gchar;
pub extern fn g_tls_password_set_warning(password: [*c]GTlsPassword, warning: [*c]const gchar) void;
pub const GVfsFileLookupFunc = ?extern fn ([*c]GVfs, [*c]const u8, gpointer) ?*GFile;
pub const struct__GVfsClass = extern struct {
    parent_class: GObjectClass,
    is_active: ?extern fn ([*c]GVfs) gboolean,
    get_file_for_path: ?extern fn ([*c]GVfs, [*c]const u8) ?*GFile,
    get_file_for_uri: ?extern fn ([*c]GVfs, [*c]const u8) ?*GFile,
    get_supported_uri_schemes: ?extern fn ([*c]GVfs) [*c]const ([*c]const gchar),
    parse_name: ?extern fn ([*c]GVfs, [*c]const u8) ?*GFile,
    local_file_add_info: ?extern fn ([*c]GVfs, [*c]const u8, guint64, ?*GFileAttributeMatcher, ?*GFileInfo, [*c]GCancellable, [*c]gpointer, [*c]GDestroyNotify) void,
    add_writable_namespaces: ?extern fn ([*c]GVfs, [*c]GFileAttributeInfoList) void,
    local_file_set_attributes: ?extern fn ([*c]GVfs, [*c]const u8, ?*GFileInfo, GFileQueryInfoFlags, [*c]GCancellable, [*c]([*c]GError)) gboolean,
    local_file_removed: ?extern fn ([*c]GVfs, [*c]const u8) void,
    local_file_moved: ?extern fn ([*c]GVfs, [*c]const u8, [*c]const u8) void,
    deserialize_icon: ?extern fn ([*c]GVfs, ?*GVariant) ?*GIcon,
    _g_reserved1: ?extern fn () void,
    _g_reserved2: ?extern fn () void,
    _g_reserved3: ?extern fn () void,
    _g_reserved4: ?extern fn () void,
    _g_reserved5: ?extern fn () void,
    _g_reserved6: ?extern fn () void,
};
pub const GVfsClass = struct__GVfsClass;
pub extern fn g_vfs_get_type() GType;
pub extern fn g_vfs_is_active(vfs: [*c]GVfs) gboolean;
pub extern fn g_vfs_get_file_for_path(vfs: [*c]GVfs, path: [*c]const u8) ?*GFile;
pub extern fn g_vfs_get_file_for_uri(vfs: [*c]GVfs, uri: [*c]const u8) ?*GFile;
pub extern fn g_vfs_get_supported_uri_schemes(vfs: [*c]GVfs) [*c]const ([*c]const gchar);
pub extern fn g_vfs_parse_name(vfs: [*c]GVfs, parse_name: [*c]const u8) ?*GFile;
pub extern fn g_vfs_get_default() [*c]GVfs;
pub extern fn g_vfs_get_local() [*c]GVfs;
pub extern fn g_vfs_register_uri_scheme(vfs: [*c]GVfs, scheme: [*c]const u8, uri_func: GVfsFileLookupFunc, uri_data: gpointer, uri_destroy: GDestroyNotify, parse_name_func: GVfsFileLookupFunc, parse_name_data: gpointer, parse_name_destroy: GDestroyNotify) gboolean;
pub extern fn g_vfs_unregister_uri_scheme(vfs: [*c]GVfs, scheme: [*c]const u8) gboolean;
pub const struct__GVolumeIface = extern struct {
    g_iface: GTypeInterface,
    changed: ?extern fn (?*GVolume) void,
    removed: ?extern fn (?*GVolume) void,
    get_name: ?extern fn (?*GVolume) [*c]u8,
    get_icon: ?extern fn (?*GVolume) ?*GIcon,
    get_uuid: ?extern fn (?*GVolume) [*c]u8,
    get_drive: ?extern fn (?*GVolume) ?*GDrive,
    get_mount: ?extern fn (?*GVolume) ?*GMount,
    can_mount: ?extern fn (?*GVolume) gboolean,
    can_eject: ?extern fn (?*GVolume) gboolean,
    mount_fn: ?extern fn (?*GVolume, GMountMountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    mount_finish: ?extern fn (?*GVolume, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    eject: ?extern fn (?*GVolume, GMountUnmountFlags, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    eject_finish: ?extern fn (?*GVolume, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    get_identifier: ?extern fn (?*GVolume, [*c]const u8) [*c]u8,
    enumerate_identifiers: ?extern fn (?*GVolume) [*c]([*c]u8),
    should_automount: ?extern fn (?*GVolume) gboolean,
    get_activation_root: ?extern fn (?*GVolume) ?*GFile,
    eject_with_operation: ?extern fn (?*GVolume, GMountUnmountFlags, [*c]GMountOperation, [*c]GCancellable, GAsyncReadyCallback, gpointer) void,
    eject_with_operation_finish: ?extern fn (?*GVolume, ?*GAsyncResult, [*c]([*c]GError)) gboolean,
    get_sort_key: ?extern fn (?*GVolume) [*c]const gchar,
    get_symbolic_icon: ?extern fn (?*GVolume) ?*GIcon,
};
pub const GVolumeIface = struct__GVolumeIface;
pub extern fn g_volume_get_type() GType;
pub extern fn g_volume_get_name(volume: ?*GVolume) [*c]u8;
pub extern fn g_volume_get_icon(volume: ?*GVolume) ?*GIcon;
pub extern fn g_volume_get_symbolic_icon(volume: ?*GVolume) ?*GIcon;
pub extern fn g_volume_get_uuid(volume: ?*GVolume) [*c]u8;
pub extern fn g_volume_get_drive(volume: ?*GVolume) ?*GDrive;
pub extern fn g_volume_get_mount(volume: ?*GVolume) ?*GMount;
pub extern fn g_volume_can_mount(volume: ?*GVolume) gboolean;
pub extern fn g_volume_can_eject(volume: ?*GVolume) gboolean;
pub extern fn g_volume_should_automount(volume: ?*GVolume) gboolean;
pub extern fn g_volume_mount(volume: ?*GVolume, flags: GMountMountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_volume_mount_finish(volume: ?*GVolume, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_volume_eject(volume: ?*GVolume, flags: GMountUnmountFlags, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_volume_eject_finish(volume: ?*GVolume, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_volume_get_identifier(volume: ?*GVolume, kind: [*c]const u8) [*c]u8;
pub extern fn g_volume_enumerate_identifiers(volume: ?*GVolume) [*c]([*c]u8);
pub extern fn g_volume_get_activation_root(volume: ?*GVolume) ?*GFile;
pub extern fn g_volume_eject_with_operation(volume: ?*GVolume, flags: GMountUnmountFlags, mount_operation: [*c]GMountOperation, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_volume_eject_with_operation_finish(volume: ?*GVolume, result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_volume_get_sort_key(volume: ?*GVolume) [*c]const gchar;
pub const struct__GZlibCompressorClass = extern struct {
    parent_class: GObjectClass,
};
pub const GZlibCompressorClass = struct__GZlibCompressorClass;
pub extern fn g_zlib_compressor_get_type() GType;
pub extern fn g_zlib_compressor_new(format: GZlibCompressorFormat, level: c_int) ?*GZlibCompressor;
pub extern fn g_zlib_compressor_get_file_info(compressor: ?*GZlibCompressor) ?*GFileInfo;
pub extern fn g_zlib_compressor_set_file_info(compressor: ?*GZlibCompressor, file_info: ?*GFileInfo) void;
pub const struct__GZlibDecompressorClass = extern struct {
    parent_class: GObjectClass,
};
pub const GZlibDecompressorClass = struct__GZlibDecompressorClass;
pub extern fn g_zlib_decompressor_get_type() GType;
pub extern fn g_zlib_decompressor_new(format: GZlibCompressorFormat) ?*GZlibDecompressor;
pub extern fn g_zlib_decompressor_get_file_info(decompressor: ?*GZlibDecompressor) ?*GFileInfo;
pub const struct__GDBusInterfaceIface = extern struct {
    parent_iface: GTypeInterface,
    get_info: ?extern fn (?*GDBusInterface) [*c]GDBusInterfaceInfo,
    get_object: ?extern fn (?*GDBusInterface) ?*GDBusObject,
    set_object: ?extern fn (?*GDBusInterface, ?*GDBusObject) void,
    dup_object: ?extern fn (?*GDBusInterface) ?*GDBusObject,
};
pub const GDBusInterfaceIface = struct__GDBusInterfaceIface;
pub extern fn g_dbus_interface_get_type() GType;
pub extern fn g_dbus_interface_get_info(interface_: ?*GDBusInterface) [*c]GDBusInterfaceInfo;
pub extern fn g_dbus_interface_get_object(interface_: ?*GDBusInterface) ?*GDBusObject;
pub extern fn g_dbus_interface_set_object(interface_: ?*GDBusInterface, object: ?*GDBusObject) void;
pub extern fn g_dbus_interface_dup_object(interface_: ?*GDBusInterface) ?*GDBusObject;
pub const struct__GDBusInterfaceSkeletonClass = extern struct {
    parent_class: GObjectClass,
    get_info: ?extern fn ([*c]GDBusInterfaceSkeleton) [*c]GDBusInterfaceInfo,
    get_vtable: ?extern fn ([*c]GDBusInterfaceSkeleton) [*c]GDBusInterfaceVTable,
    get_properties: ?extern fn ([*c]GDBusInterfaceSkeleton) ?*GVariant,
    flush: ?extern fn ([*c]GDBusInterfaceSkeleton) void,
    vfunc_padding: [8]gpointer,
    g_authorize_method: ?extern fn ([*c]GDBusInterfaceSkeleton, ?*GDBusMethodInvocation) gboolean,
    signal_padding: [8]gpointer,
};
pub const GDBusInterfaceSkeletonClass = struct__GDBusInterfaceSkeletonClass;
pub extern fn g_dbus_interface_skeleton_get_type() GType;
pub extern fn g_dbus_interface_skeleton_get_flags(interface_: [*c]GDBusInterfaceSkeleton) GDBusInterfaceSkeletonFlags;
pub extern fn g_dbus_interface_skeleton_set_flags(interface_: [*c]GDBusInterfaceSkeleton, flags: GDBusInterfaceSkeletonFlags) void;
pub extern fn g_dbus_interface_skeleton_get_info(interface_: [*c]GDBusInterfaceSkeleton) [*c]GDBusInterfaceInfo;
pub extern fn g_dbus_interface_skeleton_get_vtable(interface_: [*c]GDBusInterfaceSkeleton) [*c]GDBusInterfaceVTable;
pub extern fn g_dbus_interface_skeleton_get_properties(interface_: [*c]GDBusInterfaceSkeleton) ?*GVariant;
pub extern fn g_dbus_interface_skeleton_flush(interface_: [*c]GDBusInterfaceSkeleton) void;
pub extern fn g_dbus_interface_skeleton_export(interface_: [*c]GDBusInterfaceSkeleton, connection: ?*GDBusConnection, object_path: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn g_dbus_interface_skeleton_unexport(interface_: [*c]GDBusInterfaceSkeleton) void;
pub extern fn g_dbus_interface_skeleton_unexport_from_connection(interface_: [*c]GDBusInterfaceSkeleton, connection: ?*GDBusConnection) void;
pub extern fn g_dbus_interface_skeleton_get_connection(interface_: [*c]GDBusInterfaceSkeleton) ?*GDBusConnection;
pub extern fn g_dbus_interface_skeleton_get_connections(interface_: [*c]GDBusInterfaceSkeleton) [*c]GList;
pub extern fn g_dbus_interface_skeleton_has_connection(interface_: [*c]GDBusInterfaceSkeleton, connection: ?*GDBusConnection) gboolean;
pub extern fn g_dbus_interface_skeleton_get_object_path(interface_: [*c]GDBusInterfaceSkeleton) [*c]const gchar;
pub const struct__GDBusObjectIface = extern struct {
    parent_iface: GTypeInterface,
    get_object_path: ?extern fn (?*GDBusObject) [*c]const gchar,
    get_interfaces: ?extern fn (?*GDBusObject) [*c]GList,
    get_interface: ?extern fn (?*GDBusObject, [*c]const gchar) ?*GDBusInterface,
    interface_added: ?extern fn (?*GDBusObject, ?*GDBusInterface) void,
    interface_removed: ?extern fn (?*GDBusObject, ?*GDBusInterface) void,
};
pub const GDBusObjectIface = struct__GDBusObjectIface;
pub extern fn g_dbus_object_get_type() GType;
pub extern fn g_dbus_object_get_object_path(object: ?*GDBusObject) [*c]const gchar;
pub extern fn g_dbus_object_get_interfaces(object: ?*GDBusObject) [*c]GList;
pub extern fn g_dbus_object_get_interface(object: ?*GDBusObject, interface_name: [*c]const gchar) ?*GDBusInterface;
pub const struct__GDBusObjectSkeletonClass = extern struct {
    parent_class: GObjectClass,
    authorize_method: ?extern fn ([*c]GDBusObjectSkeleton, [*c]GDBusInterfaceSkeleton, ?*GDBusMethodInvocation) gboolean,
    padding: [8]gpointer,
};
pub const GDBusObjectSkeletonClass = struct__GDBusObjectSkeletonClass;
pub extern fn g_dbus_object_skeleton_get_type() GType;
pub extern fn g_dbus_object_skeleton_new(object_path: [*c]const gchar) [*c]GDBusObjectSkeleton;
pub extern fn g_dbus_object_skeleton_flush(object: [*c]GDBusObjectSkeleton) void;
pub extern fn g_dbus_object_skeleton_add_interface(object: [*c]GDBusObjectSkeleton, interface_: [*c]GDBusInterfaceSkeleton) void;
pub extern fn g_dbus_object_skeleton_remove_interface(object: [*c]GDBusObjectSkeleton, interface_: [*c]GDBusInterfaceSkeleton) void;
pub extern fn g_dbus_object_skeleton_remove_interface_by_name(object: [*c]GDBusObjectSkeleton, interface_name: [*c]const gchar) void;
pub extern fn g_dbus_object_skeleton_set_object_path(object: [*c]GDBusObjectSkeleton, object_path: [*c]const gchar) void;
pub const struct__GDBusObjectProxyClass = extern struct {
    parent_class: GObjectClass,
    padding: [8]gpointer,
};
pub const GDBusObjectProxyClass = struct__GDBusObjectProxyClass;
pub extern fn g_dbus_object_proxy_get_type() GType;
pub extern fn g_dbus_object_proxy_new(connection: ?*GDBusConnection, object_path: [*c]const gchar) [*c]GDBusObjectProxy;
pub extern fn g_dbus_object_proxy_get_connection(proxy: [*c]GDBusObjectProxy) ?*GDBusConnection;
pub const struct__GDBusObjectManagerIface = extern struct {
    parent_iface: GTypeInterface,
    get_object_path: ?extern fn (?*GDBusObjectManager) [*c]const gchar,
    get_objects: ?extern fn (?*GDBusObjectManager) [*c]GList,
    get_object: ?extern fn (?*GDBusObjectManager, [*c]const gchar) ?*GDBusObject,
    get_interface: ?extern fn (?*GDBusObjectManager, [*c]const gchar, [*c]const gchar) ?*GDBusInterface,
    object_added: ?extern fn (?*GDBusObjectManager, ?*GDBusObject) void,
    object_removed: ?extern fn (?*GDBusObjectManager, ?*GDBusObject) void,
    interface_added: ?extern fn (?*GDBusObjectManager, ?*GDBusObject, ?*GDBusInterface) void,
    interface_removed: ?extern fn (?*GDBusObjectManager, ?*GDBusObject, ?*GDBusInterface) void,
};
pub const GDBusObjectManagerIface = struct__GDBusObjectManagerIface;
pub extern fn g_dbus_object_manager_get_type() GType;
pub extern fn g_dbus_object_manager_get_object_path(manager: ?*GDBusObjectManager) [*c]const gchar;
pub extern fn g_dbus_object_manager_get_objects(manager: ?*GDBusObjectManager) [*c]GList;
pub extern fn g_dbus_object_manager_get_object(manager: ?*GDBusObjectManager, object_path: [*c]const gchar) ?*GDBusObject;
pub extern fn g_dbus_object_manager_get_interface(manager: ?*GDBusObjectManager, object_path: [*c]const gchar, interface_name: [*c]const gchar) ?*GDBusInterface;
pub const struct__GDBusObjectManagerClientClass = extern struct {
    parent_class: GObjectClass,
    interface_proxy_signal: ?extern fn ([*c]GDBusObjectManagerClient, [*c]GDBusObjectProxy, [*c]GDBusProxy, [*c]const gchar, [*c]const gchar, ?*GVariant) void,
    interface_proxy_properties_changed: ?extern fn ([*c]GDBusObjectManagerClient, [*c]GDBusObjectProxy, [*c]GDBusProxy, ?*GVariant, [*c]const ([*c]const gchar)) void,
    padding: [8]gpointer,
};
pub const GDBusObjectManagerClientClass = struct__GDBusObjectManagerClientClass;
pub extern fn g_dbus_object_manager_client_get_type() GType;
pub extern fn g_dbus_object_manager_client_new(connection: ?*GDBusConnection, flags: GDBusObjectManagerClientFlags, name: [*c]const gchar, object_path: [*c]const gchar, get_proxy_type_func: GDBusProxyTypeFunc, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: GDestroyNotify, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_object_manager_client_new_finish(res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GDBusObjectManager;
pub extern fn g_dbus_object_manager_client_new_sync(connection: ?*GDBusConnection, flags: GDBusObjectManagerClientFlags, name: [*c]const gchar, object_path: [*c]const gchar, get_proxy_type_func: GDBusProxyTypeFunc, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: GDestroyNotify, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GDBusObjectManager;
pub extern fn g_dbus_object_manager_client_new_for_bus(bus_type: GBusType, flags: GDBusObjectManagerClientFlags, name: [*c]const gchar, object_path: [*c]const gchar, get_proxy_type_func: GDBusProxyTypeFunc, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: GDestroyNotify, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn g_dbus_object_manager_client_new_for_bus_finish(res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GDBusObjectManager;
pub extern fn g_dbus_object_manager_client_new_for_bus_sync(bus_type: GBusType, flags: GDBusObjectManagerClientFlags, name: [*c]const gchar, object_path: [*c]const gchar, get_proxy_type_func: GDBusProxyTypeFunc, get_proxy_type_user_data: gpointer, get_proxy_type_destroy_notify: GDestroyNotify, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GDBusObjectManager;
pub extern fn g_dbus_object_manager_client_get_connection(manager: [*c]GDBusObjectManagerClient) ?*GDBusConnection;
pub extern fn g_dbus_object_manager_client_get_flags(manager: [*c]GDBusObjectManagerClient) GDBusObjectManagerClientFlags;
pub extern fn g_dbus_object_manager_client_get_name(manager: [*c]GDBusObjectManagerClient) [*c]const gchar;
pub extern fn g_dbus_object_manager_client_get_name_owner(manager: [*c]GDBusObjectManagerClient) [*c]gchar;
pub const struct__GDBusObjectManagerServerClass = extern struct {
    parent_class: GObjectClass,
    padding: [8]gpointer,
};
pub const GDBusObjectManagerServerClass = struct__GDBusObjectManagerServerClass;
pub extern fn g_dbus_object_manager_server_get_type() GType;
pub extern fn g_dbus_object_manager_server_new(object_path: [*c]const gchar) [*c]GDBusObjectManagerServer;
pub extern fn g_dbus_object_manager_server_get_connection(manager: [*c]GDBusObjectManagerServer) ?*GDBusConnection;
pub extern fn g_dbus_object_manager_server_set_connection(manager: [*c]GDBusObjectManagerServer, connection: ?*GDBusConnection) void;
pub extern fn g_dbus_object_manager_server_export(manager: [*c]GDBusObjectManagerServer, object: [*c]GDBusObjectSkeleton) void;
pub extern fn g_dbus_object_manager_server_export_uniquely(manager: [*c]GDBusObjectManagerServer, object: [*c]GDBusObjectSkeleton) void;
pub extern fn g_dbus_object_manager_server_is_exported(manager: [*c]GDBusObjectManagerServer, object: [*c]GDBusObjectSkeleton) gboolean;
pub extern fn g_dbus_object_manager_server_unexport(manager: [*c]GDBusObjectManagerServer, object_path: [*c]const gchar) gboolean;
pub extern fn g_dbus_action_group_get_type() GType;
pub extern fn g_dbus_action_group_get(connection: ?*GDBusConnection, bus_name: [*c]const gchar, object_path: [*c]const gchar) ?*GDBusActionGroup;
pub const struct__GRemoteActionGroupInterface = extern struct {
    g_iface: GTypeInterface,
    activate_action_full: ?extern fn (?*GRemoteActionGroup, [*c]const gchar, ?*GVariant, ?*GVariant) void,
    change_action_state_full: ?extern fn (?*GRemoteActionGroup, [*c]const gchar, ?*GVariant, ?*GVariant) void,
};
pub const GRemoteActionGroupInterface = struct__GRemoteActionGroupInterface;
pub extern fn g_remote_action_group_get_type() GType;
pub extern fn g_remote_action_group_activate_action_full(remote: ?*GRemoteActionGroup, action_name: [*c]const gchar, parameter: ?*GVariant, platform_data: ?*GVariant) void;
pub extern fn g_remote_action_group_change_action_state_full(remote: ?*GRemoteActionGroup, action_name: [*c]const gchar, value: ?*GVariant, platform_data: ?*GVariant) void;
pub const struct__GMenuAttributeIterPrivate = @OpaqueType();
pub const GMenuAttributeIterPrivate = struct__GMenuAttributeIterPrivate;
pub const struct__GMenuAttributeIter = extern struct {
    parent_instance: GObject,
    priv: ?*GMenuAttributeIterPrivate,
};
pub const GMenuAttributeIter = struct__GMenuAttributeIter;
pub const struct__GMenuLinkIterPrivate = @OpaqueType();
pub const GMenuLinkIterPrivate = struct__GMenuLinkIterPrivate;
pub const struct__GMenuLinkIter = extern struct {
    parent_instance: GObject,
    priv: ?*GMenuLinkIterPrivate,
};
pub const GMenuLinkIter = struct__GMenuLinkIter;
pub const struct__GMenuModelClass = extern struct {
    parent_class: GObjectClass,
    is_mutable: ?extern fn ([*c]GMenuModel) gboolean,
    get_n_items: ?extern fn ([*c]GMenuModel) gint,
    get_item_attributes: ?extern fn ([*c]GMenuModel, gint, [*c](?*GHashTable)) void,
    iterate_item_attributes: ?extern fn ([*c]GMenuModel, gint) [*c]GMenuAttributeIter,
    get_item_attribute_value: ?extern fn ([*c]GMenuModel, gint, [*c]const gchar, ?*const GVariantType) ?*GVariant,
    get_item_links: ?extern fn ([*c]GMenuModel, gint, [*c](?*GHashTable)) void,
    iterate_item_links: ?extern fn ([*c]GMenuModel, gint) [*c]GMenuLinkIter,
    get_item_link: ?extern fn ([*c]GMenuModel, gint, [*c]const gchar) [*c]GMenuModel,
};
pub const GMenuModelClass = struct__GMenuModelClass;
pub const struct__GMenuAttributeIterClass = extern struct {
    parent_class: GObjectClass,
    get_next: ?extern fn ([*c]GMenuAttributeIter, [*c]([*c]const gchar), [*c](?*GVariant)) gboolean,
};
pub const GMenuAttributeIterClass = struct__GMenuAttributeIterClass;
pub const struct__GMenuLinkIterClass = extern struct {
    parent_class: GObjectClass,
    get_next: ?extern fn ([*c]GMenuLinkIter, [*c]([*c]const gchar), [*c]([*c]GMenuModel)) gboolean,
};
pub const GMenuLinkIterClass = struct__GMenuLinkIterClass;
pub extern fn g_menu_model_get_type() GType;
pub extern fn g_menu_model_is_mutable(model: [*c]GMenuModel) gboolean;
pub extern fn g_menu_model_get_n_items(model: [*c]GMenuModel) gint;
pub extern fn g_menu_model_iterate_item_attributes(model: [*c]GMenuModel, item_index: gint) [*c]GMenuAttributeIter;
pub extern fn g_menu_model_get_item_attribute_value(model: [*c]GMenuModel, item_index: gint, attribute: [*c]const gchar, expected_type: ?*const GVariantType) ?*GVariant;
pub extern fn g_menu_model_get_item_attribute(model: [*c]GMenuModel, item_index: gint, attribute: [*c]const gchar, format_string: [*c]const gchar, ...) gboolean;
pub extern fn g_menu_model_iterate_item_links(model: [*c]GMenuModel, item_index: gint) [*c]GMenuLinkIter;
pub extern fn g_menu_model_get_item_link(model: [*c]GMenuModel, item_index: gint, link: [*c]const gchar) [*c]GMenuModel;
pub extern fn g_menu_model_items_changed(model: [*c]GMenuModel, position: gint, removed: gint, added: gint) void;
pub extern fn g_menu_attribute_iter_get_type() GType;
pub extern fn g_menu_attribute_iter_get_next(iter: [*c]GMenuAttributeIter, out_name: [*c]([*c]const gchar), value: [*c](?*GVariant)) gboolean;
pub extern fn g_menu_attribute_iter_next(iter: [*c]GMenuAttributeIter) gboolean;
pub extern fn g_menu_attribute_iter_get_name(iter: [*c]GMenuAttributeIter) [*c]const gchar;
pub extern fn g_menu_attribute_iter_get_value(iter: [*c]GMenuAttributeIter) ?*GVariant;
pub extern fn g_menu_link_iter_get_type() GType;
pub extern fn g_menu_link_iter_get_next(iter: [*c]GMenuLinkIter, out_link: [*c]([*c]const gchar), value: [*c]([*c]GMenuModel)) gboolean;
pub extern fn g_menu_link_iter_next(iter: [*c]GMenuLinkIter) gboolean;
pub extern fn g_menu_link_iter_get_name(iter: [*c]GMenuLinkIter) [*c]const gchar;
pub extern fn g_menu_link_iter_get_value(iter: [*c]GMenuLinkIter) [*c]GMenuModel;
pub const struct__GMenuItem = @OpaqueType();
pub const GMenuItem = struct__GMenuItem;
pub const struct__GMenu = @OpaqueType();
pub const GMenu = struct__GMenu;
pub extern fn g_menu_get_type() GType;
pub extern fn g_menu_new() ?*GMenu;
pub extern fn g_menu_freeze(menu: ?*GMenu) void;
pub extern fn g_menu_insert_item(menu: ?*GMenu, position: gint, item: ?*GMenuItem) void;
pub extern fn g_menu_prepend_item(menu: ?*GMenu, item: ?*GMenuItem) void;
pub extern fn g_menu_append_item(menu: ?*GMenu, item: ?*GMenuItem) void;
pub extern fn g_menu_remove(menu: ?*GMenu, position: gint) void;
pub extern fn g_menu_remove_all(menu: ?*GMenu) void;
pub extern fn g_menu_insert(menu: ?*GMenu, position: gint, label: [*c]const gchar, detailed_action: [*c]const gchar) void;
pub extern fn g_menu_prepend(menu: ?*GMenu, label: [*c]const gchar, detailed_action: [*c]const gchar) void;
pub extern fn g_menu_append(menu: ?*GMenu, label: [*c]const gchar, detailed_action: [*c]const gchar) void;
pub extern fn g_menu_insert_section(menu: ?*GMenu, position: gint, label: [*c]const gchar, section: [*c]GMenuModel) void;
pub extern fn g_menu_prepend_section(menu: ?*GMenu, label: [*c]const gchar, section: [*c]GMenuModel) void;
pub extern fn g_menu_append_section(menu: ?*GMenu, label: [*c]const gchar, section: [*c]GMenuModel) void;
pub extern fn g_menu_insert_submenu(menu: ?*GMenu, position: gint, label: [*c]const gchar, submenu: [*c]GMenuModel) void;
pub extern fn g_menu_prepend_submenu(menu: ?*GMenu, label: [*c]const gchar, submenu: [*c]GMenuModel) void;
pub extern fn g_menu_append_submenu(menu: ?*GMenu, label: [*c]const gchar, submenu: [*c]GMenuModel) void;
pub extern fn g_menu_item_get_type() GType;
pub extern fn g_menu_item_new(label: [*c]const gchar, detailed_action: [*c]const gchar) ?*GMenuItem;
pub extern fn g_menu_item_new_from_model(model: [*c]GMenuModel, item_index: gint) ?*GMenuItem;
pub extern fn g_menu_item_new_submenu(label: [*c]const gchar, submenu: [*c]GMenuModel) ?*GMenuItem;
pub extern fn g_menu_item_new_section(label: [*c]const gchar, section: [*c]GMenuModel) ?*GMenuItem;
pub extern fn g_menu_item_get_attribute_value(menu_item: ?*GMenuItem, attribute: [*c]const gchar, expected_type: ?*const GVariantType) ?*GVariant;
pub extern fn g_menu_item_get_attribute(menu_item: ?*GMenuItem, attribute: [*c]const gchar, format_string: [*c]const gchar, ...) gboolean;
pub extern fn g_menu_item_get_link(menu_item: ?*GMenuItem, link: [*c]const gchar) [*c]GMenuModel;
pub extern fn g_menu_item_set_attribute_value(menu_item: ?*GMenuItem, attribute: [*c]const gchar, value: ?*GVariant) void;
pub extern fn g_menu_item_set_attribute(menu_item: ?*GMenuItem, attribute: [*c]const gchar, format_string: [*c]const gchar, ...) void;
pub extern fn g_menu_item_set_link(menu_item: ?*GMenuItem, link: [*c]const gchar, model: [*c]GMenuModel) void;
pub extern fn g_menu_item_set_label(menu_item: ?*GMenuItem, label: [*c]const gchar) void;
pub extern fn g_menu_item_set_submenu(menu_item: ?*GMenuItem, submenu: [*c]GMenuModel) void;
pub extern fn g_menu_item_set_section(menu_item: ?*GMenuItem, section: [*c]GMenuModel) void;
pub extern fn g_menu_item_set_action_and_target_value(menu_item: ?*GMenuItem, action: [*c]const gchar, target_value: ?*GVariant) void;
pub extern fn g_menu_item_set_action_and_target(menu_item: ?*GMenuItem, action: [*c]const gchar, format_string: [*c]const gchar, ...) void;
pub extern fn g_menu_item_set_detailed_action(menu_item: ?*GMenuItem, detailed_action: [*c]const gchar) void;
pub extern fn g_menu_item_set_icon(menu_item: ?*GMenuItem, icon: ?*GIcon) void;
pub extern fn g_dbus_connection_export_menu_model(connection: ?*GDBusConnection, object_path: [*c]const gchar, menu: [*c]GMenuModel, @"error": [*c]([*c]GError)) guint;
pub extern fn g_dbus_connection_unexport_menu_model(connection: ?*GDBusConnection, export_id: guint) void;
pub const struct__GDBusMenuModel = @OpaqueType();
pub const GDBusMenuModel = struct__GDBusMenuModel;
pub extern fn g_dbus_menu_model_get_type() GType;
pub extern fn g_dbus_menu_model_get(connection: ?*GDBusConnection, bus_name: [*c]const gchar, object_path: [*c]const gchar) ?*GDBusMenuModel;
pub extern fn g_notification_get_type() GType;
pub extern fn g_notification_new(title: [*c]const gchar) ?*GNotification;
pub extern fn g_notification_set_title(notification: ?*GNotification, title: [*c]const gchar) void;
pub extern fn g_notification_set_body(notification: ?*GNotification, body: [*c]const gchar) void;
pub extern fn g_notification_set_icon(notification: ?*GNotification, icon: ?*GIcon) void;
pub extern fn g_notification_set_urgent(notification: ?*GNotification, urgent: gboolean) void;
pub extern fn g_notification_set_priority(notification: ?*GNotification, priority: GNotificationPriority) void;
pub extern fn g_notification_add_button(notification: ?*GNotification, label: [*c]const gchar, detailed_action: [*c]const gchar) void;
pub extern fn g_notification_add_button_with_target(notification: ?*GNotification, label: [*c]const gchar, action: [*c]const gchar, target_format: [*c]const gchar, ...) void;
pub extern fn g_notification_add_button_with_target_value(notification: ?*GNotification, label: [*c]const gchar, action: [*c]const gchar, target: ?*GVariant) void;
pub extern fn g_notification_set_default_action(notification: ?*GNotification, detailed_action: [*c]const gchar) void;
pub extern fn g_notification_set_default_action_and_target(notification: ?*GNotification, action: [*c]const gchar, target_format: [*c]const gchar, ...) void;
pub extern fn g_notification_set_default_action_and_target_value(notification: ?*GNotification, action: [*c]const gchar, target: ?*GVariant) void;
pub extern fn g_list_model_get_type() GType;
pub const struct__GListModel = @OpaqueType();
pub const GListModel = struct__GListModel;
pub const struct__GListModelInterface = extern struct {
    g_iface: GTypeInterface,
    get_item_type: ?extern fn (?*GListModel) GType,
    get_n_items: ?extern fn (?*GListModel) guint,
    get_item: ?extern fn (?*GListModel, guint) gpointer,
};
pub const GListModelInterface = struct__GListModelInterface;
pub const GListModel_autoptr = ?*GListModel;
pub const GListModel_listautoptr = [*c]GList;
pub const GListModel_slistautoptr = [*c]GSList;
pub const GListModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GListModel(_ptr: ?*GListModel) void {
    if (_ptr != null) glib_autoptr_clear_GObject.?(@ptrCast([*c]GObject, @alignCast(@alignOf(GObject), _ptr)));
}
pub fn glib_autoptr_cleanup_GListModel(_ptr: [*c](?*GListModel)) void {
    glib_autoptr_clear_GListModel(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GListModel(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), glib_autoptr_clear_GObject)))));
}
pub fn glib_slistautoptr_cleanup_GListModel(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), glib_autoptr_clear_GObject)))));
}
pub fn glib_queueautoptr_cleanup_GListModel(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), glib_autoptr_clear_GObject)))));
}
pub fn G_LIST_MODEL(ptr: gpointer) ?*GListModel {
    return @ptrCast(?*GListModel, @alignCast(@alignOf(GListModel), g_type_check_instance_cast(@ptrCast([*c]GTypeInstance, @alignCast(@alignOf(GTypeInstance), ptr)), g_list_model_get_type())));
}
pub fn G_IS_LIST_MODEL(ptr: gpointer) gboolean {
    return g_type_check_instance_is_a(@ptrCast([*c]GTypeInstance, @alignCast(@alignOf(GTypeInstance), ptr)), g_list_model_get_type());
}
pub fn G_LIST_MODEL_GET_IFACE(ptr: gpointer) [*c]GListModelInterface {
    return @ptrCast([*c]GListModelInterface, @alignCast(@alignOf(GListModelInterface), g_type_interface_peek(@ptrCast(gpointer, @ptrCast([*c]GTypeInstance, @alignCast(@alignOf(GTypeInstance), ptr)).?.g_class), g_list_model_get_type())));
}
pub extern fn g_list_model_get_item_type(list: ?*GListModel) GType;
pub extern fn g_list_model_get_n_items(list: ?*GListModel) guint;
pub extern fn g_list_model_get_item(list: ?*GListModel, position: guint) gpointer;
pub extern fn g_list_model_get_object(list: ?*GListModel, position: guint) [*c]GObject;
pub extern fn g_list_model_items_changed(list: ?*GListModel, position: guint, removed: guint, added: guint) void;
pub extern fn g_list_store_get_type() GType;
pub const struct__GListStore = @OpaqueType();
pub const GListStore = struct__GListStore;
pub const GListStoreClass = extern struct {
    parent_class: GObjectClass,
};
pub const GListStore_autoptr = ?*GListStore;
pub const GListStore_listautoptr = [*c]GList;
pub const GListStore_slistautoptr = [*c]GSList;
pub const GListStore_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GListStore(_ptr: ?*GListStore) void {
    if (_ptr != null) glib_autoptr_clear_GObject.?(@ptrCast([*c]GObject, @alignCast(@alignOf(GObject), _ptr)));
}
pub fn glib_autoptr_cleanup_GListStore(_ptr: [*c](?*GListStore)) void {
    glib_autoptr_clear_GListStore(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GListStore(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), glib_autoptr_clear_GObject)))));
}
pub fn glib_slistautoptr_cleanup_GListStore(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), glib_autoptr_clear_GObject)))));
}
pub fn glib_queueautoptr_cleanup_GListStore(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), glib_autoptr_clear_GObject)))));
}
pub fn G_LIST_STORE(ptr: gpointer) ?*GListStore {
    return @ptrCast(?*GListStore, @alignCast(@alignOf(GListStore), g_type_check_instance_cast(@ptrCast([*c]GTypeInstance, @alignCast(@alignOf(GTypeInstance), ptr)), g_list_store_get_type())));
}
pub fn G_IS_LIST_STORE(ptr: gpointer) gboolean {
    return g_type_check_instance_is_a(@ptrCast([*c]GTypeInstance, @alignCast(@alignOf(GTypeInstance), ptr)), g_list_store_get_type());
}
pub extern fn g_list_store_new(item_type: GType) ?*GListStore;
pub extern fn g_list_store_insert(store: ?*GListStore, position: guint, item: gpointer) void;
pub extern fn g_list_store_insert_sorted(store: ?*GListStore, item: gpointer, compare_func: GCompareDataFunc, user_data: gpointer) guint;
pub extern fn g_list_store_sort(store: ?*GListStore, compare_func: GCompareDataFunc, user_data: gpointer) void;
pub extern fn g_list_store_append(store: ?*GListStore, item: gpointer) void;
pub extern fn g_list_store_remove(store: ?*GListStore, position: guint) void;
pub extern fn g_list_store_remove_all(store: ?*GListStore) void;
pub extern fn g_list_store_splice(store: ?*GListStore, position: guint, n_removals: guint, additions: [*c]gpointer, n_additions: guint) void;
pub const GAction_autoptr = ?*GAction;
pub const GAction_listautoptr = [*c]GList;
pub const GAction_slistautoptr = [*c]GSList;
pub const GAction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAction(_ptr: ?*GAction) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GAction(_ptr: [*c](?*GAction)) void {
    glib_autoptr_clear_GAction(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GAction(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GAction(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GAction(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GActionMap_autoptr = ?*GActionMap;
pub const GActionMap_listautoptr = [*c]GList;
pub const GActionMap_slistautoptr = [*c]GSList;
pub const GActionMap_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GActionMap(_ptr: ?*GActionMap) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GActionMap(_ptr: [*c](?*GActionMap)) void {
    glib_autoptr_clear_GActionMap(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GActionMap(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GActionMap(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GActionMap(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GAppInfo_autoptr = ?*GAppInfo;
pub const GAppInfo_listautoptr = [*c]GList;
pub const GAppInfo_slistautoptr = [*c]GSList;
pub const GAppInfo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAppInfo(_ptr: ?*GAppInfo) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GAppInfo(_ptr: [*c](?*GAppInfo)) void {
    glib_autoptr_clear_GAppInfo(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GAppInfo(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GAppInfo(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GAppInfo(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GAppLaunchContext_autoptr = [*c]GAppLaunchContext;
pub const GAppLaunchContext_listautoptr = [*c]GList;
pub const GAppLaunchContext_slistautoptr = [*c]GSList;
pub const GAppLaunchContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAppLaunchContext(_ptr: [*c]GAppLaunchContext) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GAppLaunchContext(_ptr: [*c]([*c]GAppLaunchContext)) void {
    glib_autoptr_clear_GAppLaunchContext(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GAppLaunchContext(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GAppLaunchContext(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GAppLaunchContext(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GAppInfoMonitor_autoptr = ?*GAppInfoMonitor;
pub const GAppInfoMonitor_listautoptr = [*c]GList;
pub const GAppInfoMonitor_slistautoptr = [*c]GSList;
pub const GAppInfoMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAppInfoMonitor(_ptr: ?*GAppInfoMonitor) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GAppInfoMonitor(_ptr: [*c](?*GAppInfoMonitor)) void {
    glib_autoptr_clear_GAppInfoMonitor(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GAppInfoMonitor(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GAppInfoMonitor(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GAppInfoMonitor(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GApplicationCommandLine_autoptr = [*c]GApplicationCommandLine;
pub const GApplicationCommandLine_listautoptr = [*c]GList;
pub const GApplicationCommandLine_slistautoptr = [*c]GSList;
pub const GApplicationCommandLine_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GApplicationCommandLine(_ptr: [*c]GApplicationCommandLine) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GApplicationCommandLine(_ptr: [*c]([*c]GApplicationCommandLine)) void {
    glib_autoptr_clear_GApplicationCommandLine(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GApplicationCommandLine(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GApplicationCommandLine(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GApplicationCommandLine(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GApplication_autoptr = [*c]GApplication;
pub const GApplication_listautoptr = [*c]GList;
pub const GApplication_slistautoptr = [*c]GSList;
pub const GApplication_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GApplication(_ptr: [*c]GApplication) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GApplication(_ptr: [*c]([*c]GApplication)) void {
    glib_autoptr_clear_GApplication(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GApplication(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GApplication(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GApplication(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GAsyncInitable_autoptr = ?*GAsyncInitable;
pub const GAsyncInitable_listautoptr = [*c]GList;
pub const GAsyncInitable_slistautoptr = [*c]GSList;
pub const GAsyncInitable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAsyncInitable(_ptr: ?*GAsyncInitable) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GAsyncInitable(_ptr: [*c](?*GAsyncInitable)) void {
    glib_autoptr_clear_GAsyncInitable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GAsyncInitable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GAsyncInitable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GAsyncInitable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GAsyncResult_autoptr = ?*GAsyncResult;
pub const GAsyncResult_listautoptr = [*c]GList;
pub const GAsyncResult_slistautoptr = [*c]GSList;
pub const GAsyncResult_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GAsyncResult(_ptr: ?*GAsyncResult) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GAsyncResult(_ptr: [*c](?*GAsyncResult)) void {
    glib_autoptr_clear_GAsyncResult(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GAsyncResult(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GAsyncResult(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GAsyncResult(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GBufferedInputStream_autoptr = [*c]GBufferedInputStream;
pub const GBufferedInputStream_listautoptr = [*c]GList;
pub const GBufferedInputStream_slistautoptr = [*c]GSList;
pub const GBufferedInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GBufferedInputStream(_ptr: [*c]GBufferedInputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GBufferedInputStream(_ptr: [*c]([*c]GBufferedInputStream)) void {
    glib_autoptr_clear_GBufferedInputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GBufferedInputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GBufferedInputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GBufferedInputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GBufferedOutputStream_autoptr = [*c]GBufferedOutputStream;
pub const GBufferedOutputStream_listautoptr = [*c]GList;
pub const GBufferedOutputStream_slistautoptr = [*c]GSList;
pub const GBufferedOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GBufferedOutputStream(_ptr: [*c]GBufferedOutputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GBufferedOutputStream(_ptr: [*c]([*c]GBufferedOutputStream)) void {
    glib_autoptr_clear_GBufferedOutputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GBufferedOutputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GBufferedOutputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GBufferedOutputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GBytesIcon_autoptr = ?*GBytesIcon;
pub const GBytesIcon_listautoptr = [*c]GList;
pub const GBytesIcon_slistautoptr = [*c]GSList;
pub const GBytesIcon_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GBytesIcon(_ptr: ?*GBytesIcon) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GBytesIcon(_ptr: [*c](?*GBytesIcon)) void {
    glib_autoptr_clear_GBytesIcon(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GBytesIcon(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GBytesIcon(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GBytesIcon(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GCancellable_autoptr = [*c]GCancellable;
pub const GCancellable_listautoptr = [*c]GList;
pub const GCancellable_slistautoptr = [*c]GSList;
pub const GCancellable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GCancellable(_ptr: [*c]GCancellable) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GCancellable(_ptr: [*c]([*c]GCancellable)) void {
    glib_autoptr_clear_GCancellable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GCancellable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GCancellable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GCancellable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GCharsetConverter_autoptr = ?*GCharsetConverter;
pub const GCharsetConverter_listautoptr = [*c]GList;
pub const GCharsetConverter_slistautoptr = [*c]GSList;
pub const GCharsetConverter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GCharsetConverter(_ptr: ?*GCharsetConverter) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GCharsetConverter(_ptr: [*c](?*GCharsetConverter)) void {
    glib_autoptr_clear_GCharsetConverter(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GCharsetConverter(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GCharsetConverter(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GCharsetConverter(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GConverter_autoptr = ?*GConverter;
pub const GConverter_listautoptr = [*c]GList;
pub const GConverter_slistautoptr = [*c]GSList;
pub const GConverter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GConverter(_ptr: ?*GConverter) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GConverter(_ptr: [*c](?*GConverter)) void {
    glib_autoptr_clear_GConverter(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GConverter(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GConverter(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GConverter(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GConverterInputStream_autoptr = [*c]GConverterInputStream;
pub const GConverterInputStream_listautoptr = [*c]GList;
pub const GConverterInputStream_slistautoptr = [*c]GSList;
pub const GConverterInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GConverterInputStream(_ptr: [*c]GConverterInputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GConverterInputStream(_ptr: [*c]([*c]GConverterInputStream)) void {
    glib_autoptr_clear_GConverterInputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GConverterInputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GConverterInputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GConverterInputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GConverterOutputStream_autoptr = [*c]GConverterOutputStream;
pub const GConverterOutputStream_listautoptr = [*c]GList;
pub const GConverterOutputStream_slistautoptr = [*c]GSList;
pub const GConverterOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GConverterOutputStream(_ptr: [*c]GConverterOutputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GConverterOutputStream(_ptr: [*c]([*c]GConverterOutputStream)) void {
    glib_autoptr_clear_GConverterOutputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GConverterOutputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GConverterOutputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GConverterOutputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GCredentials_autoptr = ?*GCredentials;
pub const GCredentials_listautoptr = [*c]GList;
pub const GCredentials_slistautoptr = [*c]GSList;
pub const GCredentials_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GCredentials(_ptr: ?*GCredentials) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GCredentials(_ptr: [*c](?*GCredentials)) void {
    glib_autoptr_clear_GCredentials(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GCredentials(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GCredentials(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GCredentials(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDatagramBased_autoptr = ?*GDatagramBased;
pub const GDatagramBased_listautoptr = [*c]GList;
pub const GDatagramBased_slistautoptr = [*c]GSList;
pub const GDatagramBased_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDatagramBased(_ptr: ?*GDatagramBased) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDatagramBased(_ptr: [*c](?*GDatagramBased)) void {
    glib_autoptr_clear_GDatagramBased(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDatagramBased(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDatagramBased(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDatagramBased(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDataInputStream_autoptr = [*c]GDataInputStream;
pub const GDataInputStream_listautoptr = [*c]GList;
pub const GDataInputStream_slistautoptr = [*c]GSList;
pub const GDataInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDataInputStream(_ptr: [*c]GDataInputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDataInputStream(_ptr: [*c]([*c]GDataInputStream)) void {
    glib_autoptr_clear_GDataInputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDataInputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDataInputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDataInputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDataOutputStream_autoptr = [*c]GDataOutputStream;
pub const GDataOutputStream_listautoptr = [*c]GList;
pub const GDataOutputStream_slistautoptr = [*c]GSList;
pub const GDataOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDataOutputStream(_ptr: [*c]GDataOutputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDataOutputStream(_ptr: [*c]([*c]GDataOutputStream)) void {
    glib_autoptr_clear_GDataOutputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDataOutputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDataOutputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDataOutputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusActionGroup_autoptr = ?*GDBusActionGroup;
pub const GDBusActionGroup_listautoptr = [*c]GList;
pub const GDBusActionGroup_slistautoptr = [*c]GSList;
pub const GDBusActionGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusActionGroup(_ptr: ?*GDBusActionGroup) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusActionGroup(_ptr: [*c](?*GDBusActionGroup)) void {
    glib_autoptr_clear_GDBusActionGroup(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusActionGroup(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusActionGroup(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusActionGroup(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusAuthObserver_autoptr = ?*GDBusAuthObserver;
pub const GDBusAuthObserver_listautoptr = [*c]GList;
pub const GDBusAuthObserver_slistautoptr = [*c]GSList;
pub const GDBusAuthObserver_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusAuthObserver(_ptr: ?*GDBusAuthObserver) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusAuthObserver(_ptr: [*c](?*GDBusAuthObserver)) void {
    glib_autoptr_clear_GDBusAuthObserver(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusAuthObserver(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusAuthObserver(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusAuthObserver(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusConnection_autoptr = ?*GDBusConnection;
pub const GDBusConnection_listautoptr = [*c]GList;
pub const GDBusConnection_slistautoptr = [*c]GSList;
pub const GDBusConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusConnection(_ptr: ?*GDBusConnection) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusConnection(_ptr: [*c](?*GDBusConnection)) void {
    glib_autoptr_clear_GDBusConnection(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusConnection(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusConnection(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusConnection(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusInterface_autoptr = ?*GDBusInterface;
pub const GDBusInterface_listautoptr = [*c]GList;
pub const GDBusInterface_slistautoptr = [*c]GSList;
pub const GDBusInterface_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusInterface(_ptr: ?*GDBusInterface) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusInterface(_ptr: [*c](?*GDBusInterface)) void {
    glib_autoptr_clear_GDBusInterface(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusInterface(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusInterface(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusInterface(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusInterfaceSkeleton_autoptr = [*c]GDBusInterfaceSkeleton;
pub const GDBusInterfaceSkeleton_listautoptr = [*c]GList;
pub const GDBusInterfaceSkeleton_slistautoptr = [*c]GSList;
pub const GDBusInterfaceSkeleton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusInterfaceSkeleton(_ptr: [*c]GDBusInterfaceSkeleton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusInterfaceSkeleton(_ptr: [*c]([*c]GDBusInterfaceSkeleton)) void {
    glib_autoptr_clear_GDBusInterfaceSkeleton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusInterfaceSkeleton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusInterfaceSkeleton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusInterfaceSkeleton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusMenuModel_autoptr = ?*GDBusMenuModel;
pub const GDBusMenuModel_listautoptr = [*c]GList;
pub const GDBusMenuModel_slistautoptr = [*c]GSList;
pub const GDBusMenuModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusMenuModel(_ptr: ?*GDBusMenuModel) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusMenuModel(_ptr: [*c](?*GDBusMenuModel)) void {
    glib_autoptr_clear_GDBusMenuModel(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusMenuModel(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusMenuModel(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusMenuModel(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusMessage_autoptr = ?*GDBusMessage;
pub const GDBusMessage_listautoptr = [*c]GList;
pub const GDBusMessage_slistautoptr = [*c]GSList;
pub const GDBusMessage_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusMessage(_ptr: ?*GDBusMessage) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusMessage(_ptr: [*c](?*GDBusMessage)) void {
    glib_autoptr_clear_GDBusMessage(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusMessage(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusMessage(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusMessage(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusMethodInvocation_autoptr = ?*GDBusMethodInvocation;
pub const GDBusMethodInvocation_listautoptr = [*c]GList;
pub const GDBusMethodInvocation_slistautoptr = [*c]GSList;
pub const GDBusMethodInvocation_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusMethodInvocation(_ptr: ?*GDBusMethodInvocation) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusMethodInvocation(_ptr: [*c](?*GDBusMethodInvocation)) void {
    glib_autoptr_clear_GDBusMethodInvocation(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusMethodInvocation(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusMethodInvocation(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusMethodInvocation(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusNodeInfo_autoptr = [*c]GDBusNodeInfo;
pub const GDBusNodeInfo_listautoptr = [*c]GList;
pub const GDBusNodeInfo_slistautoptr = [*c]GSList;
pub const GDBusNodeInfo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusNodeInfo(_ptr: [*c]GDBusNodeInfo) void {
    if (_ptr != null) g_dbus_node_info_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GDBusNodeInfo(_ptr: [*c]([*c]GDBusNodeInfo)) void {
    glib_autoptr_clear_GDBusNodeInfo(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusNodeInfo(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_dbus_node_info_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusNodeInfo(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_dbus_node_info_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusNodeInfo(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_dbus_node_info_unref)))));
}
pub const GDBusObject_autoptr = ?*GDBusObject;
pub const GDBusObject_listautoptr = [*c]GList;
pub const GDBusObject_slistautoptr = [*c]GSList;
pub const GDBusObject_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusObject(_ptr: ?*GDBusObject) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusObject(_ptr: [*c](?*GDBusObject)) void {
    glib_autoptr_clear_GDBusObject(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusObject(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusObject(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusObject(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusObjectManagerClient_autoptr = [*c]GDBusObjectManagerClient;
pub const GDBusObjectManagerClient_listautoptr = [*c]GList;
pub const GDBusObjectManagerClient_slistautoptr = [*c]GSList;
pub const GDBusObjectManagerClient_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusObjectManagerClient(_ptr: [*c]GDBusObjectManagerClient) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusObjectManagerClient(_ptr: [*c]([*c]GDBusObjectManagerClient)) void {
    glib_autoptr_clear_GDBusObjectManagerClient(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusObjectManagerClient(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusObjectManagerClient(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusObjectManagerClient(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusObjectManager_autoptr = ?*GDBusObjectManager;
pub const GDBusObjectManager_listautoptr = [*c]GList;
pub const GDBusObjectManager_slistautoptr = [*c]GSList;
pub const GDBusObjectManager_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusObjectManager(_ptr: ?*GDBusObjectManager) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusObjectManager(_ptr: [*c](?*GDBusObjectManager)) void {
    glib_autoptr_clear_GDBusObjectManager(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusObjectManager(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusObjectManager(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusObjectManager(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusObjectManagerServer_autoptr = [*c]GDBusObjectManagerServer;
pub const GDBusObjectManagerServer_listautoptr = [*c]GList;
pub const GDBusObjectManagerServer_slistautoptr = [*c]GSList;
pub const GDBusObjectManagerServer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusObjectManagerServer(_ptr: [*c]GDBusObjectManagerServer) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusObjectManagerServer(_ptr: [*c]([*c]GDBusObjectManagerServer)) void {
    glib_autoptr_clear_GDBusObjectManagerServer(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusObjectManagerServer(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusObjectManagerServer(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusObjectManagerServer(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusObjectProxy_autoptr = [*c]GDBusObjectProxy;
pub const GDBusObjectProxy_listautoptr = [*c]GList;
pub const GDBusObjectProxy_slistautoptr = [*c]GSList;
pub const GDBusObjectProxy_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusObjectProxy(_ptr: [*c]GDBusObjectProxy) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusObjectProxy(_ptr: [*c]([*c]GDBusObjectProxy)) void {
    glib_autoptr_clear_GDBusObjectProxy(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusObjectProxy(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusObjectProxy(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusObjectProxy(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusObjectSkeleton_autoptr = [*c]GDBusObjectSkeleton;
pub const GDBusObjectSkeleton_listautoptr = [*c]GList;
pub const GDBusObjectSkeleton_slistautoptr = [*c]GSList;
pub const GDBusObjectSkeleton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusObjectSkeleton(_ptr: [*c]GDBusObjectSkeleton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusObjectSkeleton(_ptr: [*c]([*c]GDBusObjectSkeleton)) void {
    glib_autoptr_clear_GDBusObjectSkeleton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusObjectSkeleton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusObjectSkeleton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusObjectSkeleton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusProxy_autoptr = [*c]GDBusProxy;
pub const GDBusProxy_listautoptr = [*c]GList;
pub const GDBusProxy_slistautoptr = [*c]GSList;
pub const GDBusProxy_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusProxy(_ptr: [*c]GDBusProxy) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusProxy(_ptr: [*c]([*c]GDBusProxy)) void {
    glib_autoptr_clear_GDBusProxy(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusProxy(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusProxy(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusProxy(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDBusServer_autoptr = ?*GDBusServer;
pub const GDBusServer_listautoptr = [*c]GList;
pub const GDBusServer_slistautoptr = [*c]GSList;
pub const GDBusServer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDBusServer(_ptr: ?*GDBusServer) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDBusServer(_ptr: [*c](?*GDBusServer)) void {
    glib_autoptr_clear_GDBusServer(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDBusServer(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDBusServer(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDBusServer(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GDrive_autoptr = ?*GDrive;
pub const GDrive_listautoptr = [*c]GList;
pub const GDrive_slistautoptr = [*c]GSList;
pub const GDrive_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GDrive(_ptr: ?*GDrive) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GDrive(_ptr: [*c](?*GDrive)) void {
    glib_autoptr_clear_GDrive(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GDrive(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GDrive(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GDrive(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GEmblemedIcon_autoptr = [*c]GEmblemedIcon;
pub const GEmblemedIcon_listautoptr = [*c]GList;
pub const GEmblemedIcon_slistautoptr = [*c]GSList;
pub const GEmblemedIcon_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GEmblemedIcon(_ptr: [*c]GEmblemedIcon) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GEmblemedIcon(_ptr: [*c]([*c]GEmblemedIcon)) void {
    glib_autoptr_clear_GEmblemedIcon(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GEmblemedIcon(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GEmblemedIcon(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GEmblemedIcon(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GEmblem_autoptr = ?*GEmblem;
pub const GEmblem_listautoptr = [*c]GList;
pub const GEmblem_slistautoptr = [*c]GSList;
pub const GEmblem_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GEmblem(_ptr: ?*GEmblem) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GEmblem(_ptr: [*c](?*GEmblem)) void {
    glib_autoptr_clear_GEmblem(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GEmblem(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GEmblem(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GEmblem(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GFileEnumerator_autoptr = [*c]GFileEnumerator;
pub const GFileEnumerator_listautoptr = [*c]GList;
pub const GFileEnumerator_slistautoptr = [*c]GSList;
pub const GFileEnumerator_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileEnumerator(_ptr: [*c]GFileEnumerator) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GFileEnumerator(_ptr: [*c]([*c]GFileEnumerator)) void {
    glib_autoptr_clear_GFileEnumerator(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GFileEnumerator(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFileEnumerator(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFileEnumerator(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GFile_autoptr = ?*GFile;
pub const GFile_listautoptr = [*c]GList;
pub const GFile_slistautoptr = [*c]GSList;
pub const GFile_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFile(_ptr: ?*GFile) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GFile(_ptr: [*c](?*GFile)) void {
    glib_autoptr_clear_GFile(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GFile(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFile(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFile(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GFileAttributeInfoList_autoptr = [*c]GFileAttributeInfoList;
pub const GFileAttributeInfoList_listautoptr = [*c]GList;
pub const GFileAttributeInfoList_slistautoptr = [*c]GSList;
pub const GFileAttributeInfoList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileAttributeInfoList(_ptr: [*c]GFileAttributeInfoList) void {
    if (_ptr != null) g_file_attribute_info_list_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GFileAttributeInfoList(_ptr: [*c]([*c]GFileAttributeInfoList)) void {
    glib_autoptr_clear_GFileAttributeInfoList(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GFileAttributeInfoList(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_file_attribute_info_list_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFileAttributeInfoList(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_file_attribute_info_list_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFileAttributeInfoList(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_file_attribute_info_list_unref)))));
}
pub const GFileIcon_autoptr = ?*GFileIcon;
pub const GFileIcon_listautoptr = [*c]GList;
pub const GFileIcon_slistautoptr = [*c]GSList;
pub const GFileIcon_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileIcon(_ptr: ?*GFileIcon) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GFileIcon(_ptr: [*c](?*GFileIcon)) void {
    glib_autoptr_clear_GFileIcon(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GFileIcon(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFileIcon(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFileIcon(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GFileInfo_autoptr = ?*GFileInfo;
pub const GFileInfo_listautoptr = [*c]GList;
pub const GFileInfo_slistautoptr = [*c]GSList;
pub const GFileInfo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileInfo(_ptr: ?*GFileInfo) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GFileInfo(_ptr: [*c](?*GFileInfo)) void {
    glib_autoptr_clear_GFileInfo(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GFileInfo(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFileInfo(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFileInfo(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GFileInputStream_autoptr = [*c]GFileInputStream;
pub const GFileInputStream_listautoptr = [*c]GList;
pub const GFileInputStream_slistautoptr = [*c]GSList;
pub const GFileInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileInputStream(_ptr: [*c]GFileInputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GFileInputStream(_ptr: [*c]([*c]GFileInputStream)) void {
    glib_autoptr_clear_GFileInputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GFileInputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFileInputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFileInputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GFileIOStream_autoptr = [*c]GFileIOStream;
pub const GFileIOStream_listautoptr = [*c]GList;
pub const GFileIOStream_slistautoptr = [*c]GSList;
pub const GFileIOStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileIOStream(_ptr: [*c]GFileIOStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GFileIOStream(_ptr: [*c]([*c]GFileIOStream)) void {
    glib_autoptr_clear_GFileIOStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GFileIOStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFileIOStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFileIOStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GFileMonitor_autoptr = [*c]GFileMonitor;
pub const GFileMonitor_listautoptr = [*c]GList;
pub const GFileMonitor_slistautoptr = [*c]GSList;
pub const GFileMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileMonitor(_ptr: [*c]GFileMonitor) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GFileMonitor(_ptr: [*c]([*c]GFileMonitor)) void {
    glib_autoptr_clear_GFileMonitor(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GFileMonitor(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFileMonitor(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFileMonitor(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GFilenameCompleter_autoptr = ?*GFilenameCompleter;
pub const GFilenameCompleter_listautoptr = [*c]GList;
pub const GFilenameCompleter_slistautoptr = [*c]GSList;
pub const GFilenameCompleter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFilenameCompleter(_ptr: ?*GFilenameCompleter) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GFilenameCompleter(_ptr: [*c](?*GFilenameCompleter)) void {
    glib_autoptr_clear_GFilenameCompleter(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GFilenameCompleter(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFilenameCompleter(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFilenameCompleter(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GFileOutputStream_autoptr = [*c]GFileOutputStream;
pub const GFileOutputStream_listautoptr = [*c]GList;
pub const GFileOutputStream_slistautoptr = [*c]GSList;
pub const GFileOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFileOutputStream(_ptr: [*c]GFileOutputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GFileOutputStream(_ptr: [*c]([*c]GFileOutputStream)) void {
    glib_autoptr_clear_GFileOutputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GFileOutputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFileOutputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFileOutputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GFilterInputStream_autoptr = [*c]GFilterInputStream;
pub const GFilterInputStream_listautoptr = [*c]GList;
pub const GFilterInputStream_slistautoptr = [*c]GSList;
pub const GFilterInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFilterInputStream(_ptr: [*c]GFilterInputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GFilterInputStream(_ptr: [*c]([*c]GFilterInputStream)) void {
    glib_autoptr_clear_GFilterInputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GFilterInputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFilterInputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFilterInputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GFilterOutputStream_autoptr = [*c]GFilterOutputStream;
pub const GFilterOutputStream_listautoptr = [*c]GList;
pub const GFilterOutputStream_slistautoptr = [*c]GSList;
pub const GFilterOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GFilterOutputStream(_ptr: [*c]GFilterOutputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GFilterOutputStream(_ptr: [*c]([*c]GFilterOutputStream)) void {
    glib_autoptr_clear_GFilterOutputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GFilterOutputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GFilterOutputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GFilterOutputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GIcon_autoptr = ?*GIcon;
pub const GIcon_listautoptr = [*c]GList;
pub const GIcon_slistautoptr = [*c]GSList;
pub const GIcon_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GIcon(_ptr: ?*GIcon) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GIcon(_ptr: [*c](?*GIcon)) void {
    glib_autoptr_clear_GIcon(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GIcon(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GIcon(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GIcon(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GInetAddress_autoptr = [*c]GInetAddress;
pub const GInetAddress_listautoptr = [*c]GList;
pub const GInetAddress_slistautoptr = [*c]GSList;
pub const GInetAddress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GInetAddress(_ptr: [*c]GInetAddress) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GInetAddress(_ptr: [*c]([*c]GInetAddress)) void {
    glib_autoptr_clear_GInetAddress(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GInetAddress(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GInetAddress(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GInetAddress(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GInetAddressMask_autoptr = [*c]GInetAddressMask;
pub const GInetAddressMask_listautoptr = [*c]GList;
pub const GInetAddressMask_slistautoptr = [*c]GSList;
pub const GInetAddressMask_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GInetAddressMask(_ptr: [*c]GInetAddressMask) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GInetAddressMask(_ptr: [*c]([*c]GInetAddressMask)) void {
    glib_autoptr_clear_GInetAddressMask(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GInetAddressMask(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GInetAddressMask(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GInetAddressMask(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GInetSocketAddress_autoptr = [*c]GInetSocketAddress;
pub const GInetSocketAddress_listautoptr = [*c]GList;
pub const GInetSocketAddress_slistautoptr = [*c]GSList;
pub const GInetSocketAddress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GInetSocketAddress(_ptr: [*c]GInetSocketAddress) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GInetSocketAddress(_ptr: [*c]([*c]GInetSocketAddress)) void {
    glib_autoptr_clear_GInetSocketAddress(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GInetSocketAddress(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GInetSocketAddress(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GInetSocketAddress(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GInitable_autoptr = ?*GInitable;
pub const GInitable_listautoptr = [*c]GList;
pub const GInitable_slistautoptr = [*c]GSList;
pub const GInitable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GInitable(_ptr: ?*GInitable) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GInitable(_ptr: [*c](?*GInitable)) void {
    glib_autoptr_clear_GInitable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GInitable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GInitable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GInitable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GInputStream_autoptr = [*c]GInputStream;
pub const GInputStream_listautoptr = [*c]GList;
pub const GInputStream_slistautoptr = [*c]GSList;
pub const GInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GInputStream(_ptr: [*c]GInputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GInputStream(_ptr: [*c]([*c]GInputStream)) void {
    glib_autoptr_clear_GInputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GInputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GInputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GInputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GIOModule_autoptr = ?*GIOModule;
pub const GIOModule_listautoptr = [*c]GList;
pub const GIOModule_slistautoptr = [*c]GSList;
pub const GIOModule_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GIOModule(_ptr: ?*GIOModule) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GIOModule(_ptr: [*c](?*GIOModule)) void {
    glib_autoptr_clear_GIOModule(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GIOModule(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GIOModule(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GIOModule(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GIOStream_autoptr = [*c]GIOStream;
pub const GIOStream_listautoptr = [*c]GList;
pub const GIOStream_slistautoptr = [*c]GSList;
pub const GIOStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GIOStream(_ptr: [*c]GIOStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GIOStream(_ptr: [*c]([*c]GIOStream)) void {
    glib_autoptr_clear_GIOStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GIOStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GIOStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GIOStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GLoadableIcon_autoptr = ?*GLoadableIcon;
pub const GLoadableIcon_listautoptr = [*c]GList;
pub const GLoadableIcon_slistautoptr = [*c]GSList;
pub const GLoadableIcon_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GLoadableIcon(_ptr: ?*GLoadableIcon) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GLoadableIcon(_ptr: [*c](?*GLoadableIcon)) void {
    glib_autoptr_clear_GLoadableIcon(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GLoadableIcon(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GLoadableIcon(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GLoadableIcon(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GMemoryInputStream_autoptr = [*c]GMemoryInputStream;
pub const GMemoryInputStream_listautoptr = [*c]GList;
pub const GMemoryInputStream_slistautoptr = [*c]GSList;
pub const GMemoryInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMemoryInputStream(_ptr: [*c]GMemoryInputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GMemoryInputStream(_ptr: [*c]([*c]GMemoryInputStream)) void {
    glib_autoptr_clear_GMemoryInputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMemoryInputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMemoryInputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMemoryInputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GMemoryOutputStream_autoptr = [*c]GMemoryOutputStream;
pub const GMemoryOutputStream_listautoptr = [*c]GList;
pub const GMemoryOutputStream_slistautoptr = [*c]GSList;
pub const GMemoryOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMemoryOutputStream(_ptr: [*c]GMemoryOutputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GMemoryOutputStream(_ptr: [*c]([*c]GMemoryOutputStream)) void {
    glib_autoptr_clear_GMemoryOutputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMemoryOutputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMemoryOutputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMemoryOutputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GMenu_autoptr = ?*GMenu;
pub const GMenu_listautoptr = [*c]GList;
pub const GMenu_slistautoptr = [*c]GSList;
pub const GMenu_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMenu(_ptr: ?*GMenu) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GMenu(_ptr: [*c](?*GMenu)) void {
    glib_autoptr_clear_GMenu(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMenu(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMenu(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMenu(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GMenuItem_autoptr = ?*GMenuItem;
pub const GMenuItem_listautoptr = [*c]GList;
pub const GMenuItem_slistautoptr = [*c]GSList;
pub const GMenuItem_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMenuItem(_ptr: ?*GMenuItem) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GMenuItem(_ptr: [*c](?*GMenuItem)) void {
    glib_autoptr_clear_GMenuItem(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMenuItem(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMenuItem(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMenuItem(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GMenuModel_autoptr = [*c]GMenuModel;
pub const GMenuModel_listautoptr = [*c]GList;
pub const GMenuModel_slistautoptr = [*c]GSList;
pub const GMenuModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMenuModel(_ptr: [*c]GMenuModel) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GMenuModel(_ptr: [*c]([*c]GMenuModel)) void {
    glib_autoptr_clear_GMenuModel(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMenuModel(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMenuModel(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMenuModel(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GMenuAttributeIter_autoptr = [*c]GMenuAttributeIter;
pub const GMenuAttributeIter_listautoptr = [*c]GList;
pub const GMenuAttributeIter_slistautoptr = [*c]GSList;
pub const GMenuAttributeIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMenuAttributeIter(_ptr: [*c]GMenuAttributeIter) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GMenuAttributeIter(_ptr: [*c]([*c]GMenuAttributeIter)) void {
    glib_autoptr_clear_GMenuAttributeIter(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMenuAttributeIter(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMenuAttributeIter(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMenuAttributeIter(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GMenuLinkIter_autoptr = [*c]GMenuLinkIter;
pub const GMenuLinkIter_listautoptr = [*c]GList;
pub const GMenuLinkIter_slistautoptr = [*c]GSList;
pub const GMenuLinkIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMenuLinkIter(_ptr: [*c]GMenuLinkIter) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GMenuLinkIter(_ptr: [*c]([*c]GMenuLinkIter)) void {
    glib_autoptr_clear_GMenuLinkIter(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMenuLinkIter(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMenuLinkIter(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMenuLinkIter(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GMount_autoptr = ?*GMount;
pub const GMount_listautoptr = [*c]GList;
pub const GMount_slistautoptr = [*c]GSList;
pub const GMount_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMount(_ptr: ?*GMount) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GMount(_ptr: [*c](?*GMount)) void {
    glib_autoptr_clear_GMount(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMount(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMount(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMount(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GMountOperation_autoptr = [*c]GMountOperation;
pub const GMountOperation_listautoptr = [*c]GList;
pub const GMountOperation_slistautoptr = [*c]GSList;
pub const GMountOperation_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GMountOperation(_ptr: [*c]GMountOperation) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GMountOperation(_ptr: [*c]([*c]GMountOperation)) void {
    glib_autoptr_clear_GMountOperation(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GMountOperation(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GMountOperation(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GMountOperation(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GNativeVolumeMonitor_autoptr = [*c]GNativeVolumeMonitor;
pub const GNativeVolumeMonitor_listautoptr = [*c]GList;
pub const GNativeVolumeMonitor_slistautoptr = [*c]GSList;
pub const GNativeVolumeMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GNativeVolumeMonitor(_ptr: [*c]GNativeVolumeMonitor) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GNativeVolumeMonitor(_ptr: [*c]([*c]GNativeVolumeMonitor)) void {
    glib_autoptr_clear_GNativeVolumeMonitor(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GNativeVolumeMonitor(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GNativeVolumeMonitor(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GNativeVolumeMonitor(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GNetworkAddress_autoptr = [*c]GNetworkAddress;
pub const GNetworkAddress_listautoptr = [*c]GList;
pub const GNetworkAddress_slistautoptr = [*c]GSList;
pub const GNetworkAddress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GNetworkAddress(_ptr: [*c]GNetworkAddress) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GNetworkAddress(_ptr: [*c]([*c]GNetworkAddress)) void {
    glib_autoptr_clear_GNetworkAddress(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GNetworkAddress(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GNetworkAddress(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GNetworkAddress(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GNetworkMonitor_autoptr = ?*GNetworkMonitor;
pub const GNetworkMonitor_listautoptr = [*c]GList;
pub const GNetworkMonitor_slistautoptr = [*c]GSList;
pub const GNetworkMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GNetworkMonitor(_ptr: ?*GNetworkMonitor) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GNetworkMonitor(_ptr: [*c](?*GNetworkMonitor)) void {
    glib_autoptr_clear_GNetworkMonitor(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GNetworkMonitor(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GNetworkMonitor(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GNetworkMonitor(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GNetworkService_autoptr = [*c]GNetworkService;
pub const GNetworkService_listautoptr = [*c]GList;
pub const GNetworkService_slistautoptr = [*c]GSList;
pub const GNetworkService_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GNetworkService(_ptr: [*c]GNetworkService) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GNetworkService(_ptr: [*c]([*c]GNetworkService)) void {
    glib_autoptr_clear_GNetworkService(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GNetworkService(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GNetworkService(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GNetworkService(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GNotification_autoptr = ?*GNotification;
pub const GNotification_listautoptr = [*c]GList;
pub const GNotification_slistautoptr = [*c]GSList;
pub const GNotification_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GNotification(_ptr: ?*GNotification) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GNotification(_ptr: [*c](?*GNotification)) void {
    glib_autoptr_clear_GNotification(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GNotification(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GNotification(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GNotification(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GOutputStream_autoptr = [*c]GOutputStream;
pub const GOutputStream_listautoptr = [*c]GList;
pub const GOutputStream_slistautoptr = [*c]GSList;
pub const GOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GOutputStream(_ptr: [*c]GOutputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GOutputStream(_ptr: [*c]([*c]GOutputStream)) void {
    glib_autoptr_clear_GOutputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GOutputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GOutputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GOutputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GPermission_autoptr = [*c]GPermission;
pub const GPermission_listautoptr = [*c]GList;
pub const GPermission_slistautoptr = [*c]GSList;
pub const GPermission_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPermission(_ptr: [*c]GPermission) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GPermission(_ptr: [*c]([*c]GPermission)) void {
    glib_autoptr_clear_GPermission(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GPermission(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GPermission(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GPermission(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GPollableInputStream_autoptr = ?*GPollableInputStream;
pub const GPollableInputStream_listautoptr = [*c]GList;
pub const GPollableInputStream_slistautoptr = [*c]GSList;
pub const GPollableInputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPollableInputStream(_ptr: ?*GPollableInputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GPollableInputStream(_ptr: [*c](?*GPollableInputStream)) void {
    glib_autoptr_clear_GPollableInputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GPollableInputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GPollableInputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GPollableInputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GPollableOutputStream_autoptr = ?*GPollableOutputStream;
pub const GPollableOutputStream_listautoptr = [*c]GList;
pub const GPollableOutputStream_slistautoptr = [*c]GSList;
pub const GPollableOutputStream_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPollableOutputStream(_ptr: ?*GPollableOutputStream) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GPollableOutputStream(_ptr: [*c](?*GPollableOutputStream)) void {
    glib_autoptr_clear_GPollableOutputStream(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GPollableOutputStream(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GPollableOutputStream(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GPollableOutputStream(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GPropertyAction_autoptr = ?*GPropertyAction;
pub const GPropertyAction_listautoptr = [*c]GList;
pub const GPropertyAction_slistautoptr = [*c]GSList;
pub const GPropertyAction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GPropertyAction(_ptr: ?*GPropertyAction) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GPropertyAction(_ptr: [*c](?*GPropertyAction)) void {
    glib_autoptr_clear_GPropertyAction(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GPropertyAction(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GPropertyAction(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GPropertyAction(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GProxyAddressEnumerator_autoptr = [*c]GProxyAddressEnumerator;
pub const GProxyAddressEnumerator_listautoptr = [*c]GList;
pub const GProxyAddressEnumerator_slistautoptr = [*c]GSList;
pub const GProxyAddressEnumerator_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GProxyAddressEnumerator(_ptr: [*c]GProxyAddressEnumerator) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GProxyAddressEnumerator(_ptr: [*c]([*c]GProxyAddressEnumerator)) void {
    glib_autoptr_clear_GProxyAddressEnumerator(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GProxyAddressEnumerator(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GProxyAddressEnumerator(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GProxyAddressEnumerator(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GProxyAddress_autoptr = [*c]GProxyAddress;
pub const GProxyAddress_listautoptr = [*c]GList;
pub const GProxyAddress_slistautoptr = [*c]GSList;
pub const GProxyAddress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GProxyAddress(_ptr: [*c]GProxyAddress) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GProxyAddress(_ptr: [*c]([*c]GProxyAddress)) void {
    glib_autoptr_clear_GProxyAddress(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GProxyAddress(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GProxyAddress(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GProxyAddress(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GProxy_autoptr = ?*GProxy;
pub const GProxy_listautoptr = [*c]GList;
pub const GProxy_slistautoptr = [*c]GSList;
pub const GProxy_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GProxy(_ptr: ?*GProxy) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GProxy(_ptr: [*c](?*GProxy)) void {
    glib_autoptr_clear_GProxy(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GProxy(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GProxy(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GProxy(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GProxyResolver_autoptr = ?*GProxyResolver;
pub const GProxyResolver_listautoptr = [*c]GList;
pub const GProxyResolver_slistautoptr = [*c]GSList;
pub const GProxyResolver_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GProxyResolver(_ptr: ?*GProxyResolver) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GProxyResolver(_ptr: [*c](?*GProxyResolver)) void {
    glib_autoptr_clear_GProxyResolver(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GProxyResolver(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GProxyResolver(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GProxyResolver(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GRemoteActionGroup_autoptr = ?*GRemoteActionGroup;
pub const GRemoteActionGroup_listautoptr = [*c]GList;
pub const GRemoteActionGroup_slistautoptr = [*c]GSList;
pub const GRemoteActionGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GRemoteActionGroup(_ptr: ?*GRemoteActionGroup) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GRemoteActionGroup(_ptr: [*c](?*GRemoteActionGroup)) void {
    glib_autoptr_clear_GRemoteActionGroup(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GRemoteActionGroup(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GRemoteActionGroup(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GRemoteActionGroup(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GResolver_autoptr = [*c]GResolver;
pub const GResolver_listautoptr = [*c]GList;
pub const GResolver_slistautoptr = [*c]GSList;
pub const GResolver_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GResolver(_ptr: [*c]GResolver) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GResolver(_ptr: [*c]([*c]GResolver)) void {
    glib_autoptr_clear_GResolver(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GResolver(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GResolver(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GResolver(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GResource_autoptr = ?*GResource;
pub const GResource_listautoptr = [*c]GList;
pub const GResource_slistautoptr = [*c]GSList;
pub const GResource_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GResource(_ptr: ?*GResource) void {
    if (_ptr != null) g_resource_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GResource(_ptr: [*c](?*GResource)) void {
    glib_autoptr_clear_GResource(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GResource(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_resource_unref)))));
}
pub fn glib_slistautoptr_cleanup_GResource(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_resource_unref)))));
}
pub fn glib_queueautoptr_cleanup_GResource(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_resource_unref)))));
}
pub const GSeekable_autoptr = ?*GSeekable;
pub const GSeekable_listautoptr = [*c]GList;
pub const GSeekable_slistautoptr = [*c]GSList;
pub const GSeekable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSeekable(_ptr: ?*GSeekable) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSeekable(_ptr: [*c](?*GSeekable)) void {
    glib_autoptr_clear_GSeekable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSeekable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSeekable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSeekable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSettingsBackend_autoptr = ?*GSettingsBackend;
pub const GSettingsBackend_listautoptr = [*c]GList;
pub const GSettingsBackend_slistautoptr = [*c]GSList;
pub const GSettingsBackend_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSettingsBackend(_ptr: ?*GSettingsBackend) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSettingsBackend(_ptr: [*c](?*GSettingsBackend)) void {
    glib_autoptr_clear_GSettingsBackend(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSettingsBackend(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSettingsBackend(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSettingsBackend(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSettingsSchema_autoptr = ?*GSettingsSchema;
pub const GSettingsSchema_listautoptr = [*c]GList;
pub const GSettingsSchema_slistautoptr = [*c]GSList;
pub const GSettingsSchema_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSettingsSchema(_ptr: ?*GSettingsSchema) void {
    if (_ptr != null) g_settings_schema_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GSettingsSchema(_ptr: [*c](?*GSettingsSchema)) void {
    glib_autoptr_clear_GSettingsSchema(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSettingsSchema(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_settings_schema_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSettingsSchema(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_settings_schema_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSettingsSchema(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_settings_schema_unref)))));
}
pub const GSettingsSchemaKey_autoptr = ?*GSettingsSchemaKey;
pub const GSettingsSchemaKey_listautoptr = [*c]GList;
pub const GSettingsSchemaKey_slistautoptr = [*c]GSList;
pub const GSettingsSchemaKey_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSettingsSchemaKey(_ptr: ?*GSettingsSchemaKey) void {
    if (_ptr != null) g_settings_schema_key_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GSettingsSchemaKey(_ptr: [*c](?*GSettingsSchemaKey)) void {
    glib_autoptr_clear_GSettingsSchemaKey(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSettingsSchemaKey(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_settings_schema_key_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSettingsSchemaKey(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_settings_schema_key_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSettingsSchemaKey(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_settings_schema_key_unref)))));
}
pub const GSettingsSchemaSource_autoptr = ?*GSettingsSchemaSource;
pub const GSettingsSchemaSource_listautoptr = [*c]GList;
pub const GSettingsSchemaSource_slistautoptr = [*c]GSList;
pub const GSettingsSchemaSource_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSettingsSchemaSource(_ptr: ?*GSettingsSchemaSource) void {
    if (_ptr != null) g_settings_schema_source_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GSettingsSchemaSource(_ptr: [*c](?*GSettingsSchemaSource)) void {
    glib_autoptr_clear_GSettingsSchemaSource(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSettingsSchemaSource(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_settings_schema_source_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSettingsSchemaSource(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_settings_schema_source_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSettingsSchemaSource(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_settings_schema_source_unref)))));
}
pub const GSettings_autoptr = [*c]GSettings;
pub const GSettings_listautoptr = [*c]GList;
pub const GSettings_slistautoptr = [*c]GSList;
pub const GSettings_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSettings(_ptr: [*c]GSettings) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSettings(_ptr: [*c]([*c]GSettings)) void {
    glib_autoptr_clear_GSettings(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSettings(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSettings(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSettings(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSimpleActionGroup_autoptr = [*c]GSimpleActionGroup;
pub const GSimpleActionGroup_listautoptr = [*c]GList;
pub const GSimpleActionGroup_slistautoptr = [*c]GSList;
pub const GSimpleActionGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSimpleActionGroup(_ptr: [*c]GSimpleActionGroup) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSimpleActionGroup(_ptr: [*c]([*c]GSimpleActionGroup)) void {
    glib_autoptr_clear_GSimpleActionGroup(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSimpleActionGroup(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSimpleActionGroup(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSimpleActionGroup(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSimpleAction_autoptr = ?*GSimpleAction;
pub const GSimpleAction_listautoptr = [*c]GList;
pub const GSimpleAction_slistautoptr = [*c]GSList;
pub const GSimpleAction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSimpleAction(_ptr: ?*GSimpleAction) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSimpleAction(_ptr: [*c](?*GSimpleAction)) void {
    glib_autoptr_clear_GSimpleAction(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSimpleAction(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSimpleAction(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSimpleAction(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSimpleAsyncResult_autoptr = ?*GSimpleAsyncResult;
pub const GSimpleAsyncResult_listautoptr = [*c]GList;
pub const GSimpleAsyncResult_slistautoptr = [*c]GSList;
pub const GSimpleAsyncResult_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSimpleAsyncResult(_ptr: ?*GSimpleAsyncResult) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSimpleAsyncResult(_ptr: [*c](?*GSimpleAsyncResult)) void {
    glib_autoptr_clear_GSimpleAsyncResult(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSimpleAsyncResult(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSimpleAsyncResult(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSimpleAsyncResult(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSimplePermission_autoptr = ?*GSimplePermission;
pub const GSimplePermission_listautoptr = [*c]GList;
pub const GSimplePermission_slistautoptr = [*c]GSList;
pub const GSimplePermission_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSimplePermission(_ptr: ?*GSimplePermission) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSimplePermission(_ptr: [*c](?*GSimplePermission)) void {
    glib_autoptr_clear_GSimplePermission(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSimplePermission(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSimplePermission(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSimplePermission(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSimpleProxyResolver_autoptr = [*c]GSimpleProxyResolver;
pub const GSimpleProxyResolver_listautoptr = [*c]GList;
pub const GSimpleProxyResolver_slistautoptr = [*c]GSList;
pub const GSimpleProxyResolver_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSimpleProxyResolver(_ptr: [*c]GSimpleProxyResolver) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSimpleProxyResolver(_ptr: [*c]([*c]GSimpleProxyResolver)) void {
    glib_autoptr_clear_GSimpleProxyResolver(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSimpleProxyResolver(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSimpleProxyResolver(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSimpleProxyResolver(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSocketAddressEnumerator_autoptr = [*c]GSocketAddressEnumerator;
pub const GSocketAddressEnumerator_listautoptr = [*c]GList;
pub const GSocketAddressEnumerator_slistautoptr = [*c]GSList;
pub const GSocketAddressEnumerator_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketAddressEnumerator(_ptr: [*c]GSocketAddressEnumerator) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSocketAddressEnumerator(_ptr: [*c]([*c]GSocketAddressEnumerator)) void {
    glib_autoptr_clear_GSocketAddressEnumerator(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSocketAddressEnumerator(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSocketAddressEnumerator(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSocketAddressEnumerator(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSocketAddress_autoptr = [*c]GSocketAddress;
pub const GSocketAddress_listautoptr = [*c]GList;
pub const GSocketAddress_slistautoptr = [*c]GSList;
pub const GSocketAddress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketAddress(_ptr: [*c]GSocketAddress) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSocketAddress(_ptr: [*c]([*c]GSocketAddress)) void {
    glib_autoptr_clear_GSocketAddress(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSocketAddress(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSocketAddress(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSocketAddress(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSocketClient_autoptr = [*c]GSocketClient;
pub const GSocketClient_listautoptr = [*c]GList;
pub const GSocketClient_slistautoptr = [*c]GSList;
pub const GSocketClient_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketClient(_ptr: [*c]GSocketClient) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSocketClient(_ptr: [*c]([*c]GSocketClient)) void {
    glib_autoptr_clear_GSocketClient(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSocketClient(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSocketClient(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSocketClient(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSocketConnectable_autoptr = ?*GSocketConnectable;
pub const GSocketConnectable_listautoptr = [*c]GList;
pub const GSocketConnectable_slistautoptr = [*c]GSList;
pub const GSocketConnectable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketConnectable(_ptr: ?*GSocketConnectable) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSocketConnectable(_ptr: [*c](?*GSocketConnectable)) void {
    glib_autoptr_clear_GSocketConnectable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSocketConnectable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSocketConnectable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSocketConnectable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSocketConnection_autoptr = [*c]GSocketConnection;
pub const GSocketConnection_listautoptr = [*c]GList;
pub const GSocketConnection_slistautoptr = [*c]GSList;
pub const GSocketConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketConnection(_ptr: [*c]GSocketConnection) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSocketConnection(_ptr: [*c]([*c]GSocketConnection)) void {
    glib_autoptr_clear_GSocketConnection(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSocketConnection(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSocketConnection(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSocketConnection(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSocketControlMessage_autoptr = [*c]GSocketControlMessage;
pub const GSocketControlMessage_listautoptr = [*c]GList;
pub const GSocketControlMessage_slistautoptr = [*c]GSList;
pub const GSocketControlMessage_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketControlMessage(_ptr: [*c]GSocketControlMessage) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSocketControlMessage(_ptr: [*c]([*c]GSocketControlMessage)) void {
    glib_autoptr_clear_GSocketControlMessage(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSocketControlMessage(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSocketControlMessage(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSocketControlMessage(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSocket_autoptr = [*c]GSocket;
pub const GSocket_listautoptr = [*c]GList;
pub const GSocket_slistautoptr = [*c]GSList;
pub const GSocket_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocket(_ptr: [*c]GSocket) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSocket(_ptr: [*c]([*c]GSocket)) void {
    glib_autoptr_clear_GSocket(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSocket(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSocket(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSocket(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSocketListener_autoptr = [*c]GSocketListener;
pub const GSocketListener_listautoptr = [*c]GList;
pub const GSocketListener_slistautoptr = [*c]GSList;
pub const GSocketListener_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketListener(_ptr: [*c]GSocketListener) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSocketListener(_ptr: [*c]([*c]GSocketListener)) void {
    glib_autoptr_clear_GSocketListener(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSocketListener(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSocketListener(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSocketListener(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSocketService_autoptr = [*c]GSocketService;
pub const GSocketService_listautoptr = [*c]GList;
pub const GSocketService_slistautoptr = [*c]GSList;
pub const GSocketService_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSocketService(_ptr: [*c]GSocketService) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSocketService(_ptr: [*c]([*c]GSocketService)) void {
    glib_autoptr_clear_GSocketService(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSocketService(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSocketService(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSocketService(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSubprocess_autoptr = ?*GSubprocess;
pub const GSubprocess_listautoptr = [*c]GList;
pub const GSubprocess_slistautoptr = [*c]GSList;
pub const GSubprocess_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSubprocess(_ptr: ?*GSubprocess) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSubprocess(_ptr: [*c](?*GSubprocess)) void {
    glib_autoptr_clear_GSubprocess(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSubprocess(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSubprocess(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSubprocess(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GSubprocessLauncher_autoptr = ?*GSubprocessLauncher;
pub const GSubprocessLauncher_listautoptr = [*c]GList;
pub const GSubprocessLauncher_slistautoptr = [*c]GSList;
pub const GSubprocessLauncher_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GSubprocessLauncher(_ptr: ?*GSubprocessLauncher) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GSubprocessLauncher(_ptr: [*c](?*GSubprocessLauncher)) void {
    glib_autoptr_clear_GSubprocessLauncher(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GSubprocessLauncher(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GSubprocessLauncher(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GSubprocessLauncher(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTask_autoptr = ?*GTask;
pub const GTask_listautoptr = [*c]GList;
pub const GTask_slistautoptr = [*c]GSList;
pub const GTask_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTask(_ptr: ?*GTask) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTask(_ptr: [*c](?*GTask)) void {
    glib_autoptr_clear_GTask(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTask(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTask(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTask(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTcpConnection_autoptr = [*c]GTcpConnection;
pub const GTcpConnection_listautoptr = [*c]GList;
pub const GTcpConnection_slistautoptr = [*c]GSList;
pub const GTcpConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTcpConnection(_ptr: [*c]GTcpConnection) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTcpConnection(_ptr: [*c]([*c]GTcpConnection)) void {
    glib_autoptr_clear_GTcpConnection(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTcpConnection(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTcpConnection(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTcpConnection(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTcpWrapperConnection_autoptr = [*c]GTcpWrapperConnection;
pub const GTcpWrapperConnection_listautoptr = [*c]GList;
pub const GTcpWrapperConnection_slistautoptr = [*c]GSList;
pub const GTcpWrapperConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTcpWrapperConnection(_ptr: [*c]GTcpWrapperConnection) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTcpWrapperConnection(_ptr: [*c]([*c]GTcpWrapperConnection)) void {
    glib_autoptr_clear_GTcpWrapperConnection(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTcpWrapperConnection(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTcpWrapperConnection(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTcpWrapperConnection(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTestDBus_autoptr = ?*GTestDBus;
pub const GTestDBus_listautoptr = [*c]GList;
pub const GTestDBus_slistautoptr = [*c]GSList;
pub const GTestDBus_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTestDBus(_ptr: ?*GTestDBus) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTestDBus(_ptr: [*c](?*GTestDBus)) void {
    glib_autoptr_clear_GTestDBus(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTestDBus(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTestDBus(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTestDBus(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GThemedIcon_autoptr = ?*GThemedIcon;
pub const GThemedIcon_listautoptr = [*c]GList;
pub const GThemedIcon_slistautoptr = [*c]GSList;
pub const GThemedIcon_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GThemedIcon(_ptr: ?*GThemedIcon) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GThemedIcon(_ptr: [*c](?*GThemedIcon)) void {
    glib_autoptr_clear_GThemedIcon(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GThemedIcon(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GThemedIcon(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GThemedIcon(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GThreadedSocketService_autoptr = [*c]GThreadedSocketService;
pub const GThreadedSocketService_listautoptr = [*c]GList;
pub const GThreadedSocketService_slistautoptr = [*c]GSList;
pub const GThreadedSocketService_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GThreadedSocketService(_ptr: [*c]GThreadedSocketService) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GThreadedSocketService(_ptr: [*c]([*c]GThreadedSocketService)) void {
    glib_autoptr_clear_GThreadedSocketService(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GThreadedSocketService(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GThreadedSocketService(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GThreadedSocketService(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTlsBackend_autoptr = ?*GTlsBackend;
pub const GTlsBackend_listautoptr = [*c]GList;
pub const GTlsBackend_slistautoptr = [*c]GSList;
pub const GTlsBackend_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsBackend(_ptr: ?*GTlsBackend) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTlsBackend(_ptr: [*c](?*GTlsBackend)) void {
    glib_autoptr_clear_GTlsBackend(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTlsBackend(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTlsBackend(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTlsBackend(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTlsCertificate_autoptr = [*c]GTlsCertificate;
pub const GTlsCertificate_listautoptr = [*c]GList;
pub const GTlsCertificate_slistautoptr = [*c]GSList;
pub const GTlsCertificate_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsCertificate(_ptr: [*c]GTlsCertificate) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTlsCertificate(_ptr: [*c]([*c]GTlsCertificate)) void {
    glib_autoptr_clear_GTlsCertificate(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTlsCertificate(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTlsCertificate(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTlsCertificate(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTlsClientConnection_autoptr = ?*GTlsClientConnection;
pub const GTlsClientConnection_listautoptr = [*c]GList;
pub const GTlsClientConnection_slistautoptr = [*c]GSList;
pub const GTlsClientConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsClientConnection(_ptr: ?*GTlsClientConnection) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTlsClientConnection(_ptr: [*c](?*GTlsClientConnection)) void {
    glib_autoptr_clear_GTlsClientConnection(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTlsClientConnection(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTlsClientConnection(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTlsClientConnection(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTlsConnection_autoptr = [*c]GTlsConnection;
pub const GTlsConnection_listautoptr = [*c]GList;
pub const GTlsConnection_slistautoptr = [*c]GSList;
pub const GTlsConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsConnection(_ptr: [*c]GTlsConnection) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTlsConnection(_ptr: [*c]([*c]GTlsConnection)) void {
    glib_autoptr_clear_GTlsConnection(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTlsConnection(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTlsConnection(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTlsConnection(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTlsDatabase_autoptr = [*c]GTlsDatabase;
pub const GTlsDatabase_listautoptr = [*c]GList;
pub const GTlsDatabase_slistautoptr = [*c]GSList;
pub const GTlsDatabase_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsDatabase(_ptr: [*c]GTlsDatabase) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTlsDatabase(_ptr: [*c]([*c]GTlsDatabase)) void {
    glib_autoptr_clear_GTlsDatabase(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTlsDatabase(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTlsDatabase(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTlsDatabase(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTlsFileDatabase_autoptr = ?*GTlsFileDatabase;
pub const GTlsFileDatabase_listautoptr = [*c]GList;
pub const GTlsFileDatabase_slistautoptr = [*c]GSList;
pub const GTlsFileDatabase_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsFileDatabase(_ptr: ?*GTlsFileDatabase) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTlsFileDatabase(_ptr: [*c](?*GTlsFileDatabase)) void {
    glib_autoptr_clear_GTlsFileDatabase(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTlsFileDatabase(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTlsFileDatabase(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTlsFileDatabase(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTlsInteraction_autoptr = [*c]GTlsInteraction;
pub const GTlsInteraction_listautoptr = [*c]GList;
pub const GTlsInteraction_slistautoptr = [*c]GSList;
pub const GTlsInteraction_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsInteraction(_ptr: [*c]GTlsInteraction) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTlsInteraction(_ptr: [*c]([*c]GTlsInteraction)) void {
    glib_autoptr_clear_GTlsInteraction(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTlsInteraction(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTlsInteraction(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTlsInteraction(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTlsPassword_autoptr = [*c]GTlsPassword;
pub const GTlsPassword_listautoptr = [*c]GList;
pub const GTlsPassword_slistautoptr = [*c]GSList;
pub const GTlsPassword_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsPassword(_ptr: [*c]GTlsPassword) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTlsPassword(_ptr: [*c]([*c]GTlsPassword)) void {
    glib_autoptr_clear_GTlsPassword(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTlsPassword(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTlsPassword(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTlsPassword(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTlsServerConnection_autoptr = ?*GTlsServerConnection;
pub const GTlsServerConnection_listautoptr = [*c]GList;
pub const GTlsServerConnection_slistautoptr = [*c]GSList;
pub const GTlsServerConnection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GTlsServerConnection(_ptr: ?*GTlsServerConnection) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GTlsServerConnection(_ptr: [*c](?*GTlsServerConnection)) void {
    glib_autoptr_clear_GTlsServerConnection(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GTlsServerConnection(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GTlsServerConnection(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GTlsServerConnection(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GVfs_autoptr = [*c]GVfs;
pub const GVfs_listautoptr = [*c]GList;
pub const GVfs_slistautoptr = [*c]GSList;
pub const GVfs_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVfs(_ptr: [*c]GVfs) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GVfs(_ptr: [*c]([*c]GVfs)) void {
    glib_autoptr_clear_GVfs(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GVfs(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GVfs(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GVfs(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GVolume_autoptr = ?*GVolume;
pub const GVolume_listautoptr = [*c]GList;
pub const GVolume_slistautoptr = [*c]GSList;
pub const GVolume_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVolume(_ptr: ?*GVolume) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GVolume(_ptr: [*c](?*GVolume)) void {
    glib_autoptr_clear_GVolume(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GVolume(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GVolume(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GVolume(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GVolumeMonitor_autoptr = [*c]GVolumeMonitor;
pub const GVolumeMonitor_listautoptr = [*c]GList;
pub const GVolumeMonitor_slistautoptr = [*c]GSList;
pub const GVolumeMonitor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GVolumeMonitor(_ptr: [*c]GVolumeMonitor) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GVolumeMonitor(_ptr: [*c]([*c]GVolumeMonitor)) void {
    glib_autoptr_clear_GVolumeMonitor(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GVolumeMonitor(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GVolumeMonitor(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GVolumeMonitor(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GZlibCompressor_autoptr = ?*GZlibCompressor;
pub const GZlibCompressor_listautoptr = [*c]GList;
pub const GZlibCompressor_slistautoptr = [*c]GSList;
pub const GZlibCompressor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GZlibCompressor(_ptr: ?*GZlibCompressor) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GZlibCompressor(_ptr: [*c](?*GZlibCompressor)) void {
    glib_autoptr_clear_GZlibCompressor(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GZlibCompressor(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GZlibCompressor(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GZlibCompressor(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GZlibDecompressor_autoptr = ?*GZlibDecompressor;
pub const GZlibDecompressor_listautoptr = [*c]GList;
pub const GZlibDecompressor_slistautoptr = [*c]GSList;
pub const GZlibDecompressor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GZlibDecompressor(_ptr: ?*GZlibDecompressor) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GZlibDecompressor(_ptr: [*c](?*GZlibDecompressor)) void {
    glib_autoptr_clear_GZlibDecompressor(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GZlibDecompressor(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GZlibDecompressor(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GZlibDecompressor(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__PangoCoverage = @OpaqueType();
pub const PangoCoverage = struct__PangoCoverage;
pub const PANGO_COVERAGE_NONE = 0;
pub const PANGO_COVERAGE_FALLBACK = 1;
pub const PANGO_COVERAGE_APPROXIMATE = 2;
pub const PANGO_COVERAGE_EXACT = 3;
pub const PangoCoverageLevel = extern enum {
    PANGO_COVERAGE_NONE = 0,
    PANGO_COVERAGE_FALLBACK = 1,
    PANGO_COVERAGE_APPROXIMATE = 2,
    PANGO_COVERAGE_EXACT = 3,
};
pub extern fn pango_coverage_new() ?*PangoCoverage;
pub extern fn pango_coverage_ref(coverage: ?*PangoCoverage) ?*PangoCoverage;
pub extern fn pango_coverage_unref(coverage: ?*PangoCoverage) void;
pub extern fn pango_coverage_copy(coverage: ?*PangoCoverage) ?*PangoCoverage;
pub extern fn pango_coverage_get(coverage: ?*PangoCoverage, index_: c_int) PangoCoverageLevel;
pub extern fn pango_coverage_set(coverage: ?*PangoCoverage, index_: c_int, level: PangoCoverageLevel) void;
pub extern fn pango_coverage_max(coverage: ?*PangoCoverage, other: ?*PangoCoverage) void;
pub extern fn pango_coverage_to_bytes(coverage: ?*PangoCoverage, bytes: [*c]([*c]guchar), n_bytes: [*c]c_int) void;
pub extern fn pango_coverage_from_bytes(bytes: [*c]guchar, n_bytes: c_int) ?*PangoCoverage;
pub const struct__PangoLogAttr = @OpaqueType();
pub const PangoLogAttr = struct__PangoLogAttr;
pub const struct__PangoEngineLang = @OpaqueType();
pub const PangoEngineLang = struct__PangoEngineLang;
pub const struct__PangoEngineShape = @OpaqueType();
pub const PangoEngineShape = struct__PangoEngineShape;
pub const struct__PangoFont = @OpaqueType();
pub const PangoFont = struct__PangoFont;
pub const struct__PangoFontMap = @OpaqueType();
pub const PangoFontMap = struct__PangoFontMap;
pub const struct__PangoRectangle = extern struct {
    x: c_int,
    y: c_int,
    width: c_int,
    height: c_int,
};
pub const PangoRectangle = struct__PangoRectangle;
pub const PangoGlyph = guint32;
pub extern fn pango_units_from_double(d: f64) c_int;
pub extern fn pango_units_to_double(i: c_int) f64;
pub extern fn pango_extents_to_pixels(inclusive: [*c]PangoRectangle, nearest: [*c]PangoRectangle) void;
pub const PANGO_GRAVITY_SOUTH = 0;
pub const PANGO_GRAVITY_EAST = 1;
pub const PANGO_GRAVITY_NORTH = 2;
pub const PANGO_GRAVITY_WEST = 3;
pub const PANGO_GRAVITY_AUTO = 4;
pub const PangoGravity = extern enum {
    PANGO_GRAVITY_SOUTH = 0,
    PANGO_GRAVITY_EAST = 1,
    PANGO_GRAVITY_NORTH = 2,
    PANGO_GRAVITY_WEST = 3,
    PANGO_GRAVITY_AUTO = 4,
};
pub const PANGO_GRAVITY_HINT_NATURAL = 0;
pub const PANGO_GRAVITY_HINT_STRONG = 1;
pub const PANGO_GRAVITY_HINT_LINE = 2;
pub const PangoGravityHint = extern enum {
    PANGO_GRAVITY_HINT_NATURAL = 0,
    PANGO_GRAVITY_HINT_STRONG = 1,
    PANGO_GRAVITY_HINT_LINE = 2,
};
pub const struct__PangoMatrix = extern struct {
    xx: f64,
    xy: f64,
    yx: f64,
    yy: f64,
    x0: f64,
    y0: f64,
};
pub const PangoMatrix = struct__PangoMatrix;
pub extern fn pango_matrix_get_type() GType;
pub extern fn pango_matrix_copy(matrix: [*c]const PangoMatrix) [*c]PangoMatrix;
pub extern fn pango_matrix_free(matrix: [*c]PangoMatrix) void;
pub extern fn pango_matrix_translate(matrix: [*c]PangoMatrix, tx: f64, ty: f64) void;
pub extern fn pango_matrix_scale(matrix: [*c]PangoMatrix, scale_x: f64, scale_y: f64) void;
pub extern fn pango_matrix_rotate(matrix: [*c]PangoMatrix, degrees: f64) void;
pub extern fn pango_matrix_concat(matrix: [*c]PangoMatrix, new_matrix: [*c]const PangoMatrix) void;
pub extern fn pango_matrix_transform_point(matrix: [*c]const PangoMatrix, x: [*c]f64, y: [*c]f64) void;
pub extern fn pango_matrix_transform_distance(matrix: [*c]const PangoMatrix, dx: [*c]f64, dy: [*c]f64) void;
pub extern fn pango_matrix_transform_rectangle(matrix: [*c]const PangoMatrix, rect: [*c]PangoRectangle) void;
pub extern fn pango_matrix_transform_pixel_rectangle(matrix: [*c]const PangoMatrix, rect: [*c]PangoRectangle) void;
pub extern fn pango_matrix_get_font_scale_factor(matrix: [*c]const PangoMatrix) f64;
pub extern fn pango_matrix_get_font_scale_factors(matrix: [*c]const PangoMatrix, xscale: [*c]f64, yscale: [*c]f64) void;
pub const struct__PangoScriptIter = @OpaqueType();
pub const PangoScriptIter = struct__PangoScriptIter;
pub const PANGO_SCRIPT_INVALID_CODE = -1;
pub const PANGO_SCRIPT_COMMON = 0;
pub const PANGO_SCRIPT_INHERITED = 1;
pub const PANGO_SCRIPT_ARABIC = 2;
pub const PANGO_SCRIPT_ARMENIAN = 3;
pub const PANGO_SCRIPT_BENGALI = 4;
pub const PANGO_SCRIPT_BOPOMOFO = 5;
pub const PANGO_SCRIPT_CHEROKEE = 6;
pub const PANGO_SCRIPT_COPTIC = 7;
pub const PANGO_SCRIPT_CYRILLIC = 8;
pub const PANGO_SCRIPT_DESERET = 9;
pub const PANGO_SCRIPT_DEVANAGARI = 10;
pub const PANGO_SCRIPT_ETHIOPIC = 11;
pub const PANGO_SCRIPT_GEORGIAN = 12;
pub const PANGO_SCRIPT_GOTHIC = 13;
pub const PANGO_SCRIPT_GREEK = 14;
pub const PANGO_SCRIPT_GUJARATI = 15;
pub const PANGO_SCRIPT_GURMUKHI = 16;
pub const PANGO_SCRIPT_HAN = 17;
pub const PANGO_SCRIPT_HANGUL = 18;
pub const PANGO_SCRIPT_HEBREW = 19;
pub const PANGO_SCRIPT_HIRAGANA = 20;
pub const PANGO_SCRIPT_KANNADA = 21;
pub const PANGO_SCRIPT_KATAKANA = 22;
pub const PANGO_SCRIPT_KHMER = 23;
pub const PANGO_SCRIPT_LAO = 24;
pub const PANGO_SCRIPT_LATIN = 25;
pub const PANGO_SCRIPT_MALAYALAM = 26;
pub const PANGO_SCRIPT_MONGOLIAN = 27;
pub const PANGO_SCRIPT_MYANMAR = 28;
pub const PANGO_SCRIPT_OGHAM = 29;
pub const PANGO_SCRIPT_OLD_ITALIC = 30;
pub const PANGO_SCRIPT_ORIYA = 31;
pub const PANGO_SCRIPT_RUNIC = 32;
pub const PANGO_SCRIPT_SINHALA = 33;
pub const PANGO_SCRIPT_SYRIAC = 34;
pub const PANGO_SCRIPT_TAMIL = 35;
pub const PANGO_SCRIPT_TELUGU = 36;
pub const PANGO_SCRIPT_THAANA = 37;
pub const PANGO_SCRIPT_THAI = 38;
pub const PANGO_SCRIPT_TIBETAN = 39;
pub const PANGO_SCRIPT_CANADIAN_ABORIGINAL = 40;
pub const PANGO_SCRIPT_YI = 41;
pub const PANGO_SCRIPT_TAGALOG = 42;
pub const PANGO_SCRIPT_HANUNOO = 43;
pub const PANGO_SCRIPT_BUHID = 44;
pub const PANGO_SCRIPT_TAGBANWA = 45;
pub const PANGO_SCRIPT_BRAILLE = 46;
pub const PANGO_SCRIPT_CYPRIOT = 47;
pub const PANGO_SCRIPT_LIMBU = 48;
pub const PANGO_SCRIPT_OSMANYA = 49;
pub const PANGO_SCRIPT_SHAVIAN = 50;
pub const PANGO_SCRIPT_LINEAR_B = 51;
pub const PANGO_SCRIPT_TAI_LE = 52;
pub const PANGO_SCRIPT_UGARITIC = 53;
pub const PANGO_SCRIPT_NEW_TAI_LUE = 54;
pub const PANGO_SCRIPT_BUGINESE = 55;
pub const PANGO_SCRIPT_GLAGOLITIC = 56;
pub const PANGO_SCRIPT_TIFINAGH = 57;
pub const PANGO_SCRIPT_SYLOTI_NAGRI = 58;
pub const PANGO_SCRIPT_OLD_PERSIAN = 59;
pub const PANGO_SCRIPT_KHAROSHTHI = 60;
pub const PANGO_SCRIPT_UNKNOWN = 61;
pub const PANGO_SCRIPT_BALINESE = 62;
pub const PANGO_SCRIPT_CUNEIFORM = 63;
pub const PANGO_SCRIPT_PHOENICIAN = 64;
pub const PANGO_SCRIPT_PHAGS_PA = 65;
pub const PANGO_SCRIPT_NKO = 66;
pub const PANGO_SCRIPT_KAYAH_LI = 67;
pub const PANGO_SCRIPT_LEPCHA = 68;
pub const PANGO_SCRIPT_REJANG = 69;
pub const PANGO_SCRIPT_SUNDANESE = 70;
pub const PANGO_SCRIPT_SAURASHTRA = 71;
pub const PANGO_SCRIPT_CHAM = 72;
pub const PANGO_SCRIPT_OL_CHIKI = 73;
pub const PANGO_SCRIPT_VAI = 74;
pub const PANGO_SCRIPT_CARIAN = 75;
pub const PANGO_SCRIPT_LYCIAN = 76;
pub const PANGO_SCRIPT_LYDIAN = 77;
pub const PANGO_SCRIPT_BATAK = 78;
pub const PANGO_SCRIPT_BRAHMI = 79;
pub const PANGO_SCRIPT_MANDAIC = 80;
pub const PANGO_SCRIPT_CHAKMA = 81;
pub const PANGO_SCRIPT_MEROITIC_CURSIVE = 82;
pub const PANGO_SCRIPT_MEROITIC_HIEROGLYPHS = 83;
pub const PANGO_SCRIPT_MIAO = 84;
pub const PANGO_SCRIPT_SHARADA = 85;
pub const PANGO_SCRIPT_SORA_SOMPENG = 86;
pub const PANGO_SCRIPT_TAKRI = 87;
pub const PANGO_SCRIPT_BASSA_VAH = 88;
pub const PANGO_SCRIPT_CAUCASIAN_ALBANIAN = 89;
pub const PANGO_SCRIPT_DUPLOYAN = 90;
pub const PANGO_SCRIPT_ELBASAN = 91;
pub const PANGO_SCRIPT_GRANTHA = 92;
pub const PANGO_SCRIPT_KHOJKI = 93;
pub const PANGO_SCRIPT_KHUDAWADI = 94;
pub const PANGO_SCRIPT_LINEAR_A = 95;
pub const PANGO_SCRIPT_MAHAJANI = 96;
pub const PANGO_SCRIPT_MANICHAEAN = 97;
pub const PANGO_SCRIPT_MENDE_KIKAKUI = 98;
pub const PANGO_SCRIPT_MODI = 99;
pub const PANGO_SCRIPT_MRO = 100;
pub const PANGO_SCRIPT_NABATAEAN = 101;
pub const PANGO_SCRIPT_OLD_NORTH_ARABIAN = 102;
pub const PANGO_SCRIPT_OLD_PERMIC = 103;
pub const PANGO_SCRIPT_PAHAWH_HMONG = 104;
pub const PANGO_SCRIPT_PALMYRENE = 105;
pub const PANGO_SCRIPT_PAU_CIN_HAU = 106;
pub const PANGO_SCRIPT_PSALTER_PAHLAVI = 107;
pub const PANGO_SCRIPT_SIDDHAM = 108;
pub const PANGO_SCRIPT_TIRHUTA = 109;
pub const PANGO_SCRIPT_WARANG_CITI = 110;
pub const PANGO_SCRIPT_AHOM = 111;
pub const PANGO_SCRIPT_ANATOLIAN_HIEROGLYPHS = 112;
pub const PANGO_SCRIPT_HATRAN = 113;
pub const PANGO_SCRIPT_MULTANI = 114;
pub const PANGO_SCRIPT_OLD_HUNGARIAN = 115;
pub const PANGO_SCRIPT_SIGNWRITING = 116;
pub const PangoScript = extern enum {
    PANGO_SCRIPT_INVALID_CODE = -1,
    PANGO_SCRIPT_COMMON = 0,
    PANGO_SCRIPT_INHERITED = 1,
    PANGO_SCRIPT_ARABIC = 2,
    PANGO_SCRIPT_ARMENIAN = 3,
    PANGO_SCRIPT_BENGALI = 4,
    PANGO_SCRIPT_BOPOMOFO = 5,
    PANGO_SCRIPT_CHEROKEE = 6,
    PANGO_SCRIPT_COPTIC = 7,
    PANGO_SCRIPT_CYRILLIC = 8,
    PANGO_SCRIPT_DESERET = 9,
    PANGO_SCRIPT_DEVANAGARI = 10,
    PANGO_SCRIPT_ETHIOPIC = 11,
    PANGO_SCRIPT_GEORGIAN = 12,
    PANGO_SCRIPT_GOTHIC = 13,
    PANGO_SCRIPT_GREEK = 14,
    PANGO_SCRIPT_GUJARATI = 15,
    PANGO_SCRIPT_GURMUKHI = 16,
    PANGO_SCRIPT_HAN = 17,
    PANGO_SCRIPT_HANGUL = 18,
    PANGO_SCRIPT_HEBREW = 19,
    PANGO_SCRIPT_HIRAGANA = 20,
    PANGO_SCRIPT_KANNADA = 21,
    PANGO_SCRIPT_KATAKANA = 22,
    PANGO_SCRIPT_KHMER = 23,
    PANGO_SCRIPT_LAO = 24,
    PANGO_SCRIPT_LATIN = 25,
    PANGO_SCRIPT_MALAYALAM = 26,
    PANGO_SCRIPT_MONGOLIAN = 27,
    PANGO_SCRIPT_MYANMAR = 28,
    PANGO_SCRIPT_OGHAM = 29,
    PANGO_SCRIPT_OLD_ITALIC = 30,
    PANGO_SCRIPT_ORIYA = 31,
    PANGO_SCRIPT_RUNIC = 32,
    PANGO_SCRIPT_SINHALA = 33,
    PANGO_SCRIPT_SYRIAC = 34,
    PANGO_SCRIPT_TAMIL = 35,
    PANGO_SCRIPT_TELUGU = 36,
    PANGO_SCRIPT_THAANA = 37,
    PANGO_SCRIPT_THAI = 38,
    PANGO_SCRIPT_TIBETAN = 39,
    PANGO_SCRIPT_CANADIAN_ABORIGINAL = 40,
    PANGO_SCRIPT_YI = 41,
    PANGO_SCRIPT_TAGALOG = 42,
    PANGO_SCRIPT_HANUNOO = 43,
    PANGO_SCRIPT_BUHID = 44,
    PANGO_SCRIPT_TAGBANWA = 45,
    PANGO_SCRIPT_BRAILLE = 46,
    PANGO_SCRIPT_CYPRIOT = 47,
    PANGO_SCRIPT_LIMBU = 48,
    PANGO_SCRIPT_OSMANYA = 49,
    PANGO_SCRIPT_SHAVIAN = 50,
    PANGO_SCRIPT_LINEAR_B = 51,
    PANGO_SCRIPT_TAI_LE = 52,
    PANGO_SCRIPT_UGARITIC = 53,
    PANGO_SCRIPT_NEW_TAI_LUE = 54,
    PANGO_SCRIPT_BUGINESE = 55,
    PANGO_SCRIPT_GLAGOLITIC = 56,
    PANGO_SCRIPT_TIFINAGH = 57,
    PANGO_SCRIPT_SYLOTI_NAGRI = 58,
    PANGO_SCRIPT_OLD_PERSIAN = 59,
    PANGO_SCRIPT_KHAROSHTHI = 60,
    PANGO_SCRIPT_UNKNOWN = 61,
    PANGO_SCRIPT_BALINESE = 62,
    PANGO_SCRIPT_CUNEIFORM = 63,
    PANGO_SCRIPT_PHOENICIAN = 64,
    PANGO_SCRIPT_PHAGS_PA = 65,
    PANGO_SCRIPT_NKO = 66,
    PANGO_SCRIPT_KAYAH_LI = 67,
    PANGO_SCRIPT_LEPCHA = 68,
    PANGO_SCRIPT_REJANG = 69,
    PANGO_SCRIPT_SUNDANESE = 70,
    PANGO_SCRIPT_SAURASHTRA = 71,
    PANGO_SCRIPT_CHAM = 72,
    PANGO_SCRIPT_OL_CHIKI = 73,
    PANGO_SCRIPT_VAI = 74,
    PANGO_SCRIPT_CARIAN = 75,
    PANGO_SCRIPT_LYCIAN = 76,
    PANGO_SCRIPT_LYDIAN = 77,
    PANGO_SCRIPT_BATAK = 78,
    PANGO_SCRIPT_BRAHMI = 79,
    PANGO_SCRIPT_MANDAIC = 80,
    PANGO_SCRIPT_CHAKMA = 81,
    PANGO_SCRIPT_MEROITIC_CURSIVE = 82,
    PANGO_SCRIPT_MEROITIC_HIEROGLYPHS = 83,
    PANGO_SCRIPT_MIAO = 84,
    PANGO_SCRIPT_SHARADA = 85,
    PANGO_SCRIPT_SORA_SOMPENG = 86,
    PANGO_SCRIPT_TAKRI = 87,
    PANGO_SCRIPT_BASSA_VAH = 88,
    PANGO_SCRIPT_CAUCASIAN_ALBANIAN = 89,
    PANGO_SCRIPT_DUPLOYAN = 90,
    PANGO_SCRIPT_ELBASAN = 91,
    PANGO_SCRIPT_GRANTHA = 92,
    PANGO_SCRIPT_KHOJKI = 93,
    PANGO_SCRIPT_KHUDAWADI = 94,
    PANGO_SCRIPT_LINEAR_A = 95,
    PANGO_SCRIPT_MAHAJANI = 96,
    PANGO_SCRIPT_MANICHAEAN = 97,
    PANGO_SCRIPT_MENDE_KIKAKUI = 98,
    PANGO_SCRIPT_MODI = 99,
    PANGO_SCRIPT_MRO = 100,
    PANGO_SCRIPT_NABATAEAN = 101,
    PANGO_SCRIPT_OLD_NORTH_ARABIAN = 102,
    PANGO_SCRIPT_OLD_PERMIC = 103,
    PANGO_SCRIPT_PAHAWH_HMONG = 104,
    PANGO_SCRIPT_PALMYRENE = 105,
    PANGO_SCRIPT_PAU_CIN_HAU = 106,
    PANGO_SCRIPT_PSALTER_PAHLAVI = 107,
    PANGO_SCRIPT_SIDDHAM = 108,
    PANGO_SCRIPT_TIRHUTA = 109,
    PANGO_SCRIPT_WARANG_CITI = 110,
    PANGO_SCRIPT_AHOM = 111,
    PANGO_SCRIPT_ANATOLIAN_HIEROGLYPHS = 112,
    PANGO_SCRIPT_HATRAN = 113,
    PANGO_SCRIPT_MULTANI = 114,
    PANGO_SCRIPT_OLD_HUNGARIAN = 115,
    PANGO_SCRIPT_SIGNWRITING = 116,
};
pub extern fn pango_script_for_unichar(ch: gunichar) PangoScript;
pub extern fn pango_script_iter_new(text: [*c]const u8, length: c_int) ?*PangoScriptIter;
pub extern fn pango_script_iter_get_range(iter: ?*PangoScriptIter, start: [*c]([*c]const u8), end: [*c]([*c]const u8), script: [*c]PangoScript) void;
pub extern fn pango_script_iter_next(iter: ?*PangoScriptIter) gboolean;
pub extern fn pango_script_iter_free(iter: ?*PangoScriptIter) void;
pub const struct__PangoLanguage = @OpaqueType();
pub const PangoLanguage = struct__PangoLanguage;
pub extern fn pango_language_get_type() GType;
pub extern fn pango_language_from_string(language: [*c]const u8) ?*PangoLanguage;
pub extern fn pango_language_to_string(language: ?*PangoLanguage) [*c]const u8;
pub extern fn pango_language_get_sample_string(language: ?*PangoLanguage) [*c]const u8;
pub extern fn pango_language_get_default() ?*PangoLanguage;
pub extern fn pango_language_matches(language: ?*PangoLanguage, range_list: [*c]const u8) gboolean;
pub extern fn pango_language_includes_script(language: ?*PangoLanguage, script: PangoScript) gboolean;
pub extern fn pango_language_get_scripts(language: ?*PangoLanguage, num_scripts: [*c]c_int) [*c]const PangoScript;
pub extern fn pango_script_get_sample_language(script: PangoScript) ?*PangoLanguage;
pub extern fn pango_gravity_to_rotation(gravity: PangoGravity) f64;
pub extern fn pango_gravity_get_for_matrix(matrix: [*c]const PangoMatrix) PangoGravity;
pub extern fn pango_gravity_get_for_script(script: PangoScript, base_gravity: PangoGravity, hint: PangoGravityHint) PangoGravity;
pub extern fn pango_gravity_get_for_script_and_width(script: PangoScript, wide: gboolean, base_gravity: PangoGravity, hint: PangoGravityHint) PangoGravity;
pub const PANGO_DIRECTION_LTR = 0;
pub const PANGO_DIRECTION_RTL = 1;
pub const PANGO_DIRECTION_TTB_LTR = 2;
pub const PANGO_DIRECTION_TTB_RTL = 3;
pub const PANGO_DIRECTION_WEAK_LTR = 4;
pub const PANGO_DIRECTION_WEAK_RTL = 5;
pub const PANGO_DIRECTION_NEUTRAL = 6;
pub const PangoDirection = extern enum {
    PANGO_DIRECTION_LTR = 0,
    PANGO_DIRECTION_RTL = 1,
    PANGO_DIRECTION_TTB_LTR = 2,
    PANGO_DIRECTION_TTB_RTL = 3,
    PANGO_DIRECTION_WEAK_LTR = 4,
    PANGO_DIRECTION_WEAK_RTL = 5,
    PANGO_DIRECTION_NEUTRAL = 6,
};
pub const PANGO_BIDI_TYPE_L = 0;
pub const PANGO_BIDI_TYPE_LRE = 1;
pub const PANGO_BIDI_TYPE_LRO = 2;
pub const PANGO_BIDI_TYPE_R = 3;
pub const PANGO_BIDI_TYPE_AL = 4;
pub const PANGO_BIDI_TYPE_RLE = 5;
pub const PANGO_BIDI_TYPE_RLO = 6;
pub const PANGO_BIDI_TYPE_PDF = 7;
pub const PANGO_BIDI_TYPE_EN = 8;
pub const PANGO_BIDI_TYPE_ES = 9;
pub const PANGO_BIDI_TYPE_ET = 10;
pub const PANGO_BIDI_TYPE_AN = 11;
pub const PANGO_BIDI_TYPE_CS = 12;
pub const PANGO_BIDI_TYPE_NSM = 13;
pub const PANGO_BIDI_TYPE_BN = 14;
pub const PANGO_BIDI_TYPE_B = 15;
pub const PANGO_BIDI_TYPE_S = 16;
pub const PANGO_BIDI_TYPE_WS = 17;
pub const PANGO_BIDI_TYPE_ON = 18;
pub const PangoBidiType = extern enum {
    PANGO_BIDI_TYPE_L = 0,
    PANGO_BIDI_TYPE_LRE = 1,
    PANGO_BIDI_TYPE_LRO = 2,
    PANGO_BIDI_TYPE_R = 3,
    PANGO_BIDI_TYPE_AL = 4,
    PANGO_BIDI_TYPE_RLE = 5,
    PANGO_BIDI_TYPE_RLO = 6,
    PANGO_BIDI_TYPE_PDF = 7,
    PANGO_BIDI_TYPE_EN = 8,
    PANGO_BIDI_TYPE_ES = 9,
    PANGO_BIDI_TYPE_ET = 10,
    PANGO_BIDI_TYPE_AN = 11,
    PANGO_BIDI_TYPE_CS = 12,
    PANGO_BIDI_TYPE_NSM = 13,
    PANGO_BIDI_TYPE_BN = 14,
    PANGO_BIDI_TYPE_B = 15,
    PANGO_BIDI_TYPE_S = 16,
    PANGO_BIDI_TYPE_WS = 17,
    PANGO_BIDI_TYPE_ON = 18,
};
pub extern fn pango_bidi_type_for_unichar(ch: gunichar) PangoBidiType;
pub extern fn pango_unichar_direction(ch: gunichar) PangoDirection;
pub extern fn pango_find_base_dir(text: [*c]const gchar, length: gint) PangoDirection;
pub extern fn pango_get_mirror_char(ch: gunichar, mirrored_ch: [*c]gunichar) gboolean;
pub const struct__PangoFontDescription = @OpaqueType();
pub const PangoFontDescription = struct__PangoFontDescription;
pub const struct__PangoFontMetrics = @OpaqueType();
pub const PangoFontMetrics = struct__PangoFontMetrics;
pub const PANGO_STYLE_NORMAL = 0;
pub const PANGO_STYLE_OBLIQUE = 1;
pub const PANGO_STYLE_ITALIC = 2;
pub const PangoStyle = extern enum {
    PANGO_STYLE_NORMAL = 0,
    PANGO_STYLE_OBLIQUE = 1,
    PANGO_STYLE_ITALIC = 2,
};
pub const PANGO_VARIANT_NORMAL = 0;
pub const PANGO_VARIANT_SMALL_CAPS = 1;
pub const PangoVariant = extern enum {
    PANGO_VARIANT_NORMAL = 0,
    PANGO_VARIANT_SMALL_CAPS = 1,
};
pub const PANGO_WEIGHT_THIN = 100;
pub const PANGO_WEIGHT_ULTRALIGHT = 200;
pub const PANGO_WEIGHT_LIGHT = 300;
pub const PANGO_WEIGHT_SEMILIGHT = 350;
pub const PANGO_WEIGHT_BOOK = 380;
pub const PANGO_WEIGHT_NORMAL = 400;
pub const PANGO_WEIGHT_MEDIUM = 500;
pub const PANGO_WEIGHT_SEMIBOLD = 600;
pub const PANGO_WEIGHT_BOLD = 700;
pub const PANGO_WEIGHT_ULTRABOLD = 800;
pub const PANGO_WEIGHT_HEAVY = 900;
pub const PANGO_WEIGHT_ULTRAHEAVY = 1000;
pub const PangoWeight = extern enum {
    PANGO_WEIGHT_THIN = 100,
    PANGO_WEIGHT_ULTRALIGHT = 200,
    PANGO_WEIGHT_LIGHT = 300,
    PANGO_WEIGHT_SEMILIGHT = 350,
    PANGO_WEIGHT_BOOK = 380,
    PANGO_WEIGHT_NORMAL = 400,
    PANGO_WEIGHT_MEDIUM = 500,
    PANGO_WEIGHT_SEMIBOLD = 600,
    PANGO_WEIGHT_BOLD = 700,
    PANGO_WEIGHT_ULTRABOLD = 800,
    PANGO_WEIGHT_HEAVY = 900,
    PANGO_WEIGHT_ULTRAHEAVY = 1000,
};
pub const PANGO_STRETCH_ULTRA_CONDENSED = 0;
pub const PANGO_STRETCH_EXTRA_CONDENSED = 1;
pub const PANGO_STRETCH_CONDENSED = 2;
pub const PANGO_STRETCH_SEMI_CONDENSED = 3;
pub const PANGO_STRETCH_NORMAL = 4;
pub const PANGO_STRETCH_SEMI_EXPANDED = 5;
pub const PANGO_STRETCH_EXPANDED = 6;
pub const PANGO_STRETCH_EXTRA_EXPANDED = 7;
pub const PANGO_STRETCH_ULTRA_EXPANDED = 8;
pub const PangoStretch = extern enum {
    PANGO_STRETCH_ULTRA_CONDENSED = 0,
    PANGO_STRETCH_EXTRA_CONDENSED = 1,
    PANGO_STRETCH_CONDENSED = 2,
    PANGO_STRETCH_SEMI_CONDENSED = 3,
    PANGO_STRETCH_NORMAL = 4,
    PANGO_STRETCH_SEMI_EXPANDED = 5,
    PANGO_STRETCH_EXPANDED = 6,
    PANGO_STRETCH_EXTRA_EXPANDED = 7,
    PANGO_STRETCH_ULTRA_EXPANDED = 8,
};
pub const PANGO_FONT_MASK_FAMILY = 1;
pub const PANGO_FONT_MASK_STYLE = 2;
pub const PANGO_FONT_MASK_VARIANT = 4;
pub const PANGO_FONT_MASK_WEIGHT = 8;
pub const PANGO_FONT_MASK_STRETCH = 16;
pub const PANGO_FONT_MASK_SIZE = 32;
pub const PANGO_FONT_MASK_GRAVITY = 64;
pub const PANGO_FONT_MASK_VARIATIONS = 128;
pub const PangoFontMask = extern enum {
    PANGO_FONT_MASK_FAMILY = 1,
    PANGO_FONT_MASK_STYLE = 2,
    PANGO_FONT_MASK_VARIANT = 4,
    PANGO_FONT_MASK_WEIGHT = 8,
    PANGO_FONT_MASK_STRETCH = 16,
    PANGO_FONT_MASK_SIZE = 32,
    PANGO_FONT_MASK_GRAVITY = 64,
    PANGO_FONT_MASK_VARIATIONS = 128,
};
pub extern fn pango_font_description_get_type() GType;
pub extern fn pango_font_description_new() ?*PangoFontDescription;
pub extern fn pango_font_description_copy(desc: ?*const PangoFontDescription) ?*PangoFontDescription;
pub extern fn pango_font_description_copy_static(desc: ?*const PangoFontDescription) ?*PangoFontDescription;
pub extern fn pango_font_description_hash(desc: ?*const PangoFontDescription) guint;
pub extern fn pango_font_description_equal(desc1: ?*const PangoFontDescription, desc2: ?*const PangoFontDescription) gboolean;
pub extern fn pango_font_description_free(desc: ?*PangoFontDescription) void;
pub extern fn pango_font_descriptions_free(descs: [*c](?*PangoFontDescription), n_descs: c_int) void;
pub extern fn pango_font_description_set_family(desc: ?*PangoFontDescription, family: [*c]const u8) void;
pub extern fn pango_font_description_set_family_static(desc: ?*PangoFontDescription, family: [*c]const u8) void;
pub extern fn pango_font_description_get_family(desc: ?*const PangoFontDescription) [*c]const u8;
pub extern fn pango_font_description_set_style(desc: ?*PangoFontDescription, style: PangoStyle) void;
pub extern fn pango_font_description_get_style(desc: ?*const PangoFontDescription) PangoStyle;
pub extern fn pango_font_description_set_variant(desc: ?*PangoFontDescription, variant: PangoVariant) void;
pub extern fn pango_font_description_get_variant(desc: ?*const PangoFontDescription) PangoVariant;
pub extern fn pango_font_description_set_weight(desc: ?*PangoFontDescription, weight: PangoWeight) void;
pub extern fn pango_font_description_get_weight(desc: ?*const PangoFontDescription) PangoWeight;
pub extern fn pango_font_description_set_stretch(desc: ?*PangoFontDescription, stretch: PangoStretch) void;
pub extern fn pango_font_description_get_stretch(desc: ?*const PangoFontDescription) PangoStretch;
pub extern fn pango_font_description_set_size(desc: ?*PangoFontDescription, size: gint) void;
pub extern fn pango_font_description_get_size(desc: ?*const PangoFontDescription) gint;
pub extern fn pango_font_description_set_absolute_size(desc: ?*PangoFontDescription, size: f64) void;
pub extern fn pango_font_description_get_size_is_absolute(desc: ?*const PangoFontDescription) gboolean;
pub extern fn pango_font_description_set_gravity(desc: ?*PangoFontDescription, gravity: PangoGravity) void;
pub extern fn pango_font_description_get_gravity(desc: ?*const PangoFontDescription) PangoGravity;
pub extern fn pango_font_description_set_variations_static(desc: ?*PangoFontDescription, settings: [*c]const u8) void;
pub extern fn pango_font_description_set_variations(desc: ?*PangoFontDescription, settings: [*c]const u8) void;
pub extern fn pango_font_description_get_variations(desc: ?*const PangoFontDescription) [*c]const u8;
pub extern fn pango_font_description_get_set_fields(desc: ?*const PangoFontDescription) PangoFontMask;
pub extern fn pango_font_description_unset_fields(desc: ?*PangoFontDescription, to_unset: PangoFontMask) void;
pub extern fn pango_font_description_merge(desc: ?*PangoFontDescription, desc_to_merge: ?*const PangoFontDescription, replace_existing: gboolean) void;
pub extern fn pango_font_description_merge_static(desc: ?*PangoFontDescription, desc_to_merge: ?*const PangoFontDescription, replace_existing: gboolean) void;
pub extern fn pango_font_description_better_match(desc: ?*const PangoFontDescription, old_match: ?*const PangoFontDescription, new_match: ?*const PangoFontDescription) gboolean;
pub extern fn pango_font_description_from_string(str: [*c]const u8) ?*PangoFontDescription;
pub extern fn pango_font_description_to_string(desc: ?*const PangoFontDescription) [*c]u8;
pub extern fn pango_font_description_to_filename(desc: ?*const PangoFontDescription) [*c]u8;
pub extern fn pango_font_metrics_get_type() GType;
pub extern fn pango_font_metrics_ref(metrics: ?*PangoFontMetrics) ?*PangoFontMetrics;
pub extern fn pango_font_metrics_unref(metrics: ?*PangoFontMetrics) void;
pub extern fn pango_font_metrics_get_ascent(metrics: ?*PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_descent(metrics: ?*PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_approximate_char_width(metrics: ?*PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_approximate_digit_width(metrics: ?*PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_underline_position(metrics: ?*PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_underline_thickness(metrics: ?*PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_strikethrough_position(metrics: ?*PangoFontMetrics) c_int;
pub extern fn pango_font_metrics_get_strikethrough_thickness(metrics: ?*PangoFontMetrics) c_int;
pub const struct__PangoFontFamily = @OpaqueType();
pub const PangoFontFamily = struct__PangoFontFamily;
pub const struct__PangoFontFace = @OpaqueType();
pub const PangoFontFace = struct__PangoFontFace;
pub extern fn pango_font_family_get_type() GType;
pub extern fn pango_font_family_list_faces(family: ?*PangoFontFamily, faces: [*c]([*c](?*PangoFontFace)), n_faces: [*c]c_int) void;
pub extern fn pango_font_family_get_name(family: ?*PangoFontFamily) [*c]const u8;
pub extern fn pango_font_family_is_monospace(family: ?*PangoFontFamily) gboolean;
pub extern fn pango_font_family_is_variable(family: ?*PangoFontFamily) gboolean;
pub extern fn pango_font_face_get_type() GType;
pub extern fn pango_font_face_describe(face: ?*PangoFontFace) ?*PangoFontDescription;
pub extern fn pango_font_face_get_face_name(face: ?*PangoFontFace) [*c]const u8;
pub extern fn pango_font_face_list_sizes(face: ?*PangoFontFace, sizes: [*c]([*c]c_int), n_sizes: [*c]c_int) void;
pub extern fn pango_font_face_is_synthesized(face: ?*PangoFontFace) gboolean;
pub extern fn pango_font_get_type() GType;
pub extern fn pango_font_describe(font: ?*PangoFont) ?*PangoFontDescription;
pub extern fn pango_font_describe_with_absolute_size(font: ?*PangoFont) ?*PangoFontDescription;
pub extern fn pango_font_get_coverage(font: ?*PangoFont, language: ?*PangoLanguage) ?*PangoCoverage;
pub extern fn pango_font_find_shaper(font: ?*PangoFont, language: ?*PangoLanguage, ch: guint32) ?*PangoEngineShape;
pub extern fn pango_font_get_metrics(font: ?*PangoFont, language: ?*PangoLanguage) ?*PangoFontMetrics;
pub extern fn pango_font_get_glyph_extents(font: ?*PangoFont, glyph: PangoGlyph, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_font_get_font_map(font: ?*PangoFont) ?*PangoFontMap;
pub const struct__PangoColor = extern struct {
    red: guint16,
    green: guint16,
    blue: guint16,
};
pub const PangoColor = struct__PangoColor;
pub extern fn pango_color_get_type() GType;
pub extern fn pango_color_copy(src: [*c]const PangoColor) [*c]PangoColor;
pub extern fn pango_color_free(color: [*c]PangoColor) void;
pub extern fn pango_color_parse(color: [*c]PangoColor, spec: [*c]const u8) gboolean;
pub extern fn pango_color_to_string(color: [*c]const PangoColor) [*c]gchar;
pub const PANGO_ATTR_INVALID = 0;
pub const PANGO_ATTR_LANGUAGE = 1;
pub const PANGO_ATTR_FAMILY = 2;
pub const PANGO_ATTR_STYLE = 3;
pub const PANGO_ATTR_WEIGHT = 4;
pub const PANGO_ATTR_VARIANT = 5;
pub const PANGO_ATTR_STRETCH = 6;
pub const PANGO_ATTR_SIZE = 7;
pub const PANGO_ATTR_FONT_DESC = 8;
pub const PANGO_ATTR_FOREGROUND = 9;
pub const PANGO_ATTR_BACKGROUND = 10;
pub const PANGO_ATTR_UNDERLINE = 11;
pub const PANGO_ATTR_STRIKETHROUGH = 12;
pub const PANGO_ATTR_RISE = 13;
pub const PANGO_ATTR_SHAPE = 14;
pub const PANGO_ATTR_SCALE = 15;
pub const PANGO_ATTR_FALLBACK = 16;
pub const PANGO_ATTR_LETTER_SPACING = 17;
pub const PANGO_ATTR_UNDERLINE_COLOR = 18;
pub const PANGO_ATTR_STRIKETHROUGH_COLOR = 19;
pub const PANGO_ATTR_ABSOLUTE_SIZE = 20;
pub const PANGO_ATTR_GRAVITY = 21;
pub const PANGO_ATTR_GRAVITY_HINT = 22;
pub const PANGO_ATTR_FONT_FEATURES = 23;
pub const PANGO_ATTR_FOREGROUND_ALPHA = 24;
pub const PANGO_ATTR_BACKGROUND_ALPHA = 25;
pub const PangoAttrType = extern enum {
    PANGO_ATTR_INVALID = 0,
    PANGO_ATTR_LANGUAGE = 1,
    PANGO_ATTR_FAMILY = 2,
    PANGO_ATTR_STYLE = 3,
    PANGO_ATTR_WEIGHT = 4,
    PANGO_ATTR_VARIANT = 5,
    PANGO_ATTR_STRETCH = 6,
    PANGO_ATTR_SIZE = 7,
    PANGO_ATTR_FONT_DESC = 8,
    PANGO_ATTR_FOREGROUND = 9,
    PANGO_ATTR_BACKGROUND = 10,
    PANGO_ATTR_UNDERLINE = 11,
    PANGO_ATTR_STRIKETHROUGH = 12,
    PANGO_ATTR_RISE = 13,
    PANGO_ATTR_SHAPE = 14,
    PANGO_ATTR_SCALE = 15,
    PANGO_ATTR_FALLBACK = 16,
    PANGO_ATTR_LETTER_SPACING = 17,
    PANGO_ATTR_UNDERLINE_COLOR = 18,
    PANGO_ATTR_STRIKETHROUGH_COLOR = 19,
    PANGO_ATTR_ABSOLUTE_SIZE = 20,
    PANGO_ATTR_GRAVITY = 21,
    PANGO_ATTR_GRAVITY_HINT = 22,
    PANGO_ATTR_FONT_FEATURES = 23,
    PANGO_ATTR_FOREGROUND_ALPHA = 24,
    PANGO_ATTR_BACKGROUND_ALPHA = 25,
};
pub const PangoAttribute = struct__PangoAttribute;
pub const struct__PangoAttrClass = extern struct {
    type: PangoAttrType,
    copy: ?extern fn ([*c]const PangoAttribute) [*c]PangoAttribute,
    destroy: ?extern fn ([*c]PangoAttribute) void,
    equal: ?extern fn ([*c]const PangoAttribute, [*c]const PangoAttribute) gboolean,
};
pub const PangoAttrClass = struct__PangoAttrClass;
pub const struct__PangoAttribute = extern struct {
    klass: [*c]const PangoAttrClass,
    start_index: guint,
    end_index: guint,
};
pub const struct__PangoAttrString = extern struct {
    attr: PangoAttribute,
    value: [*c]u8,
};
pub const PangoAttrString = struct__PangoAttrString;
pub const struct__PangoAttrLanguage = extern struct {
    attr: PangoAttribute,
    value: ?*PangoLanguage,
};
pub const PangoAttrLanguage = struct__PangoAttrLanguage;
pub const struct__PangoAttrInt = extern struct {
    attr: PangoAttribute,
    value: c_int,
};
pub const PangoAttrInt = struct__PangoAttrInt;
pub const struct__PangoAttrSize = @OpaqueType();
pub const PangoAttrSize = struct__PangoAttrSize;
pub const struct__PangoAttrFloat = extern struct {
    attr: PangoAttribute,
    value: f64,
};
pub const PangoAttrFloat = struct__PangoAttrFloat;
pub const struct__PangoAttrColor = extern struct {
    attr: PangoAttribute,
    color: PangoColor,
};
pub const PangoAttrColor = struct__PangoAttrColor;
pub const struct__PangoAttrFontDesc = extern struct {
    attr: PangoAttribute,
    desc: ?*PangoFontDescription,
};
pub const PangoAttrFontDesc = struct__PangoAttrFontDesc;
pub const PangoAttrDataCopyFunc = ?extern fn (gconstpointer) gpointer;
pub const struct__PangoAttrShape = extern struct {
    attr: PangoAttribute,
    ink_rect: PangoRectangle,
    logical_rect: PangoRectangle,
    data: gpointer,
    copy_func: PangoAttrDataCopyFunc,
    destroy_func: GDestroyNotify,
};
pub const PangoAttrShape = struct__PangoAttrShape;
pub const struct__PangoAttrFontFeatures = extern struct {
    attr: PangoAttribute,
    features: [*c]gchar,
};
pub const PangoAttrFontFeatures = struct__PangoAttrFontFeatures;
pub const struct__PangoAttrList = @OpaqueType();
pub const PangoAttrList = struct__PangoAttrList;
pub const struct__PangoAttrIterator = @OpaqueType();
pub const PangoAttrIterator = struct__PangoAttrIterator;
pub const PANGO_UNDERLINE_NONE = 0;
pub const PANGO_UNDERLINE_SINGLE = 1;
pub const PANGO_UNDERLINE_DOUBLE = 2;
pub const PANGO_UNDERLINE_LOW = 3;
pub const PANGO_UNDERLINE_ERROR = 4;
pub const PangoUnderline = extern enum {
    PANGO_UNDERLINE_NONE = 0,
    PANGO_UNDERLINE_SINGLE = 1,
    PANGO_UNDERLINE_DOUBLE = 2,
    PANGO_UNDERLINE_LOW = 3,
    PANGO_UNDERLINE_ERROR = 4,
};
pub const PangoAttrFilterFunc = ?extern fn ([*c]PangoAttribute, gpointer) gboolean;
pub extern fn pango_attr_type_register(name: [*c]const gchar) PangoAttrType;
pub extern fn pango_attr_type_get_name(type_0: PangoAttrType) [*c]const u8;
pub extern fn pango_attribute_init(attr: [*c]PangoAttribute, klass: [*c]const PangoAttrClass) void;
pub extern fn pango_attribute_copy(attr: [*c]const PangoAttribute) [*c]PangoAttribute;
pub extern fn pango_attribute_destroy(attr: [*c]PangoAttribute) void;
pub extern fn pango_attribute_equal(attr1: [*c]const PangoAttribute, attr2: [*c]const PangoAttribute) gboolean;
pub extern fn pango_attr_language_new(language: ?*PangoLanguage) [*c]PangoAttribute;
pub extern fn pango_attr_family_new(family: [*c]const u8) [*c]PangoAttribute;
pub extern fn pango_attr_foreground_new(red: guint16, green: guint16, blue: guint16) [*c]PangoAttribute;
pub extern fn pango_attr_background_new(red: guint16, green: guint16, blue: guint16) [*c]PangoAttribute;
pub extern fn pango_attr_size_new(size: c_int) [*c]PangoAttribute;
pub extern fn pango_attr_size_new_absolute(size: c_int) [*c]PangoAttribute;
pub extern fn pango_attr_style_new(style: PangoStyle) [*c]PangoAttribute;
pub extern fn pango_attr_weight_new(weight: PangoWeight) [*c]PangoAttribute;
pub extern fn pango_attr_variant_new(variant: PangoVariant) [*c]PangoAttribute;
pub extern fn pango_attr_stretch_new(stretch: PangoStretch) [*c]PangoAttribute;
pub extern fn pango_attr_font_desc_new(desc: ?*const PangoFontDescription) [*c]PangoAttribute;
pub extern fn pango_attr_underline_new(underline: PangoUnderline) [*c]PangoAttribute;
pub extern fn pango_attr_underline_color_new(red: guint16, green: guint16, blue: guint16) [*c]PangoAttribute;
pub extern fn pango_attr_strikethrough_new(strikethrough: gboolean) [*c]PangoAttribute;
pub extern fn pango_attr_strikethrough_color_new(red: guint16, green: guint16, blue: guint16) [*c]PangoAttribute;
pub extern fn pango_attr_rise_new(rise: c_int) [*c]PangoAttribute;
pub extern fn pango_attr_scale_new(scale_factor: f64) [*c]PangoAttribute;
pub extern fn pango_attr_fallback_new(enable_fallback: gboolean) [*c]PangoAttribute;
pub extern fn pango_attr_letter_spacing_new(letter_spacing: c_int) [*c]PangoAttribute;
pub extern fn pango_attr_shape_new(ink_rect: [*c]const PangoRectangle, logical_rect: [*c]const PangoRectangle) [*c]PangoAttribute;
pub extern fn pango_attr_shape_new_with_data(ink_rect: [*c]const PangoRectangle, logical_rect: [*c]const PangoRectangle, data: gpointer, copy_func: PangoAttrDataCopyFunc, destroy_func: GDestroyNotify) [*c]PangoAttribute;
pub extern fn pango_attr_gravity_new(gravity: PangoGravity) [*c]PangoAttribute;
pub extern fn pango_attr_gravity_hint_new(hint: PangoGravityHint) [*c]PangoAttribute;
pub extern fn pango_attr_font_features_new(features: [*c]const gchar) [*c]PangoAttribute;
pub extern fn pango_attr_foreground_alpha_new(alpha: guint16) [*c]PangoAttribute;
pub extern fn pango_attr_background_alpha_new(alpha: guint16) [*c]PangoAttribute;
pub extern fn pango_attr_list_get_type() GType;
pub extern fn pango_attr_list_new() ?*PangoAttrList;
pub extern fn pango_attr_list_ref(list: ?*PangoAttrList) ?*PangoAttrList;
pub extern fn pango_attr_list_unref(list: ?*PangoAttrList) void;
pub extern fn pango_attr_list_copy(list: ?*PangoAttrList) ?*PangoAttrList;
pub extern fn pango_attr_list_insert(list: ?*PangoAttrList, attr: [*c]PangoAttribute) void;
pub extern fn pango_attr_list_insert_before(list: ?*PangoAttrList, attr: [*c]PangoAttribute) void;
pub extern fn pango_attr_list_change(list: ?*PangoAttrList, attr: [*c]PangoAttribute) void;
pub extern fn pango_attr_list_splice(list: ?*PangoAttrList, other: ?*PangoAttrList, pos: gint, len: gint) void;
pub extern fn pango_attr_list_filter(list: ?*PangoAttrList, func: PangoAttrFilterFunc, data: gpointer) ?*PangoAttrList;
pub extern fn pango_attr_list_get_iterator(list: ?*PangoAttrList) ?*PangoAttrIterator;
pub extern fn pango_attr_iterator_range(iterator: ?*PangoAttrIterator, start: [*c]gint, end: [*c]gint) void;
pub extern fn pango_attr_iterator_next(iterator: ?*PangoAttrIterator) gboolean;
pub extern fn pango_attr_iterator_copy(iterator: ?*PangoAttrIterator) ?*PangoAttrIterator;
pub extern fn pango_attr_iterator_destroy(iterator: ?*PangoAttrIterator) void;
pub extern fn pango_attr_iterator_get(iterator: ?*PangoAttrIterator, type_0: PangoAttrType) [*c]PangoAttribute;
pub extern fn pango_attr_iterator_get_font(iterator: ?*PangoAttrIterator, desc: ?*PangoFontDescription, language: [*c](?*PangoLanguage), extra_attrs: [*c]([*c]GSList)) void;
pub extern fn pango_attr_iterator_get_attrs(iterator: ?*PangoAttrIterator) [*c]GSList;
pub extern fn pango_parse_markup(markup_text: [*c]const u8, length: c_int, accel_marker: gunichar, attr_list: [*c](?*PangoAttrList), text: [*c]([*c]u8), accel_char: [*c]gunichar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn pango_markup_parser_new(accel_marker: gunichar) ?*GMarkupParseContext;
pub extern fn pango_markup_parser_finish(context: ?*GMarkupParseContext, attr_list: [*c](?*PangoAttrList), text: [*c]([*c]u8), accel_char: [*c]gunichar, @"error": [*c]([*c]GError)) gboolean;
pub const struct__PangoAnalysis = extern struct {
    shape_engine: ?*PangoEngineShape,
    lang_engine: ?*PangoEngineLang,
    font: ?*PangoFont,
    level: guint8,
    gravity: guint8,
    flags: guint8,
    script: guint8,
    language: ?*PangoLanguage,
    extra_attrs: [*c]GSList,
};
pub const PangoAnalysis = struct__PangoAnalysis;
pub const struct__PangoItem = extern struct {
    offset: gint,
    length: gint,
    num_chars: gint,
    analysis: PangoAnalysis,
};
pub const PangoItem = struct__PangoItem;
pub extern fn pango_item_get_type() GType;
pub extern fn pango_item_new() [*c]PangoItem;
pub extern fn pango_item_copy(item: [*c]PangoItem) [*c]PangoItem;
pub extern fn pango_item_free(item: [*c]PangoItem) void;
pub extern fn pango_item_split(orig: [*c]PangoItem, split_index: c_int, split_offset: c_int) [*c]PangoItem;
pub extern fn pango_break(text: [*c]const gchar, length: c_int, analysis: [*c]PangoAnalysis, attrs: ?*PangoLogAttr, attrs_len: c_int) void;
pub extern fn pango_find_paragraph_boundary(text: [*c]const gchar, length: gint, paragraph_delimiter_index: [*c]gint, next_paragraph_start: [*c]gint) void;
pub extern fn pango_get_log_attrs(text: [*c]const u8, length: c_int, level: c_int, language: ?*PangoLanguage, log_attrs: ?*PangoLogAttr, attrs_len: c_int) void;
pub extern fn pango_fontset_get_type() GType;
pub const struct__PangoFontset = @OpaqueType();
pub const PangoFontset = struct__PangoFontset;
pub const PangoFontsetForeachFunc = ?extern fn (?*PangoFontset, ?*PangoFont, gpointer) gboolean;
pub extern fn pango_fontset_get_font(fontset: ?*PangoFontset, wc: guint) ?*PangoFont;
pub extern fn pango_fontset_get_metrics(fontset: ?*PangoFontset) ?*PangoFontMetrics;
pub extern fn pango_fontset_foreach(fontset: ?*PangoFontset, func: PangoFontsetForeachFunc, data: gpointer) void;
pub const struct__PangoContext = @OpaqueType();
pub const PangoContext = struct__PangoContext;
pub extern fn pango_font_map_get_type() GType;
pub extern fn pango_font_map_create_context(fontmap: ?*PangoFontMap) ?*PangoContext;
pub extern fn pango_font_map_load_font(fontmap: ?*PangoFontMap, context: ?*PangoContext, desc: ?*const PangoFontDescription) ?*PangoFont;
pub extern fn pango_font_map_load_fontset(fontmap: ?*PangoFontMap, context: ?*PangoContext, desc: ?*const PangoFontDescription, language: ?*PangoLanguage) ?*PangoFontset;
pub extern fn pango_font_map_list_families(fontmap: ?*PangoFontMap, families: [*c]([*c](?*PangoFontFamily)), n_families: [*c]c_int) void;
pub extern fn pango_font_map_get_serial(fontmap: ?*PangoFontMap) guint;
pub extern fn pango_font_map_changed(fontmap: ?*PangoFontMap) void;
pub const struct__PangoContextClass = @OpaqueType();
pub const PangoContextClass = struct__PangoContextClass;
pub extern fn pango_context_get_type() GType;
pub extern fn pango_context_new() ?*PangoContext;
pub extern fn pango_context_changed(context: ?*PangoContext) void;
pub extern fn pango_context_set_font_map(context: ?*PangoContext, font_map: ?*PangoFontMap) void;
pub extern fn pango_context_get_font_map(context: ?*PangoContext) ?*PangoFontMap;
pub extern fn pango_context_get_serial(context: ?*PangoContext) guint;
pub extern fn pango_context_list_families(context: ?*PangoContext, families: [*c]([*c](?*PangoFontFamily)), n_families: [*c]c_int) void;
pub extern fn pango_context_load_font(context: ?*PangoContext, desc: ?*const PangoFontDescription) ?*PangoFont;
pub extern fn pango_context_load_fontset(context: ?*PangoContext, desc: ?*const PangoFontDescription, language: ?*PangoLanguage) ?*PangoFontset;
pub extern fn pango_context_get_metrics(context: ?*PangoContext, desc: ?*const PangoFontDescription, language: ?*PangoLanguage) ?*PangoFontMetrics;
pub extern fn pango_context_set_font_description(context: ?*PangoContext, desc: ?*const PangoFontDescription) void;
pub extern fn pango_context_get_font_description(context: ?*PangoContext) ?*PangoFontDescription;
pub extern fn pango_context_get_language(context: ?*PangoContext) ?*PangoLanguage;
pub extern fn pango_context_set_language(context: ?*PangoContext, language: ?*PangoLanguage) void;
pub extern fn pango_context_set_base_dir(context: ?*PangoContext, direction: PangoDirection) void;
pub extern fn pango_context_get_base_dir(context: ?*PangoContext) PangoDirection;
pub extern fn pango_context_set_base_gravity(context: ?*PangoContext, gravity: PangoGravity) void;
pub extern fn pango_context_get_base_gravity(context: ?*PangoContext) PangoGravity;
pub extern fn pango_context_get_gravity(context: ?*PangoContext) PangoGravity;
pub extern fn pango_context_set_gravity_hint(context: ?*PangoContext, hint: PangoGravityHint) void;
pub extern fn pango_context_get_gravity_hint(context: ?*PangoContext) PangoGravityHint;
pub extern fn pango_context_set_matrix(context: ?*PangoContext, matrix: [*c]const PangoMatrix) void;
pub extern fn pango_context_get_matrix(context: ?*PangoContext) [*c]const PangoMatrix;
pub extern fn pango_itemize(context: ?*PangoContext, text: [*c]const u8, start_index: c_int, length: c_int, attrs: ?*PangoAttrList, cached_iter: ?*PangoAttrIterator) [*c]GList;
pub extern fn pango_itemize_with_base_dir(context: ?*PangoContext, base_dir: PangoDirection, text: [*c]const u8, start_index: c_int, length: c_int, attrs: ?*PangoAttrList, cached_iter: ?*PangoAttrIterator) [*c]GList;
pub const PangoGlyphUnit = gint32;
pub const struct__PangoGlyphGeometry = extern struct {
    width: PangoGlyphUnit,
    x_offset: PangoGlyphUnit,
    y_offset: PangoGlyphUnit,
};
pub const PangoGlyphGeometry = struct__PangoGlyphGeometry;
pub const struct__PangoGlyphVisAttr = @OpaqueType();
pub const PangoGlyphVisAttr = struct__PangoGlyphVisAttr;
pub const struct__PangoGlyphInfo = extern struct {
    glyph: PangoGlyph,
    geometry: PangoGlyphGeometry,
    attr: PangoGlyphVisAttr,
};
pub const PangoGlyphInfo = struct__PangoGlyphInfo;
pub const struct__PangoGlyphString = extern struct {
    num_glyphs: gint,
    glyphs: [*c]PangoGlyphInfo,
    log_clusters: [*c]gint,
    space: gint,
};
pub const PangoGlyphString = struct__PangoGlyphString;
pub extern fn pango_glyph_string_new() [*c]PangoGlyphString;
pub extern fn pango_glyph_string_set_size(string: [*c]PangoGlyphString, new_len: gint) void;
pub extern fn pango_glyph_string_get_type() GType;
pub extern fn pango_glyph_string_copy(string: [*c]PangoGlyphString) [*c]PangoGlyphString;
pub extern fn pango_glyph_string_free(string: [*c]PangoGlyphString) void;
pub extern fn pango_glyph_string_extents(glyphs: [*c]PangoGlyphString, font: ?*PangoFont, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_glyph_string_get_width(glyphs: [*c]PangoGlyphString) c_int;
pub extern fn pango_glyph_string_extents_range(glyphs: [*c]PangoGlyphString, start: c_int, end: c_int, font: ?*PangoFont, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_glyph_string_get_logical_widths(glyphs: [*c]PangoGlyphString, text: [*c]const u8, length: c_int, embedding_level: c_int, logical_widths: [*c]c_int) void;
pub extern fn pango_glyph_string_index_to_x(glyphs: [*c]PangoGlyphString, text: [*c]u8, length: c_int, analysis: [*c]PangoAnalysis, index_: c_int, trailing: gboolean, x_pos: [*c]c_int) void;
pub extern fn pango_glyph_string_x_to_index(glyphs: [*c]PangoGlyphString, text: [*c]u8, length: c_int, analysis: [*c]PangoAnalysis, x_pos: c_int, index_: [*c]c_int, trailing: [*c]c_int) void;
pub extern fn pango_shape(text: [*c]const gchar, length: gint, analysis: [*c]const PangoAnalysis, glyphs: [*c]PangoGlyphString) void;
pub extern fn pango_shape_full(item_text: [*c]const gchar, item_length: gint, paragraph_text: [*c]const gchar, paragraph_length: gint, analysis: [*c]const PangoAnalysis, glyphs: [*c]PangoGlyphString) void;
pub extern fn pango_reorder_items(logical_items: [*c]GList) [*c]GList;
pub extern fn pango_attr_type_get_type() GType;
pub extern fn pango_underline_get_type() GType;
pub extern fn pango_bidi_type_get_type() GType;
pub extern fn pango_coverage_level_get_type() GType;
pub extern fn pango_direction_get_type() GType;
pub extern fn pango_style_get_type() GType;
pub extern fn pango_variant_get_type() GType;
pub extern fn pango_weight_get_type() GType;
pub extern fn pango_stretch_get_type() GType;
pub extern fn pango_font_mask_get_type() GType;
pub extern fn pango_gravity_get_type() GType;
pub extern fn pango_gravity_hint_get_type() GType;
pub extern fn pango_alignment_get_type() GType;
pub extern fn pango_wrap_mode_get_type() GType;
pub extern fn pango_ellipsize_mode_get_type() GType;
pub extern fn pango_render_part_get_type() GType;
pub extern fn pango_script_get_type() GType;
pub extern fn pango_tab_align_get_type() GType;
pub const struct__PangoGlyphItem = extern struct {
    item: [*c]PangoItem,
    glyphs: [*c]PangoGlyphString,
};
pub const PangoGlyphItem = struct__PangoGlyphItem;
pub extern fn pango_glyph_item_get_type() GType;
pub extern fn pango_glyph_item_split(orig: [*c]PangoGlyphItem, text: [*c]const u8, split_index: c_int) [*c]PangoGlyphItem;
pub extern fn pango_glyph_item_copy(orig: [*c]PangoGlyphItem) [*c]PangoGlyphItem;
pub extern fn pango_glyph_item_free(glyph_item: [*c]PangoGlyphItem) void;
pub extern fn pango_glyph_item_apply_attrs(glyph_item: [*c]PangoGlyphItem, text: [*c]const u8, list: ?*PangoAttrList) [*c]GSList;
pub extern fn pango_glyph_item_letter_space(glyph_item: [*c]PangoGlyphItem, text: [*c]const u8, log_attrs: ?*PangoLogAttr, letter_spacing: c_int) void;
pub extern fn pango_glyph_item_get_logical_widths(glyph_item: [*c]PangoGlyphItem, text: [*c]const u8, logical_widths: [*c]c_int) void;
pub const struct__PangoGlyphItemIter = extern struct {
    glyph_item: [*c]PangoGlyphItem,
    text: [*c]const gchar,
    start_glyph: c_int,
    start_index: c_int,
    start_char: c_int,
    end_glyph: c_int,
    end_index: c_int,
    end_char: c_int,
};
pub const PangoGlyphItemIter = struct__PangoGlyphItemIter;
pub extern fn pango_glyph_item_iter_get_type() GType;
pub extern fn pango_glyph_item_iter_copy(orig: [*c]PangoGlyphItemIter) [*c]PangoGlyphItemIter;
pub extern fn pango_glyph_item_iter_free(iter: [*c]PangoGlyphItemIter) void;
pub extern fn pango_glyph_item_iter_init_start(iter: [*c]PangoGlyphItemIter, glyph_item: [*c]PangoGlyphItem, text: [*c]const u8) gboolean;
pub extern fn pango_glyph_item_iter_init_end(iter: [*c]PangoGlyphItemIter, glyph_item: [*c]PangoGlyphItem, text: [*c]const u8) gboolean;
pub extern fn pango_glyph_item_iter_next_cluster(iter: [*c]PangoGlyphItemIter) gboolean;
pub extern fn pango_glyph_item_iter_prev_cluster(iter: [*c]PangoGlyphItemIter) gboolean;
pub const struct__PangoTabArray = @OpaqueType();
pub const PangoTabArray = struct__PangoTabArray;
pub const PANGO_TAB_LEFT = 0;
pub const PangoTabAlign = extern enum {
    PANGO_TAB_LEFT = 0,
};
pub extern fn pango_tab_array_new(initial_size: gint, positions_in_pixels: gboolean) ?*PangoTabArray;
pub extern fn pango_tab_array_new_with_positions(size: gint, positions_in_pixels: gboolean, first_alignment: PangoTabAlign, first_position: gint, ...) ?*PangoTabArray;
pub extern fn pango_tab_array_get_type() GType;
pub extern fn pango_tab_array_copy(src: ?*PangoTabArray) ?*PangoTabArray;
pub extern fn pango_tab_array_free(tab_array: ?*PangoTabArray) void;
pub extern fn pango_tab_array_get_size(tab_array: ?*PangoTabArray) gint;
pub extern fn pango_tab_array_resize(tab_array: ?*PangoTabArray, new_size: gint) void;
pub extern fn pango_tab_array_set_tab(tab_array: ?*PangoTabArray, tab_index: gint, alignment: PangoTabAlign, location: gint) void;
pub extern fn pango_tab_array_get_tab(tab_array: ?*PangoTabArray, tab_index: gint, alignment: [*c]PangoTabAlign, location: [*c]gint) void;
pub extern fn pango_tab_array_get_tabs(tab_array: ?*PangoTabArray, alignments: [*c]([*c]PangoTabAlign), locations: [*c]([*c]gint)) void;
pub extern fn pango_tab_array_get_positions_in_pixels(tab_array: ?*PangoTabArray) gboolean;
pub const struct__PangoLayout = @OpaqueType();
pub const PangoLayout = struct__PangoLayout;
pub const struct__PangoLayoutClass = @OpaqueType();
pub const PangoLayoutClass = struct__PangoLayoutClass;
pub const struct__PangoLayoutLine = @OpaqueType();
pub const PangoLayoutLine = struct__PangoLayoutLine;
pub const PangoLayoutRun = PangoGlyphItem;
pub const PANGO_ALIGN_LEFT = 0;
pub const PANGO_ALIGN_CENTER = 1;
pub const PANGO_ALIGN_RIGHT = 2;
pub const PangoAlignment = extern enum {
    PANGO_ALIGN_LEFT = 0,
    PANGO_ALIGN_CENTER = 1,
    PANGO_ALIGN_RIGHT = 2,
};
pub const PANGO_WRAP_WORD = 0;
pub const PANGO_WRAP_CHAR = 1;
pub const PANGO_WRAP_WORD_CHAR = 2;
pub const PangoWrapMode = extern enum {
    PANGO_WRAP_WORD = 0,
    PANGO_WRAP_CHAR = 1,
    PANGO_WRAP_WORD_CHAR = 2,
};
pub const PANGO_ELLIPSIZE_NONE = 0;
pub const PANGO_ELLIPSIZE_START = 1;
pub const PANGO_ELLIPSIZE_MIDDLE = 2;
pub const PANGO_ELLIPSIZE_END = 3;
pub const PangoEllipsizeMode = extern enum {
    PANGO_ELLIPSIZE_NONE = 0,
    PANGO_ELLIPSIZE_START = 1,
    PANGO_ELLIPSIZE_MIDDLE = 2,
    PANGO_ELLIPSIZE_END = 3,
};
pub extern fn pango_layout_get_type() GType;
pub extern fn pango_layout_new(context: ?*PangoContext) ?*PangoLayout;
pub extern fn pango_layout_copy(src: ?*PangoLayout) ?*PangoLayout;
pub extern fn pango_layout_get_context(layout: ?*PangoLayout) ?*PangoContext;
pub extern fn pango_layout_set_attributes(layout: ?*PangoLayout, attrs: ?*PangoAttrList) void;
pub extern fn pango_layout_get_attributes(layout: ?*PangoLayout) ?*PangoAttrList;
pub extern fn pango_layout_set_text(layout: ?*PangoLayout, text: [*c]const u8, length: c_int) void;
pub extern fn pango_layout_get_text(layout: ?*PangoLayout) [*c]const u8;
pub extern fn pango_layout_get_character_count(layout: ?*PangoLayout) gint;
pub extern fn pango_layout_set_markup(layout: ?*PangoLayout, markup: [*c]const u8, length: c_int) void;
pub extern fn pango_layout_set_markup_with_accel(layout: ?*PangoLayout, markup: [*c]const u8, length: c_int, accel_marker: gunichar, accel_char: [*c]gunichar) void;
pub extern fn pango_layout_set_font_description(layout: ?*PangoLayout, desc: ?*const PangoFontDescription) void;
pub extern fn pango_layout_get_font_description(layout: ?*PangoLayout) ?*const PangoFontDescription;
pub extern fn pango_layout_set_width(layout: ?*PangoLayout, width: c_int) void;
pub extern fn pango_layout_get_width(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_set_height(layout: ?*PangoLayout, height: c_int) void;
pub extern fn pango_layout_get_height(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_set_wrap(layout: ?*PangoLayout, wrap: PangoWrapMode) void;
pub extern fn pango_layout_get_wrap(layout: ?*PangoLayout) PangoWrapMode;
pub extern fn pango_layout_is_wrapped(layout: ?*PangoLayout) gboolean;
pub extern fn pango_layout_set_indent(layout: ?*PangoLayout, indent: c_int) void;
pub extern fn pango_layout_get_indent(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_set_spacing(layout: ?*PangoLayout, spacing: c_int) void;
pub extern fn pango_layout_get_spacing(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_set_justify(layout: ?*PangoLayout, justify: gboolean) void;
pub extern fn pango_layout_get_justify(layout: ?*PangoLayout) gboolean;
pub extern fn pango_layout_set_auto_dir(layout: ?*PangoLayout, auto_dir: gboolean) void;
pub extern fn pango_layout_get_auto_dir(layout: ?*PangoLayout) gboolean;
pub extern fn pango_layout_set_alignment(layout: ?*PangoLayout, alignment: PangoAlignment) void;
pub extern fn pango_layout_get_alignment(layout: ?*PangoLayout) PangoAlignment;
pub extern fn pango_layout_set_tabs(layout: ?*PangoLayout, tabs: ?*PangoTabArray) void;
pub extern fn pango_layout_get_tabs(layout: ?*PangoLayout) ?*PangoTabArray;
pub extern fn pango_layout_set_single_paragraph_mode(layout: ?*PangoLayout, setting: gboolean) void;
pub extern fn pango_layout_get_single_paragraph_mode(layout: ?*PangoLayout) gboolean;
pub extern fn pango_layout_set_ellipsize(layout: ?*PangoLayout, ellipsize: PangoEllipsizeMode) void;
pub extern fn pango_layout_get_ellipsize(layout: ?*PangoLayout) PangoEllipsizeMode;
pub extern fn pango_layout_is_ellipsized(layout: ?*PangoLayout) gboolean;
pub extern fn pango_layout_get_unknown_glyphs_count(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_context_changed(layout: ?*PangoLayout) void;
pub extern fn pango_layout_get_serial(layout: ?*PangoLayout) guint;
pub extern fn pango_layout_get_log_attrs(layout: ?*PangoLayout, attrs: [*c](?*PangoLogAttr), n_attrs: [*c]gint) void;
pub extern fn pango_layout_get_log_attrs_readonly(layout: ?*PangoLayout, n_attrs: [*c]gint) ?*const PangoLogAttr;
pub extern fn pango_layout_index_to_pos(layout: ?*PangoLayout, index_: c_int, pos: [*c]PangoRectangle) void;
pub extern fn pango_layout_index_to_line_x(layout: ?*PangoLayout, index_: c_int, trailing: gboolean, line: [*c]c_int, x_pos: [*c]c_int) void;
pub extern fn pango_layout_get_cursor_pos(layout: ?*PangoLayout, index_: c_int, strong_pos: [*c]PangoRectangle, weak_pos: [*c]PangoRectangle) void;
pub extern fn pango_layout_move_cursor_visually(layout: ?*PangoLayout, strong: gboolean, old_index: c_int, old_trailing: c_int, direction: c_int, new_index: [*c]c_int, new_trailing: [*c]c_int) void;
pub extern fn pango_layout_xy_to_index(layout: ?*PangoLayout, x: c_int, y: c_int, index_: [*c]c_int, trailing: [*c]c_int) gboolean;
pub extern fn pango_layout_get_extents(layout: ?*PangoLayout, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_get_pixel_extents(layout: ?*PangoLayout, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_get_size(layout: ?*PangoLayout, width: [*c]c_int, height: [*c]c_int) void;
pub extern fn pango_layout_get_pixel_size(layout: ?*PangoLayout, width: [*c]c_int, height: [*c]c_int) void;
pub extern fn pango_layout_get_baseline(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_get_line_count(layout: ?*PangoLayout) c_int;
pub extern fn pango_layout_get_line(layout: ?*PangoLayout, line: c_int) ?*PangoLayoutLine;
pub extern fn pango_layout_get_line_readonly(layout: ?*PangoLayout, line: c_int) ?*PangoLayoutLine;
pub extern fn pango_layout_get_lines(layout: ?*PangoLayout) [*c]GSList;
pub extern fn pango_layout_get_lines_readonly(layout: ?*PangoLayout) [*c]GSList;
pub extern fn pango_layout_line_get_type() GType;
pub extern fn pango_layout_line_ref(line: ?*PangoLayoutLine) ?*PangoLayoutLine;
pub extern fn pango_layout_line_unref(line: ?*PangoLayoutLine) void;
pub extern fn pango_layout_line_x_to_index(line: ?*PangoLayoutLine, x_pos: c_int, index_: [*c]c_int, trailing: [*c]c_int) gboolean;
pub extern fn pango_layout_line_index_to_x(line: ?*PangoLayoutLine, index_: c_int, trailing: gboolean, x_pos: [*c]c_int) void;
pub extern fn pango_layout_line_get_x_ranges(line: ?*PangoLayoutLine, start_index: c_int, end_index: c_int, ranges: [*c]([*c]c_int), n_ranges: [*c]c_int) void;
pub extern fn pango_layout_line_get_extents(line: ?*PangoLayoutLine, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_line_get_pixel_extents(layout_line: ?*PangoLayoutLine, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub const struct__PangoLayoutIter = @OpaqueType();
pub const PangoLayoutIter = struct__PangoLayoutIter;
pub extern fn pango_layout_iter_get_type() GType;
pub extern fn pango_layout_get_iter(layout: ?*PangoLayout) ?*PangoLayoutIter;
pub extern fn pango_layout_iter_copy(iter: ?*PangoLayoutIter) ?*PangoLayoutIter;
pub extern fn pango_layout_iter_free(iter: ?*PangoLayoutIter) void;
pub extern fn pango_layout_iter_get_index(iter: ?*PangoLayoutIter) c_int;
pub extern fn pango_layout_iter_get_run(iter: ?*PangoLayoutIter) [*c]PangoLayoutRun;
pub extern fn pango_layout_iter_get_run_readonly(iter: ?*PangoLayoutIter) [*c]PangoLayoutRun;
pub extern fn pango_layout_iter_get_line(iter: ?*PangoLayoutIter) ?*PangoLayoutLine;
pub extern fn pango_layout_iter_get_line_readonly(iter: ?*PangoLayoutIter) ?*PangoLayoutLine;
pub extern fn pango_layout_iter_at_last_line(iter: ?*PangoLayoutIter) gboolean;
pub extern fn pango_layout_iter_get_layout(iter: ?*PangoLayoutIter) ?*PangoLayout;
pub extern fn pango_layout_iter_next_char(iter: ?*PangoLayoutIter) gboolean;
pub extern fn pango_layout_iter_next_cluster(iter: ?*PangoLayoutIter) gboolean;
pub extern fn pango_layout_iter_next_run(iter: ?*PangoLayoutIter) gboolean;
pub extern fn pango_layout_iter_next_line(iter: ?*PangoLayoutIter) gboolean;
pub extern fn pango_layout_iter_get_char_extents(iter: ?*PangoLayoutIter, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_iter_get_cluster_extents(iter: ?*PangoLayoutIter, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_iter_get_run_extents(iter: ?*PangoLayoutIter, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_iter_get_line_extents(iter: ?*PangoLayoutIter, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_iter_get_line_yrange(iter: ?*PangoLayoutIter, y0_: [*c]c_int, y1_: [*c]c_int) void;
pub extern fn pango_layout_iter_get_layout_extents(iter: ?*PangoLayoutIter, ink_rect: [*c]PangoRectangle, logical_rect: [*c]PangoRectangle) void;
pub extern fn pango_layout_iter_get_baseline(iter: ?*PangoLayoutIter) c_int;
pub const struct__PangoRendererPrivate = @OpaqueType();
pub const PangoRendererPrivate = struct__PangoRendererPrivate;
pub const struct__PangoRenderer = extern struct {
    parent_instance: GObject,
    underline: PangoUnderline,
    strikethrough: gboolean,
    active_count: c_int,
    matrix: [*c]PangoMatrix,
    priv: ?*PangoRendererPrivate,
};
pub const PangoRenderer = struct__PangoRenderer;
pub const PANGO_RENDER_PART_FOREGROUND = 0;
pub const PANGO_RENDER_PART_BACKGROUND = 1;
pub const PANGO_RENDER_PART_UNDERLINE = 2;
pub const PANGO_RENDER_PART_STRIKETHROUGH = 3;
pub const PangoRenderPart = extern enum {
    PANGO_RENDER_PART_FOREGROUND = 0,
    PANGO_RENDER_PART_BACKGROUND = 1,
    PANGO_RENDER_PART_UNDERLINE = 2,
    PANGO_RENDER_PART_STRIKETHROUGH = 3,
};
pub const struct__PangoRendererClass = extern struct {
    parent_class: GObjectClass,
    draw_glyphs: ?extern fn ([*c]PangoRenderer, ?*PangoFont, [*c]PangoGlyphString, c_int, c_int) void,
    draw_rectangle: ?extern fn ([*c]PangoRenderer, PangoRenderPart, c_int, c_int, c_int, c_int) void,
    draw_error_underline: ?extern fn ([*c]PangoRenderer, c_int, c_int, c_int, c_int) void,
    draw_shape: ?extern fn ([*c]PangoRenderer, [*c]PangoAttrShape, c_int, c_int) void,
    draw_trapezoid: ?extern fn ([*c]PangoRenderer, PangoRenderPart, f64, f64, f64, f64, f64, f64) void,
    draw_glyph: ?extern fn ([*c]PangoRenderer, ?*PangoFont, PangoGlyph, f64, f64) void,
    part_changed: ?extern fn ([*c]PangoRenderer, PangoRenderPart) void,
    begin: ?extern fn ([*c]PangoRenderer) void,
    end: ?extern fn ([*c]PangoRenderer) void,
    prepare_run: ?extern fn ([*c]PangoRenderer, [*c]PangoLayoutRun) void,
    draw_glyph_item: ?extern fn ([*c]PangoRenderer, [*c]const u8, [*c]PangoGlyphItem, c_int, c_int) void,
    _pango_reserved2: ?extern fn () void,
    _pango_reserved3: ?extern fn () void,
    _pango_reserved4: ?extern fn () void,
};
pub const PangoRendererClass = struct__PangoRendererClass;
pub extern fn pango_renderer_get_type() GType;
pub extern fn pango_renderer_draw_layout(renderer: [*c]PangoRenderer, layout: ?*PangoLayout, x: c_int, y: c_int) void;
pub extern fn pango_renderer_draw_layout_line(renderer: [*c]PangoRenderer, line: ?*PangoLayoutLine, x: c_int, y: c_int) void;
pub extern fn pango_renderer_draw_glyphs(renderer: [*c]PangoRenderer, font: ?*PangoFont, glyphs: [*c]PangoGlyphString, x: c_int, y: c_int) void;
pub extern fn pango_renderer_draw_glyph_item(renderer: [*c]PangoRenderer, text: [*c]const u8, glyph_item: [*c]PangoGlyphItem, x: c_int, y: c_int) void;
pub extern fn pango_renderer_draw_rectangle(renderer: [*c]PangoRenderer, part: PangoRenderPart, x: c_int, y: c_int, width: c_int, height: c_int) void;
pub extern fn pango_renderer_draw_error_underline(renderer: [*c]PangoRenderer, x: c_int, y: c_int, width: c_int, height: c_int) void;
pub extern fn pango_renderer_draw_trapezoid(renderer: [*c]PangoRenderer, part: PangoRenderPart, y1_: f64, x11: f64, x21: f64, y2: f64, x12: f64, x22: f64) void;
pub extern fn pango_renderer_draw_glyph(renderer: [*c]PangoRenderer, font: ?*PangoFont, glyph: PangoGlyph, x: f64, y: f64) void;
pub extern fn pango_renderer_activate(renderer: [*c]PangoRenderer) void;
pub extern fn pango_renderer_deactivate(renderer: [*c]PangoRenderer) void;
pub extern fn pango_renderer_part_changed(renderer: [*c]PangoRenderer, part: PangoRenderPart) void;
pub extern fn pango_renderer_set_color(renderer: [*c]PangoRenderer, part: PangoRenderPart, color: [*c]const PangoColor) void;
pub extern fn pango_renderer_get_color(renderer: [*c]PangoRenderer, part: PangoRenderPart) [*c]PangoColor;
pub extern fn pango_renderer_set_alpha(renderer: [*c]PangoRenderer, part: PangoRenderPart, alpha: guint16) void;
pub extern fn pango_renderer_get_alpha(renderer: [*c]PangoRenderer, part: PangoRenderPart) guint16;
pub extern fn pango_renderer_set_matrix(renderer: [*c]PangoRenderer, matrix: [*c]const PangoMatrix) void;
pub extern fn pango_renderer_get_matrix(renderer: [*c]PangoRenderer) [*c]const PangoMatrix;
pub extern fn pango_renderer_get_layout(renderer: [*c]PangoRenderer) ?*PangoLayout;
pub extern fn pango_renderer_get_layout_line(renderer: [*c]PangoRenderer) ?*PangoLayoutLine;
pub extern fn pango_split_file_list(str: [*c]const u8) [*c]([*c]u8);
pub extern fn pango_trim_string(str: [*c]const u8) [*c]u8;
pub extern fn pango_read_line(stream: [*c]FILE, str: [*c]GString) gint;
pub extern fn pango_skip_space(pos: [*c]([*c]const u8)) gboolean;
pub extern fn pango_scan_word(pos: [*c]([*c]const u8), out: [*c]GString) gboolean;
pub extern fn pango_scan_string(pos: [*c]([*c]const u8), out: [*c]GString) gboolean;
pub extern fn pango_scan_int(pos: [*c]([*c]const u8), out: [*c]c_int) gboolean;
pub extern fn pango_parse_enum(type_0: GType, str: [*c]const u8, value: [*c]c_int, warn: gboolean, possible_values: [*c]([*c]u8)) gboolean;
pub extern fn pango_parse_style(str: [*c]const u8, style: [*c]PangoStyle, warn: gboolean) gboolean;
pub extern fn pango_parse_variant(str: [*c]const u8, variant: [*c]PangoVariant, warn: gboolean) gboolean;
pub extern fn pango_parse_weight(str: [*c]const u8, weight: [*c]PangoWeight, warn: gboolean) gboolean;
pub extern fn pango_parse_stretch(str: [*c]const u8, stretch: [*c]PangoStretch, warn: gboolean) gboolean;
pub extern fn pango_quantize_line_geometry(thickness: [*c]c_int, position: [*c]c_int) void;
pub extern fn pango_log2vis_get_embedding_levels(text: [*c]const gchar, length: c_int, pbase_dir: [*c]PangoDirection) [*c]guint8;
pub extern fn pango_is_zero_width(ch: gunichar) gboolean;
pub extern fn pango_version() c_int;
pub extern fn pango_version_string() [*c]const u8;
pub extern fn pango_version_check(required_major: c_int, required_minor: c_int, required_micro: c_int) [*c]const u8;
pub extern fn cairo_version() c_int;
pub extern fn cairo_version_string() [*c]const u8;
pub const cairo_bool_t = c_int;
pub const struct__cairo = @OpaqueType();
pub const cairo_t = struct__cairo;
pub const struct__cairo_surface = @OpaqueType();
pub const cairo_surface_t = struct__cairo_surface;
pub const struct__cairo_device = @OpaqueType();
pub const cairo_device_t = struct__cairo_device;
pub const struct__cairo_matrix = extern struct {
    xx: f64,
    yx: f64,
    xy: f64,
    yy: f64,
    x0: f64,
    y0: f64,
};
pub const cairo_matrix_t = struct__cairo_matrix;
pub const struct__cairo_pattern = @OpaqueType();
pub const cairo_pattern_t = struct__cairo_pattern;
pub const cairo_destroy_func_t = ?extern fn (?*c_void) void;
pub const struct__cairo_user_data_key = extern struct {
    unused: c_int,
};
pub const cairo_user_data_key_t = struct__cairo_user_data_key;
pub const CAIRO_STATUS_SUCCESS = enum__cairo_status.CAIRO_STATUS_SUCCESS;
pub const CAIRO_STATUS_NO_MEMORY = enum__cairo_status.CAIRO_STATUS_NO_MEMORY;
pub const CAIRO_STATUS_INVALID_RESTORE = enum__cairo_status.CAIRO_STATUS_INVALID_RESTORE;
pub const CAIRO_STATUS_INVALID_POP_GROUP = enum__cairo_status.CAIRO_STATUS_INVALID_POP_GROUP;
pub const CAIRO_STATUS_NO_CURRENT_POINT = enum__cairo_status.CAIRO_STATUS_NO_CURRENT_POINT;
pub const CAIRO_STATUS_INVALID_MATRIX = enum__cairo_status.CAIRO_STATUS_INVALID_MATRIX;
pub const CAIRO_STATUS_INVALID_STATUS = enum__cairo_status.CAIRO_STATUS_INVALID_STATUS;
pub const CAIRO_STATUS_NULL_POINTER = enum__cairo_status.CAIRO_STATUS_NULL_POINTER;
pub const CAIRO_STATUS_INVALID_STRING = enum__cairo_status.CAIRO_STATUS_INVALID_STRING;
pub const CAIRO_STATUS_INVALID_PATH_DATA = enum__cairo_status.CAIRO_STATUS_INVALID_PATH_DATA;
pub const CAIRO_STATUS_READ_ERROR = enum__cairo_status.CAIRO_STATUS_READ_ERROR;
pub const CAIRO_STATUS_WRITE_ERROR = enum__cairo_status.CAIRO_STATUS_WRITE_ERROR;
pub const CAIRO_STATUS_SURFACE_FINISHED = enum__cairo_status.CAIRO_STATUS_SURFACE_FINISHED;
pub const CAIRO_STATUS_SURFACE_TYPE_MISMATCH = enum__cairo_status.CAIRO_STATUS_SURFACE_TYPE_MISMATCH;
pub const CAIRO_STATUS_PATTERN_TYPE_MISMATCH = enum__cairo_status.CAIRO_STATUS_PATTERN_TYPE_MISMATCH;
pub const CAIRO_STATUS_INVALID_CONTENT = enum__cairo_status.CAIRO_STATUS_INVALID_CONTENT;
pub const CAIRO_STATUS_INVALID_FORMAT = enum__cairo_status.CAIRO_STATUS_INVALID_FORMAT;
pub const CAIRO_STATUS_INVALID_VISUAL = enum__cairo_status.CAIRO_STATUS_INVALID_VISUAL;
pub const CAIRO_STATUS_FILE_NOT_FOUND = enum__cairo_status.CAIRO_STATUS_FILE_NOT_FOUND;
pub const CAIRO_STATUS_INVALID_DASH = enum__cairo_status.CAIRO_STATUS_INVALID_DASH;
pub const CAIRO_STATUS_INVALID_DSC_COMMENT = enum__cairo_status.CAIRO_STATUS_INVALID_DSC_COMMENT;
pub const CAIRO_STATUS_INVALID_INDEX = enum__cairo_status.CAIRO_STATUS_INVALID_INDEX;
pub const CAIRO_STATUS_CLIP_NOT_REPRESENTABLE = enum__cairo_status.CAIRO_STATUS_CLIP_NOT_REPRESENTABLE;
pub const CAIRO_STATUS_TEMP_FILE_ERROR = enum__cairo_status.CAIRO_STATUS_TEMP_FILE_ERROR;
pub const CAIRO_STATUS_INVALID_STRIDE = enum__cairo_status.CAIRO_STATUS_INVALID_STRIDE;
pub const CAIRO_STATUS_FONT_TYPE_MISMATCH = enum__cairo_status.CAIRO_STATUS_FONT_TYPE_MISMATCH;
pub const CAIRO_STATUS_USER_FONT_IMMUTABLE = enum__cairo_status.CAIRO_STATUS_USER_FONT_IMMUTABLE;
pub const CAIRO_STATUS_USER_FONT_ERROR = enum__cairo_status.CAIRO_STATUS_USER_FONT_ERROR;
pub const CAIRO_STATUS_NEGATIVE_COUNT = enum__cairo_status.CAIRO_STATUS_NEGATIVE_COUNT;
pub const CAIRO_STATUS_INVALID_CLUSTERS = enum__cairo_status.CAIRO_STATUS_INVALID_CLUSTERS;
pub const CAIRO_STATUS_INVALID_SLANT = enum__cairo_status.CAIRO_STATUS_INVALID_SLANT;
pub const CAIRO_STATUS_INVALID_WEIGHT = enum__cairo_status.CAIRO_STATUS_INVALID_WEIGHT;
pub const CAIRO_STATUS_INVALID_SIZE = enum__cairo_status.CAIRO_STATUS_INVALID_SIZE;
pub const CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED = enum__cairo_status.CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED;
pub const CAIRO_STATUS_DEVICE_TYPE_MISMATCH = enum__cairo_status.CAIRO_STATUS_DEVICE_TYPE_MISMATCH;
pub const CAIRO_STATUS_DEVICE_ERROR = enum__cairo_status.CAIRO_STATUS_DEVICE_ERROR;
pub const CAIRO_STATUS_INVALID_MESH_CONSTRUCTION = enum__cairo_status.CAIRO_STATUS_INVALID_MESH_CONSTRUCTION;
pub const CAIRO_STATUS_DEVICE_FINISHED = enum__cairo_status.CAIRO_STATUS_DEVICE_FINISHED;
pub const CAIRO_STATUS_JBIG2_GLOBAL_MISSING = enum__cairo_status.CAIRO_STATUS_JBIG2_GLOBAL_MISSING;
pub const CAIRO_STATUS_PNG_ERROR = enum__cairo_status.CAIRO_STATUS_PNG_ERROR;
pub const CAIRO_STATUS_FREETYPE_ERROR = enum__cairo_status.CAIRO_STATUS_FREETYPE_ERROR;
pub const CAIRO_STATUS_WIN32_GDI_ERROR = enum__cairo_status.CAIRO_STATUS_WIN32_GDI_ERROR;
pub const CAIRO_STATUS_TAG_ERROR = enum__cairo_status.CAIRO_STATUS_TAG_ERROR;
pub const CAIRO_STATUS_LAST_STATUS = enum__cairo_status.CAIRO_STATUS_LAST_STATUS;
pub const enum__cairo_status = extern enum {
    CAIRO_STATUS_SUCCESS = 0,
    CAIRO_STATUS_NO_MEMORY = 1,
    CAIRO_STATUS_INVALID_RESTORE = 2,
    CAIRO_STATUS_INVALID_POP_GROUP = 3,
    CAIRO_STATUS_NO_CURRENT_POINT = 4,
    CAIRO_STATUS_INVALID_MATRIX = 5,
    CAIRO_STATUS_INVALID_STATUS = 6,
    CAIRO_STATUS_NULL_POINTER = 7,
    CAIRO_STATUS_INVALID_STRING = 8,
    CAIRO_STATUS_INVALID_PATH_DATA = 9,
    CAIRO_STATUS_READ_ERROR = 10,
    CAIRO_STATUS_WRITE_ERROR = 11,
    CAIRO_STATUS_SURFACE_FINISHED = 12,
    CAIRO_STATUS_SURFACE_TYPE_MISMATCH = 13,
    CAIRO_STATUS_PATTERN_TYPE_MISMATCH = 14,
    CAIRO_STATUS_INVALID_CONTENT = 15,
    CAIRO_STATUS_INVALID_FORMAT = 16,
    CAIRO_STATUS_INVALID_VISUAL = 17,
    CAIRO_STATUS_FILE_NOT_FOUND = 18,
    CAIRO_STATUS_INVALID_DASH = 19,
    CAIRO_STATUS_INVALID_DSC_COMMENT = 20,
    CAIRO_STATUS_INVALID_INDEX = 21,
    CAIRO_STATUS_CLIP_NOT_REPRESENTABLE = 22,
    CAIRO_STATUS_TEMP_FILE_ERROR = 23,
    CAIRO_STATUS_INVALID_STRIDE = 24,
    CAIRO_STATUS_FONT_TYPE_MISMATCH = 25,
    CAIRO_STATUS_USER_FONT_IMMUTABLE = 26,
    CAIRO_STATUS_USER_FONT_ERROR = 27,
    CAIRO_STATUS_NEGATIVE_COUNT = 28,
    CAIRO_STATUS_INVALID_CLUSTERS = 29,
    CAIRO_STATUS_INVALID_SLANT = 30,
    CAIRO_STATUS_INVALID_WEIGHT = 31,
    CAIRO_STATUS_INVALID_SIZE = 32,
    CAIRO_STATUS_USER_FONT_NOT_IMPLEMENTED = 33,
    CAIRO_STATUS_DEVICE_TYPE_MISMATCH = 34,
    CAIRO_STATUS_DEVICE_ERROR = 35,
    CAIRO_STATUS_INVALID_MESH_CONSTRUCTION = 36,
    CAIRO_STATUS_DEVICE_FINISHED = 37,
    CAIRO_STATUS_JBIG2_GLOBAL_MISSING = 38,
    CAIRO_STATUS_PNG_ERROR = 39,
    CAIRO_STATUS_FREETYPE_ERROR = 40,
    CAIRO_STATUS_WIN32_GDI_ERROR = 41,
    CAIRO_STATUS_TAG_ERROR = 42,
    CAIRO_STATUS_LAST_STATUS = 43,
};
pub const cairo_status_t = enum__cairo_status;
pub const CAIRO_CONTENT_COLOR = enum__cairo_content.CAIRO_CONTENT_COLOR;
pub const CAIRO_CONTENT_ALPHA = enum__cairo_content.CAIRO_CONTENT_ALPHA;
pub const CAIRO_CONTENT_COLOR_ALPHA = enum__cairo_content.CAIRO_CONTENT_COLOR_ALPHA;
pub const enum__cairo_content = extern enum {
    CAIRO_CONTENT_COLOR = 4096,
    CAIRO_CONTENT_ALPHA = 8192,
    CAIRO_CONTENT_COLOR_ALPHA = 12288,
};
pub const cairo_content_t = enum__cairo_content;
pub const CAIRO_FORMAT_INVALID = enum__cairo_format.CAIRO_FORMAT_INVALID;
pub const CAIRO_FORMAT_ARGB32 = enum__cairo_format.CAIRO_FORMAT_ARGB32;
pub const CAIRO_FORMAT_RGB24 = enum__cairo_format.CAIRO_FORMAT_RGB24;
pub const CAIRO_FORMAT_A8 = enum__cairo_format.CAIRO_FORMAT_A8;
pub const CAIRO_FORMAT_A1 = enum__cairo_format.CAIRO_FORMAT_A1;
pub const CAIRO_FORMAT_RGB16_565 = enum__cairo_format.CAIRO_FORMAT_RGB16_565;
pub const CAIRO_FORMAT_RGB30 = enum__cairo_format.CAIRO_FORMAT_RGB30;
pub const enum__cairo_format = extern enum {
    CAIRO_FORMAT_INVALID = -1,
    CAIRO_FORMAT_ARGB32 = 0,
    CAIRO_FORMAT_RGB24 = 1,
    CAIRO_FORMAT_A8 = 2,
    CAIRO_FORMAT_A1 = 3,
    CAIRO_FORMAT_RGB16_565 = 4,
    CAIRO_FORMAT_RGB30 = 5,
};
pub const cairo_format_t = enum__cairo_format;
pub const cairo_write_func_t = ?extern fn (?*c_void, [*c]const u8, c_uint) cairo_status_t;
pub const cairo_read_func_t = ?extern fn (?*c_void, [*c]u8, c_uint) cairo_status_t;
pub const struct__cairo_rectangle_int = extern struct {
    x: c_int,
    y: c_int,
    width: c_int,
    height: c_int,
};
pub const cairo_rectangle_int_t = struct__cairo_rectangle_int;
pub extern fn cairo_create(target: ?*cairo_surface_t) ?*cairo_t;
pub extern fn cairo_reference(cr: ?*cairo_t) ?*cairo_t;
pub extern fn cairo_destroy(cr: ?*cairo_t) void;
pub extern fn cairo_get_reference_count(cr: ?*cairo_t) c_uint;
pub extern fn cairo_get_user_data(cr: ?*cairo_t, key: [*c]const cairo_user_data_key_t) ?*c_void;
pub extern fn cairo_set_user_data(cr: ?*cairo_t, key: [*c]const cairo_user_data_key_t, user_data: ?*c_void, destroy: cairo_destroy_func_t) cairo_status_t;
pub extern fn cairo_save(cr: ?*cairo_t) void;
pub extern fn cairo_restore(cr: ?*cairo_t) void;
pub extern fn cairo_push_group(cr: ?*cairo_t) void;
pub extern fn cairo_push_group_with_content(cr: ?*cairo_t, content: cairo_content_t) void;
pub extern fn cairo_pop_group(cr: ?*cairo_t) ?*cairo_pattern_t;
pub extern fn cairo_pop_group_to_source(cr: ?*cairo_t) void;
pub const CAIRO_OPERATOR_CLEAR = enum__cairo_operator.CAIRO_OPERATOR_CLEAR;
pub const CAIRO_OPERATOR_SOURCE = enum__cairo_operator.CAIRO_OPERATOR_SOURCE;
pub const CAIRO_OPERATOR_OVER = enum__cairo_operator.CAIRO_OPERATOR_OVER;
pub const CAIRO_OPERATOR_IN = enum__cairo_operator.CAIRO_OPERATOR_IN;
pub const CAIRO_OPERATOR_OUT = enum__cairo_operator.CAIRO_OPERATOR_OUT;
pub const CAIRO_OPERATOR_ATOP = enum__cairo_operator.CAIRO_OPERATOR_ATOP;
pub const CAIRO_OPERATOR_DEST = enum__cairo_operator.CAIRO_OPERATOR_DEST;
pub const CAIRO_OPERATOR_DEST_OVER = enum__cairo_operator.CAIRO_OPERATOR_DEST_OVER;
pub const CAIRO_OPERATOR_DEST_IN = enum__cairo_operator.CAIRO_OPERATOR_DEST_IN;
pub const CAIRO_OPERATOR_DEST_OUT = enum__cairo_operator.CAIRO_OPERATOR_DEST_OUT;
pub const CAIRO_OPERATOR_DEST_ATOP = enum__cairo_operator.CAIRO_OPERATOR_DEST_ATOP;
pub const CAIRO_OPERATOR_XOR = enum__cairo_operator.CAIRO_OPERATOR_XOR;
pub const CAIRO_OPERATOR_ADD = enum__cairo_operator.CAIRO_OPERATOR_ADD;
pub const CAIRO_OPERATOR_SATURATE = enum__cairo_operator.CAIRO_OPERATOR_SATURATE;
pub const CAIRO_OPERATOR_MULTIPLY = enum__cairo_operator.CAIRO_OPERATOR_MULTIPLY;
pub const CAIRO_OPERATOR_SCREEN = enum__cairo_operator.CAIRO_OPERATOR_SCREEN;
pub const CAIRO_OPERATOR_OVERLAY = enum__cairo_operator.CAIRO_OPERATOR_OVERLAY;
pub const CAIRO_OPERATOR_DARKEN = enum__cairo_operator.CAIRO_OPERATOR_DARKEN;
pub const CAIRO_OPERATOR_LIGHTEN = enum__cairo_operator.CAIRO_OPERATOR_LIGHTEN;
pub const CAIRO_OPERATOR_COLOR_DODGE = enum__cairo_operator.CAIRO_OPERATOR_COLOR_DODGE;
pub const CAIRO_OPERATOR_COLOR_BURN = enum__cairo_operator.CAIRO_OPERATOR_COLOR_BURN;
pub const CAIRO_OPERATOR_HARD_LIGHT = enum__cairo_operator.CAIRO_OPERATOR_HARD_LIGHT;
pub const CAIRO_OPERATOR_SOFT_LIGHT = enum__cairo_operator.CAIRO_OPERATOR_SOFT_LIGHT;
pub const CAIRO_OPERATOR_DIFFERENCE = enum__cairo_operator.CAIRO_OPERATOR_DIFFERENCE;
pub const CAIRO_OPERATOR_EXCLUSION = enum__cairo_operator.CAIRO_OPERATOR_EXCLUSION;
pub const CAIRO_OPERATOR_HSL_HUE = enum__cairo_operator.CAIRO_OPERATOR_HSL_HUE;
pub const CAIRO_OPERATOR_HSL_SATURATION = enum__cairo_operator.CAIRO_OPERATOR_HSL_SATURATION;
pub const CAIRO_OPERATOR_HSL_COLOR = enum__cairo_operator.CAIRO_OPERATOR_HSL_COLOR;
pub const CAIRO_OPERATOR_HSL_LUMINOSITY = enum__cairo_operator.CAIRO_OPERATOR_HSL_LUMINOSITY;
pub const enum__cairo_operator = extern enum {
    CAIRO_OPERATOR_CLEAR,
    CAIRO_OPERATOR_SOURCE,
    CAIRO_OPERATOR_OVER,
    CAIRO_OPERATOR_IN,
    CAIRO_OPERATOR_OUT,
    CAIRO_OPERATOR_ATOP,
    CAIRO_OPERATOR_DEST,
    CAIRO_OPERATOR_DEST_OVER,
    CAIRO_OPERATOR_DEST_IN,
    CAIRO_OPERATOR_DEST_OUT,
    CAIRO_OPERATOR_DEST_ATOP,
    CAIRO_OPERATOR_XOR,
    CAIRO_OPERATOR_ADD,
    CAIRO_OPERATOR_SATURATE,
    CAIRO_OPERATOR_MULTIPLY,
    CAIRO_OPERATOR_SCREEN,
    CAIRO_OPERATOR_OVERLAY,
    CAIRO_OPERATOR_DARKEN,
    CAIRO_OPERATOR_LIGHTEN,
    CAIRO_OPERATOR_COLOR_DODGE,
    CAIRO_OPERATOR_COLOR_BURN,
    CAIRO_OPERATOR_HARD_LIGHT,
    CAIRO_OPERATOR_SOFT_LIGHT,
    CAIRO_OPERATOR_DIFFERENCE,
    CAIRO_OPERATOR_EXCLUSION,
    CAIRO_OPERATOR_HSL_HUE,
    CAIRO_OPERATOR_HSL_SATURATION,
    CAIRO_OPERATOR_HSL_COLOR,
    CAIRO_OPERATOR_HSL_LUMINOSITY,
};
pub const cairo_operator_t = enum__cairo_operator;
pub extern fn cairo_set_operator(cr: ?*cairo_t, op: cairo_operator_t) void;
pub extern fn cairo_set_source(cr: ?*cairo_t, source: ?*cairo_pattern_t) void;
pub extern fn cairo_set_source_rgb(cr: ?*cairo_t, red: f64, green: f64, blue: f64) void;
pub extern fn cairo_set_source_rgba(cr: ?*cairo_t, red: f64, green: f64, blue: f64, alpha: f64) void;
pub extern fn cairo_set_source_surface(cr: ?*cairo_t, surface: ?*cairo_surface_t, x: f64, y: f64) void;
pub extern fn cairo_set_tolerance(cr: ?*cairo_t, tolerance: f64) void;
pub const CAIRO_ANTIALIAS_DEFAULT = enum__cairo_antialias.CAIRO_ANTIALIAS_DEFAULT;
pub const CAIRO_ANTIALIAS_NONE = enum__cairo_antialias.CAIRO_ANTIALIAS_NONE;
pub const CAIRO_ANTIALIAS_GRAY = enum__cairo_antialias.CAIRO_ANTIALIAS_GRAY;
pub const CAIRO_ANTIALIAS_SUBPIXEL = enum__cairo_antialias.CAIRO_ANTIALIAS_SUBPIXEL;
pub const CAIRO_ANTIALIAS_FAST = enum__cairo_antialias.CAIRO_ANTIALIAS_FAST;
pub const CAIRO_ANTIALIAS_GOOD = enum__cairo_antialias.CAIRO_ANTIALIAS_GOOD;
pub const CAIRO_ANTIALIAS_BEST = enum__cairo_antialias.CAIRO_ANTIALIAS_BEST;
pub const enum__cairo_antialias = extern enum {
    CAIRO_ANTIALIAS_DEFAULT,
    CAIRO_ANTIALIAS_NONE,
    CAIRO_ANTIALIAS_GRAY,
    CAIRO_ANTIALIAS_SUBPIXEL,
    CAIRO_ANTIALIAS_FAST,
    CAIRO_ANTIALIAS_GOOD,
    CAIRO_ANTIALIAS_BEST,
};
pub const cairo_antialias_t = enum__cairo_antialias;
pub extern fn cairo_set_antialias(cr: ?*cairo_t, antialias: cairo_antialias_t) void;
pub const CAIRO_FILL_RULE_WINDING = enum__cairo_fill_rule.CAIRO_FILL_RULE_WINDING;
pub const CAIRO_FILL_RULE_EVEN_ODD = enum__cairo_fill_rule.CAIRO_FILL_RULE_EVEN_ODD;
pub const enum__cairo_fill_rule = extern enum {
    CAIRO_FILL_RULE_WINDING,
    CAIRO_FILL_RULE_EVEN_ODD,
};
pub const cairo_fill_rule_t = enum__cairo_fill_rule;
pub extern fn cairo_set_fill_rule(cr: ?*cairo_t, fill_rule: cairo_fill_rule_t) void;
pub extern fn cairo_set_line_width(cr: ?*cairo_t, width: f64) void;
pub const CAIRO_LINE_CAP_BUTT = enum__cairo_line_cap.CAIRO_LINE_CAP_BUTT;
pub const CAIRO_LINE_CAP_ROUND = enum__cairo_line_cap.CAIRO_LINE_CAP_ROUND;
pub const CAIRO_LINE_CAP_SQUARE = enum__cairo_line_cap.CAIRO_LINE_CAP_SQUARE;
pub const enum__cairo_line_cap = extern enum {
    CAIRO_LINE_CAP_BUTT,
    CAIRO_LINE_CAP_ROUND,
    CAIRO_LINE_CAP_SQUARE,
};
pub const cairo_line_cap_t = enum__cairo_line_cap;
pub extern fn cairo_set_line_cap(cr: ?*cairo_t, line_cap: cairo_line_cap_t) void;
pub const CAIRO_LINE_JOIN_MITER = enum__cairo_line_join.CAIRO_LINE_JOIN_MITER;
pub const CAIRO_LINE_JOIN_ROUND = enum__cairo_line_join.CAIRO_LINE_JOIN_ROUND;
pub const CAIRO_LINE_JOIN_BEVEL = enum__cairo_line_join.CAIRO_LINE_JOIN_BEVEL;
pub const enum__cairo_line_join = extern enum {
    CAIRO_LINE_JOIN_MITER,
    CAIRO_LINE_JOIN_ROUND,
    CAIRO_LINE_JOIN_BEVEL,
};
pub const cairo_line_join_t = enum__cairo_line_join;
pub extern fn cairo_set_line_join(cr: ?*cairo_t, line_join: cairo_line_join_t) void;
pub extern fn cairo_set_dash(cr: ?*cairo_t, dashes: [*c]const f64, num_dashes: c_int, offset: f64) void;
pub extern fn cairo_set_miter_limit(cr: ?*cairo_t, limit: f64) void;
pub extern fn cairo_translate(cr: ?*cairo_t, tx: f64, ty: f64) void;
pub extern fn cairo_scale(cr: ?*cairo_t, sx: f64, sy: f64) void;
pub extern fn cairo_rotate(cr: ?*cairo_t, angle: f64) void;
pub extern fn cairo_transform(cr: ?*cairo_t, matrix: [*c]const cairo_matrix_t) void;
pub extern fn cairo_set_matrix(cr: ?*cairo_t, matrix: [*c]const cairo_matrix_t) void;
pub extern fn cairo_identity_matrix(cr: ?*cairo_t) void;
pub extern fn cairo_user_to_device(cr: ?*cairo_t, x: [*c]f64, y: [*c]f64) void;
pub extern fn cairo_user_to_device_distance(cr: ?*cairo_t, dx: [*c]f64, dy: [*c]f64) void;
pub extern fn cairo_device_to_user(cr: ?*cairo_t, x: [*c]f64, y: [*c]f64) void;
pub extern fn cairo_device_to_user_distance(cr: ?*cairo_t, dx: [*c]f64, dy: [*c]f64) void;
pub extern fn cairo_new_path(cr: ?*cairo_t) void;
pub extern fn cairo_move_to(cr: ?*cairo_t, x: f64, y: f64) void;
pub extern fn cairo_new_sub_path(cr: ?*cairo_t) void;
pub extern fn cairo_line_to(cr: ?*cairo_t, x: f64, y: f64) void;
pub extern fn cairo_curve_to(cr: ?*cairo_t, x1: f64, y1: f64, x2: f64, y2: f64, x3: f64, y3: f64) void;
pub extern fn cairo_arc(cr: ?*cairo_t, xc: f64, yc: f64, radius: f64, angle1: f64, angle2: f64) void;
pub extern fn cairo_arc_negative(cr: ?*cairo_t, xc: f64, yc: f64, radius: f64, angle1: f64, angle2: f64) void;
pub extern fn cairo_rel_move_to(cr: ?*cairo_t, dx: f64, dy: f64) void;
pub extern fn cairo_rel_line_to(cr: ?*cairo_t, dx: f64, dy: f64) void;
pub extern fn cairo_rel_curve_to(cr: ?*cairo_t, dx1: f64, dy1: f64, dx2: f64, dy2: f64, dx3: f64, dy3: f64) void;
pub extern fn cairo_rectangle(cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn cairo_close_path(cr: ?*cairo_t) void;
pub extern fn cairo_path_extents(cr: ?*cairo_t, x1: [*c]f64, y1: [*c]f64, x2: [*c]f64, y2: [*c]f64) void;
pub extern fn cairo_paint(cr: ?*cairo_t) void;
pub extern fn cairo_paint_with_alpha(cr: ?*cairo_t, alpha: f64) void;
pub extern fn cairo_mask(cr: ?*cairo_t, pattern: ?*cairo_pattern_t) void;
pub extern fn cairo_mask_surface(cr: ?*cairo_t, surface: ?*cairo_surface_t, surface_x: f64, surface_y: f64) void;
pub extern fn cairo_stroke(cr: ?*cairo_t) void;
pub extern fn cairo_stroke_preserve(cr: ?*cairo_t) void;
pub extern fn cairo_fill(cr: ?*cairo_t) void;
pub extern fn cairo_fill_preserve(cr: ?*cairo_t) void;
pub extern fn cairo_copy_page(cr: ?*cairo_t) void;
pub extern fn cairo_show_page(cr: ?*cairo_t) void;
pub extern fn cairo_in_stroke(cr: ?*cairo_t, x: f64, y: f64) cairo_bool_t;
pub extern fn cairo_in_fill(cr: ?*cairo_t, x: f64, y: f64) cairo_bool_t;
pub extern fn cairo_in_clip(cr: ?*cairo_t, x: f64, y: f64) cairo_bool_t;
pub extern fn cairo_stroke_extents(cr: ?*cairo_t, x1: [*c]f64, y1: [*c]f64, x2: [*c]f64, y2: [*c]f64) void;
pub extern fn cairo_fill_extents(cr: ?*cairo_t, x1: [*c]f64, y1: [*c]f64, x2: [*c]f64, y2: [*c]f64) void;
pub extern fn cairo_reset_clip(cr: ?*cairo_t) void;
pub extern fn cairo_clip(cr: ?*cairo_t) void;
pub extern fn cairo_clip_preserve(cr: ?*cairo_t) void;
pub extern fn cairo_clip_extents(cr: ?*cairo_t, x1: [*c]f64, y1: [*c]f64, x2: [*c]f64, y2: [*c]f64) void;
pub const struct__cairo_rectangle = extern struct {
    x: f64,
    y: f64,
    width: f64,
    height: f64,
};
pub const cairo_rectangle_t = struct__cairo_rectangle;
pub const struct__cairo_rectangle_list = extern struct {
    status: cairo_status_t,
    rectangles: [*c]cairo_rectangle_t,
    num_rectangles: c_int,
};
pub const cairo_rectangle_list_t = struct__cairo_rectangle_list;
pub extern fn cairo_copy_clip_rectangle_list(cr: ?*cairo_t) [*c]cairo_rectangle_list_t;
pub extern fn cairo_rectangle_list_destroy(rectangle_list: [*c]cairo_rectangle_list_t) void;
pub extern fn cairo_tag_begin(cr: ?*cairo_t, tag_name: [*c]const u8, attributes: [*c]const u8) void;
pub extern fn cairo_tag_end(cr: ?*cairo_t, tag_name: [*c]const u8) void;
pub const struct__cairo_scaled_font = @OpaqueType();
pub const cairo_scaled_font_t = struct__cairo_scaled_font;
pub const struct__cairo_font_face = @OpaqueType();
pub const cairo_font_face_t = struct__cairo_font_face;
pub const cairo_glyph_t = extern struct {
    index: c_ulong,
    x: f64,
    y: f64,
};
pub extern fn cairo_glyph_allocate(num_glyphs: c_int) [*c]cairo_glyph_t;
pub extern fn cairo_glyph_free(glyphs: [*c]cairo_glyph_t) void;
pub const cairo_text_cluster_t = extern struct {
    num_bytes: c_int,
    num_glyphs: c_int,
};
pub extern fn cairo_text_cluster_allocate(num_clusters: c_int) [*c]cairo_text_cluster_t;
pub extern fn cairo_text_cluster_free(clusters: [*c]cairo_text_cluster_t) void;
pub const CAIRO_TEXT_CLUSTER_FLAG_BACKWARD = enum__cairo_text_cluster_flags.CAIRO_TEXT_CLUSTER_FLAG_BACKWARD;
pub const enum__cairo_text_cluster_flags = extern enum {
    CAIRO_TEXT_CLUSTER_FLAG_BACKWARD = 1,
};
pub const cairo_text_cluster_flags_t = enum__cairo_text_cluster_flags;
pub const cairo_text_extents_t = extern struct {
    x_bearing: f64,
    y_bearing: f64,
    width: f64,
    height: f64,
    x_advance: f64,
    y_advance: f64,
};
pub const cairo_font_extents_t = extern struct {
    ascent: f64,
    descent: f64,
    height: f64,
    max_x_advance: f64,
    max_y_advance: f64,
};
pub const CAIRO_FONT_SLANT_NORMAL = enum__cairo_font_slant.CAIRO_FONT_SLANT_NORMAL;
pub const CAIRO_FONT_SLANT_ITALIC = enum__cairo_font_slant.CAIRO_FONT_SLANT_ITALIC;
pub const CAIRO_FONT_SLANT_OBLIQUE = enum__cairo_font_slant.CAIRO_FONT_SLANT_OBLIQUE;
pub const enum__cairo_font_slant = extern enum {
    CAIRO_FONT_SLANT_NORMAL,
    CAIRO_FONT_SLANT_ITALIC,
    CAIRO_FONT_SLANT_OBLIQUE,
};
pub const cairo_font_slant_t = enum__cairo_font_slant;
pub const CAIRO_FONT_WEIGHT_NORMAL = enum__cairo_font_weight.CAIRO_FONT_WEIGHT_NORMAL;
pub const CAIRO_FONT_WEIGHT_BOLD = enum__cairo_font_weight.CAIRO_FONT_WEIGHT_BOLD;
pub const enum__cairo_font_weight = extern enum {
    CAIRO_FONT_WEIGHT_NORMAL,
    CAIRO_FONT_WEIGHT_BOLD,
};
pub const cairo_font_weight_t = enum__cairo_font_weight;
pub const CAIRO_SUBPIXEL_ORDER_DEFAULT = enum__cairo_subpixel_order.CAIRO_SUBPIXEL_ORDER_DEFAULT;
pub const CAIRO_SUBPIXEL_ORDER_RGB = enum__cairo_subpixel_order.CAIRO_SUBPIXEL_ORDER_RGB;
pub const CAIRO_SUBPIXEL_ORDER_BGR = enum__cairo_subpixel_order.CAIRO_SUBPIXEL_ORDER_BGR;
pub const CAIRO_SUBPIXEL_ORDER_VRGB = enum__cairo_subpixel_order.CAIRO_SUBPIXEL_ORDER_VRGB;
pub const CAIRO_SUBPIXEL_ORDER_VBGR = enum__cairo_subpixel_order.CAIRO_SUBPIXEL_ORDER_VBGR;
pub const enum__cairo_subpixel_order = extern enum {
    CAIRO_SUBPIXEL_ORDER_DEFAULT,
    CAIRO_SUBPIXEL_ORDER_RGB,
    CAIRO_SUBPIXEL_ORDER_BGR,
    CAIRO_SUBPIXEL_ORDER_VRGB,
    CAIRO_SUBPIXEL_ORDER_VBGR,
};
pub const cairo_subpixel_order_t = enum__cairo_subpixel_order;
pub const CAIRO_HINT_STYLE_DEFAULT = enum__cairo_hint_style.CAIRO_HINT_STYLE_DEFAULT;
pub const CAIRO_HINT_STYLE_NONE = enum__cairo_hint_style.CAIRO_HINT_STYLE_NONE;
pub const CAIRO_HINT_STYLE_SLIGHT = enum__cairo_hint_style.CAIRO_HINT_STYLE_SLIGHT;
pub const CAIRO_HINT_STYLE_MEDIUM = enum__cairo_hint_style.CAIRO_HINT_STYLE_MEDIUM;
pub const CAIRO_HINT_STYLE_FULL = enum__cairo_hint_style.CAIRO_HINT_STYLE_FULL;
pub const enum__cairo_hint_style = extern enum {
    CAIRO_HINT_STYLE_DEFAULT,
    CAIRO_HINT_STYLE_NONE,
    CAIRO_HINT_STYLE_SLIGHT,
    CAIRO_HINT_STYLE_MEDIUM,
    CAIRO_HINT_STYLE_FULL,
};
pub const cairo_hint_style_t = enum__cairo_hint_style;
pub const CAIRO_HINT_METRICS_DEFAULT = enum__cairo_hint_metrics.CAIRO_HINT_METRICS_DEFAULT;
pub const CAIRO_HINT_METRICS_OFF = enum__cairo_hint_metrics.CAIRO_HINT_METRICS_OFF;
pub const CAIRO_HINT_METRICS_ON = enum__cairo_hint_metrics.CAIRO_HINT_METRICS_ON;
pub const enum__cairo_hint_metrics = extern enum {
    CAIRO_HINT_METRICS_DEFAULT,
    CAIRO_HINT_METRICS_OFF,
    CAIRO_HINT_METRICS_ON,
};
pub const cairo_hint_metrics_t = enum__cairo_hint_metrics;
pub const struct__cairo_font_options = @OpaqueType();
pub const cairo_font_options_t = struct__cairo_font_options;
pub extern fn cairo_font_options_create() ?*cairo_font_options_t;
pub extern fn cairo_font_options_copy(original: ?*const cairo_font_options_t) ?*cairo_font_options_t;
pub extern fn cairo_font_options_destroy(options: ?*cairo_font_options_t) void;
pub extern fn cairo_font_options_status(options: ?*cairo_font_options_t) cairo_status_t;
pub extern fn cairo_font_options_merge(options: ?*cairo_font_options_t, other: ?*const cairo_font_options_t) void;
pub extern fn cairo_font_options_equal(options: ?*const cairo_font_options_t, other: ?*const cairo_font_options_t) cairo_bool_t;
pub extern fn cairo_font_options_hash(options: ?*const cairo_font_options_t) c_ulong;
pub extern fn cairo_font_options_set_antialias(options: ?*cairo_font_options_t, antialias: cairo_antialias_t) void;
pub extern fn cairo_font_options_get_antialias(options: ?*const cairo_font_options_t) cairo_antialias_t;
pub extern fn cairo_font_options_set_subpixel_order(options: ?*cairo_font_options_t, subpixel_order: cairo_subpixel_order_t) void;
pub extern fn cairo_font_options_get_subpixel_order(options: ?*const cairo_font_options_t) cairo_subpixel_order_t;
pub extern fn cairo_font_options_set_hint_style(options: ?*cairo_font_options_t, hint_style: cairo_hint_style_t) void;
pub extern fn cairo_font_options_get_hint_style(options: ?*const cairo_font_options_t) cairo_hint_style_t;
pub extern fn cairo_font_options_set_hint_metrics(options: ?*cairo_font_options_t, hint_metrics: cairo_hint_metrics_t) void;
pub extern fn cairo_font_options_get_hint_metrics(options: ?*const cairo_font_options_t) cairo_hint_metrics_t;
pub extern fn cairo_font_options_get_variations(options: ?*cairo_font_options_t) [*c]const u8;
pub extern fn cairo_font_options_set_variations(options: ?*cairo_font_options_t, variations: [*c]const u8) void;
pub extern fn cairo_select_font_face(cr: ?*cairo_t, family: [*c]const u8, slant: cairo_font_slant_t, weight: cairo_font_weight_t) void;
pub extern fn cairo_set_font_size(cr: ?*cairo_t, size: f64) void;
pub extern fn cairo_set_font_matrix(cr: ?*cairo_t, matrix: [*c]const cairo_matrix_t) void;
pub extern fn cairo_get_font_matrix(cr: ?*cairo_t, matrix: [*c]cairo_matrix_t) void;
pub extern fn cairo_set_font_options(cr: ?*cairo_t, options: ?*const cairo_font_options_t) void;
pub extern fn cairo_get_font_options(cr: ?*cairo_t, options: ?*cairo_font_options_t) void;
pub extern fn cairo_set_font_face(cr: ?*cairo_t, font_face: ?*cairo_font_face_t) void;
pub extern fn cairo_get_font_face(cr: ?*cairo_t) ?*cairo_font_face_t;
pub extern fn cairo_set_scaled_font(cr: ?*cairo_t, scaled_font: ?*const cairo_scaled_font_t) void;
pub extern fn cairo_get_scaled_font(cr: ?*cairo_t) ?*cairo_scaled_font_t;
pub extern fn cairo_show_text(cr: ?*cairo_t, utf8: [*c]const u8) void;
pub extern fn cairo_show_glyphs(cr: ?*cairo_t, glyphs: [*c]const cairo_glyph_t, num_glyphs: c_int) void;
pub extern fn cairo_show_text_glyphs(cr: ?*cairo_t, utf8: [*c]const u8, utf8_len: c_int, glyphs: [*c]const cairo_glyph_t, num_glyphs: c_int, clusters: [*c]const cairo_text_cluster_t, num_clusters: c_int, cluster_flags: cairo_text_cluster_flags_t) void;
pub extern fn cairo_text_path(cr: ?*cairo_t, utf8: [*c]const u8) void;
pub extern fn cairo_glyph_path(cr: ?*cairo_t, glyphs: [*c]const cairo_glyph_t, num_glyphs: c_int) void;
pub extern fn cairo_text_extents(cr: ?*cairo_t, utf8: [*c]const u8, extents: [*c]cairo_text_extents_t) void;
pub extern fn cairo_glyph_extents(cr: ?*cairo_t, glyphs: [*c]const cairo_glyph_t, num_glyphs: c_int, extents: [*c]cairo_text_extents_t) void;
pub extern fn cairo_font_extents(cr: ?*cairo_t, extents: [*c]cairo_font_extents_t) void;
pub extern fn cairo_font_face_reference(font_face: ?*cairo_font_face_t) ?*cairo_font_face_t;
pub extern fn cairo_font_face_destroy(font_face: ?*cairo_font_face_t) void;
pub extern fn cairo_font_face_get_reference_count(font_face: ?*cairo_font_face_t) c_uint;
pub extern fn cairo_font_face_status(font_face: ?*cairo_font_face_t) cairo_status_t;
pub const CAIRO_FONT_TYPE_TOY = enum__cairo_font_type.CAIRO_FONT_TYPE_TOY;
pub const CAIRO_FONT_TYPE_FT = enum__cairo_font_type.CAIRO_FONT_TYPE_FT;
pub const CAIRO_FONT_TYPE_WIN32 = enum__cairo_font_type.CAIRO_FONT_TYPE_WIN32;
pub const CAIRO_FONT_TYPE_QUARTZ = enum__cairo_font_type.CAIRO_FONT_TYPE_QUARTZ;
pub const CAIRO_FONT_TYPE_USER = enum__cairo_font_type.CAIRO_FONT_TYPE_USER;
pub const enum__cairo_font_type = extern enum {
    CAIRO_FONT_TYPE_TOY,
    CAIRO_FONT_TYPE_FT,
    CAIRO_FONT_TYPE_WIN32,
    CAIRO_FONT_TYPE_QUARTZ,
    CAIRO_FONT_TYPE_USER,
};
pub const cairo_font_type_t = enum__cairo_font_type;
pub extern fn cairo_font_face_get_type(font_face: ?*cairo_font_face_t) cairo_font_type_t;
pub extern fn cairo_font_face_get_user_data(font_face: ?*cairo_font_face_t, key: [*c]const cairo_user_data_key_t) ?*c_void;
pub extern fn cairo_font_face_set_user_data(font_face: ?*cairo_font_face_t, key: [*c]const cairo_user_data_key_t, user_data: ?*c_void, destroy: cairo_destroy_func_t) cairo_status_t;
pub extern fn cairo_scaled_font_create(font_face: ?*cairo_font_face_t, font_matrix: [*c]const cairo_matrix_t, ctm: [*c]const cairo_matrix_t, options: ?*const cairo_font_options_t) ?*cairo_scaled_font_t;
pub extern fn cairo_scaled_font_reference(scaled_font: ?*cairo_scaled_font_t) ?*cairo_scaled_font_t;
pub extern fn cairo_scaled_font_destroy(scaled_font: ?*cairo_scaled_font_t) void;
pub extern fn cairo_scaled_font_get_reference_count(scaled_font: ?*cairo_scaled_font_t) c_uint;
pub extern fn cairo_scaled_font_status(scaled_font: ?*cairo_scaled_font_t) cairo_status_t;
pub extern fn cairo_scaled_font_get_type(scaled_font: ?*cairo_scaled_font_t) cairo_font_type_t;
pub extern fn cairo_scaled_font_get_user_data(scaled_font: ?*cairo_scaled_font_t, key: [*c]const cairo_user_data_key_t) ?*c_void;
pub extern fn cairo_scaled_font_set_user_data(scaled_font: ?*cairo_scaled_font_t, key: [*c]const cairo_user_data_key_t, user_data: ?*c_void, destroy: cairo_destroy_func_t) cairo_status_t;
pub extern fn cairo_scaled_font_extents(scaled_font: ?*cairo_scaled_font_t, extents: [*c]cairo_font_extents_t) void;
pub extern fn cairo_scaled_font_text_extents(scaled_font: ?*cairo_scaled_font_t, utf8: [*c]const u8, extents: [*c]cairo_text_extents_t) void;
pub extern fn cairo_scaled_font_glyph_extents(scaled_font: ?*cairo_scaled_font_t, glyphs: [*c]const cairo_glyph_t, num_glyphs: c_int, extents: [*c]cairo_text_extents_t) void;
pub extern fn cairo_scaled_font_text_to_glyphs(scaled_font: ?*cairo_scaled_font_t, x: f64, y: f64, utf8: [*c]const u8, utf8_len: c_int, glyphs: [*c]([*c]cairo_glyph_t), num_glyphs: [*c]c_int, clusters: [*c]([*c]cairo_text_cluster_t), num_clusters: [*c]c_int, cluster_flags: [*c]cairo_text_cluster_flags_t) cairo_status_t;
pub extern fn cairo_scaled_font_get_font_face(scaled_font: ?*cairo_scaled_font_t) ?*cairo_font_face_t;
pub extern fn cairo_scaled_font_get_font_matrix(scaled_font: ?*cairo_scaled_font_t, font_matrix: [*c]cairo_matrix_t) void;
pub extern fn cairo_scaled_font_get_ctm(scaled_font: ?*cairo_scaled_font_t, ctm: [*c]cairo_matrix_t) void;
pub extern fn cairo_scaled_font_get_scale_matrix(scaled_font: ?*cairo_scaled_font_t, scale_matrix: [*c]cairo_matrix_t) void;
pub extern fn cairo_scaled_font_get_font_options(scaled_font: ?*cairo_scaled_font_t, options: ?*cairo_font_options_t) void;
pub extern fn cairo_toy_font_face_create(family: [*c]const u8, slant: cairo_font_slant_t, weight: cairo_font_weight_t) ?*cairo_font_face_t;
pub extern fn cairo_toy_font_face_get_family(font_face: ?*cairo_font_face_t) [*c]const u8;
pub extern fn cairo_toy_font_face_get_slant(font_face: ?*cairo_font_face_t) cairo_font_slant_t;
pub extern fn cairo_toy_font_face_get_weight(font_face: ?*cairo_font_face_t) cairo_font_weight_t;
pub extern fn cairo_user_font_face_create() ?*cairo_font_face_t;
pub const cairo_user_scaled_font_init_func_t = ?extern fn (?*cairo_scaled_font_t, ?*cairo_t, [*c]cairo_font_extents_t) cairo_status_t;
pub const cairo_user_scaled_font_render_glyph_func_t = ?extern fn (?*cairo_scaled_font_t, c_ulong, ?*cairo_t, [*c]cairo_text_extents_t) cairo_status_t;
pub const cairo_user_scaled_font_text_to_glyphs_func_t = ?extern fn (?*cairo_scaled_font_t, [*c]const u8, c_int, [*c]([*c]cairo_glyph_t), [*c]c_int, [*c]([*c]cairo_text_cluster_t), [*c]c_int, [*c]cairo_text_cluster_flags_t) cairo_status_t;
pub const cairo_user_scaled_font_unicode_to_glyph_func_t = ?extern fn (?*cairo_scaled_font_t, c_ulong, [*c]c_ulong) cairo_status_t;
pub extern fn cairo_user_font_face_set_init_func(font_face: ?*cairo_font_face_t, init_func: cairo_user_scaled_font_init_func_t) void;
pub extern fn cairo_user_font_face_set_render_glyph_func(font_face: ?*cairo_font_face_t, render_glyph_func: cairo_user_scaled_font_render_glyph_func_t) void;
pub extern fn cairo_user_font_face_set_text_to_glyphs_func(font_face: ?*cairo_font_face_t, text_to_glyphs_func: cairo_user_scaled_font_text_to_glyphs_func_t) void;
pub extern fn cairo_user_font_face_set_unicode_to_glyph_func(font_face: ?*cairo_font_face_t, unicode_to_glyph_func: cairo_user_scaled_font_unicode_to_glyph_func_t) void;
pub extern fn cairo_user_font_face_get_init_func(font_face: ?*cairo_font_face_t) cairo_user_scaled_font_init_func_t;
pub extern fn cairo_user_font_face_get_render_glyph_func(font_face: ?*cairo_font_face_t) cairo_user_scaled_font_render_glyph_func_t;
pub extern fn cairo_user_font_face_get_text_to_glyphs_func(font_face: ?*cairo_font_face_t) cairo_user_scaled_font_text_to_glyphs_func_t;
pub extern fn cairo_user_font_face_get_unicode_to_glyph_func(font_face: ?*cairo_font_face_t) cairo_user_scaled_font_unicode_to_glyph_func_t;
pub extern fn cairo_get_operator(cr: ?*cairo_t) cairo_operator_t;
pub extern fn cairo_get_source(cr: ?*cairo_t) ?*cairo_pattern_t;
pub extern fn cairo_get_tolerance(cr: ?*cairo_t) f64;
pub extern fn cairo_get_antialias(cr: ?*cairo_t) cairo_antialias_t;
pub extern fn cairo_has_current_point(cr: ?*cairo_t) cairo_bool_t;
pub extern fn cairo_get_current_point(cr: ?*cairo_t, x: [*c]f64, y: [*c]f64) void;
pub extern fn cairo_get_fill_rule(cr: ?*cairo_t) cairo_fill_rule_t;
pub extern fn cairo_get_line_width(cr: ?*cairo_t) f64;
pub extern fn cairo_get_line_cap(cr: ?*cairo_t) cairo_line_cap_t;
pub extern fn cairo_get_line_join(cr: ?*cairo_t) cairo_line_join_t;
pub extern fn cairo_get_miter_limit(cr: ?*cairo_t) f64;
pub extern fn cairo_get_dash_count(cr: ?*cairo_t) c_int;
pub extern fn cairo_get_dash(cr: ?*cairo_t, dashes: [*c]f64, offset: [*c]f64) void;
pub extern fn cairo_get_matrix(cr: ?*cairo_t, matrix: [*c]cairo_matrix_t) void;
pub extern fn cairo_get_target(cr: ?*cairo_t) ?*cairo_surface_t;
pub extern fn cairo_get_group_target(cr: ?*cairo_t) ?*cairo_surface_t;
pub const CAIRO_PATH_MOVE_TO = enum__cairo_path_data_type.CAIRO_PATH_MOVE_TO;
pub const CAIRO_PATH_LINE_TO = enum__cairo_path_data_type.CAIRO_PATH_LINE_TO;
pub const CAIRO_PATH_CURVE_TO = enum__cairo_path_data_type.CAIRO_PATH_CURVE_TO;
pub const CAIRO_PATH_CLOSE_PATH = enum__cairo_path_data_type.CAIRO_PATH_CLOSE_PATH;
pub const enum__cairo_path_data_type = extern enum {
    CAIRO_PATH_MOVE_TO,
    CAIRO_PATH_LINE_TO,
    CAIRO_PATH_CURVE_TO,
    CAIRO_PATH_CLOSE_PATH,
};
pub const cairo_path_data_type_t = enum__cairo_path_data_type;
pub const union__cairo_path_data_t = extern union {
    header: extern struct {
        type: cairo_path_data_type_t,
        length: c_int,
    },
    point: extern struct {
        x: f64,
        y: f64,
    },
};
pub const cairo_path_data_t = union__cairo_path_data_t;
pub const struct_cairo_path = extern struct {
    status: cairo_status_t,
    data: [*c]cairo_path_data_t,
    num_data: c_int,
};
pub const cairo_path_t = struct_cairo_path;
pub extern fn cairo_copy_path(cr: ?*cairo_t) [*c]cairo_path_t;
pub extern fn cairo_copy_path_flat(cr: ?*cairo_t) [*c]cairo_path_t;
pub extern fn cairo_append_path(cr: ?*cairo_t, path: [*c]const cairo_path_t) void;
pub extern fn cairo_path_destroy(path: [*c]cairo_path_t) void;
pub extern fn cairo_status(cr: ?*cairo_t) cairo_status_t;
pub extern fn cairo_status_to_string(status: cairo_status_t) [*c]const u8;
pub extern fn cairo_device_reference(device: ?*cairo_device_t) ?*cairo_device_t;
pub const CAIRO_DEVICE_TYPE_DRM = enum__cairo_device_type.CAIRO_DEVICE_TYPE_DRM;
pub const CAIRO_DEVICE_TYPE_GL = enum__cairo_device_type.CAIRO_DEVICE_TYPE_GL;
pub const CAIRO_DEVICE_TYPE_SCRIPT = enum__cairo_device_type.CAIRO_DEVICE_TYPE_SCRIPT;
pub const CAIRO_DEVICE_TYPE_XCB = enum__cairo_device_type.CAIRO_DEVICE_TYPE_XCB;
pub const CAIRO_DEVICE_TYPE_XLIB = enum__cairo_device_type.CAIRO_DEVICE_TYPE_XLIB;
pub const CAIRO_DEVICE_TYPE_XML = enum__cairo_device_type.CAIRO_DEVICE_TYPE_XML;
pub const CAIRO_DEVICE_TYPE_COGL = enum__cairo_device_type.CAIRO_DEVICE_TYPE_COGL;
pub const CAIRO_DEVICE_TYPE_WIN32 = enum__cairo_device_type.CAIRO_DEVICE_TYPE_WIN32;
pub const CAIRO_DEVICE_TYPE_INVALID = enum__cairo_device_type.CAIRO_DEVICE_TYPE_INVALID;
pub const enum__cairo_device_type = extern enum {
    CAIRO_DEVICE_TYPE_DRM = 0,
    CAIRO_DEVICE_TYPE_GL = 1,
    CAIRO_DEVICE_TYPE_SCRIPT = 2,
    CAIRO_DEVICE_TYPE_XCB = 3,
    CAIRO_DEVICE_TYPE_XLIB = 4,
    CAIRO_DEVICE_TYPE_XML = 5,
    CAIRO_DEVICE_TYPE_COGL = 6,
    CAIRO_DEVICE_TYPE_WIN32 = 7,
    CAIRO_DEVICE_TYPE_INVALID = -1,
};
pub const cairo_device_type_t = enum__cairo_device_type;
pub extern fn cairo_device_get_type(device: ?*cairo_device_t) cairo_device_type_t;
pub extern fn cairo_device_status(device: ?*cairo_device_t) cairo_status_t;
pub extern fn cairo_device_acquire(device: ?*cairo_device_t) cairo_status_t;
pub extern fn cairo_device_release(device: ?*cairo_device_t) void;
pub extern fn cairo_device_flush(device: ?*cairo_device_t) void;
pub extern fn cairo_device_finish(device: ?*cairo_device_t) void;
pub extern fn cairo_device_destroy(device: ?*cairo_device_t) void;
pub extern fn cairo_device_get_reference_count(device: ?*cairo_device_t) c_uint;
pub extern fn cairo_device_get_user_data(device: ?*cairo_device_t, key: [*c]const cairo_user_data_key_t) ?*c_void;
pub extern fn cairo_device_set_user_data(device: ?*cairo_device_t, key: [*c]const cairo_user_data_key_t, user_data: ?*c_void, destroy: cairo_destroy_func_t) cairo_status_t;
pub extern fn cairo_surface_create_similar(other: ?*cairo_surface_t, content: cairo_content_t, width: c_int, height: c_int) ?*cairo_surface_t;
pub extern fn cairo_surface_create_similar_image(other: ?*cairo_surface_t, format: cairo_format_t, width: c_int, height: c_int) ?*cairo_surface_t;
pub extern fn cairo_surface_map_to_image(surface: ?*cairo_surface_t, extents: [*c]const cairo_rectangle_int_t) ?*cairo_surface_t;
pub extern fn cairo_surface_unmap_image(surface: ?*cairo_surface_t, image: ?*cairo_surface_t) void;
pub extern fn cairo_surface_create_for_rectangle(target: ?*cairo_surface_t, x: f64, y: f64, width: f64, height: f64) ?*cairo_surface_t;
pub const CAIRO_SURFACE_OBSERVER_NORMAL = 0;
pub const CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS = 1;
pub const cairo_surface_observer_mode_t = extern enum {
    CAIRO_SURFACE_OBSERVER_NORMAL = 0,
    CAIRO_SURFACE_OBSERVER_RECORD_OPERATIONS = 1,
};
pub extern fn cairo_surface_create_observer(target: ?*cairo_surface_t, mode: cairo_surface_observer_mode_t) ?*cairo_surface_t;
pub const cairo_surface_observer_callback_t = ?extern fn (?*cairo_surface_t, ?*cairo_surface_t, ?*c_void) void;
pub extern fn cairo_surface_observer_add_paint_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*c_void) cairo_status_t;
pub extern fn cairo_surface_observer_add_mask_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*c_void) cairo_status_t;
pub extern fn cairo_surface_observer_add_fill_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*c_void) cairo_status_t;
pub extern fn cairo_surface_observer_add_stroke_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*c_void) cairo_status_t;
pub extern fn cairo_surface_observer_add_glyphs_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*c_void) cairo_status_t;
pub extern fn cairo_surface_observer_add_flush_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*c_void) cairo_status_t;
pub extern fn cairo_surface_observer_add_finish_callback(abstract_surface: ?*cairo_surface_t, func: cairo_surface_observer_callback_t, data: ?*c_void) cairo_status_t;
pub extern fn cairo_surface_observer_print(surface: ?*cairo_surface_t, write_func: cairo_write_func_t, closure: ?*c_void) cairo_status_t;
pub extern fn cairo_surface_observer_elapsed(surface: ?*cairo_surface_t) f64;
pub extern fn cairo_device_observer_print(device: ?*cairo_device_t, write_func: cairo_write_func_t, closure: ?*c_void) cairo_status_t;
pub extern fn cairo_device_observer_elapsed(device: ?*cairo_device_t) f64;
pub extern fn cairo_device_observer_paint_elapsed(device: ?*cairo_device_t) f64;
pub extern fn cairo_device_observer_mask_elapsed(device: ?*cairo_device_t) f64;
pub extern fn cairo_device_observer_fill_elapsed(device: ?*cairo_device_t) f64;
pub extern fn cairo_device_observer_stroke_elapsed(device: ?*cairo_device_t) f64;
pub extern fn cairo_device_observer_glyphs_elapsed(device: ?*cairo_device_t) f64;
pub extern fn cairo_surface_reference(surface: ?*cairo_surface_t) ?*cairo_surface_t;
pub extern fn cairo_surface_finish(surface: ?*cairo_surface_t) void;
pub extern fn cairo_surface_destroy(surface: ?*cairo_surface_t) void;
pub extern fn cairo_surface_get_device(surface: ?*cairo_surface_t) ?*cairo_device_t;
pub extern fn cairo_surface_get_reference_count(surface: ?*cairo_surface_t) c_uint;
pub extern fn cairo_surface_status(surface: ?*cairo_surface_t) cairo_status_t;
pub const CAIRO_SURFACE_TYPE_IMAGE = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_IMAGE;
pub const CAIRO_SURFACE_TYPE_PDF = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_PDF;
pub const CAIRO_SURFACE_TYPE_PS = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_PS;
pub const CAIRO_SURFACE_TYPE_XLIB = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_XLIB;
pub const CAIRO_SURFACE_TYPE_XCB = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_XCB;
pub const CAIRO_SURFACE_TYPE_GLITZ = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_GLITZ;
pub const CAIRO_SURFACE_TYPE_QUARTZ = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_QUARTZ;
pub const CAIRO_SURFACE_TYPE_WIN32 = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_WIN32;
pub const CAIRO_SURFACE_TYPE_BEOS = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_BEOS;
pub const CAIRO_SURFACE_TYPE_DIRECTFB = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_DIRECTFB;
pub const CAIRO_SURFACE_TYPE_SVG = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_SVG;
pub const CAIRO_SURFACE_TYPE_OS2 = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_OS2;
pub const CAIRO_SURFACE_TYPE_WIN32_PRINTING = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_WIN32_PRINTING;
pub const CAIRO_SURFACE_TYPE_QUARTZ_IMAGE = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_QUARTZ_IMAGE;
pub const CAIRO_SURFACE_TYPE_SCRIPT = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_SCRIPT;
pub const CAIRO_SURFACE_TYPE_QT = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_QT;
pub const CAIRO_SURFACE_TYPE_RECORDING = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_RECORDING;
pub const CAIRO_SURFACE_TYPE_VG = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_VG;
pub const CAIRO_SURFACE_TYPE_GL = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_GL;
pub const CAIRO_SURFACE_TYPE_DRM = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_DRM;
pub const CAIRO_SURFACE_TYPE_TEE = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_TEE;
pub const CAIRO_SURFACE_TYPE_XML = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_XML;
pub const CAIRO_SURFACE_TYPE_SKIA = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_SKIA;
pub const CAIRO_SURFACE_TYPE_SUBSURFACE = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_SUBSURFACE;
pub const CAIRO_SURFACE_TYPE_COGL = enum__cairo_surface_type.CAIRO_SURFACE_TYPE_COGL;
pub const enum__cairo_surface_type = extern enum {
    CAIRO_SURFACE_TYPE_IMAGE,
    CAIRO_SURFACE_TYPE_PDF,
    CAIRO_SURFACE_TYPE_PS,
    CAIRO_SURFACE_TYPE_XLIB,
    CAIRO_SURFACE_TYPE_XCB,
    CAIRO_SURFACE_TYPE_GLITZ,
    CAIRO_SURFACE_TYPE_QUARTZ,
    CAIRO_SURFACE_TYPE_WIN32,
    CAIRO_SURFACE_TYPE_BEOS,
    CAIRO_SURFACE_TYPE_DIRECTFB,
    CAIRO_SURFACE_TYPE_SVG,
    CAIRO_SURFACE_TYPE_OS2,
    CAIRO_SURFACE_TYPE_WIN32_PRINTING,
    CAIRO_SURFACE_TYPE_QUARTZ_IMAGE,
    CAIRO_SURFACE_TYPE_SCRIPT,
    CAIRO_SURFACE_TYPE_QT,
    CAIRO_SURFACE_TYPE_RECORDING,
    CAIRO_SURFACE_TYPE_VG,
    CAIRO_SURFACE_TYPE_GL,
    CAIRO_SURFACE_TYPE_DRM,
    CAIRO_SURFACE_TYPE_TEE,
    CAIRO_SURFACE_TYPE_XML,
    CAIRO_SURFACE_TYPE_SKIA,
    CAIRO_SURFACE_TYPE_SUBSURFACE,
    CAIRO_SURFACE_TYPE_COGL,
};
pub const cairo_surface_type_t = enum__cairo_surface_type;
pub extern fn cairo_surface_get_type(surface: ?*cairo_surface_t) cairo_surface_type_t;
pub extern fn cairo_surface_get_content(surface: ?*cairo_surface_t) cairo_content_t;
pub extern fn cairo_surface_write_to_png(surface: ?*cairo_surface_t, filename: [*c]const u8) cairo_status_t;
pub extern fn cairo_surface_write_to_png_stream(surface: ?*cairo_surface_t, write_func: cairo_write_func_t, closure: ?*c_void) cairo_status_t;
pub extern fn cairo_surface_get_user_data(surface: ?*cairo_surface_t, key: [*c]const cairo_user_data_key_t) ?*c_void;
pub extern fn cairo_surface_set_user_data(surface: ?*cairo_surface_t, key: [*c]const cairo_user_data_key_t, user_data: ?*c_void, destroy: cairo_destroy_func_t) cairo_status_t;
pub extern fn cairo_surface_get_mime_data(surface: ?*cairo_surface_t, mime_type: [*c]const u8, data: [*c]([*c]const u8), length: [*c]c_ulong) void;
pub extern fn cairo_surface_set_mime_data(surface: ?*cairo_surface_t, mime_type: [*c]const u8, data: [*c]const u8, length: c_ulong, destroy: cairo_destroy_func_t, closure: ?*c_void) cairo_status_t;
pub extern fn cairo_surface_supports_mime_type(surface: ?*cairo_surface_t, mime_type: [*c]const u8) cairo_bool_t;
pub extern fn cairo_surface_get_font_options(surface: ?*cairo_surface_t, options: ?*cairo_font_options_t) void;
pub extern fn cairo_surface_flush(surface: ?*cairo_surface_t) void;
pub extern fn cairo_surface_mark_dirty(surface: ?*cairo_surface_t) void;
pub extern fn cairo_surface_mark_dirty_rectangle(surface: ?*cairo_surface_t, x: c_int, y: c_int, width: c_int, height: c_int) void;
pub extern fn cairo_surface_set_device_scale(surface: ?*cairo_surface_t, x_scale: f64, y_scale: f64) void;
pub extern fn cairo_surface_get_device_scale(surface: ?*cairo_surface_t, x_scale: [*c]f64, y_scale: [*c]f64) void;
pub extern fn cairo_surface_set_device_offset(surface: ?*cairo_surface_t, x_offset: f64, y_offset: f64) void;
pub extern fn cairo_surface_get_device_offset(surface: ?*cairo_surface_t, x_offset: [*c]f64, y_offset: [*c]f64) void;
pub extern fn cairo_surface_set_fallback_resolution(surface: ?*cairo_surface_t, x_pixels_per_inch: f64, y_pixels_per_inch: f64) void;
pub extern fn cairo_surface_get_fallback_resolution(surface: ?*cairo_surface_t, x_pixels_per_inch: [*c]f64, y_pixels_per_inch: [*c]f64) void;
pub extern fn cairo_surface_copy_page(surface: ?*cairo_surface_t) void;
pub extern fn cairo_surface_show_page(surface: ?*cairo_surface_t) void;
pub extern fn cairo_surface_has_show_text_glyphs(surface: ?*cairo_surface_t) cairo_bool_t;
pub extern fn cairo_image_surface_create(format: cairo_format_t, width: c_int, height: c_int) ?*cairo_surface_t;
pub extern fn cairo_format_stride_for_width(format: cairo_format_t, width: c_int) c_int;
pub extern fn cairo_image_surface_create_for_data(data: [*c]u8, format: cairo_format_t, width: c_int, height: c_int, stride: c_int) ?*cairo_surface_t;
pub extern fn cairo_image_surface_get_data(surface: ?*cairo_surface_t) [*c]u8;
pub extern fn cairo_image_surface_get_format(surface: ?*cairo_surface_t) cairo_format_t;
pub extern fn cairo_image_surface_get_width(surface: ?*cairo_surface_t) c_int;
pub extern fn cairo_image_surface_get_height(surface: ?*cairo_surface_t) c_int;
pub extern fn cairo_image_surface_get_stride(surface: ?*cairo_surface_t) c_int;
pub extern fn cairo_image_surface_create_from_png(filename: [*c]const u8) ?*cairo_surface_t;
pub extern fn cairo_image_surface_create_from_png_stream(read_func: cairo_read_func_t, closure: ?*c_void) ?*cairo_surface_t;
pub extern fn cairo_recording_surface_create(content: cairo_content_t, extents: [*c]const cairo_rectangle_t) ?*cairo_surface_t;
pub extern fn cairo_recording_surface_ink_extents(surface: ?*cairo_surface_t, x0: [*c]f64, y0: [*c]f64, width: [*c]f64, height: [*c]f64) void;
pub extern fn cairo_recording_surface_get_extents(surface: ?*cairo_surface_t, extents: [*c]cairo_rectangle_t) cairo_bool_t;
pub const cairo_raster_source_acquire_func_t = ?extern fn (?*cairo_pattern_t, ?*c_void, ?*cairo_surface_t, [*c]const cairo_rectangle_int_t) ?*cairo_surface_t;
pub const cairo_raster_source_release_func_t = ?extern fn (?*cairo_pattern_t, ?*c_void, ?*cairo_surface_t) void;
pub const cairo_raster_source_snapshot_func_t = ?extern fn (?*cairo_pattern_t, ?*c_void) cairo_status_t;
pub const cairo_raster_source_copy_func_t = ?extern fn (?*cairo_pattern_t, ?*c_void, ?*const cairo_pattern_t) cairo_status_t;
pub const cairo_raster_source_finish_func_t = ?extern fn (?*cairo_pattern_t, ?*c_void) void;
pub extern fn cairo_pattern_create_raster_source(user_data: ?*c_void, content: cairo_content_t, width: c_int, height: c_int) ?*cairo_pattern_t;
pub extern fn cairo_raster_source_pattern_set_callback_data(pattern: ?*cairo_pattern_t, data: ?*c_void) void;
pub extern fn cairo_raster_source_pattern_get_callback_data(pattern: ?*cairo_pattern_t) ?*c_void;
pub extern fn cairo_raster_source_pattern_set_acquire(pattern: ?*cairo_pattern_t, acquire: cairo_raster_source_acquire_func_t, release: cairo_raster_source_release_func_t) void;
pub extern fn cairo_raster_source_pattern_get_acquire(pattern: ?*cairo_pattern_t, acquire: [*c]cairo_raster_source_acquire_func_t, release: [*c]cairo_raster_source_release_func_t) void;
pub extern fn cairo_raster_source_pattern_set_snapshot(pattern: ?*cairo_pattern_t, snapshot: cairo_raster_source_snapshot_func_t) void;
pub extern fn cairo_raster_source_pattern_get_snapshot(pattern: ?*cairo_pattern_t) cairo_raster_source_snapshot_func_t;
pub extern fn cairo_raster_source_pattern_set_copy(pattern: ?*cairo_pattern_t, copy: cairo_raster_source_copy_func_t) void;
pub extern fn cairo_raster_source_pattern_get_copy(pattern: ?*cairo_pattern_t) cairo_raster_source_copy_func_t;
pub extern fn cairo_raster_source_pattern_set_finish(pattern: ?*cairo_pattern_t, finish: cairo_raster_source_finish_func_t) void;
pub extern fn cairo_raster_source_pattern_get_finish(pattern: ?*cairo_pattern_t) cairo_raster_source_finish_func_t;
pub extern fn cairo_pattern_create_rgb(red: f64, green: f64, blue: f64) ?*cairo_pattern_t;
pub extern fn cairo_pattern_create_rgba(red: f64, green: f64, blue: f64, alpha: f64) ?*cairo_pattern_t;
pub extern fn cairo_pattern_create_for_surface(surface: ?*cairo_surface_t) ?*cairo_pattern_t;
pub extern fn cairo_pattern_create_linear(x0: f64, y0: f64, x1: f64, y1: f64) ?*cairo_pattern_t;
pub extern fn cairo_pattern_create_radial(cx0: f64, cy0: f64, radius0: f64, cx1: f64, cy1: f64, radius1: f64) ?*cairo_pattern_t;
pub extern fn cairo_pattern_create_mesh() ?*cairo_pattern_t;
pub extern fn cairo_pattern_reference(pattern: ?*cairo_pattern_t) ?*cairo_pattern_t;
pub extern fn cairo_pattern_destroy(pattern: ?*cairo_pattern_t) void;
pub extern fn cairo_pattern_get_reference_count(pattern: ?*cairo_pattern_t) c_uint;
pub extern fn cairo_pattern_status(pattern: ?*cairo_pattern_t) cairo_status_t;
pub extern fn cairo_pattern_get_user_data(pattern: ?*cairo_pattern_t, key: [*c]const cairo_user_data_key_t) ?*c_void;
pub extern fn cairo_pattern_set_user_data(pattern: ?*cairo_pattern_t, key: [*c]const cairo_user_data_key_t, user_data: ?*c_void, destroy: cairo_destroy_func_t) cairo_status_t;
pub const CAIRO_PATTERN_TYPE_SOLID = enum__cairo_pattern_type.CAIRO_PATTERN_TYPE_SOLID;
pub const CAIRO_PATTERN_TYPE_SURFACE = enum__cairo_pattern_type.CAIRO_PATTERN_TYPE_SURFACE;
pub const CAIRO_PATTERN_TYPE_LINEAR = enum__cairo_pattern_type.CAIRO_PATTERN_TYPE_LINEAR;
pub const CAIRO_PATTERN_TYPE_RADIAL = enum__cairo_pattern_type.CAIRO_PATTERN_TYPE_RADIAL;
pub const CAIRO_PATTERN_TYPE_MESH = enum__cairo_pattern_type.CAIRO_PATTERN_TYPE_MESH;
pub const CAIRO_PATTERN_TYPE_RASTER_SOURCE = enum__cairo_pattern_type.CAIRO_PATTERN_TYPE_RASTER_SOURCE;
pub const enum__cairo_pattern_type = extern enum {
    CAIRO_PATTERN_TYPE_SOLID,
    CAIRO_PATTERN_TYPE_SURFACE,
    CAIRO_PATTERN_TYPE_LINEAR,
    CAIRO_PATTERN_TYPE_RADIAL,
    CAIRO_PATTERN_TYPE_MESH,
    CAIRO_PATTERN_TYPE_RASTER_SOURCE,
};
pub const cairo_pattern_type_t = enum__cairo_pattern_type;
pub extern fn cairo_pattern_get_type(pattern: ?*cairo_pattern_t) cairo_pattern_type_t;
pub extern fn cairo_pattern_add_color_stop_rgb(pattern: ?*cairo_pattern_t, offset: f64, red: f64, green: f64, blue: f64) void;
pub extern fn cairo_pattern_add_color_stop_rgba(pattern: ?*cairo_pattern_t, offset: f64, red: f64, green: f64, blue: f64, alpha: f64) void;
pub extern fn cairo_mesh_pattern_begin_patch(pattern: ?*cairo_pattern_t) void;
pub extern fn cairo_mesh_pattern_end_patch(pattern: ?*cairo_pattern_t) void;
pub extern fn cairo_mesh_pattern_curve_to(pattern: ?*cairo_pattern_t, x1: f64, y1: f64, x2: f64, y2: f64, x3: f64, y3: f64) void;
pub extern fn cairo_mesh_pattern_line_to(pattern: ?*cairo_pattern_t, x: f64, y: f64) void;
pub extern fn cairo_mesh_pattern_move_to(pattern: ?*cairo_pattern_t, x: f64, y: f64) void;
pub extern fn cairo_mesh_pattern_set_control_point(pattern: ?*cairo_pattern_t, point_num: c_uint, x: f64, y: f64) void;
pub extern fn cairo_mesh_pattern_set_corner_color_rgb(pattern: ?*cairo_pattern_t, corner_num: c_uint, red: f64, green: f64, blue: f64) void;
pub extern fn cairo_mesh_pattern_set_corner_color_rgba(pattern: ?*cairo_pattern_t, corner_num: c_uint, red: f64, green: f64, blue: f64, alpha: f64) void;
pub extern fn cairo_pattern_set_matrix(pattern: ?*cairo_pattern_t, matrix: [*c]const cairo_matrix_t) void;
pub extern fn cairo_pattern_get_matrix(pattern: ?*cairo_pattern_t, matrix: [*c]cairo_matrix_t) void;
pub const CAIRO_EXTEND_NONE = enum__cairo_extend.CAIRO_EXTEND_NONE;
pub const CAIRO_EXTEND_REPEAT = enum__cairo_extend.CAIRO_EXTEND_REPEAT;
pub const CAIRO_EXTEND_REFLECT = enum__cairo_extend.CAIRO_EXTEND_REFLECT;
pub const CAIRO_EXTEND_PAD = enum__cairo_extend.CAIRO_EXTEND_PAD;
pub const enum__cairo_extend = extern enum {
    CAIRO_EXTEND_NONE,
    CAIRO_EXTEND_REPEAT,
    CAIRO_EXTEND_REFLECT,
    CAIRO_EXTEND_PAD,
};
pub const cairo_extend_t = enum__cairo_extend;
pub extern fn cairo_pattern_set_extend(pattern: ?*cairo_pattern_t, extend: cairo_extend_t) void;
pub extern fn cairo_pattern_get_extend(pattern: ?*cairo_pattern_t) cairo_extend_t;
pub const CAIRO_FILTER_FAST = enum__cairo_filter.CAIRO_FILTER_FAST;
pub const CAIRO_FILTER_GOOD = enum__cairo_filter.CAIRO_FILTER_GOOD;
pub const CAIRO_FILTER_BEST = enum__cairo_filter.CAIRO_FILTER_BEST;
pub const CAIRO_FILTER_NEAREST = enum__cairo_filter.CAIRO_FILTER_NEAREST;
pub const CAIRO_FILTER_BILINEAR = enum__cairo_filter.CAIRO_FILTER_BILINEAR;
pub const CAIRO_FILTER_GAUSSIAN = enum__cairo_filter.CAIRO_FILTER_GAUSSIAN;
pub const enum__cairo_filter = extern enum {
    CAIRO_FILTER_FAST,
    CAIRO_FILTER_GOOD,
    CAIRO_FILTER_BEST,
    CAIRO_FILTER_NEAREST,
    CAIRO_FILTER_BILINEAR,
    CAIRO_FILTER_GAUSSIAN,
};
pub const cairo_filter_t = enum__cairo_filter;
pub extern fn cairo_pattern_set_filter(pattern: ?*cairo_pattern_t, filter: cairo_filter_t) void;
pub extern fn cairo_pattern_get_filter(pattern: ?*cairo_pattern_t) cairo_filter_t;
pub extern fn cairo_pattern_get_rgba(pattern: ?*cairo_pattern_t, red: [*c]f64, green: [*c]f64, blue: [*c]f64, alpha: [*c]f64) cairo_status_t;
pub extern fn cairo_pattern_get_surface(pattern: ?*cairo_pattern_t, surface: [*c](?*cairo_surface_t)) cairo_status_t;
pub extern fn cairo_pattern_get_color_stop_rgba(pattern: ?*cairo_pattern_t, index: c_int, offset: [*c]f64, red: [*c]f64, green: [*c]f64, blue: [*c]f64, alpha: [*c]f64) cairo_status_t;
pub extern fn cairo_pattern_get_color_stop_count(pattern: ?*cairo_pattern_t, count: [*c]c_int) cairo_status_t;
pub extern fn cairo_pattern_get_linear_points(pattern: ?*cairo_pattern_t, x0: [*c]f64, y0: [*c]f64, x1: [*c]f64, y1: [*c]f64) cairo_status_t;
pub extern fn cairo_pattern_get_radial_circles(pattern: ?*cairo_pattern_t, x0: [*c]f64, y0: [*c]f64, r0: [*c]f64, x1: [*c]f64, y1: [*c]f64, r1: [*c]f64) cairo_status_t;
pub extern fn cairo_mesh_pattern_get_patch_count(pattern: ?*cairo_pattern_t, count: [*c]c_uint) cairo_status_t;
pub extern fn cairo_mesh_pattern_get_path(pattern: ?*cairo_pattern_t, patch_num: c_uint) [*c]cairo_path_t;
pub extern fn cairo_mesh_pattern_get_corner_color_rgba(pattern: ?*cairo_pattern_t, patch_num: c_uint, corner_num: c_uint, red: [*c]f64, green: [*c]f64, blue: [*c]f64, alpha: [*c]f64) cairo_status_t;
pub extern fn cairo_mesh_pattern_get_control_point(pattern: ?*cairo_pattern_t, patch_num: c_uint, point_num: c_uint, x: [*c]f64, y: [*c]f64) cairo_status_t;
pub extern fn cairo_matrix_init(matrix: [*c]cairo_matrix_t, xx: f64, yx: f64, xy: f64, yy: f64, x0: f64, y0: f64) void;
pub extern fn cairo_matrix_init_identity(matrix: [*c]cairo_matrix_t) void;
pub extern fn cairo_matrix_init_translate(matrix: [*c]cairo_matrix_t, tx: f64, ty: f64) void;
pub extern fn cairo_matrix_init_scale(matrix: [*c]cairo_matrix_t, sx: f64, sy: f64) void;
pub extern fn cairo_matrix_init_rotate(matrix: [*c]cairo_matrix_t, radians: f64) void;
pub extern fn cairo_matrix_translate(matrix: [*c]cairo_matrix_t, tx: f64, ty: f64) void;
pub extern fn cairo_matrix_scale(matrix: [*c]cairo_matrix_t, sx: f64, sy: f64) void;
pub extern fn cairo_matrix_rotate(matrix: [*c]cairo_matrix_t, radians: f64) void;
pub extern fn cairo_matrix_invert(matrix: [*c]cairo_matrix_t) cairo_status_t;
pub extern fn cairo_matrix_multiply(result: [*c]cairo_matrix_t, a: [*c]const cairo_matrix_t, b: [*c]const cairo_matrix_t) void;
pub extern fn cairo_matrix_transform_distance(matrix: [*c]const cairo_matrix_t, dx: [*c]f64, dy: [*c]f64) void;
pub extern fn cairo_matrix_transform_point(matrix: [*c]const cairo_matrix_t, x: [*c]f64, y: [*c]f64) void;
pub const struct__cairo_region = @OpaqueType();
pub const cairo_region_t = struct__cairo_region;
pub const CAIRO_REGION_OVERLAP_IN = enum__cairo_region_overlap.CAIRO_REGION_OVERLAP_IN;
pub const CAIRO_REGION_OVERLAP_OUT = enum__cairo_region_overlap.CAIRO_REGION_OVERLAP_OUT;
pub const CAIRO_REGION_OVERLAP_PART = enum__cairo_region_overlap.CAIRO_REGION_OVERLAP_PART;
pub const enum__cairo_region_overlap = extern enum {
    CAIRO_REGION_OVERLAP_IN,
    CAIRO_REGION_OVERLAP_OUT,
    CAIRO_REGION_OVERLAP_PART,
};
pub const cairo_region_overlap_t = enum__cairo_region_overlap;
pub extern fn cairo_region_create() ?*cairo_region_t;
pub extern fn cairo_region_create_rectangle(rectangle: [*c]const cairo_rectangle_int_t) ?*cairo_region_t;
pub extern fn cairo_region_create_rectangles(rects: [*c]const cairo_rectangle_int_t, count: c_int) ?*cairo_region_t;
pub extern fn cairo_region_copy(original: ?*const cairo_region_t) ?*cairo_region_t;
pub extern fn cairo_region_reference(region: ?*cairo_region_t) ?*cairo_region_t;
pub extern fn cairo_region_destroy(region: ?*cairo_region_t) void;
pub extern fn cairo_region_equal(a: ?*const cairo_region_t, b: ?*const cairo_region_t) cairo_bool_t;
pub extern fn cairo_region_status(region: ?*const cairo_region_t) cairo_status_t;
pub extern fn cairo_region_get_extents(region: ?*const cairo_region_t, extents: [*c]cairo_rectangle_int_t) void;
pub extern fn cairo_region_num_rectangles(region: ?*const cairo_region_t) c_int;
pub extern fn cairo_region_get_rectangle(region: ?*const cairo_region_t, nth: c_int, rectangle: [*c]cairo_rectangle_int_t) void;
pub extern fn cairo_region_is_empty(region: ?*const cairo_region_t) cairo_bool_t;
pub extern fn cairo_region_contains_rectangle(region: ?*const cairo_region_t, rectangle: [*c]const cairo_rectangle_int_t) cairo_region_overlap_t;
pub extern fn cairo_region_contains_point(region: ?*const cairo_region_t, x: c_int, y: c_int) cairo_bool_t;
pub extern fn cairo_region_translate(region: ?*cairo_region_t, dx: c_int, dy: c_int) void;
pub extern fn cairo_region_subtract(dst: ?*cairo_region_t, other: ?*const cairo_region_t) cairo_status_t;
pub extern fn cairo_region_subtract_rectangle(dst: ?*cairo_region_t, rectangle: [*c]const cairo_rectangle_int_t) cairo_status_t;
pub extern fn cairo_region_intersect(dst: ?*cairo_region_t, other: ?*const cairo_region_t) cairo_status_t;
pub extern fn cairo_region_intersect_rectangle(dst: ?*cairo_region_t, rectangle: [*c]const cairo_rectangle_int_t) cairo_status_t;
pub extern fn cairo_region_union(dst: ?*cairo_region_t, other: ?*const cairo_region_t) cairo_status_t;
pub extern fn cairo_region_union_rectangle(dst: ?*cairo_region_t, rectangle: [*c]const cairo_rectangle_int_t) cairo_status_t;
pub extern fn cairo_region_xor(dst: ?*cairo_region_t, other: ?*const cairo_region_t) cairo_status_t;
pub extern fn cairo_region_xor_rectangle(dst: ?*cairo_region_t, rectangle: [*c]const cairo_rectangle_int_t) cairo_status_t;
pub extern fn cairo_debug_reset_static_data() void;
pub const struct__GdkPoint = extern struct {
    x: gint,
    y: gint,
};
pub const GdkPoint = struct__GdkPoint;
pub const GdkRectangle = cairo_rectangle_int_t;
pub const struct__GdkAtom = @OpaqueType();
pub const GdkAtom = ?*struct__GdkAtom;
pub const struct__GdkColor = extern struct {
    pixel: guint32,
    red: guint16,
    green: guint16,
    blue: guint16,
};
pub const GdkColor = struct__GdkColor;
pub const struct__GdkRGBA = extern struct {
    red: gdouble,
    green: gdouble,
    blue: gdouble,
    alpha: gdouble,
};
pub const GdkRGBA = struct__GdkRGBA;
pub const struct__GdkCursor = @OpaqueType();
pub const GdkCursor = struct__GdkCursor;
pub const struct__GdkVisual = @OpaqueType();
pub const GdkVisual = struct__GdkVisual;
pub const struct__GdkDevice = @OpaqueType();
pub const GdkDevice = struct__GdkDevice;
pub const struct__GdkDragContext = @OpaqueType();
pub const GdkDragContext = struct__GdkDragContext;
pub const struct__GdkDisplayManager = @OpaqueType();
pub const GdkDisplayManager = struct__GdkDisplayManager;
pub const struct__GdkDeviceManager = @OpaqueType();
pub const GdkDeviceManager = struct__GdkDeviceManager;
pub const struct__GdkDisplay = @OpaqueType();
pub const GdkDisplay = struct__GdkDisplay;
pub const struct__GdkScreen = @OpaqueType();
pub const GdkScreen = struct__GdkScreen;
pub const struct__GdkWindow = @OpaqueType();
pub const GdkWindow = struct__GdkWindow;
pub const struct__GdkKeymap = @OpaqueType();
pub const GdkKeymap = struct__GdkKeymap;
pub const struct__GdkAppLaunchContext = @OpaqueType();
pub const GdkAppLaunchContext = struct__GdkAppLaunchContext;
pub const struct__GdkSeat = extern struct {
    parent_instance: GObject,
};
pub const GdkSeat = struct__GdkSeat;
pub const struct__GdkGLContext = @OpaqueType();
pub const GdkGLContext = struct__GdkGLContext;
pub const GDK_LSB_FIRST = 0;
pub const GDK_MSB_FIRST = 1;
pub const GdkByteOrder = extern enum {
    GDK_LSB_FIRST = 0,
    GDK_MSB_FIRST = 1,
};
pub const GDK_SHIFT_MASK = 1;
pub const GDK_LOCK_MASK = 2;
pub const GDK_CONTROL_MASK = 4;
pub const GDK_MOD1_MASK = 8;
pub const GDK_MOD2_MASK = 16;
pub const GDK_MOD3_MASK = 32;
pub const GDK_MOD4_MASK = 64;
pub const GDK_MOD5_MASK = 128;
pub const GDK_BUTTON1_MASK = 256;
pub const GDK_BUTTON2_MASK = 512;
pub const GDK_BUTTON3_MASK = 1024;
pub const GDK_BUTTON4_MASK = 2048;
pub const GDK_BUTTON5_MASK = 4096;
pub const GDK_MODIFIER_RESERVED_13_MASK = 8192;
pub const GDK_MODIFIER_RESERVED_14_MASK = 16384;
pub const GDK_MODIFIER_RESERVED_15_MASK = 32768;
pub const GDK_MODIFIER_RESERVED_16_MASK = 65536;
pub const GDK_MODIFIER_RESERVED_17_MASK = 131072;
pub const GDK_MODIFIER_RESERVED_18_MASK = 262144;
pub const GDK_MODIFIER_RESERVED_19_MASK = 524288;
pub const GDK_MODIFIER_RESERVED_20_MASK = 1048576;
pub const GDK_MODIFIER_RESERVED_21_MASK = 2097152;
pub const GDK_MODIFIER_RESERVED_22_MASK = 4194304;
pub const GDK_MODIFIER_RESERVED_23_MASK = 8388608;
pub const GDK_MODIFIER_RESERVED_24_MASK = 16777216;
pub const GDK_MODIFIER_RESERVED_25_MASK = 33554432;
pub const GDK_SUPER_MASK = 67108864;
pub const GDK_HYPER_MASK = 134217728;
pub const GDK_META_MASK = 268435456;
pub const GDK_MODIFIER_RESERVED_29_MASK = 536870912;
pub const GDK_RELEASE_MASK = 1073741824;
pub const GDK_MODIFIER_MASK = 1543512063;
pub const GdkModifierType = extern enum {
    GDK_SHIFT_MASK = 1,
    GDK_LOCK_MASK = 2,
    GDK_CONTROL_MASK = 4,
    GDK_MOD1_MASK = 8,
    GDK_MOD2_MASK = 16,
    GDK_MOD3_MASK = 32,
    GDK_MOD4_MASK = 64,
    GDK_MOD5_MASK = 128,
    GDK_BUTTON1_MASK = 256,
    GDK_BUTTON2_MASK = 512,
    GDK_BUTTON3_MASK = 1024,
    GDK_BUTTON4_MASK = 2048,
    GDK_BUTTON5_MASK = 4096,
    GDK_MODIFIER_RESERVED_13_MASK = 8192,
    GDK_MODIFIER_RESERVED_14_MASK = 16384,
    GDK_MODIFIER_RESERVED_15_MASK = 32768,
    GDK_MODIFIER_RESERVED_16_MASK = 65536,
    GDK_MODIFIER_RESERVED_17_MASK = 131072,
    GDK_MODIFIER_RESERVED_18_MASK = 262144,
    GDK_MODIFIER_RESERVED_19_MASK = 524288,
    GDK_MODIFIER_RESERVED_20_MASK = 1048576,
    GDK_MODIFIER_RESERVED_21_MASK = 2097152,
    GDK_MODIFIER_RESERVED_22_MASK = 4194304,
    GDK_MODIFIER_RESERVED_23_MASK = 8388608,
    GDK_MODIFIER_RESERVED_24_MASK = 16777216,
    GDK_MODIFIER_RESERVED_25_MASK = 33554432,
    GDK_SUPER_MASK = 67108864,
    GDK_HYPER_MASK = 134217728,
    GDK_META_MASK = 268435456,
    GDK_MODIFIER_RESERVED_29_MASK = 536870912,
    GDK_RELEASE_MASK = 1073741824,
    GDK_MODIFIER_MASK = 1543512063,
};
pub const GDK_MODIFIER_INTENT_PRIMARY_ACCELERATOR = 0;
pub const GDK_MODIFIER_INTENT_CONTEXT_MENU = 1;
pub const GDK_MODIFIER_INTENT_EXTEND_SELECTION = 2;
pub const GDK_MODIFIER_INTENT_MODIFY_SELECTION = 3;
pub const GDK_MODIFIER_INTENT_NO_TEXT_INPUT = 4;
pub const GDK_MODIFIER_INTENT_SHIFT_GROUP = 5;
pub const GDK_MODIFIER_INTENT_DEFAULT_MOD_MASK = 6;
pub const GdkModifierIntent = extern enum {
    GDK_MODIFIER_INTENT_PRIMARY_ACCELERATOR = 0,
    GDK_MODIFIER_INTENT_CONTEXT_MENU = 1,
    GDK_MODIFIER_INTENT_EXTEND_SELECTION = 2,
    GDK_MODIFIER_INTENT_MODIFY_SELECTION = 3,
    GDK_MODIFIER_INTENT_NO_TEXT_INPUT = 4,
    GDK_MODIFIER_INTENT_SHIFT_GROUP = 5,
    GDK_MODIFIER_INTENT_DEFAULT_MOD_MASK = 6,
};
pub const GDK_OK = 0;
pub const GDK_ERROR = -1;
pub const GDK_ERROR_PARAM = -2;
pub const GDK_ERROR_FILE = -3;
pub const GDK_ERROR_MEM = -4;
pub const GdkStatus = extern enum {
    GDK_OK = 0,
    GDK_ERROR = -1,
    GDK_ERROR_PARAM = -2,
    GDK_ERROR_FILE = -3,
    GDK_ERROR_MEM = -4,
};
pub const GDK_GRAB_SUCCESS = 0;
pub const GDK_GRAB_ALREADY_GRABBED = 1;
pub const GDK_GRAB_INVALID_TIME = 2;
pub const GDK_GRAB_NOT_VIEWABLE = 3;
pub const GDK_GRAB_FROZEN = 4;
pub const GDK_GRAB_FAILED = 5;
pub const GdkGrabStatus = extern enum {
    GDK_GRAB_SUCCESS = 0,
    GDK_GRAB_ALREADY_GRABBED = 1,
    GDK_GRAB_INVALID_TIME = 2,
    GDK_GRAB_NOT_VIEWABLE = 3,
    GDK_GRAB_FROZEN = 4,
    GDK_GRAB_FAILED = 5,
};
pub const GDK_OWNERSHIP_NONE = 0;
pub const GDK_OWNERSHIP_WINDOW = 1;
pub const GDK_OWNERSHIP_APPLICATION = 2;
pub const GdkGrabOwnership = extern enum {
    GDK_OWNERSHIP_NONE = 0,
    GDK_OWNERSHIP_WINDOW = 1,
    GDK_OWNERSHIP_APPLICATION = 2,
};
pub const GDK_EXPOSURE_MASK = 2;
pub const GDK_POINTER_MOTION_MASK = 4;
pub const GDK_POINTER_MOTION_HINT_MASK = 8;
pub const GDK_BUTTON_MOTION_MASK = 16;
pub const GDK_BUTTON1_MOTION_MASK = 32;
pub const GDK_BUTTON2_MOTION_MASK = 64;
pub const GDK_BUTTON3_MOTION_MASK = 128;
pub const GDK_BUTTON_PRESS_MASK = 256;
pub const GDK_BUTTON_RELEASE_MASK = 512;
pub const GDK_KEY_PRESS_MASK = 1024;
pub const GDK_KEY_RELEASE_MASK = 2048;
pub const GDK_ENTER_NOTIFY_MASK = 4096;
pub const GDK_LEAVE_NOTIFY_MASK = 8192;
pub const GDK_FOCUS_CHANGE_MASK = 16384;
pub const GDK_STRUCTURE_MASK = 32768;
pub const GDK_PROPERTY_CHANGE_MASK = 65536;
pub const GDK_VISIBILITY_NOTIFY_MASK = 131072;
pub const GDK_PROXIMITY_IN_MASK = 262144;
pub const GDK_PROXIMITY_OUT_MASK = 524288;
pub const GDK_SUBSTRUCTURE_MASK = 1048576;
pub const GDK_SCROLL_MASK = 2097152;
pub const GDK_TOUCH_MASK = 4194304;
pub const GDK_SMOOTH_SCROLL_MASK = 8388608;
pub const GDK_TOUCHPAD_GESTURE_MASK = 16777216;
pub const GDK_TABLET_PAD_MASK = 33554432;
pub const GDK_ALL_EVENTS_MASK = 67108862;
pub const GdkEventMask = extern enum {
    GDK_EXPOSURE_MASK = 2,
    GDK_POINTER_MOTION_MASK = 4,
    GDK_POINTER_MOTION_HINT_MASK = 8,
    GDK_BUTTON_MOTION_MASK = 16,
    GDK_BUTTON1_MOTION_MASK = 32,
    GDK_BUTTON2_MOTION_MASK = 64,
    GDK_BUTTON3_MOTION_MASK = 128,
    GDK_BUTTON_PRESS_MASK = 256,
    GDK_BUTTON_RELEASE_MASK = 512,
    GDK_KEY_PRESS_MASK = 1024,
    GDK_KEY_RELEASE_MASK = 2048,
    GDK_ENTER_NOTIFY_MASK = 4096,
    GDK_LEAVE_NOTIFY_MASK = 8192,
    GDK_FOCUS_CHANGE_MASK = 16384,
    GDK_STRUCTURE_MASK = 32768,
    GDK_PROPERTY_CHANGE_MASK = 65536,
    GDK_VISIBILITY_NOTIFY_MASK = 131072,
    GDK_PROXIMITY_IN_MASK = 262144,
    GDK_PROXIMITY_OUT_MASK = 524288,
    GDK_SUBSTRUCTURE_MASK = 1048576,
    GDK_SCROLL_MASK = 2097152,
    GDK_TOUCH_MASK = 4194304,
    GDK_SMOOTH_SCROLL_MASK = 8388608,
    GDK_TOUCHPAD_GESTURE_MASK = 16777216,
    GDK_TABLET_PAD_MASK = 33554432,
    GDK_ALL_EVENTS_MASK = 67108862,
};
pub const GDK_GL_ERROR_NOT_AVAILABLE = 0;
pub const GDK_GL_ERROR_UNSUPPORTED_FORMAT = 1;
pub const GDK_GL_ERROR_UNSUPPORTED_PROFILE = 2;
pub const GdkGLError = extern enum {
    GDK_GL_ERROR_NOT_AVAILABLE = 0,
    GDK_GL_ERROR_UNSUPPORTED_FORMAT = 1,
    GDK_GL_ERROR_UNSUPPORTED_PROFILE = 2,
};
pub const GDK_WINDOW_TYPE_HINT_NORMAL = 0;
pub const GDK_WINDOW_TYPE_HINT_DIALOG = 1;
pub const GDK_WINDOW_TYPE_HINT_MENU = 2;
pub const GDK_WINDOW_TYPE_HINT_TOOLBAR = 3;
pub const GDK_WINDOW_TYPE_HINT_SPLASHSCREEN = 4;
pub const GDK_WINDOW_TYPE_HINT_UTILITY = 5;
pub const GDK_WINDOW_TYPE_HINT_DOCK = 6;
pub const GDK_WINDOW_TYPE_HINT_DESKTOP = 7;
pub const GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU = 8;
pub const GDK_WINDOW_TYPE_HINT_POPUP_MENU = 9;
pub const GDK_WINDOW_TYPE_HINT_TOOLTIP = 10;
pub const GDK_WINDOW_TYPE_HINT_NOTIFICATION = 11;
pub const GDK_WINDOW_TYPE_HINT_COMBO = 12;
pub const GDK_WINDOW_TYPE_HINT_DND = 13;
pub const GdkWindowTypeHint = extern enum {
    GDK_WINDOW_TYPE_HINT_NORMAL = 0,
    GDK_WINDOW_TYPE_HINT_DIALOG = 1,
    GDK_WINDOW_TYPE_HINT_MENU = 2,
    GDK_WINDOW_TYPE_HINT_TOOLBAR = 3,
    GDK_WINDOW_TYPE_HINT_SPLASHSCREEN = 4,
    GDK_WINDOW_TYPE_HINT_UTILITY = 5,
    GDK_WINDOW_TYPE_HINT_DOCK = 6,
    GDK_WINDOW_TYPE_HINT_DESKTOP = 7,
    GDK_WINDOW_TYPE_HINT_DROPDOWN_MENU = 8,
    GDK_WINDOW_TYPE_HINT_POPUP_MENU = 9,
    GDK_WINDOW_TYPE_HINT_TOOLTIP = 10,
    GDK_WINDOW_TYPE_HINT_NOTIFICATION = 11,
    GDK_WINDOW_TYPE_HINT_COMBO = 12,
    GDK_WINDOW_TYPE_HINT_DND = 13,
};
pub const GDK_AXIS_IGNORE = 0;
pub const GDK_AXIS_X = 1;
pub const GDK_AXIS_Y = 2;
pub const GDK_AXIS_PRESSURE = 3;
pub const GDK_AXIS_XTILT = 4;
pub const GDK_AXIS_YTILT = 5;
pub const GDK_AXIS_WHEEL = 6;
pub const GDK_AXIS_DISTANCE = 7;
pub const GDK_AXIS_ROTATION = 8;
pub const GDK_AXIS_SLIDER = 9;
pub const GDK_AXIS_LAST = 10;
pub const GdkAxisUse = extern enum {
    GDK_AXIS_IGNORE = 0,
    GDK_AXIS_X = 1,
    GDK_AXIS_Y = 2,
    GDK_AXIS_PRESSURE = 3,
    GDK_AXIS_XTILT = 4,
    GDK_AXIS_YTILT = 5,
    GDK_AXIS_WHEEL = 6,
    GDK_AXIS_DISTANCE = 7,
    GDK_AXIS_ROTATION = 8,
    GDK_AXIS_SLIDER = 9,
    GDK_AXIS_LAST = 10,
};
pub const GDK_AXIS_FLAG_X = 2;
pub const GDK_AXIS_FLAG_Y = 4;
pub const GDK_AXIS_FLAG_PRESSURE = 8;
pub const GDK_AXIS_FLAG_XTILT = 16;
pub const GDK_AXIS_FLAG_YTILT = 32;
pub const GDK_AXIS_FLAG_WHEEL = 64;
pub const GDK_AXIS_FLAG_DISTANCE = 128;
pub const GDK_AXIS_FLAG_ROTATION = 256;
pub const GDK_AXIS_FLAG_SLIDER = 512;
pub const GdkAxisFlags = extern enum {
    GDK_AXIS_FLAG_X = 2,
    GDK_AXIS_FLAG_Y = 4,
    GDK_AXIS_FLAG_PRESSURE = 8,
    GDK_AXIS_FLAG_XTILT = 16,
    GDK_AXIS_FLAG_YTILT = 32,
    GDK_AXIS_FLAG_WHEEL = 64,
    GDK_AXIS_FLAG_DISTANCE = 128,
    GDK_AXIS_FLAG_ROTATION = 256,
    GDK_AXIS_FLAG_SLIDER = 512,
};
pub const struct__GdkTimeCoord = extern struct {
    time: guint32,
    axes: [128]gdouble,
};
pub const GdkTimeCoord = struct__GdkTimeCoord;
pub const GDK_SOURCE_MOUSE = 0;
pub const GDK_SOURCE_PEN = 1;
pub const GDK_SOURCE_ERASER = 2;
pub const GDK_SOURCE_CURSOR = 3;
pub const GDK_SOURCE_KEYBOARD = 4;
pub const GDK_SOURCE_TOUCHSCREEN = 5;
pub const GDK_SOURCE_TOUCHPAD = 6;
pub const GDK_SOURCE_TRACKPOINT = 7;
pub const GDK_SOURCE_TABLET_PAD = 8;
pub const GdkInputSource = extern enum {
    GDK_SOURCE_MOUSE = 0,
    GDK_SOURCE_PEN = 1,
    GDK_SOURCE_ERASER = 2,
    GDK_SOURCE_CURSOR = 3,
    GDK_SOURCE_KEYBOARD = 4,
    GDK_SOURCE_TOUCHSCREEN = 5,
    GDK_SOURCE_TOUCHPAD = 6,
    GDK_SOURCE_TRACKPOINT = 7,
    GDK_SOURCE_TABLET_PAD = 8,
};
pub const GDK_MODE_DISABLED = 0;
pub const GDK_MODE_SCREEN = 1;
pub const GDK_MODE_WINDOW = 2;
pub const GdkInputMode = extern enum {
    GDK_MODE_DISABLED = 0,
    GDK_MODE_SCREEN = 1,
    GDK_MODE_WINDOW = 2,
};
pub const GDK_DEVICE_TYPE_MASTER = 0;
pub const GDK_DEVICE_TYPE_SLAVE = 1;
pub const GDK_DEVICE_TYPE_FLOATING = 2;
pub const GdkDeviceType = extern enum {
    GDK_DEVICE_TYPE_MASTER = 0,
    GDK_DEVICE_TYPE_SLAVE = 1,
    GDK_DEVICE_TYPE_FLOATING = 2,
};
pub extern fn gdk_device_get_type() GType;
pub extern fn gdk_device_get_name(device: ?*GdkDevice) [*c]const gchar;
pub extern fn gdk_device_get_has_cursor(device: ?*GdkDevice) gboolean;
pub extern fn gdk_device_get_source(device: ?*GdkDevice) GdkInputSource;
pub extern fn gdk_device_get_mode(device: ?*GdkDevice) GdkInputMode;
pub extern fn gdk_device_set_mode(device: ?*GdkDevice, mode: GdkInputMode) gboolean;
pub extern fn gdk_device_get_n_keys(device: ?*GdkDevice) gint;
pub extern fn gdk_device_get_key(device: ?*GdkDevice, index_: guint, keyval: [*c]guint, modifiers: [*c]GdkModifierType) gboolean;
pub extern fn gdk_device_set_key(device: ?*GdkDevice, index_: guint, keyval: guint, modifiers: GdkModifierType) void;
pub extern fn gdk_device_get_axis_use(device: ?*GdkDevice, index_: guint) GdkAxisUse;
pub extern fn gdk_device_set_axis_use(device: ?*GdkDevice, index_: guint, @"use": GdkAxisUse) void;
pub extern fn gdk_device_get_state(device: ?*GdkDevice, window: ?*GdkWindow, axes: [*c]gdouble, mask: [*c]GdkModifierType) void;
pub extern fn gdk_device_get_position(device: ?*GdkDevice, screen: [*c](?*GdkScreen), x: [*c]gint, y: [*c]gint) void;
pub extern fn gdk_device_get_window_at_position(device: ?*GdkDevice, win_x: [*c]gint, win_y: [*c]gint) ?*GdkWindow;
pub extern fn gdk_device_get_position_double(device: ?*GdkDevice, screen: [*c](?*GdkScreen), x: [*c]gdouble, y: [*c]gdouble) void;
pub extern fn gdk_device_get_window_at_position_double(device: ?*GdkDevice, win_x: [*c]gdouble, win_y: [*c]gdouble) ?*GdkWindow;
pub extern fn gdk_device_get_history(device: ?*GdkDevice, window: ?*GdkWindow, start: guint32, stop: guint32, events: [*c]([*c]([*c]GdkTimeCoord)), n_events: [*c]gint) gboolean;
pub extern fn gdk_device_free_history(events: [*c]([*c]GdkTimeCoord), n_events: gint) void;
pub extern fn gdk_device_get_n_axes(device: ?*GdkDevice) gint;
pub extern fn gdk_device_list_axes(device: ?*GdkDevice) [*c]GList;
pub extern fn gdk_device_get_axis_value(device: ?*GdkDevice, axes: [*c]gdouble, axis_label: GdkAtom, value: [*c]gdouble) gboolean;
pub extern fn gdk_device_get_axis(device: ?*GdkDevice, axes: [*c]gdouble, @"use": GdkAxisUse, value: [*c]gdouble) gboolean;
pub extern fn gdk_device_get_display(device: ?*GdkDevice) ?*GdkDisplay;
pub extern fn gdk_device_get_associated_device(device: ?*GdkDevice) ?*GdkDevice;
pub extern fn gdk_device_list_slave_devices(device: ?*GdkDevice) [*c]GList;
pub extern fn gdk_device_get_device_type(device: ?*GdkDevice) GdkDeviceType;
pub extern fn gdk_device_grab(device: ?*GdkDevice, window: ?*GdkWindow, grab_ownership: GdkGrabOwnership, owner_events: gboolean, event_mask: GdkEventMask, cursor: ?*GdkCursor, time_: guint32) GdkGrabStatus;
pub extern fn gdk_device_ungrab(device: ?*GdkDevice, time_: guint32) void;
pub extern fn gdk_device_warp(device: ?*GdkDevice, screen: ?*GdkScreen, x: gint, y: gint) void;
pub extern fn gdk_device_grab_info_libgtk_only(display: ?*GdkDisplay, device: ?*GdkDevice, grab_window: [*c](?*GdkWindow), owner_events: [*c]gboolean) gboolean;
pub extern fn gdk_device_get_last_event_window(device: ?*GdkDevice) ?*GdkWindow;
pub extern fn gdk_device_get_vendor_id(device: ?*GdkDevice) [*c]const gchar;
pub extern fn gdk_device_get_product_id(device: ?*GdkDevice) [*c]const gchar;
pub extern fn gdk_device_get_seat(device: ?*GdkDevice) [*c]GdkSeat;
pub extern fn gdk_device_get_axes(device: ?*GdkDevice) GdkAxisFlags;
pub const GDK_ACTION_DEFAULT = 1;
pub const GDK_ACTION_COPY = 2;
pub const GDK_ACTION_MOVE = 4;
pub const GDK_ACTION_LINK = 8;
pub const GDK_ACTION_PRIVATE = 16;
pub const GDK_ACTION_ASK = 32;
pub const GdkDragAction = extern enum {
    GDK_ACTION_DEFAULT = 1,
    GDK_ACTION_COPY = 2,
    GDK_ACTION_MOVE = 4,
    GDK_ACTION_LINK = 8,
    GDK_ACTION_PRIVATE = 16,
    GDK_ACTION_ASK = 32,
};
pub const GDK_DRAG_CANCEL_NO_TARGET = 0;
pub const GDK_DRAG_CANCEL_USER_CANCELLED = 1;
pub const GDK_DRAG_CANCEL_ERROR = 2;
pub const GdkDragCancelReason = extern enum {
    GDK_DRAG_CANCEL_NO_TARGET = 0,
    GDK_DRAG_CANCEL_USER_CANCELLED = 1,
    GDK_DRAG_CANCEL_ERROR = 2,
};
pub const GDK_DRAG_PROTO_NONE = 0;
pub const GDK_DRAG_PROTO_MOTIF = 1;
pub const GDK_DRAG_PROTO_XDND = 2;
pub const GDK_DRAG_PROTO_ROOTWIN = 3;
pub const GDK_DRAG_PROTO_WIN32_DROPFILES = 4;
pub const GDK_DRAG_PROTO_OLE2 = 5;
pub const GDK_DRAG_PROTO_LOCAL = 6;
pub const GDK_DRAG_PROTO_WAYLAND = 7;
pub const GdkDragProtocol = extern enum {
    GDK_DRAG_PROTO_NONE = 0,
    GDK_DRAG_PROTO_MOTIF = 1,
    GDK_DRAG_PROTO_XDND = 2,
    GDK_DRAG_PROTO_ROOTWIN = 3,
    GDK_DRAG_PROTO_WIN32_DROPFILES = 4,
    GDK_DRAG_PROTO_OLE2 = 5,
    GDK_DRAG_PROTO_LOCAL = 6,
    GDK_DRAG_PROTO_WAYLAND = 7,
};
pub extern fn gdk_drag_context_get_type() GType;
pub extern fn gdk_drag_context_set_device(context: ?*GdkDragContext, device: ?*GdkDevice) void;
pub extern fn gdk_drag_context_get_device(context: ?*GdkDragContext) ?*GdkDevice;
pub extern fn gdk_drag_context_list_targets(context: ?*GdkDragContext) [*c]GList;
pub extern fn gdk_drag_context_get_actions(context: ?*GdkDragContext) GdkDragAction;
pub extern fn gdk_drag_context_get_suggested_action(context: ?*GdkDragContext) GdkDragAction;
pub extern fn gdk_drag_context_get_selected_action(context: ?*GdkDragContext) GdkDragAction;
pub extern fn gdk_drag_context_get_source_window(context: ?*GdkDragContext) ?*GdkWindow;
pub extern fn gdk_drag_context_get_dest_window(context: ?*GdkDragContext) ?*GdkWindow;
pub extern fn gdk_drag_context_get_protocol(context: ?*GdkDragContext) GdkDragProtocol;
pub extern fn gdk_drag_status(context: ?*GdkDragContext, action: GdkDragAction, time_: guint32) void;
pub extern fn gdk_drop_reply(context: ?*GdkDragContext, accepted: gboolean, time_: guint32) void;
pub extern fn gdk_drop_finish(context: ?*GdkDragContext, success: gboolean, time_: guint32) void;
pub extern fn gdk_drag_get_selection(context: ?*GdkDragContext) GdkAtom;
pub extern fn gdk_drag_begin(window: ?*GdkWindow, targets: [*c]GList) ?*GdkDragContext;
pub extern fn gdk_drag_begin_for_device(window: ?*GdkWindow, device: ?*GdkDevice, targets: [*c]GList) ?*GdkDragContext;
pub extern fn gdk_drag_begin_from_point(window: ?*GdkWindow, device: ?*GdkDevice, targets: [*c]GList, x_root: gint, y_root: gint) ?*GdkDragContext;
pub extern fn gdk_drag_find_window_for_screen(context: ?*GdkDragContext, drag_window: ?*GdkWindow, screen: ?*GdkScreen, x_root: gint, y_root: gint, dest_window: [*c](?*GdkWindow), protocol: [*c]GdkDragProtocol) void;
pub extern fn gdk_drag_motion(context: ?*GdkDragContext, dest_window: ?*GdkWindow, protocol: GdkDragProtocol, x_root: gint, y_root: gint, suggested_action: GdkDragAction, possible_actions: GdkDragAction, time_: guint32) gboolean;
pub extern fn gdk_drag_drop(context: ?*GdkDragContext, time_: guint32) void;
pub extern fn gdk_drag_abort(context: ?*GdkDragContext, time_: guint32) void;
pub extern fn gdk_drag_drop_succeeded(context: ?*GdkDragContext) gboolean;
pub extern fn gdk_drag_drop_done(context: ?*GdkDragContext, success: gboolean) void;
pub extern fn gdk_drag_context_get_drag_window(context: ?*GdkDragContext) ?*GdkWindow;
pub extern fn gdk_drag_context_set_hotspot(context: ?*GdkDragContext, hot_x: gint, hot_y: gint) void;
pub extern fn gdk_drag_context_manage_dnd(context: ?*GdkDragContext, ipc_window: ?*GdkWindow, actions: GdkDragAction) gboolean;
pub const struct__GdkDeviceTool = @OpaqueType();
pub const GdkDeviceTool = struct__GdkDeviceTool;
pub const GDK_DEVICE_TOOL_TYPE_UNKNOWN = 0;
pub const GDK_DEVICE_TOOL_TYPE_PEN = 1;
pub const GDK_DEVICE_TOOL_TYPE_ERASER = 2;
pub const GDK_DEVICE_TOOL_TYPE_BRUSH = 3;
pub const GDK_DEVICE_TOOL_TYPE_PENCIL = 4;
pub const GDK_DEVICE_TOOL_TYPE_AIRBRUSH = 5;
pub const GDK_DEVICE_TOOL_TYPE_MOUSE = 6;
pub const GDK_DEVICE_TOOL_TYPE_LENS = 7;
pub const GdkDeviceToolType = extern enum {
    GDK_DEVICE_TOOL_TYPE_UNKNOWN = 0,
    GDK_DEVICE_TOOL_TYPE_PEN = 1,
    GDK_DEVICE_TOOL_TYPE_ERASER = 2,
    GDK_DEVICE_TOOL_TYPE_BRUSH = 3,
    GDK_DEVICE_TOOL_TYPE_PENCIL = 4,
    GDK_DEVICE_TOOL_TYPE_AIRBRUSH = 5,
    GDK_DEVICE_TOOL_TYPE_MOUSE = 6,
    GDK_DEVICE_TOOL_TYPE_LENS = 7,
};
pub extern fn gdk_device_tool_get_type() GType;
pub extern fn gdk_device_tool_get_serial(tool: ?*GdkDeviceTool) guint64;
pub extern fn gdk_device_tool_get_hardware_id(tool: ?*GdkDeviceTool) guint64;
pub extern fn gdk_device_tool_get_tool_type(tool: ?*GdkDeviceTool) GdkDeviceToolType;
pub const GDK_NOTHING = -1;
pub const GDK_DELETE = 0;
pub const GDK_DESTROY = 1;
pub const GDK_EXPOSE = 2;
pub const GDK_MOTION_NOTIFY = 3;
pub const GDK_BUTTON_PRESS = 4;
pub const GDK_2BUTTON_PRESS = 5;
pub const GDK_DOUBLE_BUTTON_PRESS = 5;
pub const GDK_3BUTTON_PRESS = 6;
pub const GDK_TRIPLE_BUTTON_PRESS = 6;
pub const GDK_BUTTON_RELEASE = 7;
pub const GDK_KEY_PRESS = 8;
pub const GDK_KEY_RELEASE = 9;
pub const GDK_ENTER_NOTIFY = 10;
pub const GDK_LEAVE_NOTIFY = 11;
pub const GDK_FOCUS_CHANGE = 12;
pub const GDK_CONFIGURE = 13;
pub const GDK_MAP = 14;
pub const GDK_UNMAP = 15;
pub const GDK_PROPERTY_NOTIFY = 16;
pub const GDK_SELECTION_CLEAR = 17;
pub const GDK_SELECTION_REQUEST = 18;
pub const GDK_SELECTION_NOTIFY = 19;
pub const GDK_PROXIMITY_IN = 20;
pub const GDK_PROXIMITY_OUT = 21;
pub const GDK_DRAG_ENTER = 22;
pub const GDK_DRAG_LEAVE = 23;
pub const GDK_DRAG_MOTION = 24;
pub const GDK_DRAG_STATUS = 25;
pub const GDK_DROP_START = 26;
pub const GDK_DROP_FINISHED = 27;
pub const GDK_CLIENT_EVENT = 28;
pub const GDK_VISIBILITY_NOTIFY = 29;
pub const GDK_SCROLL = 31;
pub const GDK_WINDOW_STATE = 32;
pub const GDK_SETTING = 33;
pub const GDK_OWNER_CHANGE = 34;
pub const GDK_GRAB_BROKEN = 35;
pub const GDK_DAMAGE = 36;
pub const GDK_TOUCH_BEGIN = 37;
pub const GDK_TOUCH_UPDATE = 38;
pub const GDK_TOUCH_END = 39;
pub const GDK_TOUCH_CANCEL = 40;
pub const GDK_TOUCHPAD_SWIPE = 41;
pub const GDK_TOUCHPAD_PINCH = 42;
pub const GDK_PAD_BUTTON_PRESS = 43;
pub const GDK_PAD_BUTTON_RELEASE = 44;
pub const GDK_PAD_RING = 45;
pub const GDK_PAD_STRIP = 46;
pub const GDK_PAD_GROUP_MODE = 47;
pub const GDK_EVENT_LAST = 48;
pub const GdkEventType = extern enum {
    GDK_NOTHING = -1,
    GDK_DELETE = 0,
    GDK_DESTROY = 1,
    GDK_EXPOSE = 2,
    GDK_MOTION_NOTIFY = 3,
    GDK_BUTTON_PRESS = 4,
    GDK_2BUTTON_PRESS = 5,
    GDK_DOUBLE_BUTTON_PRESS = 5,
    GDK_3BUTTON_PRESS = 6,
    GDK_TRIPLE_BUTTON_PRESS = 6,
    GDK_BUTTON_RELEASE = 7,
    GDK_KEY_PRESS = 8,
    GDK_KEY_RELEASE = 9,
    GDK_ENTER_NOTIFY = 10,
    GDK_LEAVE_NOTIFY = 11,
    GDK_FOCUS_CHANGE = 12,
    GDK_CONFIGURE = 13,
    GDK_MAP = 14,
    GDK_UNMAP = 15,
    GDK_PROPERTY_NOTIFY = 16,
    GDK_SELECTION_CLEAR = 17,
    GDK_SELECTION_REQUEST = 18,
    GDK_SELECTION_NOTIFY = 19,
    GDK_PROXIMITY_IN = 20,
    GDK_PROXIMITY_OUT = 21,
    GDK_DRAG_ENTER = 22,
    GDK_DRAG_LEAVE = 23,
    GDK_DRAG_MOTION = 24,
    GDK_DRAG_STATUS = 25,
    GDK_DROP_START = 26,
    GDK_DROP_FINISHED = 27,
    GDK_CLIENT_EVENT = 28,
    GDK_VISIBILITY_NOTIFY = 29,
    GDK_SCROLL = 31,
    GDK_WINDOW_STATE = 32,
    GDK_SETTING = 33,
    GDK_OWNER_CHANGE = 34,
    GDK_GRAB_BROKEN = 35,
    GDK_DAMAGE = 36,
    GDK_TOUCH_BEGIN = 37,
    GDK_TOUCH_UPDATE = 38,
    GDK_TOUCH_END = 39,
    GDK_TOUCH_CANCEL = 40,
    GDK_TOUCHPAD_SWIPE = 41,
    GDK_TOUCHPAD_PINCH = 42,
    GDK_PAD_BUTTON_PRESS = 43,
    GDK_PAD_BUTTON_RELEASE = 44,
    GDK_PAD_RING = 45,
    GDK_PAD_STRIP = 46,
    GDK_PAD_GROUP_MODE = 47,
    GDK_EVENT_LAST = 48,
};
pub const struct__GdkEventAny = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
};
pub const GdkEventAny = struct__GdkEventAny;
pub const struct__GdkEventExpose = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    area: GdkRectangle,
    region: ?*cairo_region_t,
    count: gint,
};
pub const GdkEventExpose = struct__GdkEventExpose;
pub const GDK_VISIBILITY_UNOBSCURED = 0;
pub const GDK_VISIBILITY_PARTIAL = 1;
pub const GDK_VISIBILITY_FULLY_OBSCURED = 2;
pub const GdkVisibilityState = extern enum {
    GDK_VISIBILITY_UNOBSCURED = 0,
    GDK_VISIBILITY_PARTIAL = 1,
    GDK_VISIBILITY_FULLY_OBSCURED = 2,
};
pub const struct__GdkEventVisibility = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    state: GdkVisibilityState,
};
pub const GdkEventVisibility = struct__GdkEventVisibility;
pub const struct__GdkEventMotion = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    time: guint32,
    x: gdouble,
    y: gdouble,
    axes: [*c]gdouble,
    state: guint,
    is_hint: gint16,
    device: ?*GdkDevice,
    x_root: gdouble,
    y_root: gdouble,
};
pub const GdkEventMotion = struct__GdkEventMotion;
pub const struct__GdkEventButton = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    time: guint32,
    x: gdouble,
    y: gdouble,
    axes: [*c]gdouble,
    state: guint,
    button: guint,
    device: ?*GdkDevice,
    x_root: gdouble,
    y_root: gdouble,
};
pub const GdkEventButton = struct__GdkEventButton;
pub const struct__GdkEventSequence = @OpaqueType();
pub const GdkEventSequence = struct__GdkEventSequence;
pub const struct__GdkEventTouch = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    time: guint32,
    x: gdouble,
    y: gdouble,
    axes: [*c]gdouble,
    state: guint,
    sequence: ?*GdkEventSequence,
    emulating_pointer: gboolean,
    device: ?*GdkDevice,
    x_root: gdouble,
    y_root: gdouble,
};
pub const GdkEventTouch = struct__GdkEventTouch;
pub const struct__GdkEventScroll = @OpaqueType();
pub const GdkEventScroll = struct__GdkEventScroll;
pub const struct__GdkEventKey = @OpaqueType();
pub const GdkEventKey = struct__GdkEventKey;
pub const struct__GdkEventFocus = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    in: gint16,
};
pub const GdkEventFocus = struct__GdkEventFocus;
pub const GDK_CROSSING_NORMAL = 0;
pub const GDK_CROSSING_GRAB = 1;
pub const GDK_CROSSING_UNGRAB = 2;
pub const GDK_CROSSING_GTK_GRAB = 3;
pub const GDK_CROSSING_GTK_UNGRAB = 4;
pub const GDK_CROSSING_STATE_CHANGED = 5;
pub const GDK_CROSSING_TOUCH_BEGIN = 6;
pub const GDK_CROSSING_TOUCH_END = 7;
pub const GDK_CROSSING_DEVICE_SWITCH = 8;
pub const GdkCrossingMode = extern enum {
    GDK_CROSSING_NORMAL = 0,
    GDK_CROSSING_GRAB = 1,
    GDK_CROSSING_UNGRAB = 2,
    GDK_CROSSING_GTK_GRAB = 3,
    GDK_CROSSING_GTK_UNGRAB = 4,
    GDK_CROSSING_STATE_CHANGED = 5,
    GDK_CROSSING_TOUCH_BEGIN = 6,
    GDK_CROSSING_TOUCH_END = 7,
    GDK_CROSSING_DEVICE_SWITCH = 8,
};
pub const GDK_NOTIFY_ANCESTOR = 0;
pub const GDK_NOTIFY_VIRTUAL = 1;
pub const GDK_NOTIFY_INFERIOR = 2;
pub const GDK_NOTIFY_NONLINEAR = 3;
pub const GDK_NOTIFY_NONLINEAR_VIRTUAL = 4;
pub const GDK_NOTIFY_UNKNOWN = 5;
pub const GdkNotifyType = extern enum {
    GDK_NOTIFY_ANCESTOR = 0,
    GDK_NOTIFY_VIRTUAL = 1,
    GDK_NOTIFY_INFERIOR = 2,
    GDK_NOTIFY_NONLINEAR = 3,
    GDK_NOTIFY_NONLINEAR_VIRTUAL = 4,
    GDK_NOTIFY_UNKNOWN = 5,
};
pub const struct__GdkEventCrossing = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    subwindow: ?*GdkWindow,
    time: guint32,
    x: gdouble,
    y: gdouble,
    x_root: gdouble,
    y_root: gdouble,
    mode: GdkCrossingMode,
    detail: GdkNotifyType,
    focus: gboolean,
    state: guint,
};
pub const GdkEventCrossing = struct__GdkEventCrossing;
pub const struct__GdkEventConfigure = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    x: gint,
    y: gint,
    width: gint,
    height: gint,
};
pub const GdkEventConfigure = struct__GdkEventConfigure;
pub const struct__GdkEventProperty = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    atom: GdkAtom,
    time: guint32,
    state: guint,
};
pub const GdkEventProperty = struct__GdkEventProperty;
pub const struct__GdkEventSelection = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    selection: GdkAtom,
    target: GdkAtom,
    property: GdkAtom,
    time: guint32,
    requestor: ?*GdkWindow,
};
pub const GdkEventSelection = struct__GdkEventSelection;
pub const GDK_OWNER_CHANGE_NEW_OWNER = 0;
pub const GDK_OWNER_CHANGE_DESTROY = 1;
pub const GDK_OWNER_CHANGE_CLOSE = 2;
pub const GdkOwnerChange = extern enum {
    GDK_OWNER_CHANGE_NEW_OWNER = 0,
    GDK_OWNER_CHANGE_DESTROY = 1,
    GDK_OWNER_CHANGE_CLOSE = 2,
};
pub const struct__GdkEventOwnerChange = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    owner: ?*GdkWindow,
    reason: GdkOwnerChange,
    selection: GdkAtom,
    time: guint32,
    selection_time: guint32,
};
pub const GdkEventOwnerChange = struct__GdkEventOwnerChange;
pub const struct__GdkEventProximity = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    time: guint32,
    device: ?*GdkDevice,
};
pub const GdkEventProximity = struct__GdkEventProximity;
pub const struct__GdkEventDND = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    context: ?*GdkDragContext,
    time: guint32,
    x_root: gshort,
    y_root: gshort,
};
pub const GdkEventDND = struct__GdkEventDND;
pub const GDK_WINDOW_STATE_WITHDRAWN = 1;
pub const GDK_WINDOW_STATE_ICONIFIED = 2;
pub const GDK_WINDOW_STATE_MAXIMIZED = 4;
pub const GDK_WINDOW_STATE_STICKY = 8;
pub const GDK_WINDOW_STATE_FULLSCREEN = 16;
pub const GDK_WINDOW_STATE_ABOVE = 32;
pub const GDK_WINDOW_STATE_BELOW = 64;
pub const GDK_WINDOW_STATE_FOCUSED = 128;
pub const GDK_WINDOW_STATE_TILED = 256;
pub const GDK_WINDOW_STATE_TOP_TILED = 512;
pub const GDK_WINDOW_STATE_TOP_RESIZABLE = 1024;
pub const GDK_WINDOW_STATE_RIGHT_TILED = 2048;
pub const GDK_WINDOW_STATE_RIGHT_RESIZABLE = 4096;
pub const GDK_WINDOW_STATE_BOTTOM_TILED = 8192;
pub const GDK_WINDOW_STATE_BOTTOM_RESIZABLE = 16384;
pub const GDK_WINDOW_STATE_LEFT_TILED = 32768;
pub const GDK_WINDOW_STATE_LEFT_RESIZABLE = 65536;
pub const GdkWindowState = extern enum {
    GDK_WINDOW_STATE_WITHDRAWN = 1,
    GDK_WINDOW_STATE_ICONIFIED = 2,
    GDK_WINDOW_STATE_MAXIMIZED = 4,
    GDK_WINDOW_STATE_STICKY = 8,
    GDK_WINDOW_STATE_FULLSCREEN = 16,
    GDK_WINDOW_STATE_ABOVE = 32,
    GDK_WINDOW_STATE_BELOW = 64,
    GDK_WINDOW_STATE_FOCUSED = 128,
    GDK_WINDOW_STATE_TILED = 256,
    GDK_WINDOW_STATE_TOP_TILED = 512,
    GDK_WINDOW_STATE_TOP_RESIZABLE = 1024,
    GDK_WINDOW_STATE_RIGHT_TILED = 2048,
    GDK_WINDOW_STATE_RIGHT_RESIZABLE = 4096,
    GDK_WINDOW_STATE_BOTTOM_TILED = 8192,
    GDK_WINDOW_STATE_BOTTOM_RESIZABLE = 16384,
    GDK_WINDOW_STATE_LEFT_TILED = 32768,
    GDK_WINDOW_STATE_LEFT_RESIZABLE = 65536,
};
pub const struct__GdkEventWindowState = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    changed_mask: GdkWindowState,
    new_window_state: GdkWindowState,
};
pub const GdkEventWindowState = struct__GdkEventWindowState;
pub const GDK_SETTING_ACTION_NEW = 0;
pub const GDK_SETTING_ACTION_CHANGED = 1;
pub const GDK_SETTING_ACTION_DELETED = 2;
pub const GdkSettingAction = extern enum {
    GDK_SETTING_ACTION_NEW = 0,
    GDK_SETTING_ACTION_CHANGED = 1,
    GDK_SETTING_ACTION_DELETED = 2,
};
pub const struct__GdkEventSetting = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    action: GdkSettingAction,
    name: [*c]u8,
};
pub const GdkEventSetting = struct__GdkEventSetting;
pub const struct__GdkEventGrabBroken = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    keyboard: gboolean,
    implicit: gboolean,
    grab_window: ?*GdkWindow,
};
pub const GdkEventGrabBroken = struct__GdkEventGrabBroken;
pub const struct__GdkEventTouchpadSwipe = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    phase: gint8,
    n_fingers: gint8,
    time: guint32,
    x: gdouble,
    y: gdouble,
    dx: gdouble,
    dy: gdouble,
    x_root: gdouble,
    y_root: gdouble,
    state: guint,
};
pub const GdkEventTouchpadSwipe = struct__GdkEventTouchpadSwipe;
pub const struct__GdkEventTouchpadPinch = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    phase: gint8,
    n_fingers: gint8,
    time: guint32,
    x: gdouble,
    y: gdouble,
    dx: gdouble,
    dy: gdouble,
    angle_delta: gdouble,
    scale: gdouble,
    x_root: gdouble,
    y_root: gdouble,
    state: guint,
};
pub const GdkEventTouchpadPinch = struct__GdkEventTouchpadPinch;
pub const struct__GdkEventPadButton = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    time: guint32,
    group: guint,
    button: guint,
    mode: guint,
};
pub const GdkEventPadButton = struct__GdkEventPadButton;
pub const struct__GdkEventPadAxis = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    time: guint32,
    group: guint,
    index: guint,
    mode: guint,
    value: gdouble,
};
pub const GdkEventPadAxis = struct__GdkEventPadAxis;
pub const struct__GdkEventPadGroupMode = extern struct {
    type: GdkEventType,
    window: ?*GdkWindow,
    send_event: gint8,
    time: guint32,
    group: guint,
    mode: guint,
};
pub const GdkEventPadGroupMode = struct__GdkEventPadGroupMode;
pub const union__GdkEvent = extern union {
    type: GdkEventType,
    any: GdkEventAny,
    expose: GdkEventExpose,
    visibility: GdkEventVisibility,
    motion: GdkEventMotion,
    button: GdkEventButton,
    touch: GdkEventTouch,
    scroll: GdkEventScroll,
    key: GdkEventKey,
    crossing: GdkEventCrossing,
    focus_change: GdkEventFocus,
    configure: GdkEventConfigure,
    property: GdkEventProperty,
    selection: GdkEventSelection,
    owner_change: GdkEventOwnerChange,
    proximity: GdkEventProximity,
    dnd: GdkEventDND,
    window_state: GdkEventWindowState,
    setting: GdkEventSetting,
    grab_broken: GdkEventGrabBroken,
    touchpad_swipe: GdkEventTouchpadSwipe,
    touchpad_pinch: GdkEventTouchpadPinch,
    pad_button: GdkEventPadButton,
    pad_axis: GdkEventPadAxis,
    pad_group_mode: GdkEventPadGroupMode,
};
pub const GdkEvent = union__GdkEvent;
pub const GdkEventFunc = ?extern fn ([*c]GdkEvent, gpointer) void;
pub const GdkXEvent = c_void;
pub const GDK_FILTER_CONTINUE = 0;
pub const GDK_FILTER_TRANSLATE = 1;
pub const GDK_FILTER_REMOVE = 2;
pub const GdkFilterReturn = extern enum {
    GDK_FILTER_CONTINUE = 0,
    GDK_FILTER_TRANSLATE = 1,
    GDK_FILTER_REMOVE = 2,
};
pub const GdkFilterFunc = ?extern fn (?*GdkXEvent, [*c]GdkEvent, gpointer) GdkFilterReturn;
pub const GDK_TOUCHPAD_GESTURE_PHASE_BEGIN = 0;
pub const GDK_TOUCHPAD_GESTURE_PHASE_UPDATE = 1;
pub const GDK_TOUCHPAD_GESTURE_PHASE_END = 2;
pub const GDK_TOUCHPAD_GESTURE_PHASE_CANCEL = 3;
pub const GdkTouchpadGesturePhase = extern enum {
    GDK_TOUCHPAD_GESTURE_PHASE_BEGIN = 0,
    GDK_TOUCHPAD_GESTURE_PHASE_UPDATE = 1,
    GDK_TOUCHPAD_GESTURE_PHASE_END = 2,
    GDK_TOUCHPAD_GESTURE_PHASE_CANCEL = 3,
};
pub const GDK_SCROLL_UP = 0;
pub const GDK_SCROLL_DOWN = 1;
pub const GDK_SCROLL_LEFT = 2;
pub const GDK_SCROLL_RIGHT = 3;
pub const GDK_SCROLL_SMOOTH = 4;
pub const GdkScrollDirection = extern enum {
    GDK_SCROLL_UP = 0,
    GDK_SCROLL_DOWN = 1,
    GDK_SCROLL_LEFT = 2,
    GDK_SCROLL_RIGHT = 3,
    GDK_SCROLL_SMOOTH = 4,
};
pub const GDK_PROPERTY_NEW_VALUE = 0;
pub const GDK_PROPERTY_DELETE = 1;
pub const GdkPropertyState = extern enum {
    GDK_PROPERTY_NEW_VALUE = 0,
    GDK_PROPERTY_DELETE = 1,
};
pub extern fn gdk_event_get_type() GType;
pub extern fn gdk_event_sequence_get_type() GType;
pub extern fn gdk_events_pending() gboolean;
pub extern fn gdk_event_get() [*c]GdkEvent;
pub extern fn gdk_event_peek() [*c]GdkEvent;
pub extern fn gdk_event_put(event: [*c]const GdkEvent) void;
pub extern fn gdk_event_new(type_0: GdkEventType) [*c]GdkEvent;
pub extern fn gdk_event_copy(event: [*c]const GdkEvent) [*c]GdkEvent;
pub extern fn gdk_event_free(event: [*c]GdkEvent) void;
pub extern fn gdk_event_get_window(event: [*c]const GdkEvent) ?*GdkWindow;
pub extern fn gdk_event_get_time(event: [*c]const GdkEvent) guint32;
pub extern fn gdk_event_get_state(event: [*c]const GdkEvent, state: [*c]GdkModifierType) gboolean;
pub extern fn gdk_event_get_coords(event: [*c]const GdkEvent, x_win: [*c]gdouble, y_win: [*c]gdouble) gboolean;
pub extern fn gdk_event_get_root_coords(event: [*c]const GdkEvent, x_root: [*c]gdouble, y_root: [*c]gdouble) gboolean;
pub extern fn gdk_event_get_button(event: [*c]const GdkEvent, button: [*c]guint) gboolean;
pub extern fn gdk_event_get_click_count(event: [*c]const GdkEvent, click_count: [*c]guint) gboolean;
pub extern fn gdk_event_get_keyval(event: [*c]const GdkEvent, keyval: [*c]guint) gboolean;
pub extern fn gdk_event_get_keycode(event: [*c]const GdkEvent, keycode: [*c]guint16) gboolean;
pub extern fn gdk_event_get_scroll_direction(event: [*c]const GdkEvent, direction: [*c]GdkScrollDirection) gboolean;
pub extern fn gdk_event_get_scroll_deltas(event: [*c]const GdkEvent, delta_x: [*c]gdouble, delta_y: [*c]gdouble) gboolean;
pub extern fn gdk_event_is_scroll_stop_event(event: [*c]const GdkEvent) gboolean;
pub extern fn gdk_event_get_axis(event: [*c]const GdkEvent, axis_use: GdkAxisUse, value: [*c]gdouble) gboolean;
pub extern fn gdk_event_set_device(event: [*c]GdkEvent, device: ?*GdkDevice) void;
pub extern fn gdk_event_get_device(event: [*c]const GdkEvent) ?*GdkDevice;
pub extern fn gdk_event_set_source_device(event: [*c]GdkEvent, device: ?*GdkDevice) void;
pub extern fn gdk_event_get_source_device(event: [*c]const GdkEvent) ?*GdkDevice;
pub extern fn gdk_event_request_motions(event: [*c]const GdkEventMotion) void;
pub extern fn gdk_event_triggers_context_menu(event: [*c]const GdkEvent) gboolean;
pub extern fn gdk_events_get_distance(event1: [*c]GdkEvent, event2: [*c]GdkEvent, distance: [*c]gdouble) gboolean;
pub extern fn gdk_events_get_angle(event1: [*c]GdkEvent, event2: [*c]GdkEvent, angle: [*c]gdouble) gboolean;
pub extern fn gdk_events_get_center(event1: [*c]GdkEvent, event2: [*c]GdkEvent, x: [*c]gdouble, y: [*c]gdouble) gboolean;
pub extern fn gdk_event_handler_set(func: GdkEventFunc, data: gpointer, notify: GDestroyNotify) void;
pub extern fn gdk_event_set_screen(event: [*c]GdkEvent, screen: ?*GdkScreen) void;
pub extern fn gdk_event_get_screen(event: [*c]const GdkEvent) ?*GdkScreen;
pub extern fn gdk_event_get_event_sequence(event: [*c]const GdkEvent) ?*GdkEventSequence;
pub extern fn gdk_event_get_event_type(event: [*c]const GdkEvent) GdkEventType;
pub extern fn gdk_event_get_seat(event: [*c]const GdkEvent) [*c]GdkSeat;
pub extern fn gdk_set_show_events(show_events: gboolean) void;
pub extern fn gdk_get_show_events() gboolean;
pub extern fn gdk_setting_get(name: [*c]const gchar, value: [*c]GValue) gboolean;
pub extern fn gdk_event_get_device_tool(event: [*c]const GdkEvent) ?*GdkDeviceTool;
pub extern fn gdk_event_set_device_tool(event: [*c]GdkEvent, tool: ?*GdkDeviceTool) void;
pub extern fn gdk_event_get_scancode(event: [*c]GdkEvent) c_int;
pub extern fn gdk_event_get_pointer_emulated(event: [*c]GdkEvent) gboolean;
pub extern fn gdk_device_manager_get_type() GType;
pub extern fn gdk_device_manager_get_display(device_manager: ?*GdkDeviceManager) ?*GdkDisplay;
pub extern fn gdk_device_manager_list_devices(device_manager: ?*GdkDeviceManager, type_0: GdkDeviceType) [*c]GList;
pub extern fn gdk_device_manager_get_client_pointer(device_manager: ?*GdkDeviceManager) ?*GdkDevice;
pub const struct__GdkDrawingContext = @OpaqueType();
pub const GdkDrawingContext = struct__GdkDrawingContext;
pub const struct__GdkDrawingContextClass = @OpaqueType();
pub const GdkDrawingContextClass = struct__GdkDrawingContextClass;
pub extern fn gdk_drawing_context_get_type() GType;
pub extern fn gdk_drawing_context_get_window(context: ?*GdkDrawingContext) ?*GdkWindow;
pub extern fn gdk_drawing_context_get_clip(context: ?*GdkDrawingContext) ?*cairo_region_t;
pub extern fn gdk_drawing_context_is_valid(context: ?*GdkDrawingContext) gboolean;
pub extern fn gdk_drawing_context_get_cairo_context(context: ?*GdkDrawingContext) ?*cairo_t;
pub const struct__GdkFrameTimings = @OpaqueType();
pub const GdkFrameTimings = struct__GdkFrameTimings;
pub extern fn gdk_frame_timings_get_type() GType;
pub extern fn gdk_frame_timings_ref(timings: ?*GdkFrameTimings) ?*GdkFrameTimings;
pub extern fn gdk_frame_timings_unref(timings: ?*GdkFrameTimings) void;
pub extern fn gdk_frame_timings_get_frame_counter(timings: ?*GdkFrameTimings) gint64;
pub extern fn gdk_frame_timings_get_complete(timings: ?*GdkFrameTimings) gboolean;
pub extern fn gdk_frame_timings_get_frame_time(timings: ?*GdkFrameTimings) gint64;
pub extern fn gdk_frame_timings_get_presentation_time(timings: ?*GdkFrameTimings) gint64;
pub extern fn gdk_frame_timings_get_refresh_interval(timings: ?*GdkFrameTimings) gint64;
pub extern fn gdk_frame_timings_get_predicted_presentation_time(timings: ?*GdkFrameTimings) gint64;
pub const struct__GdkFrameClock = @OpaqueType();
pub const GdkFrameClock = struct__GdkFrameClock;
pub const struct__GdkFrameClockPrivate = @OpaqueType();
pub const GdkFrameClockPrivate = struct__GdkFrameClockPrivate;
pub const struct__GdkFrameClockClass = @OpaqueType();
pub const GdkFrameClockClass = struct__GdkFrameClockClass;
pub const GDK_FRAME_CLOCK_PHASE_NONE = 0;
pub const GDK_FRAME_CLOCK_PHASE_FLUSH_EVENTS = 1;
pub const GDK_FRAME_CLOCK_PHASE_BEFORE_PAINT = 2;
pub const GDK_FRAME_CLOCK_PHASE_UPDATE = 4;
pub const GDK_FRAME_CLOCK_PHASE_LAYOUT = 8;
pub const GDK_FRAME_CLOCK_PHASE_PAINT = 16;
pub const GDK_FRAME_CLOCK_PHASE_RESUME_EVENTS = 32;
pub const GDK_FRAME_CLOCK_PHASE_AFTER_PAINT = 64;
pub const GdkFrameClockPhase = extern enum {
    GDK_FRAME_CLOCK_PHASE_NONE = 0,
    GDK_FRAME_CLOCK_PHASE_FLUSH_EVENTS = 1,
    GDK_FRAME_CLOCK_PHASE_BEFORE_PAINT = 2,
    GDK_FRAME_CLOCK_PHASE_UPDATE = 4,
    GDK_FRAME_CLOCK_PHASE_LAYOUT = 8,
    GDK_FRAME_CLOCK_PHASE_PAINT = 16,
    GDK_FRAME_CLOCK_PHASE_RESUME_EVENTS = 32,
    GDK_FRAME_CLOCK_PHASE_AFTER_PAINT = 64,
};
pub extern fn gdk_frame_clock_get_type() GType;
pub extern fn gdk_frame_clock_get_frame_time(frame_clock: ?*GdkFrameClock) gint64;
pub extern fn gdk_frame_clock_request_phase(frame_clock: ?*GdkFrameClock, phase: GdkFrameClockPhase) void;
pub extern fn gdk_frame_clock_begin_updating(frame_clock: ?*GdkFrameClock) void;
pub extern fn gdk_frame_clock_end_updating(frame_clock: ?*GdkFrameClock) void;
pub extern fn gdk_frame_clock_get_frame_counter(frame_clock: ?*GdkFrameClock) gint64;
pub extern fn gdk_frame_clock_get_history_start(frame_clock: ?*GdkFrameClock) gint64;
pub extern fn gdk_frame_clock_get_timings(frame_clock: ?*GdkFrameClock, frame_counter: gint64) ?*GdkFrameTimings;
pub extern fn gdk_frame_clock_get_current_timings(frame_clock: ?*GdkFrameClock) ?*GdkFrameTimings;
pub extern fn gdk_frame_clock_get_refresh_info(frame_clock: ?*GdkFrameClock, base_time: gint64, refresh_interval_return: [*c]gint64, presentation_time_return: [*c]gint64) void;
pub const GDK_GRAVITY_NORTH_WEST = 1;
pub const GDK_GRAVITY_NORTH = 2;
pub const GDK_GRAVITY_NORTH_EAST = 3;
pub const GDK_GRAVITY_WEST = 4;
pub const GDK_GRAVITY_CENTER = 5;
pub const GDK_GRAVITY_EAST = 6;
pub const GDK_GRAVITY_SOUTH_WEST = 7;
pub const GDK_GRAVITY_SOUTH = 8;
pub const GDK_GRAVITY_SOUTH_EAST = 9;
pub const GDK_GRAVITY_STATIC = 10;
pub const GdkGravity = extern enum {
    GDK_GRAVITY_NORTH_WEST = 1,
    GDK_GRAVITY_NORTH = 2,
    GDK_GRAVITY_NORTH_EAST = 3,
    GDK_GRAVITY_WEST = 4,
    GDK_GRAVITY_CENTER = 5,
    GDK_GRAVITY_EAST = 6,
    GDK_GRAVITY_SOUTH_WEST = 7,
    GDK_GRAVITY_SOUTH = 8,
    GDK_GRAVITY_SOUTH_EAST = 9,
    GDK_GRAVITY_STATIC = 10,
};
pub const struct__GdkGeometry = extern struct {
    min_width: gint,
    min_height: gint,
    max_width: gint,
    max_height: gint,
    base_width: gint,
    base_height: gint,
    width_inc: gint,
    height_inc: gint,
    min_aspect: gdouble,
    max_aspect: gdouble,
    win_gravity: GdkGravity,
};
pub const GdkGeometry = struct__GdkGeometry;
pub const GDK_INPUT_OUTPUT = 0;
pub const GDK_INPUT_ONLY = 1;
pub const GdkWindowWindowClass = extern enum {
    GDK_INPUT_OUTPUT = 0,
    GDK_INPUT_ONLY = 1,
};
pub const GDK_WINDOW_ROOT = 0;
pub const GDK_WINDOW_TOPLEVEL = 1;
pub const GDK_WINDOW_CHILD = 2;
pub const GDK_WINDOW_TEMP = 3;
pub const GDK_WINDOW_FOREIGN = 4;
pub const GDK_WINDOW_OFFSCREEN = 5;
pub const GDK_WINDOW_SUBSURFACE = 6;
pub const GdkWindowType = extern enum {
    GDK_WINDOW_ROOT = 0,
    GDK_WINDOW_TOPLEVEL = 1,
    GDK_WINDOW_CHILD = 2,
    GDK_WINDOW_TEMP = 3,
    GDK_WINDOW_FOREIGN = 4,
    GDK_WINDOW_OFFSCREEN = 5,
    GDK_WINDOW_SUBSURFACE = 6,
};
pub const struct__GdkWindowAttr = extern struct {
    title: [*c]gchar,
    event_mask: gint,
    x: gint,
    y: gint,
    width: gint,
    height: gint,
    wclass: GdkWindowWindowClass,
    visual: ?*GdkVisual,
    window_type: GdkWindowType,
    cursor: ?*GdkCursor,
    wmclass_name: [*c]gchar,
    wmclass_class: [*c]gchar,
    override_redirect: gboolean,
    type_hint: GdkWindowTypeHint,
};
pub const GdkWindowAttr = struct__GdkWindowAttr;
pub const struct__GdkWindowRedirect = @OpaqueType();
pub const GdkWindowRedirect = struct__GdkWindowRedirect;
pub const GDK_WA_TITLE = 2;
pub const GDK_WA_X = 4;
pub const GDK_WA_Y = 8;
pub const GDK_WA_CURSOR = 16;
pub const GDK_WA_VISUAL = 32;
pub const GDK_WA_WMCLASS = 64;
pub const GDK_WA_NOREDIR = 128;
pub const GDK_WA_TYPE_HINT = 256;
pub const GdkWindowAttributesType = extern enum {
    GDK_WA_TITLE = 2,
    GDK_WA_X = 4,
    GDK_WA_Y = 8,
    GDK_WA_CURSOR = 16,
    GDK_WA_VISUAL = 32,
    GDK_WA_WMCLASS = 64,
    GDK_WA_NOREDIR = 128,
    GDK_WA_TYPE_HINT = 256,
};
pub const GDK_HINT_POS = 1;
pub const GDK_HINT_MIN_SIZE = 2;
pub const GDK_HINT_MAX_SIZE = 4;
pub const GDK_HINT_BASE_SIZE = 8;
pub const GDK_HINT_ASPECT = 16;
pub const GDK_HINT_RESIZE_INC = 32;
pub const GDK_HINT_WIN_GRAVITY = 64;
pub const GDK_HINT_USER_POS = 128;
pub const GDK_HINT_USER_SIZE = 256;
pub const GdkWindowHints = extern enum {
    GDK_HINT_POS = 1,
    GDK_HINT_MIN_SIZE = 2,
    GDK_HINT_MAX_SIZE = 4,
    GDK_HINT_BASE_SIZE = 8,
    GDK_HINT_ASPECT = 16,
    GDK_HINT_RESIZE_INC = 32,
    GDK_HINT_WIN_GRAVITY = 64,
    GDK_HINT_USER_POS = 128,
    GDK_HINT_USER_SIZE = 256,
};
pub const GDK_DECOR_ALL = 1;
pub const GDK_DECOR_BORDER = 2;
pub const GDK_DECOR_RESIZEH = 4;
pub const GDK_DECOR_TITLE = 8;
pub const GDK_DECOR_MENU = 16;
pub const GDK_DECOR_MINIMIZE = 32;
pub const GDK_DECOR_MAXIMIZE = 64;
pub const GdkWMDecoration = extern enum {
    GDK_DECOR_ALL = 1,
    GDK_DECOR_BORDER = 2,
    GDK_DECOR_RESIZEH = 4,
    GDK_DECOR_TITLE = 8,
    GDK_DECOR_MENU = 16,
    GDK_DECOR_MINIMIZE = 32,
    GDK_DECOR_MAXIMIZE = 64,
};
pub const GDK_FUNC_ALL = 1;
pub const GDK_FUNC_RESIZE = 2;
pub const GDK_FUNC_MOVE = 4;
pub const GDK_FUNC_MINIMIZE = 8;
pub const GDK_FUNC_MAXIMIZE = 16;
pub const GDK_FUNC_CLOSE = 32;
pub const GdkWMFunction = extern enum {
    GDK_FUNC_ALL = 1,
    GDK_FUNC_RESIZE = 2,
    GDK_FUNC_MOVE = 4,
    GDK_FUNC_MINIMIZE = 8,
    GDK_FUNC_MAXIMIZE = 16,
    GDK_FUNC_CLOSE = 32,
};
pub const GDK_ANCHOR_FLIP_X = 1;
pub const GDK_ANCHOR_FLIP_Y = 2;
pub const GDK_ANCHOR_SLIDE_X = 4;
pub const GDK_ANCHOR_SLIDE_Y = 8;
pub const GDK_ANCHOR_RESIZE_X = 16;
pub const GDK_ANCHOR_RESIZE_Y = 32;
pub const GDK_ANCHOR_FLIP = 3;
pub const GDK_ANCHOR_SLIDE = 12;
pub const GDK_ANCHOR_RESIZE = 48;
pub const GdkAnchorHints = extern enum {
    GDK_ANCHOR_FLIP_X = 1,
    GDK_ANCHOR_FLIP_Y = 2,
    GDK_ANCHOR_SLIDE_X = 4,
    GDK_ANCHOR_SLIDE_Y = 8,
    GDK_ANCHOR_RESIZE_X = 16,
    GDK_ANCHOR_RESIZE_Y = 32,
    GDK_ANCHOR_FLIP = 3,
    GDK_ANCHOR_SLIDE = 12,
    GDK_ANCHOR_RESIZE = 48,
};
pub const GDK_WINDOW_EDGE_NORTH_WEST = 0;
pub const GDK_WINDOW_EDGE_NORTH = 1;
pub const GDK_WINDOW_EDGE_NORTH_EAST = 2;
pub const GDK_WINDOW_EDGE_WEST = 3;
pub const GDK_WINDOW_EDGE_EAST = 4;
pub const GDK_WINDOW_EDGE_SOUTH_WEST = 5;
pub const GDK_WINDOW_EDGE_SOUTH = 6;
pub const GDK_WINDOW_EDGE_SOUTH_EAST = 7;
pub const GdkWindowEdge = extern enum {
    GDK_WINDOW_EDGE_NORTH_WEST = 0,
    GDK_WINDOW_EDGE_NORTH = 1,
    GDK_WINDOW_EDGE_NORTH_EAST = 2,
    GDK_WINDOW_EDGE_WEST = 3,
    GDK_WINDOW_EDGE_EAST = 4,
    GDK_WINDOW_EDGE_SOUTH_WEST = 5,
    GDK_WINDOW_EDGE_SOUTH = 6,
    GDK_WINDOW_EDGE_SOUTH_EAST = 7,
};
pub const GDK_FULLSCREEN_ON_CURRENT_MONITOR = 0;
pub const GDK_FULLSCREEN_ON_ALL_MONITORS = 1;
pub const GdkFullscreenMode = extern enum {
    GDK_FULLSCREEN_ON_CURRENT_MONITOR = 0,
    GDK_FULLSCREEN_ON_ALL_MONITORS = 1,
};
pub const struct__GdkWindowClass = extern struct {
    parent_class: GObjectClass,
    pick_embedded_child: ?extern fn (?*GdkWindow, gdouble, gdouble) ?*GdkWindow,
    to_embedder: ?extern fn (?*GdkWindow, gdouble, gdouble, [*c]gdouble, [*c]gdouble) void,
    from_embedder: ?extern fn (?*GdkWindow, gdouble, gdouble, [*c]gdouble, [*c]gdouble) void,
    create_surface: ?extern fn (?*GdkWindow, gint, gint) ?*cairo_surface_t,
    _gdk_reserved1: ?extern fn () void,
    _gdk_reserved2: ?extern fn () void,
    _gdk_reserved3: ?extern fn () void,
    _gdk_reserved4: ?extern fn () void,
    _gdk_reserved5: ?extern fn () void,
    _gdk_reserved6: ?extern fn () void,
    _gdk_reserved7: ?extern fn () void,
    _gdk_reserved8: ?extern fn () void,
};
pub const GdkWindowClass = struct__GdkWindowClass;
pub extern fn gdk_window_get_type() GType;
pub extern fn gdk_window_new(parent: ?*GdkWindow, attributes: [*c]GdkWindowAttr, attributes_mask: gint) ?*GdkWindow;
pub extern fn gdk_window_destroy(window: ?*GdkWindow) void;
pub extern fn gdk_window_get_window_type(window: ?*GdkWindow) GdkWindowType;
pub extern fn gdk_window_is_destroyed(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_get_visual(window: ?*GdkWindow) ?*GdkVisual;
pub extern fn gdk_window_get_screen(window: ?*GdkWindow) ?*GdkScreen;
pub extern fn gdk_window_get_display(window: ?*GdkWindow) ?*GdkDisplay;
pub extern fn gdk_window_at_pointer(win_x: [*c]gint, win_y: [*c]gint) ?*GdkWindow;
pub extern fn gdk_window_show(window: ?*GdkWindow) void;
pub extern fn gdk_window_hide(window: ?*GdkWindow) void;
pub extern fn gdk_window_withdraw(window: ?*GdkWindow) void;
pub extern fn gdk_window_show_unraised(window: ?*GdkWindow) void;
pub extern fn gdk_window_move(window: ?*GdkWindow, x: gint, y: gint) void;
pub extern fn gdk_window_resize(window: ?*GdkWindow, width: gint, height: gint) void;
pub extern fn gdk_window_move_resize(window: ?*GdkWindow, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gdk_window_move_to_rect(window: ?*GdkWindow, rect: [*c]const GdkRectangle, rect_anchor: GdkGravity, window_anchor: GdkGravity, anchor_hints: GdkAnchorHints, rect_anchor_dx: gint, rect_anchor_dy: gint) void;
pub extern fn gdk_window_reparent(window: ?*GdkWindow, new_parent: ?*GdkWindow, x: gint, y: gint) void;
pub extern fn gdk_window_raise(window: ?*GdkWindow) void;
pub extern fn gdk_window_lower(window: ?*GdkWindow) void;
pub extern fn gdk_window_restack(window: ?*GdkWindow, sibling: ?*GdkWindow, above: gboolean) void;
pub extern fn gdk_window_focus(window: ?*GdkWindow, timestamp: guint32) void;
pub extern fn gdk_window_set_user_data(window: ?*GdkWindow, user_data: gpointer) void;
pub extern fn gdk_window_set_override_redirect(window: ?*GdkWindow, override_redirect: gboolean) void;
pub extern fn gdk_window_get_accept_focus(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_set_accept_focus(window: ?*GdkWindow, accept_focus: gboolean) void;
pub extern fn gdk_window_get_focus_on_map(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_set_focus_on_map(window: ?*GdkWindow, focus_on_map: gboolean) void;
pub extern fn gdk_window_add_filter(window: ?*GdkWindow, function: GdkFilterFunc, data: gpointer) void;
pub extern fn gdk_window_remove_filter(window: ?*GdkWindow, function: GdkFilterFunc, data: gpointer) void;
pub extern fn gdk_window_scroll(window: ?*GdkWindow, dx: gint, dy: gint) void;
pub extern fn gdk_window_move_region(window: ?*GdkWindow, region: ?*const cairo_region_t, dx: gint, dy: gint) void;
pub extern fn gdk_window_ensure_native(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_shape_combine_region(window: ?*GdkWindow, shape_region: ?*const cairo_region_t, offset_x: gint, offset_y: gint) void;
pub extern fn gdk_window_set_child_shapes(window: ?*GdkWindow) void;
pub extern fn gdk_window_get_composited(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_set_composited(window: ?*GdkWindow, composited: gboolean) void;
pub extern fn gdk_window_merge_child_shapes(window: ?*GdkWindow) void;
pub extern fn gdk_window_input_shape_combine_region(window: ?*GdkWindow, shape_region: ?*const cairo_region_t, offset_x: gint, offset_y: gint) void;
pub extern fn gdk_window_set_child_input_shapes(window: ?*GdkWindow) void;
pub extern fn gdk_window_merge_child_input_shapes(window: ?*GdkWindow) void;
pub extern fn gdk_window_set_pass_through(window: ?*GdkWindow, pass_through: gboolean) void;
pub extern fn gdk_window_get_pass_through(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_is_visible(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_is_viewable(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_is_input_only(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_is_shaped(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_get_state(window: ?*GdkWindow) GdkWindowState;
pub extern fn gdk_window_set_static_gravities(window: ?*GdkWindow, use_static: gboolean) gboolean;
pub const GdkWindowInvalidateHandlerFunc = ?extern fn (?*GdkWindow, ?*cairo_region_t) void;
pub extern fn gdk_window_set_invalidate_handler(window: ?*GdkWindow, handler: GdkWindowInvalidateHandlerFunc) void;
pub extern fn gdk_window_has_native(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_set_type_hint(window: ?*GdkWindow, hint: GdkWindowTypeHint) void;
pub extern fn gdk_window_get_type_hint(window: ?*GdkWindow) GdkWindowTypeHint;
pub extern fn gdk_window_get_modal_hint(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_set_modal_hint(window: ?*GdkWindow, modal: gboolean) void;
pub extern fn gdk_window_set_skip_taskbar_hint(window: ?*GdkWindow, skips_taskbar: gboolean) void;
pub extern fn gdk_window_set_skip_pager_hint(window: ?*GdkWindow, skips_pager: gboolean) void;
pub extern fn gdk_window_set_urgency_hint(window: ?*GdkWindow, urgent: gboolean) void;
pub extern fn gdk_window_set_geometry_hints(window: ?*GdkWindow, geometry: [*c]const GdkGeometry, geom_mask: GdkWindowHints) void;
pub extern fn gdk_window_get_clip_region(window: ?*GdkWindow) ?*cairo_region_t;
pub extern fn gdk_window_get_visible_region(window: ?*GdkWindow) ?*cairo_region_t;
pub extern fn gdk_window_begin_paint_rect(window: ?*GdkWindow, rectangle: [*c]const GdkRectangle) void;
pub extern fn gdk_window_mark_paint_from_clip(window: ?*GdkWindow, cr: ?*cairo_t) void;
pub extern fn gdk_window_begin_paint_region(window: ?*GdkWindow, region: ?*const cairo_region_t) void;
pub extern fn gdk_window_end_paint(window: ?*GdkWindow) void;
pub extern fn gdk_window_begin_draw_frame(window: ?*GdkWindow, region: ?*const cairo_region_t) ?*GdkDrawingContext;
pub extern fn gdk_window_end_draw_frame(window: ?*GdkWindow, context: ?*GdkDrawingContext) void;
pub extern fn gdk_window_flush(window: ?*GdkWindow) void;
pub extern fn gdk_window_set_title(window: ?*GdkWindow, title: [*c]const gchar) void;
pub extern fn gdk_window_set_role(window: ?*GdkWindow, role: [*c]const gchar) void;
pub extern fn gdk_window_set_startup_id(window: ?*GdkWindow, startup_id: [*c]const gchar) void;
pub extern fn gdk_window_set_transient_for(window: ?*GdkWindow, parent: ?*GdkWindow) void;
pub extern fn gdk_window_set_background(window: ?*GdkWindow, color: [*c]const GdkColor) void;
pub extern fn gdk_window_set_background_rgba(window: ?*GdkWindow, rgba: [*c]const GdkRGBA) void;
pub extern fn gdk_window_set_background_pattern(window: ?*GdkWindow, pattern: ?*cairo_pattern_t) void;
pub extern fn gdk_window_get_background_pattern(window: ?*GdkWindow) ?*cairo_pattern_t;
pub extern fn gdk_window_set_cursor(window: ?*GdkWindow, cursor: ?*GdkCursor) void;
pub extern fn gdk_window_get_cursor(window: ?*GdkWindow) ?*GdkCursor;
pub extern fn gdk_window_set_device_cursor(window: ?*GdkWindow, device: ?*GdkDevice, cursor: ?*GdkCursor) void;
pub extern fn gdk_window_get_device_cursor(window: ?*GdkWindow, device: ?*GdkDevice) ?*GdkCursor;
pub extern fn gdk_window_get_user_data(window: ?*GdkWindow, data: [*c]gpointer) void;
pub extern fn gdk_window_get_geometry(window: ?*GdkWindow, x: [*c]gint, y: [*c]gint, width: [*c]gint, height: [*c]gint) void;
pub extern fn gdk_window_get_width(window: ?*GdkWindow) c_int;
pub extern fn gdk_window_get_height(window: ?*GdkWindow) c_int;
pub extern fn gdk_window_get_position(window: ?*GdkWindow, x: [*c]gint, y: [*c]gint) void;
pub extern fn gdk_window_get_origin(window: ?*GdkWindow, x: [*c]gint, y: [*c]gint) gint;
pub extern fn gdk_window_get_root_coords(window: ?*GdkWindow, x: gint, y: gint, root_x: [*c]gint, root_y: [*c]gint) void;
pub extern fn gdk_window_coords_to_parent(window: ?*GdkWindow, x: gdouble, y: gdouble, parent_x: [*c]gdouble, parent_y: [*c]gdouble) void;
pub extern fn gdk_window_coords_from_parent(window: ?*GdkWindow, parent_x: gdouble, parent_y: gdouble, x: [*c]gdouble, y: [*c]gdouble) void;
pub extern fn gdk_window_get_root_origin(window: ?*GdkWindow, x: [*c]gint, y: [*c]gint) void;
pub extern fn gdk_window_get_frame_extents(window: ?*GdkWindow, rect: [*c]GdkRectangle) void;
pub extern fn gdk_window_get_scale_factor(window: ?*GdkWindow) gint;
pub extern fn gdk_window_get_pointer(window: ?*GdkWindow, x: [*c]gint, y: [*c]gint, mask: [*c]GdkModifierType) ?*GdkWindow;
pub extern fn gdk_window_get_device_position(window: ?*GdkWindow, device: ?*GdkDevice, x: [*c]gint, y: [*c]gint, mask: [*c]GdkModifierType) ?*GdkWindow;
pub extern fn gdk_window_get_device_position_double(window: ?*GdkWindow, device: ?*GdkDevice, x: [*c]gdouble, y: [*c]gdouble, mask: [*c]GdkModifierType) ?*GdkWindow;
pub extern fn gdk_window_get_parent(window: ?*GdkWindow) ?*GdkWindow;
pub extern fn gdk_window_get_toplevel(window: ?*GdkWindow) ?*GdkWindow;
pub extern fn gdk_window_get_effective_parent(window: ?*GdkWindow) ?*GdkWindow;
pub extern fn gdk_window_get_effective_toplevel(window: ?*GdkWindow) ?*GdkWindow;
pub extern fn gdk_window_get_children(window: ?*GdkWindow) [*c]GList;
pub extern fn gdk_window_peek_children(window: ?*GdkWindow) [*c]GList;
pub extern fn gdk_window_get_children_with_user_data(window: ?*GdkWindow, user_data: gpointer) [*c]GList;
pub extern fn gdk_window_get_events(window: ?*GdkWindow) GdkEventMask;
pub extern fn gdk_window_set_events(window: ?*GdkWindow, event_mask: GdkEventMask) void;
pub extern fn gdk_window_set_device_events(window: ?*GdkWindow, device: ?*GdkDevice, event_mask: GdkEventMask) void;
pub extern fn gdk_window_get_device_events(window: ?*GdkWindow, device: ?*GdkDevice) GdkEventMask;
pub extern fn gdk_window_set_source_events(window: ?*GdkWindow, source: GdkInputSource, event_mask: GdkEventMask) void;
pub extern fn gdk_window_get_source_events(window: ?*GdkWindow, source: GdkInputSource) GdkEventMask;
pub extern fn gdk_window_set_icon_list(window: ?*GdkWindow, pixbufs: [*c]GList) void;
pub extern fn gdk_window_set_icon_name(window: ?*GdkWindow, name: [*c]const gchar) void;
pub extern fn gdk_window_set_group(window: ?*GdkWindow, leader: ?*GdkWindow) void;
pub extern fn gdk_window_get_group(window: ?*GdkWindow) ?*GdkWindow;
pub extern fn gdk_window_set_decorations(window: ?*GdkWindow, decorations: GdkWMDecoration) void;
pub extern fn gdk_window_get_decorations(window: ?*GdkWindow, decorations: [*c]GdkWMDecoration) gboolean;
pub extern fn gdk_window_set_functions(window: ?*GdkWindow, functions: GdkWMFunction) void;
pub extern fn gdk_window_create_similar_surface(window: ?*GdkWindow, content: cairo_content_t, width: c_int, height: c_int) ?*cairo_surface_t;
pub extern fn gdk_window_create_similar_image_surface(window: ?*GdkWindow, format: cairo_format_t, width: c_int, height: c_int, scale: c_int) ?*cairo_surface_t;
pub extern fn gdk_window_beep(window: ?*GdkWindow) void;
pub extern fn gdk_window_iconify(window: ?*GdkWindow) void;
pub extern fn gdk_window_deiconify(window: ?*GdkWindow) void;
pub extern fn gdk_window_stick(window: ?*GdkWindow) void;
pub extern fn gdk_window_unstick(window: ?*GdkWindow) void;
pub extern fn gdk_window_maximize(window: ?*GdkWindow) void;
pub extern fn gdk_window_unmaximize(window: ?*GdkWindow) void;
pub extern fn gdk_window_fullscreen(window: ?*GdkWindow) void;
pub extern fn gdk_window_fullscreen_on_monitor(window: ?*GdkWindow, monitor: gint) void;
pub extern fn gdk_window_set_fullscreen_mode(window: ?*GdkWindow, mode: GdkFullscreenMode) void;
pub extern fn gdk_window_get_fullscreen_mode(window: ?*GdkWindow) GdkFullscreenMode;
pub extern fn gdk_window_unfullscreen(window: ?*GdkWindow) void;
pub extern fn gdk_window_set_keep_above(window: ?*GdkWindow, setting: gboolean) void;
pub extern fn gdk_window_set_keep_below(window: ?*GdkWindow, setting: gboolean) void;
pub extern fn gdk_window_set_opacity(window: ?*GdkWindow, opacity: gdouble) void;
pub extern fn gdk_window_register_dnd(window: ?*GdkWindow) void;
pub extern fn gdk_window_get_drag_protocol(window: ?*GdkWindow, target: [*c](?*GdkWindow)) GdkDragProtocol;
pub extern fn gdk_window_begin_resize_drag(window: ?*GdkWindow, edge: GdkWindowEdge, button: gint, root_x: gint, root_y: gint, timestamp: guint32) void;
pub extern fn gdk_window_begin_resize_drag_for_device(window: ?*GdkWindow, edge: GdkWindowEdge, device: ?*GdkDevice, button: gint, root_x: gint, root_y: gint, timestamp: guint32) void;
pub extern fn gdk_window_begin_move_drag(window: ?*GdkWindow, button: gint, root_x: gint, root_y: gint, timestamp: guint32) void;
pub extern fn gdk_window_begin_move_drag_for_device(window: ?*GdkWindow, device: ?*GdkDevice, button: gint, root_x: gint, root_y: gint, timestamp: guint32) void;
pub extern fn gdk_window_invalidate_rect(window: ?*GdkWindow, rect: [*c]const GdkRectangle, invalidate_children: gboolean) void;
pub extern fn gdk_window_invalidate_region(window: ?*GdkWindow, region: ?*const cairo_region_t, invalidate_children: gboolean) void;
pub const GdkWindowChildFunc = ?extern fn (?*GdkWindow, gpointer) gboolean;
pub extern fn gdk_window_invalidate_maybe_recurse(window: ?*GdkWindow, region: ?*const cairo_region_t, child_func: GdkWindowChildFunc, user_data: gpointer) void;
pub extern fn gdk_window_get_update_area(window: ?*GdkWindow) ?*cairo_region_t;
pub extern fn gdk_window_freeze_updates(window: ?*GdkWindow) void;
pub extern fn gdk_window_thaw_updates(window: ?*GdkWindow) void;
pub extern fn gdk_window_freeze_toplevel_updates_libgtk_only(window: ?*GdkWindow) void;
pub extern fn gdk_window_thaw_toplevel_updates_libgtk_only(window: ?*GdkWindow) void;
pub extern fn gdk_window_process_all_updates() void;
pub extern fn gdk_window_process_updates(window: ?*GdkWindow, update_children: gboolean) void;
pub extern fn gdk_window_set_debug_updates(setting: gboolean) void;
pub extern fn gdk_window_constrain_size(geometry: [*c]GdkGeometry, flags: GdkWindowHints, width: gint, height: gint, new_width: [*c]gint, new_height: [*c]gint) void;
pub extern fn gdk_window_enable_synchronized_configure(window: ?*GdkWindow) void;
pub extern fn gdk_window_configure_finished(window: ?*GdkWindow) void;
pub extern fn gdk_get_default_root_window() ?*GdkWindow;
pub extern fn gdk_offscreen_window_get_surface(window: ?*GdkWindow) ?*cairo_surface_t;
pub extern fn gdk_offscreen_window_set_embedder(window: ?*GdkWindow, embedder: ?*GdkWindow) void;
pub extern fn gdk_offscreen_window_get_embedder(window: ?*GdkWindow) ?*GdkWindow;
pub extern fn gdk_window_geometry_changed(window: ?*GdkWindow) void;
pub extern fn gdk_window_set_support_multidevice(window: ?*GdkWindow, support_multidevice: gboolean) void;
pub extern fn gdk_window_get_support_multidevice(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_get_frame_clock(window: ?*GdkWindow) ?*GdkFrameClock;
pub extern fn gdk_window_set_opaque_region(window: ?*GdkWindow, region: ?*cairo_region_t) void;
pub extern fn gdk_window_set_event_compression(window: ?*GdkWindow, event_compression: gboolean) void;
pub extern fn gdk_window_get_event_compression(window: ?*GdkWindow) gboolean;
pub extern fn gdk_window_set_shadow_width(window: ?*GdkWindow, left: gint, right: gint, top: gint, bottom: gint) void;
pub extern fn gdk_window_show_window_menu(window: ?*GdkWindow, event: [*c]GdkEvent) gboolean;
pub extern fn gdk_window_create_gl_context(window: ?*GdkWindow, @"error": [*c]([*c]GError)) ?*GdkGLContext;
pub const GDK_SEAT_CAPABILITY_NONE = 0;
pub const GDK_SEAT_CAPABILITY_POINTER = 1;
pub const GDK_SEAT_CAPABILITY_TOUCH = 2;
pub const GDK_SEAT_CAPABILITY_TABLET_STYLUS = 4;
pub const GDK_SEAT_CAPABILITY_KEYBOARD = 8;
pub const GDK_SEAT_CAPABILITY_ALL_POINTING = 7;
pub const GDK_SEAT_CAPABILITY_ALL = 15;
pub const GdkSeatCapabilities = extern enum {
    GDK_SEAT_CAPABILITY_NONE = 0,
    GDK_SEAT_CAPABILITY_POINTER = 1,
    GDK_SEAT_CAPABILITY_TOUCH = 2,
    GDK_SEAT_CAPABILITY_TABLET_STYLUS = 4,
    GDK_SEAT_CAPABILITY_KEYBOARD = 8,
    GDK_SEAT_CAPABILITY_ALL_POINTING = 7,
    GDK_SEAT_CAPABILITY_ALL = 15,
};
pub const GdkSeatGrabPrepareFunc = ?extern fn ([*c]GdkSeat, ?*GdkWindow, gpointer) void;
pub extern fn gdk_seat_get_type() GType;
pub extern fn gdk_seat_grab(seat: [*c]GdkSeat, window: ?*GdkWindow, capabilities: GdkSeatCapabilities, owner_events: gboolean, cursor: ?*GdkCursor, event: [*c]const GdkEvent, prepare_func: GdkSeatGrabPrepareFunc, prepare_func_data: gpointer) GdkGrabStatus;
pub extern fn gdk_seat_ungrab(seat: [*c]GdkSeat) void;
pub extern fn gdk_seat_get_display(seat: [*c]GdkSeat) ?*GdkDisplay;
pub extern fn gdk_seat_get_capabilities(seat: [*c]GdkSeat) GdkSeatCapabilities;
pub extern fn gdk_seat_get_slaves(seat: [*c]GdkSeat, capabilities: GdkSeatCapabilities) [*c]GList;
pub extern fn gdk_seat_get_pointer(seat: [*c]GdkSeat) ?*GdkDevice;
pub extern fn gdk_seat_get_keyboard(seat: [*c]GdkSeat) ?*GdkDevice;
pub extern fn gdk_rectangle_intersect(src1: [*c]const GdkRectangle, src2: [*c]const GdkRectangle, dest: [*c]GdkRectangle) gboolean;
pub extern fn gdk_rectangle_union(src1: [*c]const GdkRectangle, src2: [*c]const GdkRectangle, dest: [*c]GdkRectangle) void;
pub extern fn gdk_rectangle_equal(rect1: [*c]const GdkRectangle, rect2: [*c]const GdkRectangle) gboolean;
pub extern fn gdk_rectangle_get_type() GType;
pub const struct__GdkMonitor = @OpaqueType();
pub const GdkMonitor = struct__GdkMonitor;
pub const struct__GdkMonitorClass = @OpaqueType();
pub const GdkMonitorClass = struct__GdkMonitorClass;
pub const GDK_SUBPIXEL_LAYOUT_UNKNOWN = 0;
pub const GDK_SUBPIXEL_LAYOUT_NONE = 1;
pub const GDK_SUBPIXEL_LAYOUT_HORIZONTAL_RGB = 2;
pub const GDK_SUBPIXEL_LAYOUT_HORIZONTAL_BGR = 3;
pub const GDK_SUBPIXEL_LAYOUT_VERTICAL_RGB = 4;
pub const GDK_SUBPIXEL_LAYOUT_VERTICAL_BGR = 5;
pub const GdkSubpixelLayout = extern enum {
    GDK_SUBPIXEL_LAYOUT_UNKNOWN = 0,
    GDK_SUBPIXEL_LAYOUT_NONE = 1,
    GDK_SUBPIXEL_LAYOUT_HORIZONTAL_RGB = 2,
    GDK_SUBPIXEL_LAYOUT_HORIZONTAL_BGR = 3,
    GDK_SUBPIXEL_LAYOUT_VERTICAL_RGB = 4,
    GDK_SUBPIXEL_LAYOUT_VERTICAL_BGR = 5,
};
pub extern fn gdk_monitor_get_type() GType;
pub extern fn gdk_monitor_get_display(monitor: ?*GdkMonitor) ?*GdkDisplay;
pub extern fn gdk_monitor_get_geometry(monitor: ?*GdkMonitor, geometry: [*c]GdkRectangle) void;
pub extern fn gdk_monitor_get_workarea(monitor: ?*GdkMonitor, workarea: [*c]GdkRectangle) void;
pub extern fn gdk_monitor_get_width_mm(monitor: ?*GdkMonitor) c_int;
pub extern fn gdk_monitor_get_height_mm(monitor: ?*GdkMonitor) c_int;
pub extern fn gdk_monitor_get_manufacturer(monitor: ?*GdkMonitor) [*c]const u8;
pub extern fn gdk_monitor_get_model(monitor: ?*GdkMonitor) [*c]const u8;
pub extern fn gdk_monitor_get_scale_factor(monitor: ?*GdkMonitor) c_int;
pub extern fn gdk_monitor_get_refresh_rate(monitor: ?*GdkMonitor) c_int;
pub extern fn gdk_monitor_get_subpixel_layout(monitor: ?*GdkMonitor) GdkSubpixelLayout;
pub extern fn gdk_monitor_is_primary(monitor: ?*GdkMonitor) gboolean;
pub extern fn gdk_display_get_type() GType;
pub extern fn gdk_display_open(display_name: [*c]const gchar) ?*GdkDisplay;
pub extern fn gdk_display_get_name(display: ?*GdkDisplay) [*c]const gchar;
pub extern fn gdk_display_get_n_screens(display: ?*GdkDisplay) gint;
pub extern fn gdk_display_get_screen(display: ?*GdkDisplay, screen_num: gint) ?*GdkScreen;
pub extern fn gdk_display_get_default_screen(display: ?*GdkDisplay) ?*GdkScreen;
pub extern fn gdk_display_pointer_ungrab(display: ?*GdkDisplay, time_: guint32) void;
pub extern fn gdk_display_keyboard_ungrab(display: ?*GdkDisplay, time_: guint32) void;
pub extern fn gdk_display_pointer_is_grabbed(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_device_is_grabbed(display: ?*GdkDisplay, device: ?*GdkDevice) gboolean;
pub extern fn gdk_display_beep(display: ?*GdkDisplay) void;
pub extern fn gdk_display_sync(display: ?*GdkDisplay) void;
pub extern fn gdk_display_flush(display: ?*GdkDisplay) void;
pub extern fn gdk_display_close(display: ?*GdkDisplay) void;
pub extern fn gdk_display_is_closed(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_list_devices(display: ?*GdkDisplay) [*c]GList;
pub extern fn gdk_display_get_event(display: ?*GdkDisplay) [*c]GdkEvent;
pub extern fn gdk_display_peek_event(display: ?*GdkDisplay) [*c]GdkEvent;
pub extern fn gdk_display_put_event(display: ?*GdkDisplay, event: [*c]const GdkEvent) void;
pub extern fn gdk_display_has_pending(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_set_double_click_time(display: ?*GdkDisplay, msec: guint) void;
pub extern fn gdk_display_set_double_click_distance(display: ?*GdkDisplay, distance: guint) void;
pub extern fn gdk_display_get_default() ?*GdkDisplay;
pub extern fn gdk_display_get_pointer(display: ?*GdkDisplay, screen: [*c](?*GdkScreen), x: [*c]gint, y: [*c]gint, mask: [*c]GdkModifierType) void;
pub extern fn gdk_display_get_window_at_pointer(display: ?*GdkDisplay, win_x: [*c]gint, win_y: [*c]gint) ?*GdkWindow;
pub extern fn gdk_display_warp_pointer(display: ?*GdkDisplay, screen: ?*GdkScreen, x: gint, y: gint) void;
pub extern fn gdk_display_open_default_libgtk_only() ?*GdkDisplay;
pub extern fn gdk_display_supports_cursor_alpha(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_supports_cursor_color(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_get_default_cursor_size(display: ?*GdkDisplay) guint;
pub extern fn gdk_display_get_maximal_cursor_size(display: ?*GdkDisplay, width: [*c]guint, height: [*c]guint) void;
pub extern fn gdk_display_get_default_group(display: ?*GdkDisplay) ?*GdkWindow;
pub extern fn gdk_display_supports_selection_notification(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_request_selection_notification(display: ?*GdkDisplay, selection: GdkAtom) gboolean;
pub extern fn gdk_display_supports_clipboard_persistence(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_store_clipboard(display: ?*GdkDisplay, clipboard_window: ?*GdkWindow, time_: guint32, targets: [*c]const GdkAtom, n_targets: gint) void;
pub extern fn gdk_display_supports_shapes(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_supports_input_shapes(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_supports_composite(display: ?*GdkDisplay) gboolean;
pub extern fn gdk_display_notify_startup_complete(display: ?*GdkDisplay, startup_id: [*c]const gchar) void;
pub extern fn gdk_display_get_device_manager(display: ?*GdkDisplay) ?*GdkDeviceManager;
pub extern fn gdk_display_get_app_launch_context(display: ?*GdkDisplay) ?*GdkAppLaunchContext;
pub extern fn gdk_display_get_default_seat(display: ?*GdkDisplay) [*c]GdkSeat;
pub extern fn gdk_display_list_seats(display: ?*GdkDisplay) [*c]GList;
pub extern fn gdk_display_get_n_monitors(display: ?*GdkDisplay) c_int;
pub extern fn gdk_display_get_monitor(display: ?*GdkDisplay, monitor_num: c_int) ?*GdkMonitor;
pub extern fn gdk_display_get_primary_monitor(display: ?*GdkDisplay) ?*GdkMonitor;
pub extern fn gdk_display_get_monitor_at_point(display: ?*GdkDisplay, x: c_int, y: c_int) ?*GdkMonitor;
pub extern fn gdk_display_get_monitor_at_window(display: ?*GdkDisplay, window: ?*GdkWindow) ?*GdkMonitor;
pub extern fn gdk_screen_get_type() GType;
pub extern fn gdk_screen_get_system_visual(screen: ?*GdkScreen) ?*GdkVisual;
pub extern fn gdk_screen_get_rgba_visual(screen: ?*GdkScreen) ?*GdkVisual;
pub extern fn gdk_screen_is_composited(screen: ?*GdkScreen) gboolean;
pub extern fn gdk_screen_get_root_window(screen: ?*GdkScreen) ?*GdkWindow;
pub extern fn gdk_screen_get_display(screen: ?*GdkScreen) ?*GdkDisplay;
pub extern fn gdk_screen_get_number(screen: ?*GdkScreen) gint;
pub extern fn gdk_screen_get_width(screen: ?*GdkScreen) gint;
pub extern fn gdk_screen_get_height(screen: ?*GdkScreen) gint;
pub extern fn gdk_screen_get_width_mm(screen: ?*GdkScreen) gint;
pub extern fn gdk_screen_get_height_mm(screen: ?*GdkScreen) gint;
pub extern fn gdk_screen_list_visuals(screen: ?*GdkScreen) [*c]GList;
pub extern fn gdk_screen_get_toplevel_windows(screen: ?*GdkScreen) [*c]GList;
pub extern fn gdk_screen_make_display_name(screen: ?*GdkScreen) [*c]gchar;
pub extern fn gdk_screen_get_n_monitors(screen: ?*GdkScreen) gint;
pub extern fn gdk_screen_get_primary_monitor(screen: ?*GdkScreen) gint;
pub extern fn gdk_screen_get_monitor_geometry(screen: ?*GdkScreen, monitor_num: gint, dest: [*c]GdkRectangle) void;
pub extern fn gdk_screen_get_monitor_workarea(screen: ?*GdkScreen, monitor_num: gint, dest: [*c]GdkRectangle) void;
pub extern fn gdk_screen_get_monitor_at_point(screen: ?*GdkScreen, x: gint, y: gint) gint;
pub extern fn gdk_screen_get_monitor_at_window(screen: ?*GdkScreen, window: ?*GdkWindow) gint;
pub extern fn gdk_screen_get_monitor_width_mm(screen: ?*GdkScreen, monitor_num: gint) gint;
pub extern fn gdk_screen_get_monitor_height_mm(screen: ?*GdkScreen, monitor_num: gint) gint;
pub extern fn gdk_screen_get_monitor_plug_name(screen: ?*GdkScreen, monitor_num: gint) [*c]gchar;
pub extern fn gdk_screen_get_monitor_scale_factor(screen: ?*GdkScreen, monitor_num: gint) gint;
pub extern fn gdk_screen_get_default() ?*GdkScreen;
pub extern fn gdk_screen_get_setting(screen: ?*GdkScreen, name: [*c]const gchar, value: [*c]GValue) gboolean;
pub extern fn gdk_screen_set_font_options(screen: ?*GdkScreen, options: ?*const cairo_font_options_t) void;
pub extern fn gdk_screen_get_font_options(screen: ?*GdkScreen) ?*const cairo_font_options_t;
pub extern fn gdk_screen_set_resolution(screen: ?*GdkScreen, dpi: gdouble) void;
pub extern fn gdk_screen_get_resolution(screen: ?*GdkScreen) gdouble;
pub extern fn gdk_screen_get_active_window(screen: ?*GdkScreen) ?*GdkWindow;
pub extern fn gdk_screen_get_window_stack(screen: ?*GdkScreen) [*c]GList;
pub extern fn gdk_app_launch_context_get_type() GType;
pub extern fn gdk_app_launch_context_new() ?*GdkAppLaunchContext;
pub extern fn gdk_app_launch_context_set_display(context: ?*GdkAppLaunchContext, display: ?*GdkDisplay) void;
pub extern fn gdk_app_launch_context_set_screen(context: ?*GdkAppLaunchContext, screen: ?*GdkScreen) void;
pub extern fn gdk_app_launch_context_set_desktop(context: ?*GdkAppLaunchContext, desktop: gint) void;
pub extern fn gdk_app_launch_context_set_timestamp(context: ?*GdkAppLaunchContext, timestamp: guint32) void;
pub extern fn gdk_app_launch_context_set_icon(context: ?*GdkAppLaunchContext, icon: ?*GIcon) void;
pub extern fn gdk_app_launch_context_set_icon_name(context: ?*GdkAppLaunchContext, icon_name: [*c]const u8) void;
pub extern fn gdk_color_get_type() GType;
pub extern fn gdk_color_copy(color: [*c]const GdkColor) [*c]GdkColor;
pub extern fn gdk_color_free(color: [*c]GdkColor) void;
pub extern fn gdk_color_hash(color: [*c]const GdkColor) guint;
pub extern fn gdk_color_equal(colora: [*c]const GdkColor, colorb: [*c]const GdkColor) gboolean;
pub extern fn gdk_color_parse(spec: [*c]const gchar, color: [*c]GdkColor) gboolean;
pub extern fn gdk_color_to_string(color: [*c]const GdkColor) [*c]gchar;
pub extern fn gdk_rgba_get_type() GType;
pub extern fn gdk_rgba_copy(rgba: [*c]const GdkRGBA) [*c]GdkRGBA;
pub extern fn gdk_rgba_free(rgba: [*c]GdkRGBA) void;
pub extern fn gdk_rgba_hash(p: gconstpointer) guint;
pub extern fn gdk_rgba_equal(p1: gconstpointer, p2: gconstpointer) gboolean;
pub extern fn gdk_rgba_parse(rgba: [*c]GdkRGBA, spec: [*c]const gchar) gboolean;
pub extern fn gdk_rgba_to_string(rgba: [*c]const GdkRGBA) [*c]gchar;
pub extern const gdk_pixbuf_major_version: guint;
pub extern const gdk_pixbuf_minor_version: guint;
pub extern const gdk_pixbuf_micro_version: guint;
pub extern var gdk_pixbuf_version: [*c]const u8;
pub const GDK_PIXBUF_ALPHA_BILEVEL = 0;
pub const GDK_PIXBUF_ALPHA_FULL = 1;
pub const GdkPixbufAlphaMode = extern enum {
    GDK_PIXBUF_ALPHA_BILEVEL = 0,
    GDK_PIXBUF_ALPHA_FULL = 1,
};
pub const GDK_COLORSPACE_RGB = 0;
pub const GdkColorspace = extern enum {
    GDK_COLORSPACE_RGB = 0,
};
pub const struct__GdkPixbuf = @OpaqueType();
pub const GdkPixbuf = struct__GdkPixbuf;
pub const GdkPixbufDestroyNotify = ?extern fn ([*c]guchar, gpointer) void;
pub const GDK_PIXBUF_ERROR_CORRUPT_IMAGE = 0;
pub const GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY = 1;
pub const GDK_PIXBUF_ERROR_BAD_OPTION = 2;
pub const GDK_PIXBUF_ERROR_UNKNOWN_TYPE = 3;
pub const GDK_PIXBUF_ERROR_UNSUPPORTED_OPERATION = 4;
pub const GDK_PIXBUF_ERROR_FAILED = 5;
pub const GDK_PIXBUF_ERROR_INCOMPLETE_ANIMATION = 6;
pub const GdkPixbufError = extern enum {
    GDK_PIXBUF_ERROR_CORRUPT_IMAGE = 0,
    GDK_PIXBUF_ERROR_INSUFFICIENT_MEMORY = 1,
    GDK_PIXBUF_ERROR_BAD_OPTION = 2,
    GDK_PIXBUF_ERROR_UNKNOWN_TYPE = 3,
    GDK_PIXBUF_ERROR_UNSUPPORTED_OPERATION = 4,
    GDK_PIXBUF_ERROR_FAILED = 5,
    GDK_PIXBUF_ERROR_INCOMPLETE_ANIMATION = 6,
};
pub extern fn gdk_pixbuf_error_quark() GQuark;
pub extern fn gdk_pixbuf_get_type() GType;
pub extern fn gdk_pixbuf_ref(pixbuf: ?*GdkPixbuf) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_unref(pixbuf: ?*GdkPixbuf) void;
pub extern fn gdk_pixbuf_get_colorspace(pixbuf: ?*const GdkPixbuf) GdkColorspace;
pub extern fn gdk_pixbuf_get_n_channels(pixbuf: ?*const GdkPixbuf) c_int;
pub extern fn gdk_pixbuf_get_has_alpha(pixbuf: ?*const GdkPixbuf) gboolean;
pub extern fn gdk_pixbuf_get_bits_per_sample(pixbuf: ?*const GdkPixbuf) c_int;
pub extern fn gdk_pixbuf_get_pixels(pixbuf: ?*const GdkPixbuf) [*c]guchar;
pub extern fn gdk_pixbuf_get_width(pixbuf: ?*const GdkPixbuf) c_int;
pub extern fn gdk_pixbuf_get_height(pixbuf: ?*const GdkPixbuf) c_int;
pub extern fn gdk_pixbuf_get_rowstride(pixbuf: ?*const GdkPixbuf) c_int;
pub extern fn gdk_pixbuf_get_byte_length(pixbuf: ?*const GdkPixbuf) gsize;
pub extern fn gdk_pixbuf_get_pixels_with_length(pixbuf: ?*const GdkPixbuf, length: [*c]guint) [*c]guchar;
pub extern fn gdk_pixbuf_read_pixels(pixbuf: ?*const GdkPixbuf) [*c]const guint8;
pub extern fn gdk_pixbuf_read_pixel_bytes(pixbuf: ?*const GdkPixbuf) ?*GBytes;
pub extern fn gdk_pixbuf_new(colorspace: GdkColorspace, has_alpha: gboolean, bits_per_sample: c_int, width: c_int, height: c_int) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_calculate_rowstride(colorspace: GdkColorspace, has_alpha: gboolean, bits_per_sample: c_int, width: c_int, height: c_int) gint;
pub extern fn gdk_pixbuf_copy(pixbuf: ?*const GdkPixbuf) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_subpixbuf(src_pixbuf: ?*GdkPixbuf, src_x: c_int, src_y: c_int, width: c_int, height: c_int) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_file_utf8(filename: [*c]const u8, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_file_at_size_utf8(filename: [*c]const u8, width: c_int, height: c_int, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_file_at_scale_utf8(filename: [*c]const u8, width: c_int, height: c_int, preserve_aspect_ratio: gboolean, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_file(filename: [*c]const u8, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_file_at_size(filename: [*c]const u8, width: c_int, height: c_int, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_file_at_scale(filename: [*c]const u8, width: c_int, height: c_int, preserve_aspect_ratio: gboolean, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_resource(resource_path: [*c]const u8, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_resource_at_scale(resource_path: [*c]const u8, width: c_int, height: c_int, preserve_aspect_ratio: gboolean, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_data(data: [*c]const guchar, colorspace: GdkColorspace, has_alpha: gboolean, bits_per_sample: c_int, width: c_int, height: c_int, rowstride: c_int, destroy_fn: GdkPixbufDestroyNotify, destroy_fn_data: gpointer) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_bytes(data: ?*GBytes, colorspace: GdkColorspace, has_alpha: gboolean, bits_per_sample: c_int, width: c_int, height: c_int, rowstride: c_int) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_xpm_data(data: [*c]([*c]const u8)) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_inline(data_length: gint, data: [*c]const guint8, copy_pixels: gboolean, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_fill(pixbuf: ?*GdkPixbuf, pixel: guint32) void;
pub extern fn gdk_pixbuf_save_utf8(pixbuf: ?*GdkPixbuf, filename: [*c]const u8, type_0: [*c]const u8, @"error": [*c]([*c]GError), ...) gboolean;
pub extern fn gdk_pixbuf_savev(pixbuf: ?*GdkPixbuf, filename: [*c]const u8, type_0: [*c]const u8, option_keys: [*c]([*c]u8), option_values: [*c]([*c]u8), @"error": [*c]([*c]GError)) gboolean;
pub extern fn gdk_pixbuf_savev_utf8(pixbuf: ?*GdkPixbuf, filename: [*c]const u8, type_0: [*c]const u8, option_keys: [*c]([*c]u8), option_values: [*c]([*c]u8), @"error": [*c]([*c]GError)) gboolean;
pub const GdkPixbufSaveFunc = ?extern fn ([*c]const gchar, gsize, [*c]([*c]GError), gpointer) gboolean;
pub extern fn gdk_pixbuf_save_to_callback(pixbuf: ?*GdkPixbuf, save_func: GdkPixbufSaveFunc, user_data: gpointer, type_0: [*c]const u8, @"error": [*c]([*c]GError), ...) gboolean;
pub extern fn gdk_pixbuf_save_to_callbackv(pixbuf: ?*GdkPixbuf, save_func: GdkPixbufSaveFunc, user_data: gpointer, type_0: [*c]const u8, option_keys: [*c]([*c]u8), option_values: [*c]([*c]u8), @"error": [*c]([*c]GError)) gboolean;
pub extern fn gdk_pixbuf_save_to_buffer(pixbuf: ?*GdkPixbuf, buffer: [*c]([*c]gchar), buffer_size: [*c]gsize, type_0: [*c]const u8, @"error": [*c]([*c]GError), ...) gboolean;
pub extern fn gdk_pixbuf_save_to_bufferv(pixbuf: ?*GdkPixbuf, buffer: [*c]([*c]gchar), buffer_size: [*c]gsize, type_0: [*c]const u8, option_keys: [*c]([*c]u8), option_values: [*c]([*c]u8), @"error": [*c]([*c]GError)) gboolean;
pub extern fn gdk_pixbuf_new_from_stream(stream: [*c]GInputStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_stream_async(stream: [*c]GInputStream, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_pixbuf_new_from_stream_finish(async_result: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_stream_at_scale(stream: [*c]GInputStream, width: gint, height: gint, preserve_aspect_ratio: gboolean, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_new_from_stream_at_scale_async(stream: [*c]GInputStream, width: gint, height: gint, preserve_aspect_ratio: gboolean, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_pixbuf_save_to_stream(pixbuf: ?*GdkPixbuf, stream: [*c]GOutputStream, type_0: [*c]const u8, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError), ...) gboolean;
pub extern fn gdk_pixbuf_save_to_stream_async(pixbuf: ?*GdkPixbuf, stream: [*c]GOutputStream, type_0: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer, ...) void;
pub extern fn gdk_pixbuf_save_to_stream_finish(async_result: ?*GAsyncResult, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gdk_pixbuf_save_to_streamv_async(pixbuf: ?*GdkPixbuf, stream: [*c]GOutputStream, type_0: [*c]const gchar, option_keys: [*c]([*c]gchar), option_values: [*c]([*c]gchar), cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_pixbuf_save_to_streamv(pixbuf: ?*GdkPixbuf, stream: [*c]GOutputStream, type_0: [*c]const u8, option_keys: [*c]([*c]u8), option_values: [*c]([*c]u8), cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gdk_pixbuf_add_alpha(pixbuf: ?*const GdkPixbuf, substitute_color: gboolean, r: guchar, g: guchar, b: guchar) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_copy_area(src_pixbuf: ?*const GdkPixbuf, src_x: c_int, src_y: c_int, width: c_int, height: c_int, dest_pixbuf: ?*GdkPixbuf, dest_x: c_int, dest_y: c_int) void;
pub extern fn gdk_pixbuf_saturate_and_pixelate(src: ?*const GdkPixbuf, dest: ?*GdkPixbuf, saturation: gfloat, pixelate: gboolean) void;
pub extern fn gdk_pixbuf_apply_embedded_orientation(src: ?*GdkPixbuf) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_set_option(pixbuf: ?*GdkPixbuf, key: [*c]const gchar, value: [*c]const gchar) gboolean;
pub extern fn gdk_pixbuf_get_option(pixbuf: ?*GdkPixbuf, key: [*c]const gchar) [*c]const gchar;
pub extern fn gdk_pixbuf_remove_option(pixbuf: ?*GdkPixbuf, key: [*c]const gchar) gboolean;
pub extern fn gdk_pixbuf_get_options(pixbuf: ?*GdkPixbuf) ?*GHashTable;
pub extern fn gdk_pixbuf_copy_options(src_pixbuf: ?*GdkPixbuf, dest_pixbuf: ?*GdkPixbuf) gboolean;
pub const GDK_INTERP_NEAREST = 0;
pub const GDK_INTERP_TILES = 1;
pub const GDK_INTERP_BILINEAR = 2;
pub const GDK_INTERP_HYPER = 3;
pub const GdkInterpType = extern enum {
    GDK_INTERP_NEAREST = 0,
    GDK_INTERP_TILES = 1,
    GDK_INTERP_BILINEAR = 2,
    GDK_INTERP_HYPER = 3,
};
pub const GDK_PIXBUF_ROTATE_NONE = 0;
pub const GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE = 90;
pub const GDK_PIXBUF_ROTATE_UPSIDEDOWN = 180;
pub const GDK_PIXBUF_ROTATE_CLOCKWISE = 270;
pub const GdkPixbufRotation = extern enum {
    GDK_PIXBUF_ROTATE_NONE = 0,
    GDK_PIXBUF_ROTATE_COUNTERCLOCKWISE = 90,
    GDK_PIXBUF_ROTATE_UPSIDEDOWN = 180,
    GDK_PIXBUF_ROTATE_CLOCKWISE = 270,
};
pub extern fn gdk_pixbuf_scale(src: ?*const GdkPixbuf, dest: ?*GdkPixbuf, dest_x: c_int, dest_y: c_int, dest_width: c_int, dest_height: c_int, offset_x: f64, offset_y: f64, scale_x: f64, scale_y: f64, interp_type: GdkInterpType) void;
pub extern fn gdk_pixbuf_composite(src: ?*const GdkPixbuf, dest: ?*GdkPixbuf, dest_x: c_int, dest_y: c_int, dest_width: c_int, dest_height: c_int, offset_x: f64, offset_y: f64, scale_x: f64, scale_y: f64, interp_type: GdkInterpType, overall_alpha: c_int) void;
pub extern fn gdk_pixbuf_composite_color(src: ?*const GdkPixbuf, dest: ?*GdkPixbuf, dest_x: c_int, dest_y: c_int, dest_width: c_int, dest_height: c_int, offset_x: f64, offset_y: f64, scale_x: f64, scale_y: f64, interp_type: GdkInterpType, overall_alpha: c_int, check_x: c_int, check_y: c_int, check_size: c_int, color1: guint32, color2: guint32) void;
pub extern fn gdk_pixbuf_scale_simple(src: ?*const GdkPixbuf, dest_width: c_int, dest_height: c_int, interp_type: GdkInterpType) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_composite_color_simple(src: ?*const GdkPixbuf, dest_width: c_int, dest_height: c_int, interp_type: GdkInterpType, overall_alpha: c_int, check_size: c_int, color1: guint32, color2: guint32) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_rotate_simple(src: ?*const GdkPixbuf, angle: GdkPixbufRotation) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_flip(src: ?*const GdkPixbuf, horizontal: gboolean) ?*GdkPixbuf;
pub const struct__GdkPixbufAnimation = @OpaqueType();
pub const GdkPixbufAnimation = struct__GdkPixbufAnimation;
pub const struct__GdkPixbufAnimationIter = @OpaqueType();
pub const GdkPixbufAnimationIter = struct__GdkPixbufAnimationIter;
pub extern fn gdk_pixbuf_animation_get_type() GType;
pub extern fn gdk_pixbuf_animation_new_from_file_utf8(filename: [*c]const u8, @"error": [*c]([*c]GError)) ?*GdkPixbufAnimation;
pub extern fn gdk_pixbuf_animation_new_from_file(filename: [*c]const u8, @"error": [*c]([*c]GError)) ?*GdkPixbufAnimation;
pub extern fn gdk_pixbuf_animation_new_from_stream(stream: [*c]GInputStream, cancellable: [*c]GCancellable, @"error": [*c]([*c]GError)) ?*GdkPixbufAnimation;
pub extern fn gdk_pixbuf_animation_new_from_stream_async(stream: [*c]GInputStream, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_pixbuf_animation_new_from_stream_finish(async_result: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GdkPixbufAnimation;
pub extern fn gdk_pixbuf_animation_new_from_resource(resource_path: [*c]const u8, @"error": [*c]([*c]GError)) ?*GdkPixbufAnimation;
pub extern fn gdk_pixbuf_animation_ref(animation: ?*GdkPixbufAnimation) ?*GdkPixbufAnimation;
pub extern fn gdk_pixbuf_animation_unref(animation: ?*GdkPixbufAnimation) void;
pub extern fn gdk_pixbuf_animation_get_width(animation: ?*GdkPixbufAnimation) c_int;
pub extern fn gdk_pixbuf_animation_get_height(animation: ?*GdkPixbufAnimation) c_int;
pub extern fn gdk_pixbuf_animation_is_static_image(animation: ?*GdkPixbufAnimation) gboolean;
pub extern fn gdk_pixbuf_animation_get_static_image(animation: ?*GdkPixbufAnimation) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_animation_get_iter(animation: ?*GdkPixbufAnimation, start_time: [*c]const GTimeVal) ?*GdkPixbufAnimationIter;
pub extern fn gdk_pixbuf_animation_iter_get_type() GType;
pub extern fn gdk_pixbuf_animation_iter_get_delay_time(iter: ?*GdkPixbufAnimationIter) c_int;
pub extern fn gdk_pixbuf_animation_iter_get_pixbuf(iter: ?*GdkPixbufAnimationIter) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_animation_iter_on_currently_loading_frame(iter: ?*GdkPixbufAnimationIter) gboolean;
pub extern fn gdk_pixbuf_animation_iter_advance(iter: ?*GdkPixbufAnimationIter, current_time: [*c]const GTimeVal) gboolean;
pub const struct__GdkPixbufSimpleAnim = @OpaqueType();
pub const GdkPixbufSimpleAnim = struct__GdkPixbufSimpleAnim;
pub const struct__GdkPixbufSimpleAnimClass = @OpaqueType();
pub const GdkPixbufSimpleAnimClass = struct__GdkPixbufSimpleAnimClass;
pub extern fn gdk_pixbuf_simple_anim_get_type() GType;
pub extern fn gdk_pixbuf_simple_anim_iter_get_type() GType;
pub extern fn gdk_pixbuf_simple_anim_new(width: gint, height: gint, rate: gfloat) ?*GdkPixbufSimpleAnim;
pub extern fn gdk_pixbuf_simple_anim_add_frame(animation: ?*GdkPixbufSimpleAnim, pixbuf: ?*GdkPixbuf) void;
pub extern fn gdk_pixbuf_simple_anim_set_loop(animation: ?*GdkPixbufSimpleAnim, loop: gboolean) void;
pub extern fn gdk_pixbuf_simple_anim_get_loop(animation: ?*GdkPixbufSimpleAnim) gboolean;
pub const struct__GdkPixbufFormat = @OpaqueType();
pub const GdkPixbufFormat = struct__GdkPixbufFormat;
pub extern fn gdk_pixbuf_init_modules(path: [*c]const u8, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gdk_pixbuf_format_get_type() GType;
pub extern fn gdk_pixbuf_get_formats() [*c]GSList;
pub extern fn gdk_pixbuf_format_get_name(format: ?*GdkPixbufFormat) [*c]gchar;
pub extern fn gdk_pixbuf_format_get_description(format: ?*GdkPixbufFormat) [*c]gchar;
pub extern fn gdk_pixbuf_format_get_mime_types(format: ?*GdkPixbufFormat) [*c]([*c]gchar);
pub extern fn gdk_pixbuf_format_get_extensions(format: ?*GdkPixbufFormat) [*c]([*c]gchar);
pub extern fn gdk_pixbuf_format_is_save_option_supported(format: ?*GdkPixbufFormat, option_key: [*c]const gchar) gboolean;
pub extern fn gdk_pixbuf_format_is_writable(format: ?*GdkPixbufFormat) gboolean;
pub extern fn gdk_pixbuf_format_is_scalable(format: ?*GdkPixbufFormat) gboolean;
pub extern fn gdk_pixbuf_format_is_disabled(format: ?*GdkPixbufFormat) gboolean;
pub extern fn gdk_pixbuf_format_set_disabled(format: ?*GdkPixbufFormat, disabled: gboolean) void;
pub extern fn gdk_pixbuf_format_get_license(format: ?*GdkPixbufFormat) [*c]gchar;
pub extern fn gdk_pixbuf_get_file_info(filename: [*c]const gchar, width: [*c]gint, height: [*c]gint) ?*GdkPixbufFormat;
pub extern fn gdk_pixbuf_get_file_info_async(filename: [*c]const gchar, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gdk_pixbuf_get_file_info_finish(async_result: ?*GAsyncResult, width: [*c]gint, height: [*c]gint, @"error": [*c]([*c]GError)) ?*GdkPixbufFormat;
pub extern fn gdk_pixbuf_format_copy(format: ?*const GdkPixbufFormat) ?*GdkPixbufFormat;
pub extern fn gdk_pixbuf_format_free(format: ?*GdkPixbufFormat) void;
pub const struct__GdkPixbufLoader = extern struct {
    parent_instance: GObject,
    priv: gpointer,
};
pub const GdkPixbufLoader = struct__GdkPixbufLoader;
pub const struct__GdkPixbufLoaderClass = extern struct {
    parent_class: GObjectClass,
    size_prepared: ?extern fn ([*c]GdkPixbufLoader, c_int, c_int) void,
    area_prepared: ?extern fn ([*c]GdkPixbufLoader) void,
    area_updated: ?extern fn ([*c]GdkPixbufLoader, c_int, c_int, c_int, c_int) void,
    closed: ?extern fn ([*c]GdkPixbufLoader) void,
};
pub const GdkPixbufLoaderClass = struct__GdkPixbufLoaderClass;
pub extern fn gdk_pixbuf_loader_get_type() GType;
pub extern fn gdk_pixbuf_loader_new() [*c]GdkPixbufLoader;
pub extern fn gdk_pixbuf_loader_new_with_type(image_type: [*c]const u8, @"error": [*c]([*c]GError)) [*c]GdkPixbufLoader;
pub extern fn gdk_pixbuf_loader_new_with_mime_type(mime_type: [*c]const u8, @"error": [*c]([*c]GError)) [*c]GdkPixbufLoader;
pub extern fn gdk_pixbuf_loader_set_size(loader: [*c]GdkPixbufLoader, width: c_int, height: c_int) void;
pub extern fn gdk_pixbuf_loader_write(loader: [*c]GdkPixbufLoader, buf: [*c]const guchar, count: gsize, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gdk_pixbuf_loader_write_bytes(loader: [*c]GdkPixbufLoader, buffer: ?*GBytes, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gdk_pixbuf_loader_get_pixbuf(loader: [*c]GdkPixbufLoader) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_loader_get_animation(loader: [*c]GdkPixbufLoader) ?*GdkPixbufAnimation;
pub extern fn gdk_pixbuf_loader_close(loader: [*c]GdkPixbufLoader, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gdk_pixbuf_loader_get_format(loader: [*c]GdkPixbufLoader) ?*GdkPixbufFormat;
pub extern fn gdk_pixbuf_alpha_mode_get_type() GType;
pub extern fn gdk_colorspace_get_type() GType;
pub extern fn gdk_pixbuf_error_get_type() GType;
pub extern fn gdk_interp_type_get_type() GType;
pub extern fn gdk_pixbuf_rotation_get_type() GType;
pub const GdkPixbuf_autoptr = ?*GdkPixbuf;
pub const GdkPixbuf_listautoptr = [*c]GList;
pub const GdkPixbuf_slistautoptr = [*c]GSList;
pub const GdkPixbuf_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkPixbuf(_ptr: ?*GdkPixbuf) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkPixbuf(_ptr: [*c](?*GdkPixbuf)) void {
    glib_autoptr_clear_GdkPixbuf(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkPixbuf(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkPixbuf(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkPixbuf(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkPixbufAnimation_autoptr = ?*GdkPixbufAnimation;
pub const GdkPixbufAnimation_listautoptr = [*c]GList;
pub const GdkPixbufAnimation_slistautoptr = [*c]GSList;
pub const GdkPixbufAnimation_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkPixbufAnimation(_ptr: ?*GdkPixbufAnimation) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkPixbufAnimation(_ptr: [*c](?*GdkPixbufAnimation)) void {
    glib_autoptr_clear_GdkPixbufAnimation(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkPixbufAnimation(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkPixbufAnimation(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkPixbufAnimation(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkPixbufAnimationIter_autoptr = ?*GdkPixbufAnimationIter;
pub const GdkPixbufAnimationIter_listautoptr = [*c]GList;
pub const GdkPixbufAnimationIter_slistautoptr = [*c]GSList;
pub const GdkPixbufAnimationIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkPixbufAnimationIter(_ptr: ?*GdkPixbufAnimationIter) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkPixbufAnimationIter(_ptr: [*c](?*GdkPixbufAnimationIter)) void {
    glib_autoptr_clear_GdkPixbufAnimationIter(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkPixbufAnimationIter(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkPixbufAnimationIter(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkPixbufAnimationIter(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkPixbufLoader_autoptr = [*c]GdkPixbufLoader;
pub const GdkPixbufLoader_listautoptr = [*c]GList;
pub const GdkPixbufLoader_slistautoptr = [*c]GSList;
pub const GdkPixbufLoader_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkPixbufLoader(_ptr: [*c]GdkPixbufLoader) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkPixbufLoader(_ptr: [*c]([*c]GdkPixbufLoader)) void {
    glib_autoptr_clear_GdkPixbufLoader(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkPixbufLoader(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkPixbufLoader(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkPixbufLoader(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkPixbufSimpleAnim_autoptr = ?*GdkPixbufSimpleAnim;
pub const GdkPixbufSimpleAnim_listautoptr = [*c]GList;
pub const GdkPixbufSimpleAnim_slistautoptr = [*c]GSList;
pub const GdkPixbufSimpleAnim_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkPixbufSimpleAnim(_ptr: ?*GdkPixbufSimpleAnim) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkPixbufSimpleAnim(_ptr: [*c](?*GdkPixbufSimpleAnim)) void {
    glib_autoptr_clear_GdkPixbufSimpleAnim(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkPixbufSimpleAnim(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkPixbufSimpleAnim(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkPixbufSimpleAnim(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub extern fn gdk_pixbuf_get_from_window(window: ?*GdkWindow, src_x: gint, src_y: gint, width: gint, height: gint) ?*GdkPixbuf;
pub extern fn gdk_pixbuf_get_from_surface(surface: ?*cairo_surface_t, src_x: gint, src_y: gint, width: gint, height: gint) ?*GdkPixbuf;
pub const struct__PangoCairoFont = @OpaqueType();
pub const PangoCairoFont = struct__PangoCairoFont;
pub const struct__PangoCairoFontMap = @OpaqueType();
pub const PangoCairoFontMap = struct__PangoCairoFontMap;
pub const PangoCairoShapeRendererFunc = ?extern fn (?*cairo_t, [*c]PangoAttrShape, gboolean, gpointer) void;
pub extern fn pango_cairo_font_map_get_type() GType;
pub extern fn pango_cairo_font_map_new() ?*PangoFontMap;
pub extern fn pango_cairo_font_map_new_for_font_type(fonttype: cairo_font_type_t) ?*PangoFontMap;
pub extern fn pango_cairo_font_map_get_default() ?*PangoFontMap;
pub extern fn pango_cairo_font_map_set_default(fontmap: ?*PangoCairoFontMap) void;
pub extern fn pango_cairo_font_map_get_font_type(fontmap: ?*PangoCairoFontMap) cairo_font_type_t;
pub extern fn pango_cairo_font_map_set_resolution(fontmap: ?*PangoCairoFontMap, dpi: f64) void;
pub extern fn pango_cairo_font_map_get_resolution(fontmap: ?*PangoCairoFontMap) f64;
pub extern fn pango_cairo_font_map_create_context(fontmap: ?*PangoCairoFontMap) ?*PangoContext;
pub extern fn pango_cairo_font_get_type() GType;
pub extern fn pango_cairo_font_get_scaled_font(font: ?*PangoCairoFont) ?*cairo_scaled_font_t;
pub extern fn pango_cairo_update_context(cr: ?*cairo_t, context: ?*PangoContext) void;
pub extern fn pango_cairo_context_set_font_options(context: ?*PangoContext, options: ?*const cairo_font_options_t) void;
pub extern fn pango_cairo_context_get_font_options(context: ?*PangoContext) ?*const cairo_font_options_t;
pub extern fn pango_cairo_context_set_resolution(context: ?*PangoContext, dpi: f64) void;
pub extern fn pango_cairo_context_get_resolution(context: ?*PangoContext) f64;
pub extern fn pango_cairo_context_set_shape_renderer(context: ?*PangoContext, func: PangoCairoShapeRendererFunc, data: gpointer, dnotify: GDestroyNotify) void;
pub extern fn pango_cairo_context_get_shape_renderer(context: ?*PangoContext, data: [*c]gpointer) PangoCairoShapeRendererFunc;
pub extern fn pango_cairo_create_context(cr: ?*cairo_t) ?*PangoContext;
pub extern fn pango_cairo_create_layout(cr: ?*cairo_t) ?*PangoLayout;
pub extern fn pango_cairo_update_layout(cr: ?*cairo_t, layout: ?*PangoLayout) void;
pub extern fn pango_cairo_show_glyph_string(cr: ?*cairo_t, font: ?*PangoFont, glyphs: [*c]PangoGlyphString) void;
pub extern fn pango_cairo_show_glyph_item(cr: ?*cairo_t, text: [*c]const u8, glyph_item: [*c]PangoGlyphItem) void;
pub extern fn pango_cairo_show_layout_line(cr: ?*cairo_t, line: ?*PangoLayoutLine) void;
pub extern fn pango_cairo_show_layout(cr: ?*cairo_t, layout: ?*PangoLayout) void;
pub extern fn pango_cairo_show_error_underline(cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn pango_cairo_glyph_string_path(cr: ?*cairo_t, font: ?*PangoFont, glyphs: [*c]PangoGlyphString) void;
pub extern fn pango_cairo_layout_line_path(cr: ?*cairo_t, line: ?*PangoLayoutLine) void;
pub extern fn pango_cairo_layout_path(cr: ?*cairo_t, layout: ?*PangoLayout) void;
pub extern fn pango_cairo_error_underline_path(cr: ?*cairo_t, x: f64, y: f64, width: f64, height: f64) void;
pub extern fn gdk_cairo_create(window: ?*GdkWindow) ?*cairo_t;
pub extern fn gdk_cairo_get_clip_rectangle(cr: ?*cairo_t, rect: [*c]GdkRectangle) gboolean;
pub extern fn gdk_cairo_set_source_rgba(cr: ?*cairo_t, rgba: [*c]const GdkRGBA) void;
pub extern fn gdk_cairo_set_source_pixbuf(cr: ?*cairo_t, pixbuf: ?*const GdkPixbuf, pixbuf_x: gdouble, pixbuf_y: gdouble) void;
pub extern fn gdk_cairo_set_source_window(cr: ?*cairo_t, window: ?*GdkWindow, x: gdouble, y: gdouble) void;
pub extern fn gdk_cairo_rectangle(cr: ?*cairo_t, rectangle: [*c]const GdkRectangle) void;
pub extern fn gdk_cairo_region(cr: ?*cairo_t, region: ?*const cairo_region_t) void;
pub extern fn gdk_cairo_region_create_from_surface(surface: ?*cairo_surface_t) ?*cairo_region_t;
pub extern fn gdk_cairo_set_source_color(cr: ?*cairo_t, color: [*c]const GdkColor) void;
pub extern fn gdk_cairo_surface_create_from_pixbuf(pixbuf: ?*const GdkPixbuf, scale: c_int, for_window: ?*GdkWindow) ?*cairo_surface_t;
pub extern fn gdk_cairo_draw_from_gl(cr: ?*cairo_t, window: ?*GdkWindow, source: c_int, source_type: c_int, buffer_scale: c_int, x: c_int, y: c_int, width: c_int, height: c_int) void;
pub extern fn gdk_cairo_get_drawing_context(cr: ?*cairo_t) ?*GdkDrawingContext;
pub const GDK_X_CURSOR = 0;
pub const GDK_ARROW = 2;
pub const GDK_BASED_ARROW_DOWN = 4;
pub const GDK_BASED_ARROW_UP = 6;
pub const GDK_BOAT = 8;
pub const GDK_BOGOSITY = 10;
pub const GDK_BOTTOM_LEFT_CORNER = 12;
pub const GDK_BOTTOM_RIGHT_CORNER = 14;
pub const GDK_BOTTOM_SIDE = 16;
pub const GDK_BOTTOM_TEE = 18;
pub const GDK_BOX_SPIRAL = 20;
pub const GDK_CENTER_PTR = 22;
pub const GDK_CIRCLE = 24;
pub const GDK_CLOCK = 26;
pub const GDK_COFFEE_MUG = 28;
pub const GDK_CROSS = 30;
pub const GDK_CROSS_REVERSE = 32;
pub const GDK_CROSSHAIR = 34;
pub const GDK_DIAMOND_CROSS = 36;
pub const GDK_DOT = 38;
pub const GDK_DOTBOX = 40;
pub const GDK_DOUBLE_ARROW = 42;
pub const GDK_DRAFT_LARGE = 44;
pub const GDK_DRAFT_SMALL = 46;
pub const GDK_DRAPED_BOX = 48;
pub const GDK_EXCHANGE = 50;
pub const GDK_FLEUR = 52;
pub const GDK_GOBBLER = 54;
pub const GDK_GUMBY = 56;
pub const GDK_HAND1 = 58;
pub const GDK_HAND2 = 60;
pub const GDK_HEART = 62;
pub const GDK_ICON = 64;
pub const GDK_IRON_CROSS = 66;
pub const GDK_LEFT_PTR = 68;
pub const GDK_LEFT_SIDE = 70;
pub const GDK_LEFT_TEE = 72;
pub const GDK_LEFTBUTTON = 74;
pub const GDK_LL_ANGLE = 76;
pub const GDK_LR_ANGLE = 78;
pub const GDK_MAN = 80;
pub const GDK_MIDDLEBUTTON = 82;
pub const GDK_MOUSE = 84;
pub const GDK_PENCIL = 86;
pub const GDK_PIRATE = 88;
pub const GDK_PLUS = 90;
pub const GDK_QUESTION_ARROW = 92;
pub const GDK_RIGHT_PTR = 94;
pub const GDK_RIGHT_SIDE = 96;
pub const GDK_RIGHT_TEE = 98;
pub const GDK_RIGHTBUTTON = 100;
pub const GDK_RTL_LOGO = 102;
pub const GDK_SAILBOAT = 104;
pub const GDK_SB_DOWN_ARROW = 106;
pub const GDK_SB_H_DOUBLE_ARROW = 108;
pub const GDK_SB_LEFT_ARROW = 110;
pub const GDK_SB_RIGHT_ARROW = 112;
pub const GDK_SB_UP_ARROW = 114;
pub const GDK_SB_V_DOUBLE_ARROW = 116;
pub const GDK_SHUTTLE = 118;
pub const GDK_SIZING = 120;
pub const GDK_SPIDER = 122;
pub const GDK_SPRAYCAN = 124;
pub const GDK_STAR = 126;
pub const GDK_TARGET = 128;
pub const GDK_TCROSS = 130;
pub const GDK_TOP_LEFT_ARROW = 132;
pub const GDK_TOP_LEFT_CORNER = 134;
pub const GDK_TOP_RIGHT_CORNER = 136;
pub const GDK_TOP_SIDE = 138;
pub const GDK_TOP_TEE = 140;
pub const GDK_TREK = 142;
pub const GDK_UL_ANGLE = 144;
pub const GDK_UMBRELLA = 146;
pub const GDK_UR_ANGLE = 148;
pub const GDK_WATCH = 150;
pub const GDK_XTERM = 152;
pub const GDK_LAST_CURSOR = 153;
pub const GDK_BLANK_CURSOR = -2;
pub const GDK_CURSOR_IS_PIXMAP = -1;
pub const GdkCursorType = extern enum {
    GDK_X_CURSOR = 0,
    GDK_ARROW = 2,
    GDK_BASED_ARROW_DOWN = 4,
    GDK_BASED_ARROW_UP = 6,
    GDK_BOAT = 8,
    GDK_BOGOSITY = 10,
    GDK_BOTTOM_LEFT_CORNER = 12,
    GDK_BOTTOM_RIGHT_CORNER = 14,
    GDK_BOTTOM_SIDE = 16,
    GDK_BOTTOM_TEE = 18,
    GDK_BOX_SPIRAL = 20,
    GDK_CENTER_PTR = 22,
    GDK_CIRCLE = 24,
    GDK_CLOCK = 26,
    GDK_COFFEE_MUG = 28,
    GDK_CROSS = 30,
    GDK_CROSS_REVERSE = 32,
    GDK_CROSSHAIR = 34,
    GDK_DIAMOND_CROSS = 36,
    GDK_DOT = 38,
    GDK_DOTBOX = 40,
    GDK_DOUBLE_ARROW = 42,
    GDK_DRAFT_LARGE = 44,
    GDK_DRAFT_SMALL = 46,
    GDK_DRAPED_BOX = 48,
    GDK_EXCHANGE = 50,
    GDK_FLEUR = 52,
    GDK_GOBBLER = 54,
    GDK_GUMBY = 56,
    GDK_HAND1 = 58,
    GDK_HAND2 = 60,
    GDK_HEART = 62,
    GDK_ICON = 64,
    GDK_IRON_CROSS = 66,
    GDK_LEFT_PTR = 68,
    GDK_LEFT_SIDE = 70,
    GDK_LEFT_TEE = 72,
    GDK_LEFTBUTTON = 74,
    GDK_LL_ANGLE = 76,
    GDK_LR_ANGLE = 78,
    GDK_MAN = 80,
    GDK_MIDDLEBUTTON = 82,
    GDK_MOUSE = 84,
    GDK_PENCIL = 86,
    GDK_PIRATE = 88,
    GDK_PLUS = 90,
    GDK_QUESTION_ARROW = 92,
    GDK_RIGHT_PTR = 94,
    GDK_RIGHT_SIDE = 96,
    GDK_RIGHT_TEE = 98,
    GDK_RIGHTBUTTON = 100,
    GDK_RTL_LOGO = 102,
    GDK_SAILBOAT = 104,
    GDK_SB_DOWN_ARROW = 106,
    GDK_SB_H_DOUBLE_ARROW = 108,
    GDK_SB_LEFT_ARROW = 110,
    GDK_SB_RIGHT_ARROW = 112,
    GDK_SB_UP_ARROW = 114,
    GDK_SB_V_DOUBLE_ARROW = 116,
    GDK_SHUTTLE = 118,
    GDK_SIZING = 120,
    GDK_SPIDER = 122,
    GDK_SPRAYCAN = 124,
    GDK_STAR = 126,
    GDK_TARGET = 128,
    GDK_TCROSS = 130,
    GDK_TOP_LEFT_ARROW = 132,
    GDK_TOP_LEFT_CORNER = 134,
    GDK_TOP_RIGHT_CORNER = 136,
    GDK_TOP_SIDE = 138,
    GDK_TOP_TEE = 140,
    GDK_TREK = 142,
    GDK_UL_ANGLE = 144,
    GDK_UMBRELLA = 146,
    GDK_UR_ANGLE = 148,
    GDK_WATCH = 150,
    GDK_XTERM = 152,
    GDK_LAST_CURSOR = 153,
    GDK_BLANK_CURSOR = -2,
    GDK_CURSOR_IS_PIXMAP = -1,
};
pub extern fn gdk_cursor_get_type() GType;
pub extern fn gdk_cursor_new_for_display(display: ?*GdkDisplay, cursor_type: GdkCursorType) ?*GdkCursor;
pub extern fn gdk_cursor_new(cursor_type: GdkCursorType) ?*GdkCursor;
pub extern fn gdk_cursor_new_from_pixbuf(display: ?*GdkDisplay, pixbuf: ?*GdkPixbuf, x: gint, y: gint) ?*GdkCursor;
pub extern fn gdk_cursor_new_from_surface(display: ?*GdkDisplay, surface: ?*cairo_surface_t, x: gdouble, y: gdouble) ?*GdkCursor;
pub extern fn gdk_cursor_new_from_name(display: ?*GdkDisplay, name: [*c]const gchar) ?*GdkCursor;
pub extern fn gdk_cursor_get_display(cursor: ?*GdkCursor) ?*GdkDisplay;
pub extern fn gdk_cursor_ref(cursor: ?*GdkCursor) ?*GdkCursor;
pub extern fn gdk_cursor_unref(cursor: ?*GdkCursor) void;
pub extern fn gdk_cursor_get_image(cursor: ?*GdkCursor) ?*GdkPixbuf;
pub extern fn gdk_cursor_get_surface(cursor: ?*GdkCursor, x_hot: [*c]gdouble, y_hot: [*c]gdouble) ?*cairo_surface_t;
pub extern fn gdk_cursor_get_cursor_type(cursor: ?*GdkCursor) GdkCursorType;
pub const struct__GdkDevicePad = @OpaqueType();
pub const GdkDevicePad = struct__GdkDevicePad;
pub const struct__GdkDevicePadInterface = @OpaqueType();
pub const GdkDevicePadInterface = struct__GdkDevicePadInterface;
pub const GDK_DEVICE_PAD_FEATURE_BUTTON = 0;
pub const GDK_DEVICE_PAD_FEATURE_RING = 1;
pub const GDK_DEVICE_PAD_FEATURE_STRIP = 2;
pub const GdkDevicePadFeature = extern enum {
    GDK_DEVICE_PAD_FEATURE_BUTTON = 0,
    GDK_DEVICE_PAD_FEATURE_RING = 1,
    GDK_DEVICE_PAD_FEATURE_STRIP = 2,
};
pub extern fn gdk_device_pad_get_type() GType;
pub extern fn gdk_device_pad_get_n_groups(pad: ?*GdkDevicePad) gint;
pub extern fn gdk_device_pad_get_group_n_modes(pad: ?*GdkDevicePad, group_idx: gint) gint;
pub extern fn gdk_device_pad_get_n_features(pad: ?*GdkDevicePad, feature: GdkDevicePadFeature) gint;
pub extern fn gdk_device_pad_get_feature_group(pad: ?*GdkDevicePad, feature: GdkDevicePadFeature, feature_idx: gint) gint;
pub extern fn gdk_display_manager_get_type() GType;
pub extern fn gdk_display_manager_get() ?*GdkDisplayManager;
pub extern fn gdk_display_manager_get_default_display(manager: ?*GdkDisplayManager) ?*GdkDisplay;
pub extern fn gdk_display_manager_set_default_display(manager: ?*GdkDisplayManager, display: ?*GdkDisplay) void;
pub extern fn gdk_display_manager_list_displays(manager: ?*GdkDisplayManager) [*c]GSList;
pub extern fn gdk_display_manager_open_display(manager: ?*GdkDisplayManager, name: [*c]const gchar) ?*GdkDisplay;
pub extern fn gdk_cursor_type_get_type() GType;
pub extern fn gdk_input_source_get_type() GType;
pub extern fn gdk_input_mode_get_type() GType;
pub extern fn gdk_device_type_get_type() GType;
pub extern fn gdk_device_pad_feature_get_type() GType;
pub extern fn gdk_device_tool_type_get_type() GType;
pub extern fn gdk_drag_action_get_type() GType;
pub extern fn gdk_drag_cancel_reason_get_type() GType;
pub extern fn gdk_drag_protocol_get_type() GType;
pub extern fn gdk_filter_return_get_type() GType;
pub extern fn gdk_event_type_get_type() GType;
pub extern fn gdk_visibility_state_get_type() GType;
pub extern fn gdk_touchpad_gesture_phase_get_type() GType;
pub extern fn gdk_scroll_direction_get_type() GType;
pub extern fn gdk_notify_type_get_type() GType;
pub extern fn gdk_crossing_mode_get_type() GType;
pub extern fn gdk_property_state_get_type() GType;
pub extern fn gdk_window_state_get_type() GType;
pub extern fn gdk_setting_action_get_type() GType;
pub extern fn gdk_owner_change_get_type() GType;
pub extern fn gdk_frame_clock_phase_get_type() GType;
pub extern fn gdk_subpixel_layout_get_type() GType;
pub extern fn gdk_prop_mode_get_type() GType;
pub extern fn gdk_seat_capabilities_get_type() GType;
pub extern fn gdk_byte_order_get_type() GType;
pub extern fn gdk_modifier_type_get_type() GType;
pub extern fn gdk_modifier_intent_get_type() GType;
pub extern fn gdk_status_get_type() GType;
pub extern fn gdk_grab_status_get_type() GType;
pub extern fn gdk_grab_ownership_get_type() GType;
pub extern fn gdk_event_mask_get_type() GType;
pub extern fn gdk_gl_error_get_type() GType;
pub extern fn gdk_window_type_hint_get_type() GType;
pub extern fn gdk_axis_use_get_type() GType;
pub extern fn gdk_axis_flags_get_type() GType;
pub extern fn gdk_visual_type_get_type() GType;
pub extern fn gdk_window_window_class_get_type() GType;
pub extern fn gdk_window_type_get_type() GType;
pub extern fn gdk_window_attributes_type_get_type() GType;
pub extern fn gdk_window_hints_get_type() GType;
pub extern fn gdk_wm_decoration_get_type() GType;
pub extern fn gdk_wm_function_get_type() GType;
pub extern fn gdk_gravity_get_type() GType;
pub extern fn gdk_anchor_hints_get_type() GType;
pub extern fn gdk_window_edge_get_type() GType;
pub extern fn gdk_fullscreen_mode_get_type() GType;
pub extern fn gdk_gl_error_quark() GQuark;
pub extern fn gdk_gl_context_get_type() GType;
pub extern fn gdk_gl_context_get_display(context: ?*GdkGLContext) ?*GdkDisplay;
pub extern fn gdk_gl_context_get_window(context: ?*GdkGLContext) ?*GdkWindow;
pub extern fn gdk_gl_context_get_shared_context(context: ?*GdkGLContext) ?*GdkGLContext;
pub extern fn gdk_gl_context_get_version(context: ?*GdkGLContext, major: [*c]c_int, minor: [*c]c_int) void;
pub extern fn gdk_gl_context_is_legacy(context: ?*GdkGLContext) gboolean;
pub extern fn gdk_gl_context_set_required_version(context: ?*GdkGLContext, major: c_int, minor: c_int) void;
pub extern fn gdk_gl_context_get_required_version(context: ?*GdkGLContext, major: [*c]c_int, minor: [*c]c_int) void;
pub extern fn gdk_gl_context_set_debug_enabled(context: ?*GdkGLContext, enabled: gboolean) void;
pub extern fn gdk_gl_context_get_debug_enabled(context: ?*GdkGLContext) gboolean;
pub extern fn gdk_gl_context_set_forward_compatible(context: ?*GdkGLContext, compatible: gboolean) void;
pub extern fn gdk_gl_context_get_forward_compatible(context: ?*GdkGLContext) gboolean;
pub extern fn gdk_gl_context_set_use_es(context: ?*GdkGLContext, use_es: c_int) void;
pub extern fn gdk_gl_context_get_use_es(context: ?*GdkGLContext) gboolean;
pub extern fn gdk_gl_context_realize(context: ?*GdkGLContext, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gdk_gl_context_make_current(context: ?*GdkGLContext) void;
pub extern fn gdk_gl_context_get_current() ?*GdkGLContext;
pub extern fn gdk_gl_context_clear_current() void;
pub const struct__GdkKeymapKey = extern struct {
    keycode: guint,
    group: gint,
    level: gint,
};
pub const GdkKeymapKey = struct__GdkKeymapKey;
pub extern fn gdk_keymap_get_type() GType;
pub extern fn gdk_keymap_get_default() ?*GdkKeymap;
pub extern fn gdk_keymap_get_for_display(display: ?*GdkDisplay) ?*GdkKeymap;
pub extern fn gdk_keymap_lookup_key(keymap: ?*GdkKeymap, key: [*c]const GdkKeymapKey) guint;
pub extern fn gdk_keymap_translate_keyboard_state(keymap: ?*GdkKeymap, hardware_keycode: guint, state: GdkModifierType, group: gint, keyval: [*c]guint, effective_group: [*c]gint, level: [*c]gint, consumed_modifiers: [*c]GdkModifierType) gboolean;
pub extern fn gdk_keymap_get_entries_for_keyval(keymap: ?*GdkKeymap, keyval: guint, keys: [*c]([*c]GdkKeymapKey), n_keys: [*c]gint) gboolean;
pub extern fn gdk_keymap_get_entries_for_keycode(keymap: ?*GdkKeymap, hardware_keycode: guint, keys: [*c]([*c]GdkKeymapKey), keyvals: [*c]([*c]guint), n_entries: [*c]gint) gboolean;
pub extern fn gdk_keymap_get_direction(keymap: ?*GdkKeymap) PangoDirection;
pub extern fn gdk_keymap_have_bidi_layouts(keymap: ?*GdkKeymap) gboolean;
pub extern fn gdk_keymap_get_caps_lock_state(keymap: ?*GdkKeymap) gboolean;
pub extern fn gdk_keymap_get_num_lock_state(keymap: ?*GdkKeymap) gboolean;
pub extern fn gdk_keymap_get_scroll_lock_state(keymap: ?*GdkKeymap) gboolean;
pub extern fn gdk_keymap_get_modifier_state(keymap: ?*GdkKeymap) guint;
pub extern fn gdk_keymap_add_virtual_modifiers(keymap: ?*GdkKeymap, state: [*c]GdkModifierType) void;
pub extern fn gdk_keymap_map_virtual_modifiers(keymap: ?*GdkKeymap, state: [*c]GdkModifierType) gboolean;
pub extern fn gdk_keymap_get_modifier_mask(keymap: ?*GdkKeymap, intent: GdkModifierIntent) GdkModifierType;
pub extern fn gdk_keyval_name(keyval: guint) [*c]gchar;
pub extern fn gdk_keyval_from_name(keyval_name: [*c]const gchar) guint;
pub extern fn gdk_keyval_convert_case(symbol: guint, lower: [*c]guint, upper: [*c]guint) void;
pub extern fn gdk_keyval_to_upper(keyval: guint) guint;
pub extern fn gdk_keyval_to_lower(keyval: guint) guint;
pub extern fn gdk_keyval_is_upper(keyval: guint) gboolean;
pub extern fn gdk_keyval_is_lower(keyval: guint) gboolean;
pub extern fn gdk_keyval_to_unicode(keyval: guint) guint32;
pub extern fn gdk_unicode_to_keyval(wc: guint32) guint;
pub extern fn gdk_parse_args(argc: [*c]gint, argv: [*c]([*c]([*c]gchar))) void;
pub extern fn gdk_init(argc: [*c]gint, argv: [*c]([*c]([*c]gchar))) void;
pub extern fn gdk_init_check(argc: [*c]gint, argv: [*c]([*c]([*c]gchar))) gboolean;
pub extern fn gdk_add_option_entries_libgtk_only(group: ?*GOptionGroup) void;
pub extern fn gdk_pre_parse_libgtk_only() void;
pub extern fn gdk_get_program_class() [*c]const gchar;
pub extern fn gdk_set_program_class(program_class: [*c]const gchar) void;
pub extern fn gdk_notify_startup_complete() void;
pub extern fn gdk_notify_startup_complete_with_id(startup_id: [*c]const gchar) void;
pub extern fn gdk_error_trap_push() void;
pub extern fn gdk_error_trap_pop() gint;
pub extern fn gdk_error_trap_pop_ignored() void;
pub extern fn gdk_get_display_arg_name() [*c]const gchar;
pub extern fn gdk_get_display() [*c]gchar;
pub extern fn gdk_pointer_grab(window: ?*GdkWindow, owner_events: gboolean, event_mask: GdkEventMask, confine_to: ?*GdkWindow, cursor: ?*GdkCursor, time_: guint32) GdkGrabStatus;
pub extern fn gdk_keyboard_grab(window: ?*GdkWindow, owner_events: gboolean, time_: guint32) GdkGrabStatus;
pub extern fn gdk_pointer_ungrab(time_: guint32) void;
pub extern fn gdk_keyboard_ungrab(time_: guint32) void;
pub extern fn gdk_pointer_is_grabbed() gboolean;
pub extern fn gdk_screen_width() gint;
pub extern fn gdk_screen_height() gint;
pub extern fn gdk_screen_width_mm() gint;
pub extern fn gdk_screen_height_mm() gint;
pub extern fn gdk_set_double_click_time(msec: guint) void;
pub extern fn gdk_beep() void;
pub extern fn gdk_flush() void;
pub extern fn gdk_disable_multidevice() void;
pub extern fn gdk_set_allowed_backends(backends: [*c]const gchar) void;
pub extern fn gdk_pango_context_get_for_screen(screen: ?*GdkScreen) ?*PangoContext;
pub extern fn gdk_pango_context_get_for_display(display: ?*GdkDisplay) ?*PangoContext;
pub extern fn gdk_pango_context_get() ?*PangoContext;
pub extern fn gdk_pango_layout_line_get_clip_region(line: ?*PangoLayoutLine, x_origin: gint, y_origin: gint, index_ranges: [*c]const gint, n_ranges: gint) ?*cairo_region_t;
pub extern fn gdk_pango_layout_get_clip_region(layout: ?*PangoLayout, x_origin: gint, y_origin: gint, index_ranges: [*c]const gint, n_ranges: gint) ?*cairo_region_t;
pub const GDK_PROP_MODE_REPLACE = 0;
pub const GDK_PROP_MODE_PREPEND = 1;
pub const GDK_PROP_MODE_APPEND = 2;
pub const GdkPropMode = extern enum {
    GDK_PROP_MODE_REPLACE = 0,
    GDK_PROP_MODE_PREPEND = 1,
    GDK_PROP_MODE_APPEND = 2,
};
pub extern fn gdk_atom_intern(atom_name: [*c]const gchar, only_if_exists: gboolean) GdkAtom;
pub extern fn gdk_atom_intern_static_string(atom_name: [*c]const gchar) GdkAtom;
pub extern fn gdk_atom_name(atom: GdkAtom) [*c]gchar;
pub extern fn gdk_property_get(window: ?*GdkWindow, property: GdkAtom, type_0: GdkAtom, offset: gulong, length: gulong, pdelete: gint, actual_property_type: [*c]GdkAtom, actual_format: [*c]gint, actual_length: [*c]gint, data: [*c]([*c]guchar)) gboolean;
pub extern fn gdk_property_change(window: ?*GdkWindow, property: GdkAtom, type_0: GdkAtom, format: gint, mode: GdkPropMode, data: [*c]const guchar, nelements: gint) void;
pub extern fn gdk_property_delete(window: ?*GdkWindow, property: GdkAtom) void;
pub extern fn gdk_text_property_to_utf8_list_for_display(display: ?*GdkDisplay, encoding: GdkAtom, format: gint, text: [*c]const guchar, length: gint, list: [*c]([*c]([*c]gchar))) gint;
pub extern fn gdk_utf8_to_string_target(str: [*c]const gchar) [*c]gchar;
pub extern fn gdk_selection_owner_set(owner: ?*GdkWindow, selection: GdkAtom, time_: guint32, send_event: gboolean) gboolean;
pub extern fn gdk_selection_owner_get(selection: GdkAtom) ?*GdkWindow;
pub extern fn gdk_selection_owner_set_for_display(display: ?*GdkDisplay, owner: ?*GdkWindow, selection: GdkAtom, time_: guint32, send_event: gboolean) gboolean;
pub extern fn gdk_selection_owner_get_for_display(display: ?*GdkDisplay, selection: GdkAtom) ?*GdkWindow;
pub extern fn gdk_selection_convert(requestor: ?*GdkWindow, selection: GdkAtom, target: GdkAtom, time_: guint32) void;
pub extern fn gdk_selection_property_get(requestor: ?*GdkWindow, data: [*c]([*c]guchar), prop_type: [*c]GdkAtom, prop_format: [*c]gint) gint;
pub extern fn gdk_selection_send_notify(requestor: ?*GdkWindow, selection: GdkAtom, target: GdkAtom, property: GdkAtom, time_: guint32) void;
pub extern fn gdk_selection_send_notify_for_display(display: ?*GdkDisplay, requestor: ?*GdkWindow, selection: GdkAtom, target: GdkAtom, property: GdkAtom, time_: guint32) void;
pub extern fn gdk_test_render_sync(window: ?*GdkWindow) void;
pub extern fn gdk_test_simulate_key(window: ?*GdkWindow, x: gint, y: gint, keyval: guint, modifiers: GdkModifierType, key_pressrelease: GdkEventType) gboolean;
pub extern fn gdk_test_simulate_button(window: ?*GdkWindow, x: gint, y: gint, button: guint, modifiers: GdkModifierType, button_pressrelease: GdkEventType) gboolean;
pub extern fn gdk_threads_init() void;
pub extern fn gdk_threads_enter() void;
pub extern fn gdk_threads_leave() void;
pub extern fn gdk_threads_set_lock_functions(enter_fn: GCallback, leave_fn: GCallback) void;
pub extern fn gdk_threads_add_idle_full(priority: gint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn gdk_threads_add_idle(function: GSourceFunc, data: gpointer) guint;
pub extern fn gdk_threads_add_timeout_full(priority: gint, interval: guint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn gdk_threads_add_timeout(interval: guint, function: GSourceFunc, data: gpointer) guint;
pub extern fn gdk_threads_add_timeout_seconds_full(priority: gint, interval: guint, function: GSourceFunc, data: gpointer, notify: GDestroyNotify) guint;
pub extern fn gdk_threads_add_timeout_seconds(interval: guint, function: GSourceFunc, data: gpointer) guint;
pub const GDK_VISUAL_STATIC_GRAY = 0;
pub const GDK_VISUAL_GRAYSCALE = 1;
pub const GDK_VISUAL_STATIC_COLOR = 2;
pub const GDK_VISUAL_PSEUDO_COLOR = 3;
pub const GDK_VISUAL_TRUE_COLOR = 4;
pub const GDK_VISUAL_DIRECT_COLOR = 5;
pub const GdkVisualType = extern enum {
    GDK_VISUAL_STATIC_GRAY = 0,
    GDK_VISUAL_GRAYSCALE = 1,
    GDK_VISUAL_STATIC_COLOR = 2,
    GDK_VISUAL_PSEUDO_COLOR = 3,
    GDK_VISUAL_TRUE_COLOR = 4,
    GDK_VISUAL_DIRECT_COLOR = 5,
};
pub extern fn gdk_visual_get_type() GType;
pub extern fn gdk_visual_get_best_depth() gint;
pub extern fn gdk_visual_get_best_type() GdkVisualType;
pub extern fn gdk_visual_get_system() ?*GdkVisual;
pub extern fn gdk_visual_get_best() ?*GdkVisual;
pub extern fn gdk_visual_get_best_with_depth(depth: gint) ?*GdkVisual;
pub extern fn gdk_visual_get_best_with_type(visual_type: GdkVisualType) ?*GdkVisual;
pub extern fn gdk_visual_get_best_with_both(depth: gint, visual_type: GdkVisualType) ?*GdkVisual;
pub extern fn gdk_query_depths(depths: [*c]([*c]gint), count: [*c]gint) void;
pub extern fn gdk_query_visual_types(visual_types: [*c]([*c]GdkVisualType), count: [*c]gint) void;
pub extern fn gdk_list_visuals() [*c]GList;
pub extern fn gdk_visual_get_screen(visual: ?*GdkVisual) ?*GdkScreen;
pub extern fn gdk_visual_get_visual_type(visual: ?*GdkVisual) GdkVisualType;
pub extern fn gdk_visual_get_depth(visual: ?*GdkVisual) gint;
pub extern fn gdk_visual_get_byte_order(visual: ?*GdkVisual) GdkByteOrder;
pub extern fn gdk_visual_get_colormap_size(visual: ?*GdkVisual) gint;
pub extern fn gdk_visual_get_bits_per_rgb(visual: ?*GdkVisual) gint;
pub extern fn gdk_visual_get_red_pixel_details(visual: ?*GdkVisual, mask: [*c]guint32, shift: [*c]gint, precision: [*c]gint) void;
pub extern fn gdk_visual_get_green_pixel_details(visual: ?*GdkVisual, mask: [*c]guint32, shift: [*c]gint, precision: [*c]gint) void;
pub extern fn gdk_visual_get_blue_pixel_details(visual: ?*GdkVisual, mask: [*c]guint32, shift: [*c]gint, precision: [*c]gint) void;
pub const GdkAppLaunchContext_autoptr = ?*GdkAppLaunchContext;
pub const GdkAppLaunchContext_listautoptr = [*c]GList;
pub const GdkAppLaunchContext_slistautoptr = [*c]GSList;
pub const GdkAppLaunchContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkAppLaunchContext(_ptr: ?*GdkAppLaunchContext) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkAppLaunchContext(_ptr: [*c](?*GdkAppLaunchContext)) void {
    glib_autoptr_clear_GdkAppLaunchContext(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkAppLaunchContext(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkAppLaunchContext(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkAppLaunchContext(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkCursor_autoptr = ?*GdkCursor;
pub const GdkCursor_listautoptr = [*c]GList;
pub const GdkCursor_slistautoptr = [*c]GSList;
pub const GdkCursor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkCursor(_ptr: ?*GdkCursor) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkCursor(_ptr: [*c](?*GdkCursor)) void {
    glib_autoptr_clear_GdkCursor(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkCursor(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkCursor(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkCursor(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkDevice_autoptr = ?*GdkDevice;
pub const GdkDevice_listautoptr = [*c]GList;
pub const GdkDevice_slistautoptr = [*c]GSList;
pub const GdkDevice_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkDevice(_ptr: ?*GdkDevice) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkDevice(_ptr: [*c](?*GdkDevice)) void {
    glib_autoptr_clear_GdkDevice(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkDevice(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkDevice(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkDevice(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkDeviceManager_autoptr = ?*GdkDeviceManager;
pub const GdkDeviceManager_listautoptr = [*c]GList;
pub const GdkDeviceManager_slistautoptr = [*c]GSList;
pub const GdkDeviceManager_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkDeviceManager(_ptr: ?*GdkDeviceManager) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkDeviceManager(_ptr: [*c](?*GdkDeviceManager)) void {
    glib_autoptr_clear_GdkDeviceManager(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkDeviceManager(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkDeviceManager(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkDeviceManager(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkDisplay_autoptr = ?*GdkDisplay;
pub const GdkDisplay_listautoptr = [*c]GList;
pub const GdkDisplay_slistautoptr = [*c]GSList;
pub const GdkDisplay_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkDisplay(_ptr: ?*GdkDisplay) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkDisplay(_ptr: [*c](?*GdkDisplay)) void {
    glib_autoptr_clear_GdkDisplay(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkDisplay(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkDisplay(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkDisplay(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkDisplayManager_autoptr = ?*GdkDisplayManager;
pub const GdkDisplayManager_listautoptr = [*c]GList;
pub const GdkDisplayManager_slistautoptr = [*c]GSList;
pub const GdkDisplayManager_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkDisplayManager(_ptr: ?*GdkDisplayManager) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkDisplayManager(_ptr: [*c](?*GdkDisplayManager)) void {
    glib_autoptr_clear_GdkDisplayManager(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkDisplayManager(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkDisplayManager(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkDisplayManager(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkDragContext_autoptr = ?*GdkDragContext;
pub const GdkDragContext_listautoptr = [*c]GList;
pub const GdkDragContext_slistautoptr = [*c]GSList;
pub const GdkDragContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkDragContext(_ptr: ?*GdkDragContext) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkDragContext(_ptr: [*c](?*GdkDragContext)) void {
    glib_autoptr_clear_GdkDragContext(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkDragContext(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkDragContext(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkDragContext(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkFrameClock_autoptr = ?*GdkFrameClock;
pub const GdkFrameClock_listautoptr = [*c]GList;
pub const GdkFrameClock_slistautoptr = [*c]GSList;
pub const GdkFrameClock_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkFrameClock(_ptr: ?*GdkFrameClock) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkFrameClock(_ptr: [*c](?*GdkFrameClock)) void {
    glib_autoptr_clear_GdkFrameClock(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkFrameClock(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkFrameClock(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkFrameClock(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkGLContext_autoptr = ?*GdkGLContext;
pub const GdkGLContext_listautoptr = [*c]GList;
pub const GdkGLContext_slistautoptr = [*c]GSList;
pub const GdkGLContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkGLContext(_ptr: ?*GdkGLContext) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkGLContext(_ptr: [*c](?*GdkGLContext)) void {
    glib_autoptr_clear_GdkGLContext(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkGLContext(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkGLContext(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkGLContext(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkKeymap_autoptr = ?*GdkKeymap;
pub const GdkKeymap_listautoptr = [*c]GList;
pub const GdkKeymap_slistautoptr = [*c]GSList;
pub const GdkKeymap_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkKeymap(_ptr: ?*GdkKeymap) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkKeymap(_ptr: [*c](?*GdkKeymap)) void {
    glib_autoptr_clear_GdkKeymap(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkKeymap(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkKeymap(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkKeymap(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkScreen_autoptr = ?*GdkScreen;
pub const GdkScreen_listautoptr = [*c]GList;
pub const GdkScreen_slistautoptr = [*c]GSList;
pub const GdkScreen_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkScreen(_ptr: ?*GdkScreen) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkScreen(_ptr: [*c](?*GdkScreen)) void {
    glib_autoptr_clear_GdkScreen(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkScreen(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkScreen(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkScreen(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkVisual_autoptr = ?*GdkVisual;
pub const GdkVisual_listautoptr = [*c]GList;
pub const GdkVisual_slistautoptr = [*c]GSList;
pub const GdkVisual_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkVisual(_ptr: ?*GdkVisual) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkVisual(_ptr: [*c](?*GdkVisual)) void {
    glib_autoptr_clear_GdkVisual(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkVisual(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkVisual(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkVisual(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkWindow_autoptr = ?*GdkWindow;
pub const GdkWindow_listautoptr = [*c]GList;
pub const GdkWindow_slistautoptr = [*c]GSList;
pub const GdkWindow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkWindow(_ptr: ?*GdkWindow) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GdkWindow(_ptr: [*c](?*GdkWindow)) void {
    glib_autoptr_clear_GdkWindow(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkWindow(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkWindow(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkWindow(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GdkEvent_autoptr = [*c]GdkEvent;
pub const GdkEvent_listautoptr = [*c]GList;
pub const GdkEvent_slistautoptr = [*c]GSList;
pub const GdkEvent_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkEvent(_ptr: [*c]GdkEvent) void {
    if (_ptr != null) gdk_event_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GdkEvent(_ptr: [*c]([*c]GdkEvent)) void {
    glib_autoptr_clear_GdkEvent(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkEvent(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gdk_event_free)))));
}
pub fn glib_slistautoptr_cleanup_GdkEvent(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gdk_event_free)))));
}
pub fn glib_queueautoptr_cleanup_GdkEvent(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gdk_event_free)))));
}
pub const GdkFrameTimings_autoptr = ?*GdkFrameTimings;
pub const GdkFrameTimings_listautoptr = [*c]GList;
pub const GdkFrameTimings_slistautoptr = [*c]GSList;
pub const GdkFrameTimings_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkFrameTimings(_ptr: ?*GdkFrameTimings) void {
    if (_ptr != null) gdk_frame_timings_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GdkFrameTimings(_ptr: [*c](?*GdkFrameTimings)) void {
    glib_autoptr_clear_GdkFrameTimings(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkFrameTimings(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gdk_frame_timings_unref)))));
}
pub fn glib_slistautoptr_cleanup_GdkFrameTimings(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gdk_frame_timings_unref)))));
}
pub fn glib_queueautoptr_cleanup_GdkFrameTimings(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gdk_frame_timings_unref)))));
}
pub const GdkRGBA_autoptr = [*c]GdkRGBA;
pub const GdkRGBA_listautoptr = [*c]GList;
pub const GdkRGBA_slistautoptr = [*c]GSList;
pub const GdkRGBA_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GdkRGBA(_ptr: [*c]GdkRGBA) void {
    if (_ptr != null) gdk_rgba_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GdkRGBA(_ptr: [*c]([*c]GdkRGBA)) void {
    glib_autoptr_clear_GdkRGBA(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GdkRGBA(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gdk_rgba_free)))));
}
pub fn glib_slistautoptr_cleanup_GdkRGBA(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gdk_rgba_free)))));
}
pub fn glib_queueautoptr_cleanup_GdkRGBA(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gdk_rgba_free)))));
}
pub const GTK_ALIGN_FILL = 0;
pub const GTK_ALIGN_START = 1;
pub const GTK_ALIGN_END = 2;
pub const GTK_ALIGN_CENTER = 3;
pub const GTK_ALIGN_BASELINE = 4;
pub const GtkAlign = extern enum {
    GTK_ALIGN_FILL = 0,
    GTK_ALIGN_START = 1,
    GTK_ALIGN_END = 2,
    GTK_ALIGN_CENTER = 3,
    GTK_ALIGN_BASELINE = 4,
};
pub const GTK_ARROW_UP = 0;
pub const GTK_ARROW_DOWN = 1;
pub const GTK_ARROW_LEFT = 2;
pub const GTK_ARROW_RIGHT = 3;
pub const GTK_ARROW_NONE = 4;
pub const GtkArrowType = extern enum {
    GTK_ARROW_UP = 0,
    GTK_ARROW_DOWN = 1,
    GTK_ARROW_LEFT = 2,
    GTK_ARROW_RIGHT = 3,
    GTK_ARROW_NONE = 4,
};
pub const GTK_BASELINE_POSITION_TOP = 0;
pub const GTK_BASELINE_POSITION_CENTER = 1;
pub const GTK_BASELINE_POSITION_BOTTOM = 2;
pub const GtkBaselinePosition = extern enum {
    GTK_BASELINE_POSITION_TOP = 0,
    GTK_BASELINE_POSITION_CENTER = 1,
    GTK_BASELINE_POSITION_BOTTOM = 2,
};
pub const GTK_DELETE_CHARS = 0;
pub const GTK_DELETE_WORD_ENDS = 1;
pub const GTK_DELETE_WORDS = 2;
pub const GTK_DELETE_DISPLAY_LINES = 3;
pub const GTK_DELETE_DISPLAY_LINE_ENDS = 4;
pub const GTK_DELETE_PARAGRAPH_ENDS = 5;
pub const GTK_DELETE_PARAGRAPHS = 6;
pub const GTK_DELETE_WHITESPACE = 7;
pub const GtkDeleteType = extern enum {
    GTK_DELETE_CHARS = 0,
    GTK_DELETE_WORD_ENDS = 1,
    GTK_DELETE_WORDS = 2,
    GTK_DELETE_DISPLAY_LINES = 3,
    GTK_DELETE_DISPLAY_LINE_ENDS = 4,
    GTK_DELETE_PARAGRAPH_ENDS = 5,
    GTK_DELETE_PARAGRAPHS = 6,
    GTK_DELETE_WHITESPACE = 7,
};
pub const GTK_DIR_TAB_FORWARD = 0;
pub const GTK_DIR_TAB_BACKWARD = 1;
pub const GTK_DIR_UP = 2;
pub const GTK_DIR_DOWN = 3;
pub const GTK_DIR_LEFT = 4;
pub const GTK_DIR_RIGHT = 5;
pub const GtkDirectionType = extern enum {
    GTK_DIR_TAB_FORWARD = 0,
    GTK_DIR_TAB_BACKWARD = 1,
    GTK_DIR_UP = 2,
    GTK_DIR_DOWN = 3,
    GTK_DIR_LEFT = 4,
    GTK_DIR_RIGHT = 5,
};
pub const GTK_ICON_SIZE_INVALID = 0;
pub const GTK_ICON_SIZE_MENU = 1;
pub const GTK_ICON_SIZE_SMALL_TOOLBAR = 2;
pub const GTK_ICON_SIZE_LARGE_TOOLBAR = 3;
pub const GTK_ICON_SIZE_BUTTON = 4;
pub const GTK_ICON_SIZE_DND = 5;
pub const GTK_ICON_SIZE_DIALOG = 6;
pub const GtkIconSize = extern enum {
    GTK_ICON_SIZE_INVALID = 0,
    GTK_ICON_SIZE_MENU = 1,
    GTK_ICON_SIZE_SMALL_TOOLBAR = 2,
    GTK_ICON_SIZE_LARGE_TOOLBAR = 3,
    GTK_ICON_SIZE_BUTTON = 4,
    GTK_ICON_SIZE_DND = 5,
    GTK_ICON_SIZE_DIALOG = 6,
};
pub const GTK_SENSITIVITY_AUTO = 0;
pub const GTK_SENSITIVITY_ON = 1;
pub const GTK_SENSITIVITY_OFF = 2;
pub const GtkSensitivityType = extern enum {
    GTK_SENSITIVITY_AUTO = 0,
    GTK_SENSITIVITY_ON = 1,
    GTK_SENSITIVITY_OFF = 2,
};
pub const GTK_TEXT_DIR_NONE = 0;
pub const GTK_TEXT_DIR_LTR = 1;
pub const GTK_TEXT_DIR_RTL = 2;
pub const GtkTextDirection = extern enum {
    GTK_TEXT_DIR_NONE = 0,
    GTK_TEXT_DIR_LTR = 1,
    GTK_TEXT_DIR_RTL = 2,
};
pub const GTK_JUSTIFY_LEFT = 0;
pub const GTK_JUSTIFY_RIGHT = 1;
pub const GTK_JUSTIFY_CENTER = 2;
pub const GTK_JUSTIFY_FILL = 3;
pub const GtkJustification = extern enum {
    GTK_JUSTIFY_LEFT = 0,
    GTK_JUSTIFY_RIGHT = 1,
    GTK_JUSTIFY_CENTER = 2,
    GTK_JUSTIFY_FILL = 3,
};
pub const GTK_MENU_DIR_PARENT = 0;
pub const GTK_MENU_DIR_CHILD = 1;
pub const GTK_MENU_DIR_NEXT = 2;
pub const GTK_MENU_DIR_PREV = 3;
pub const GtkMenuDirectionType = extern enum {
    GTK_MENU_DIR_PARENT = 0,
    GTK_MENU_DIR_CHILD = 1,
    GTK_MENU_DIR_NEXT = 2,
    GTK_MENU_DIR_PREV = 3,
};
pub const GTK_MESSAGE_INFO = 0;
pub const GTK_MESSAGE_WARNING = 1;
pub const GTK_MESSAGE_QUESTION = 2;
pub const GTK_MESSAGE_ERROR = 3;
pub const GTK_MESSAGE_OTHER = 4;
pub const GtkMessageType = extern enum {
    GTK_MESSAGE_INFO = 0,
    GTK_MESSAGE_WARNING = 1,
    GTK_MESSAGE_QUESTION = 2,
    GTK_MESSAGE_ERROR = 3,
    GTK_MESSAGE_OTHER = 4,
};
pub const GTK_MOVEMENT_LOGICAL_POSITIONS = 0;
pub const GTK_MOVEMENT_VISUAL_POSITIONS = 1;
pub const GTK_MOVEMENT_WORDS = 2;
pub const GTK_MOVEMENT_DISPLAY_LINES = 3;
pub const GTK_MOVEMENT_DISPLAY_LINE_ENDS = 4;
pub const GTK_MOVEMENT_PARAGRAPHS = 5;
pub const GTK_MOVEMENT_PARAGRAPH_ENDS = 6;
pub const GTK_MOVEMENT_PAGES = 7;
pub const GTK_MOVEMENT_BUFFER_ENDS = 8;
pub const GTK_MOVEMENT_HORIZONTAL_PAGES = 9;
pub const GtkMovementStep = extern enum {
    GTK_MOVEMENT_LOGICAL_POSITIONS = 0,
    GTK_MOVEMENT_VISUAL_POSITIONS = 1,
    GTK_MOVEMENT_WORDS = 2,
    GTK_MOVEMENT_DISPLAY_LINES = 3,
    GTK_MOVEMENT_DISPLAY_LINE_ENDS = 4,
    GTK_MOVEMENT_PARAGRAPHS = 5,
    GTK_MOVEMENT_PARAGRAPH_ENDS = 6,
    GTK_MOVEMENT_PAGES = 7,
    GTK_MOVEMENT_BUFFER_ENDS = 8,
    GTK_MOVEMENT_HORIZONTAL_PAGES = 9,
};
pub const GTK_SCROLL_STEPS = 0;
pub const GTK_SCROLL_PAGES = 1;
pub const GTK_SCROLL_ENDS = 2;
pub const GTK_SCROLL_HORIZONTAL_STEPS = 3;
pub const GTK_SCROLL_HORIZONTAL_PAGES = 4;
pub const GTK_SCROLL_HORIZONTAL_ENDS = 5;
pub const GtkScrollStep = extern enum {
    GTK_SCROLL_STEPS = 0,
    GTK_SCROLL_PAGES = 1,
    GTK_SCROLL_ENDS = 2,
    GTK_SCROLL_HORIZONTAL_STEPS = 3,
    GTK_SCROLL_HORIZONTAL_PAGES = 4,
    GTK_SCROLL_HORIZONTAL_ENDS = 5,
};
pub const GTK_ORIENTATION_HORIZONTAL = 0;
pub const GTK_ORIENTATION_VERTICAL = 1;
pub const GtkOrientation = extern enum {
    GTK_ORIENTATION_HORIZONTAL = 0,
    GTK_ORIENTATION_VERTICAL = 1,
};
pub const GTK_PACK_START = 0;
pub const GTK_PACK_END = 1;
pub const GtkPackType = extern enum {
    GTK_PACK_START = 0,
    GTK_PACK_END = 1,
};
pub const GTK_POS_LEFT = 0;
pub const GTK_POS_RIGHT = 1;
pub const GTK_POS_TOP = 2;
pub const GTK_POS_BOTTOM = 3;
pub const GtkPositionType = extern enum {
    GTK_POS_LEFT = 0,
    GTK_POS_RIGHT = 1,
    GTK_POS_TOP = 2,
    GTK_POS_BOTTOM = 3,
};
pub const GTK_RELIEF_NORMAL = 0;
pub const GTK_RELIEF_HALF = 1;
pub const GTK_RELIEF_NONE = 2;
pub const GtkReliefStyle = extern enum {
    GTK_RELIEF_NORMAL = 0,
    GTK_RELIEF_HALF = 1,
    GTK_RELIEF_NONE = 2,
};
pub const GTK_SCROLL_NONE = 0;
pub const GTK_SCROLL_JUMP = 1;
pub const GTK_SCROLL_STEP_BACKWARD = 2;
pub const GTK_SCROLL_STEP_FORWARD = 3;
pub const GTK_SCROLL_PAGE_BACKWARD = 4;
pub const GTK_SCROLL_PAGE_FORWARD = 5;
pub const GTK_SCROLL_STEP_UP = 6;
pub const GTK_SCROLL_STEP_DOWN = 7;
pub const GTK_SCROLL_PAGE_UP = 8;
pub const GTK_SCROLL_PAGE_DOWN = 9;
pub const GTK_SCROLL_STEP_LEFT = 10;
pub const GTK_SCROLL_STEP_RIGHT = 11;
pub const GTK_SCROLL_PAGE_LEFT = 12;
pub const GTK_SCROLL_PAGE_RIGHT = 13;
pub const GTK_SCROLL_START = 14;
pub const GTK_SCROLL_END = 15;
pub const GtkScrollType = extern enum {
    GTK_SCROLL_NONE = 0,
    GTK_SCROLL_JUMP = 1,
    GTK_SCROLL_STEP_BACKWARD = 2,
    GTK_SCROLL_STEP_FORWARD = 3,
    GTK_SCROLL_PAGE_BACKWARD = 4,
    GTK_SCROLL_PAGE_FORWARD = 5,
    GTK_SCROLL_STEP_UP = 6,
    GTK_SCROLL_STEP_DOWN = 7,
    GTK_SCROLL_PAGE_UP = 8,
    GTK_SCROLL_PAGE_DOWN = 9,
    GTK_SCROLL_STEP_LEFT = 10,
    GTK_SCROLL_STEP_RIGHT = 11,
    GTK_SCROLL_PAGE_LEFT = 12,
    GTK_SCROLL_PAGE_RIGHT = 13,
    GTK_SCROLL_START = 14,
    GTK_SCROLL_END = 15,
};
pub const GTK_SELECTION_NONE = 0;
pub const GTK_SELECTION_SINGLE = 1;
pub const GTK_SELECTION_BROWSE = 2;
pub const GTK_SELECTION_MULTIPLE = 3;
pub const GtkSelectionMode = extern enum {
    GTK_SELECTION_NONE = 0,
    GTK_SELECTION_SINGLE = 1,
    GTK_SELECTION_BROWSE = 2,
    GTK_SELECTION_MULTIPLE = 3,
};
pub const GTK_SHADOW_NONE = 0;
pub const GTK_SHADOW_IN = 1;
pub const GTK_SHADOW_OUT = 2;
pub const GTK_SHADOW_ETCHED_IN = 3;
pub const GTK_SHADOW_ETCHED_OUT = 4;
pub const GtkShadowType = extern enum {
    GTK_SHADOW_NONE = 0,
    GTK_SHADOW_IN = 1,
    GTK_SHADOW_OUT = 2,
    GTK_SHADOW_ETCHED_IN = 3,
    GTK_SHADOW_ETCHED_OUT = 4,
};
pub const GTK_STATE_NORMAL = 0;
pub const GTK_STATE_ACTIVE = 1;
pub const GTK_STATE_PRELIGHT = 2;
pub const GTK_STATE_SELECTED = 3;
pub const GTK_STATE_INSENSITIVE = 4;
pub const GTK_STATE_INCONSISTENT = 5;
pub const GTK_STATE_FOCUSED = 6;
pub const GtkStateType = extern enum {
    GTK_STATE_NORMAL = 0,
    GTK_STATE_ACTIVE = 1,
    GTK_STATE_PRELIGHT = 2,
    GTK_STATE_SELECTED = 3,
    GTK_STATE_INSENSITIVE = 4,
    GTK_STATE_INCONSISTENT = 5,
    GTK_STATE_FOCUSED = 6,
};
pub const GTK_TOOLBAR_ICONS = 0;
pub const GTK_TOOLBAR_TEXT = 1;
pub const GTK_TOOLBAR_BOTH = 2;
pub const GTK_TOOLBAR_BOTH_HORIZ = 3;
pub const GtkToolbarStyle = extern enum {
    GTK_TOOLBAR_ICONS = 0,
    GTK_TOOLBAR_TEXT = 1,
    GTK_TOOLBAR_BOTH = 2,
    GTK_TOOLBAR_BOTH_HORIZ = 3,
};
pub const GTK_WRAP_NONE = 0;
pub const GTK_WRAP_CHAR = 1;
pub const GTK_WRAP_WORD = 2;
pub const GTK_WRAP_WORD_CHAR = 3;
pub const GtkWrapMode = extern enum {
    GTK_WRAP_NONE = 0,
    GTK_WRAP_CHAR = 1,
    GTK_WRAP_WORD = 2,
    GTK_WRAP_WORD_CHAR = 3,
};
pub const GTK_SORT_ASCENDING = 0;
pub const GTK_SORT_DESCENDING = 1;
pub const GtkSortType = extern enum {
    GTK_SORT_ASCENDING = 0,
    GTK_SORT_DESCENDING = 1,
};
pub const GTK_IM_PREEDIT_NOTHING = 0;
pub const GTK_IM_PREEDIT_CALLBACK = 1;
pub const GTK_IM_PREEDIT_NONE = 2;
pub const GtkIMPreeditStyle = extern enum {
    GTK_IM_PREEDIT_NOTHING = 0,
    GTK_IM_PREEDIT_CALLBACK = 1,
    GTK_IM_PREEDIT_NONE = 2,
};
pub const GTK_IM_STATUS_NOTHING = 0;
pub const GTK_IM_STATUS_CALLBACK = 1;
pub const GTK_IM_STATUS_NONE = 2;
pub const GtkIMStatusStyle = extern enum {
    GTK_IM_STATUS_NOTHING = 0,
    GTK_IM_STATUS_CALLBACK = 1,
    GTK_IM_STATUS_NONE = 2,
};
pub const GTK_PACK_DIRECTION_LTR = 0;
pub const GTK_PACK_DIRECTION_RTL = 1;
pub const GTK_PACK_DIRECTION_TTB = 2;
pub const GTK_PACK_DIRECTION_BTT = 3;
pub const GtkPackDirection = extern enum {
    GTK_PACK_DIRECTION_LTR = 0,
    GTK_PACK_DIRECTION_RTL = 1,
    GTK_PACK_DIRECTION_TTB = 2,
    GTK_PACK_DIRECTION_BTT = 3,
};
pub const GTK_PRINT_PAGES_ALL = 0;
pub const GTK_PRINT_PAGES_CURRENT = 1;
pub const GTK_PRINT_PAGES_RANGES = 2;
pub const GTK_PRINT_PAGES_SELECTION = 3;
pub const GtkPrintPages = extern enum {
    GTK_PRINT_PAGES_ALL = 0,
    GTK_PRINT_PAGES_CURRENT = 1,
    GTK_PRINT_PAGES_RANGES = 2,
    GTK_PRINT_PAGES_SELECTION = 3,
};
pub const GTK_PAGE_SET_ALL = 0;
pub const GTK_PAGE_SET_EVEN = 1;
pub const GTK_PAGE_SET_ODD = 2;
pub const GtkPageSet = extern enum {
    GTK_PAGE_SET_ALL = 0,
    GTK_PAGE_SET_EVEN = 1,
    GTK_PAGE_SET_ODD = 2,
};
pub const GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM = 0;
pub const GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP = 1;
pub const GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM = 2;
pub const GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP = 3;
pub const GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT = 4;
pub const GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT = 5;
pub const GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT = 6;
pub const GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT = 7;
pub const GtkNumberUpLayout = extern enum {
    GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_TOP_TO_BOTTOM = 0,
    GTK_NUMBER_UP_LAYOUT_LEFT_TO_RIGHT_BOTTOM_TO_TOP = 1,
    GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_TOP_TO_BOTTOM = 2,
    GTK_NUMBER_UP_LAYOUT_RIGHT_TO_LEFT_BOTTOM_TO_TOP = 3,
    GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_LEFT_TO_RIGHT = 4,
    GTK_NUMBER_UP_LAYOUT_TOP_TO_BOTTOM_RIGHT_TO_LEFT = 5,
    GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_LEFT_TO_RIGHT = 6,
    GTK_NUMBER_UP_LAYOUT_BOTTOM_TO_TOP_RIGHT_TO_LEFT = 7,
};
pub const GTK_PAGE_ORIENTATION_PORTRAIT = 0;
pub const GTK_PAGE_ORIENTATION_LANDSCAPE = 1;
pub const GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT = 2;
pub const GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE = 3;
pub const GtkPageOrientation = extern enum {
    GTK_PAGE_ORIENTATION_PORTRAIT = 0,
    GTK_PAGE_ORIENTATION_LANDSCAPE = 1,
    GTK_PAGE_ORIENTATION_REVERSE_PORTRAIT = 2,
    GTK_PAGE_ORIENTATION_REVERSE_LANDSCAPE = 3,
};
pub const GTK_PRINT_QUALITY_LOW = 0;
pub const GTK_PRINT_QUALITY_NORMAL = 1;
pub const GTK_PRINT_QUALITY_HIGH = 2;
pub const GTK_PRINT_QUALITY_DRAFT = 3;
pub const GtkPrintQuality = extern enum {
    GTK_PRINT_QUALITY_LOW = 0,
    GTK_PRINT_QUALITY_NORMAL = 1,
    GTK_PRINT_QUALITY_HIGH = 2,
    GTK_PRINT_QUALITY_DRAFT = 3,
};
pub const GTK_PRINT_DUPLEX_SIMPLEX = 0;
pub const GTK_PRINT_DUPLEX_HORIZONTAL = 1;
pub const GTK_PRINT_DUPLEX_VERTICAL = 2;
pub const GtkPrintDuplex = extern enum {
    GTK_PRINT_DUPLEX_SIMPLEX = 0,
    GTK_PRINT_DUPLEX_HORIZONTAL = 1,
    GTK_PRINT_DUPLEX_VERTICAL = 2,
};
pub const GTK_UNIT_NONE = 0;
pub const GTK_UNIT_POINTS = 1;
pub const GTK_UNIT_INCH = 2;
pub const GTK_UNIT_MM = 3;
pub const GtkUnit = extern enum {
    GTK_UNIT_NONE = 0,
    GTK_UNIT_POINTS = 1,
    GTK_UNIT_INCH = 2,
    GTK_UNIT_MM = 3,
};
pub const GTK_TREE_VIEW_GRID_LINES_NONE = 0;
pub const GTK_TREE_VIEW_GRID_LINES_HORIZONTAL = 1;
pub const GTK_TREE_VIEW_GRID_LINES_VERTICAL = 2;
pub const GTK_TREE_VIEW_GRID_LINES_BOTH = 3;
pub const GtkTreeViewGridLines = extern enum {
    GTK_TREE_VIEW_GRID_LINES_NONE = 0,
    GTK_TREE_VIEW_GRID_LINES_HORIZONTAL = 1,
    GTK_TREE_VIEW_GRID_LINES_VERTICAL = 2,
    GTK_TREE_VIEW_GRID_LINES_BOTH = 3,
};
pub const GTK_DRAG_RESULT_SUCCESS = 0;
pub const GTK_DRAG_RESULT_NO_TARGET = 1;
pub const GTK_DRAG_RESULT_USER_CANCELLED = 2;
pub const GTK_DRAG_RESULT_TIMEOUT_EXPIRED = 3;
pub const GTK_DRAG_RESULT_GRAB_BROKEN = 4;
pub const GTK_DRAG_RESULT_ERROR = 5;
pub const GtkDragResult = extern enum {
    GTK_DRAG_RESULT_SUCCESS = 0,
    GTK_DRAG_RESULT_NO_TARGET = 1,
    GTK_DRAG_RESULT_USER_CANCELLED = 2,
    GTK_DRAG_RESULT_TIMEOUT_EXPIRED = 3,
    GTK_DRAG_RESULT_GRAB_BROKEN = 4,
    GTK_DRAG_RESULT_ERROR = 5,
};
pub const GTK_SIZE_GROUP_NONE = 0;
pub const GTK_SIZE_GROUP_HORIZONTAL = 1;
pub const GTK_SIZE_GROUP_VERTICAL = 2;
pub const GTK_SIZE_GROUP_BOTH = 3;
pub const GtkSizeGroupMode = extern enum {
    GTK_SIZE_GROUP_NONE = 0,
    GTK_SIZE_GROUP_HORIZONTAL = 1,
    GTK_SIZE_GROUP_VERTICAL = 2,
    GTK_SIZE_GROUP_BOTH = 3,
};
pub const GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH = 0;
pub const GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT = 1;
pub const GTK_SIZE_REQUEST_CONSTANT_SIZE = 2;
pub const GtkSizeRequestMode = extern enum {
    GTK_SIZE_REQUEST_HEIGHT_FOR_WIDTH = 0,
    GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT = 1,
    GTK_SIZE_REQUEST_CONSTANT_SIZE = 2,
};
pub const GTK_SCROLL_MINIMUM = 0;
pub const GTK_SCROLL_NATURAL = 1;
pub const GtkScrollablePolicy = extern enum {
    GTK_SCROLL_MINIMUM = 0,
    GTK_SCROLL_NATURAL = 1,
};
pub const GTK_STATE_FLAG_NORMAL = 0;
pub const GTK_STATE_FLAG_ACTIVE = 1;
pub const GTK_STATE_FLAG_PRELIGHT = 2;
pub const GTK_STATE_FLAG_SELECTED = 4;
pub const GTK_STATE_FLAG_INSENSITIVE = 8;
pub const GTK_STATE_FLAG_INCONSISTENT = 16;
pub const GTK_STATE_FLAG_FOCUSED = 32;
pub const GTK_STATE_FLAG_BACKDROP = 64;
pub const GTK_STATE_FLAG_DIR_LTR = 128;
pub const GTK_STATE_FLAG_DIR_RTL = 256;
pub const GTK_STATE_FLAG_LINK = 512;
pub const GTK_STATE_FLAG_VISITED = 1024;
pub const GTK_STATE_FLAG_CHECKED = 2048;
pub const GTK_STATE_FLAG_DROP_ACTIVE = 4096;
pub const GtkStateFlags = extern enum {
    GTK_STATE_FLAG_NORMAL = 0,
    GTK_STATE_FLAG_ACTIVE = 1,
    GTK_STATE_FLAG_PRELIGHT = 2,
    GTK_STATE_FLAG_SELECTED = 4,
    GTK_STATE_FLAG_INSENSITIVE = 8,
    GTK_STATE_FLAG_INCONSISTENT = 16,
    GTK_STATE_FLAG_FOCUSED = 32,
    GTK_STATE_FLAG_BACKDROP = 64,
    GTK_STATE_FLAG_DIR_LTR = 128,
    GTK_STATE_FLAG_DIR_RTL = 256,
    GTK_STATE_FLAG_LINK = 512,
    GTK_STATE_FLAG_VISITED = 1024,
    GTK_STATE_FLAG_CHECKED = 2048,
    GTK_STATE_FLAG_DROP_ACTIVE = 4096,
};
pub const GTK_REGION_EVEN = 1;
pub const GTK_REGION_ODD = 2;
pub const GTK_REGION_FIRST = 4;
pub const GTK_REGION_LAST = 8;
pub const GTK_REGION_ONLY = 16;
pub const GTK_REGION_SORTED = 32;
pub const GtkRegionFlags = extern enum {
    GTK_REGION_EVEN = 1,
    GTK_REGION_ODD = 2,
    GTK_REGION_FIRST = 4,
    GTK_REGION_LAST = 8,
    GTK_REGION_ONLY = 16,
    GTK_REGION_SORTED = 32,
};
pub const GTK_JUNCTION_NONE = 0;
pub const GTK_JUNCTION_CORNER_TOPLEFT = 1;
pub const GTK_JUNCTION_CORNER_TOPRIGHT = 2;
pub const GTK_JUNCTION_CORNER_BOTTOMLEFT = 4;
pub const GTK_JUNCTION_CORNER_BOTTOMRIGHT = 8;
pub const GTK_JUNCTION_TOP = 3;
pub const GTK_JUNCTION_BOTTOM = 12;
pub const GTK_JUNCTION_LEFT = 5;
pub const GTK_JUNCTION_RIGHT = 10;
pub const GtkJunctionSides = extern enum {
    GTK_JUNCTION_NONE = 0,
    GTK_JUNCTION_CORNER_TOPLEFT = 1,
    GTK_JUNCTION_CORNER_TOPRIGHT = 2,
    GTK_JUNCTION_CORNER_BOTTOMLEFT = 4,
    GTK_JUNCTION_CORNER_BOTTOMRIGHT = 8,
    GTK_JUNCTION_TOP = 3,
    GTK_JUNCTION_BOTTOM = 12,
    GTK_JUNCTION_LEFT = 5,
    GTK_JUNCTION_RIGHT = 10,
};
pub const GTK_BORDER_STYLE_NONE = 0;
pub const GTK_BORDER_STYLE_SOLID = 1;
pub const GTK_BORDER_STYLE_INSET = 2;
pub const GTK_BORDER_STYLE_OUTSET = 3;
pub const GTK_BORDER_STYLE_HIDDEN = 4;
pub const GTK_BORDER_STYLE_DOTTED = 5;
pub const GTK_BORDER_STYLE_DASHED = 6;
pub const GTK_BORDER_STYLE_DOUBLE = 7;
pub const GTK_BORDER_STYLE_GROOVE = 8;
pub const GTK_BORDER_STYLE_RIDGE = 9;
pub const GtkBorderStyle = extern enum {
    GTK_BORDER_STYLE_NONE = 0,
    GTK_BORDER_STYLE_SOLID = 1,
    GTK_BORDER_STYLE_INSET = 2,
    GTK_BORDER_STYLE_OUTSET = 3,
    GTK_BORDER_STYLE_HIDDEN = 4,
    GTK_BORDER_STYLE_DOTTED = 5,
    GTK_BORDER_STYLE_DASHED = 6,
    GTK_BORDER_STYLE_DOUBLE = 7,
    GTK_BORDER_STYLE_GROOVE = 8,
    GTK_BORDER_STYLE_RIDGE = 9,
};
pub const GTK_LEVEL_BAR_MODE_CONTINUOUS = 0;
pub const GTK_LEVEL_BAR_MODE_DISCRETE = 1;
pub const GtkLevelBarMode = extern enum {
    GTK_LEVEL_BAR_MODE_CONTINUOUS = 0,
    GTK_LEVEL_BAR_MODE_DISCRETE = 1,
};
pub const GTK_INPUT_PURPOSE_FREE_FORM = 0;
pub const GTK_INPUT_PURPOSE_ALPHA = 1;
pub const GTK_INPUT_PURPOSE_DIGITS = 2;
pub const GTK_INPUT_PURPOSE_NUMBER = 3;
pub const GTK_INPUT_PURPOSE_PHONE = 4;
pub const GTK_INPUT_PURPOSE_URL = 5;
pub const GTK_INPUT_PURPOSE_EMAIL = 6;
pub const GTK_INPUT_PURPOSE_NAME = 7;
pub const GTK_INPUT_PURPOSE_PASSWORD = 8;
pub const GTK_INPUT_PURPOSE_PIN = 9;
pub const GtkInputPurpose = extern enum {
    GTK_INPUT_PURPOSE_FREE_FORM = 0,
    GTK_INPUT_PURPOSE_ALPHA = 1,
    GTK_INPUT_PURPOSE_DIGITS = 2,
    GTK_INPUT_PURPOSE_NUMBER = 3,
    GTK_INPUT_PURPOSE_PHONE = 4,
    GTK_INPUT_PURPOSE_URL = 5,
    GTK_INPUT_PURPOSE_EMAIL = 6,
    GTK_INPUT_PURPOSE_NAME = 7,
    GTK_INPUT_PURPOSE_PASSWORD = 8,
    GTK_INPUT_PURPOSE_PIN = 9,
};
pub const GTK_INPUT_HINT_NONE = 0;
pub const GTK_INPUT_HINT_SPELLCHECK = 1;
pub const GTK_INPUT_HINT_NO_SPELLCHECK = 2;
pub const GTK_INPUT_HINT_WORD_COMPLETION = 4;
pub const GTK_INPUT_HINT_LOWERCASE = 8;
pub const GTK_INPUT_HINT_UPPERCASE_CHARS = 16;
pub const GTK_INPUT_HINT_UPPERCASE_WORDS = 32;
pub const GTK_INPUT_HINT_UPPERCASE_SENTENCES = 64;
pub const GTK_INPUT_HINT_INHIBIT_OSK = 128;
pub const GTK_INPUT_HINT_VERTICAL_WRITING = 256;
pub const GTK_INPUT_HINT_EMOJI = 512;
pub const GTK_INPUT_HINT_NO_EMOJI = 1024;
pub const GtkInputHints = extern enum {
    GTK_INPUT_HINT_NONE = 0,
    GTK_INPUT_HINT_SPELLCHECK = 1,
    GTK_INPUT_HINT_NO_SPELLCHECK = 2,
    GTK_INPUT_HINT_WORD_COMPLETION = 4,
    GTK_INPUT_HINT_LOWERCASE = 8,
    GTK_INPUT_HINT_UPPERCASE_CHARS = 16,
    GTK_INPUT_HINT_UPPERCASE_WORDS = 32,
    GTK_INPUT_HINT_UPPERCASE_SENTENCES = 64,
    GTK_INPUT_HINT_INHIBIT_OSK = 128,
    GTK_INPUT_HINT_VERTICAL_WRITING = 256,
    GTK_INPUT_HINT_EMOJI = 512,
    GTK_INPUT_HINT_NO_EMOJI = 1024,
};
pub const GTK_PHASE_NONE = 0;
pub const GTK_PHASE_CAPTURE = 1;
pub const GTK_PHASE_BUBBLE = 2;
pub const GTK_PHASE_TARGET = 3;
pub const GtkPropagationPhase = extern enum {
    GTK_PHASE_NONE = 0,
    GTK_PHASE_CAPTURE = 1,
    GTK_PHASE_BUBBLE = 2,
    GTK_PHASE_TARGET = 3,
};
pub const GTK_EVENT_SEQUENCE_NONE = 0;
pub const GTK_EVENT_SEQUENCE_CLAIMED = 1;
pub const GTK_EVENT_SEQUENCE_DENIED = 2;
pub const GtkEventSequenceState = extern enum {
    GTK_EVENT_SEQUENCE_NONE = 0,
    GTK_EVENT_SEQUENCE_CLAIMED = 1,
    GTK_EVENT_SEQUENCE_DENIED = 2,
};
pub const GTK_PAN_DIRECTION_LEFT = 0;
pub const GTK_PAN_DIRECTION_RIGHT = 1;
pub const GTK_PAN_DIRECTION_UP = 2;
pub const GTK_PAN_DIRECTION_DOWN = 3;
pub const GtkPanDirection = extern enum {
    GTK_PAN_DIRECTION_LEFT = 0,
    GTK_PAN_DIRECTION_RIGHT = 1,
    GTK_PAN_DIRECTION_UP = 2,
    GTK_PAN_DIRECTION_DOWN = 3,
};
pub const GTK_POPOVER_CONSTRAINT_NONE = 0;
pub const GTK_POPOVER_CONSTRAINT_WINDOW = 1;
pub const GtkPopoverConstraint = extern enum {
    GTK_POPOVER_CONSTRAINT_NONE = 0,
    GTK_POPOVER_CONSTRAINT_WINDOW = 1,
};
pub const GTK_ACCEL_VISIBLE = 1;
pub const GTK_ACCEL_LOCKED = 2;
pub const GTK_ACCEL_MASK = 7;
pub const GtkAccelFlags = extern enum {
    GTK_ACCEL_VISIBLE = 1,
    GTK_ACCEL_LOCKED = 2,
    GTK_ACCEL_MASK = 7,
};
pub const struct__GtkAccelGroupPrivate = @OpaqueType();
pub const GtkAccelGroupPrivate = struct__GtkAccelGroupPrivate;
pub const struct__GtkAccelGroup = extern struct {
    parent: GObject,
    priv: ?*GtkAccelGroupPrivate,
};
pub const GtkAccelGroup = struct__GtkAccelGroup;
pub const struct__GtkAccelGroupClass = extern struct {
    parent_class: GObjectClass,
    accel_changed: ?extern fn ([*c]GtkAccelGroup, guint, GdkModifierType, ?*GClosure) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkAccelGroupClass = struct__GtkAccelGroupClass;
pub const struct__GtkAccelKey = @OpaqueType();
pub const GtkAccelKey = struct__GtkAccelKey;
pub const struct__GtkAccelGroupEntry = extern struct {
    key: GtkAccelKey,
    closure: ?*GClosure,
    accel_path_quark: GQuark,
};
pub const GtkAccelGroupEntry = struct__GtkAccelGroupEntry;
pub const GtkAccelGroupActivate = ?extern fn ([*c]GtkAccelGroup, [*c]GObject, guint, GdkModifierType) gboolean;
pub const GtkAccelGroupFindFunc = ?extern fn (?*GtkAccelKey, ?*GClosure, gpointer) gboolean;
pub extern fn gtk_accel_group_get_type() GType;
pub extern fn gtk_accel_group_new() [*c]GtkAccelGroup;
pub extern fn gtk_accel_group_get_is_locked(accel_group: [*c]GtkAccelGroup) gboolean;
pub extern fn gtk_accel_group_get_modifier_mask(accel_group: [*c]GtkAccelGroup) GdkModifierType;
pub extern fn gtk_accel_group_lock(accel_group: [*c]GtkAccelGroup) void;
pub extern fn gtk_accel_group_unlock(accel_group: [*c]GtkAccelGroup) void;
pub extern fn gtk_accel_group_connect(accel_group: [*c]GtkAccelGroup, accel_key: guint, accel_mods: GdkModifierType, accel_flags: GtkAccelFlags, closure: ?*GClosure) void;
pub extern fn gtk_accel_group_connect_by_path(accel_group: [*c]GtkAccelGroup, accel_path: [*c]const gchar, closure: ?*GClosure) void;
pub extern fn gtk_accel_group_disconnect(accel_group: [*c]GtkAccelGroup, closure: ?*GClosure) gboolean;
pub extern fn gtk_accel_group_disconnect_key(accel_group: [*c]GtkAccelGroup, accel_key: guint, accel_mods: GdkModifierType) gboolean;
pub extern fn gtk_accel_group_activate(accel_group: [*c]GtkAccelGroup, accel_quark: GQuark, acceleratable: [*c]GObject, accel_key: guint, accel_mods: GdkModifierType) gboolean;
pub extern fn _gtk_accel_group_attach(accel_group: [*c]GtkAccelGroup, object: [*c]GObject) void;
pub extern fn _gtk_accel_group_detach(accel_group: [*c]GtkAccelGroup, object: [*c]GObject) void;
pub extern fn gtk_accel_groups_activate(object: [*c]GObject, accel_key: guint, accel_mods: GdkModifierType) gboolean;
pub extern fn gtk_accel_groups_from_object(object: [*c]GObject) [*c]GSList;
pub extern fn gtk_accel_group_find(accel_group: [*c]GtkAccelGroup, find_func: GtkAccelGroupFindFunc, data: gpointer) ?*GtkAccelKey;
pub extern fn gtk_accel_group_from_accel_closure(closure: ?*GClosure) [*c]GtkAccelGroup;
pub extern fn gtk_accelerator_valid(keyval: guint, modifiers: GdkModifierType) gboolean;
pub extern fn gtk_accelerator_parse(accelerator: [*c]const gchar, accelerator_key: [*c]guint, accelerator_mods: [*c]GdkModifierType) void;
pub extern fn gtk_accelerator_parse_with_keycode(accelerator: [*c]const gchar, accelerator_key: [*c]guint, accelerator_codes: [*c]([*c]guint), accelerator_mods: [*c]GdkModifierType) void;
pub extern fn gtk_accelerator_name(accelerator_key: guint, accelerator_mods: GdkModifierType) [*c]gchar;
pub extern fn gtk_accelerator_name_with_keycode(display: ?*GdkDisplay, accelerator_key: guint, keycode: guint, accelerator_mods: GdkModifierType) [*c]gchar;
pub extern fn gtk_accelerator_get_label(accelerator_key: guint, accelerator_mods: GdkModifierType) [*c]gchar;
pub extern fn gtk_accelerator_get_label_with_keycode(display: ?*GdkDisplay, accelerator_key: guint, keycode: guint, accelerator_mods: GdkModifierType) [*c]gchar;
pub extern fn gtk_accelerator_set_default_mod_mask(default_mod_mask: GdkModifierType) void;
pub extern fn gtk_accelerator_get_default_mod_mask() GdkModifierType;
pub extern fn gtk_accel_group_query(accel_group: [*c]GtkAccelGroup, accel_key: guint, accel_mods: GdkModifierType, n_entries: [*c]guint) [*c]GtkAccelGroupEntry;
pub const GtkAccelGroup_autoptr = [*c]GtkAccelGroup;
pub const GtkAccelGroup_listautoptr = [*c]GList;
pub const GtkAccelGroup_slistautoptr = [*c]GSList;
pub const GtkAccelGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAccelGroup(_ptr: [*c]GtkAccelGroup) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkAccelGroup(_ptr: [*c]([*c]GtkAccelGroup)) void {
    glib_autoptr_clear_GtkAccelGroup(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkAccelGroup(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkAccelGroup(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkAccelGroup(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__GtkBorder = extern struct {
    left: gint16,
    right: gint16,
    top: gint16,
    bottom: gint16,
};
pub const GtkBorder = struct__GtkBorder;
pub extern fn gtk_border_get_type() GType;
pub extern fn gtk_border_new() [*c]GtkBorder;
pub extern fn gtk_border_copy(border_: [*c]const GtkBorder) [*c]GtkBorder;
pub extern fn gtk_border_free(border_: [*c]GtkBorder) void;
pub const GtkBorder_autoptr = [*c]GtkBorder;
pub const GtkBorder_listautoptr = [*c]GList;
pub const GtkBorder_slistautoptr = [*c]GSList;
pub const GtkBorder_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBorder(_ptr: [*c]GtkBorder) void {
    if (_ptr != null) gtk_border_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GtkBorder(_ptr: [*c]([*c]GtkBorder)) void {
    glib_autoptr_clear_GtkBorder(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkBorder(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_border_free)))));
}
pub fn glib_slistautoptr_cleanup_GtkBorder(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_border_free)))));
}
pub fn glib_queueautoptr_cleanup_GtkBorder(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_border_free)))));
}
pub const struct__GtkAdjustmentPrivate = @OpaqueType();
pub const GtkAdjustmentPrivate = struct__GtkAdjustmentPrivate;
pub const struct__GtkAdjustment = extern struct {
    parent_instance: GInitiallyUnowned,
    priv: ?*GtkAdjustmentPrivate,
};
pub const GtkAdjustment = struct__GtkAdjustment;
pub const struct__GtkBuilderPrivate = @OpaqueType();
pub const GtkBuilderPrivate = struct__GtkBuilderPrivate;
pub const struct__GtkBuilder = extern struct {
    parent_instance: GObject,
    priv: ?*GtkBuilderPrivate,
};
pub const GtkBuilder = struct__GtkBuilder;
pub const struct__GtkClipboard = @OpaqueType();
pub const GtkClipboard = struct__GtkClipboard;
pub const struct__GtkIconSet = @OpaqueType();
pub const GtkIconSet = struct__GtkIconSet;
pub const struct__GtkIconSource = @OpaqueType();
pub const GtkIconSource = struct__GtkIconSource;
pub const struct__GtkRcStyle = @OpaqueType();
pub const GtkRcStyle = struct__GtkRcStyle;
pub const struct__GtkRequisition = extern struct {
    width: gint,
    height: gint,
};
pub const GtkRequisition = struct__GtkRequisition;
pub const struct__GtkSelectionData = @OpaqueType();
pub const GtkSelectionData = struct__GtkSelectionData;
pub const struct__GtkSettingsPrivate = @OpaqueType();
pub const GtkSettingsPrivate = struct__GtkSettingsPrivate;
pub const struct__GtkSettings = extern struct {
    parent_instance: GObject,
    priv: ?*GtkSettingsPrivate,
};
pub const GtkSettings = struct__GtkSettings;
pub const struct__GtkStyle = extern struct {
    parent_instance: GObject,
    fg: [5]GdkColor,
    bg: [5]GdkColor,
    light: [5]GdkColor,
    dark: [5]GdkColor,
    mid: [5]GdkColor,
    text: [5]GdkColor,
    base: [5]GdkColor,
    text_aa: [5]GdkColor,
    black: GdkColor,
    white: GdkColor,
    font_desc: ?*PangoFontDescription,
    xthickness: gint,
    ythickness: gint,
    background: [5](?*cairo_pattern_t),
    attach_count: gint,
    visual: ?*GdkVisual,
    private_font_desc: ?*PangoFontDescription,
    rc_style: ?*GtkRcStyle,
    styles: [*c]GSList,
    property_cache: [*c]GArray,
    icon_factories: [*c]GSList,
};
pub const GtkStyle = struct__GtkStyle;
pub const struct__GtkStyleContextPrivate = @OpaqueType();
pub const GtkStyleContextPrivate = struct__GtkStyleContextPrivate;
pub const struct__GtkStyleContext = extern struct {
    parent_object: GObject,
    priv: ?*GtkStyleContextPrivate,
};
pub const GtkStyleContext = struct__GtkStyleContext;
pub const struct__GtkTooltip = @OpaqueType();
pub const GtkTooltip = struct__GtkTooltip;
pub const struct__GtkWidgetPrivate = @OpaqueType();
pub const GtkWidgetPrivate = struct__GtkWidgetPrivate;
pub const struct__GtkWidget = extern struct {
    parent_instance: GInitiallyUnowned,
    priv: ?*GtkWidgetPrivate,
};
pub const GtkWidget = struct__GtkWidget;
pub const struct__GtkWidgetPath = @OpaqueType();
pub const GtkWidgetPath = struct__GtkWidgetPath;
pub const struct__GtkContainerPrivate = @OpaqueType();
pub const GtkContainerPrivate = struct__GtkContainerPrivate;
pub const struct__GtkContainer = extern struct {
    widget: GtkWidget,
    priv: ?*GtkContainerPrivate,
};
pub const GtkContainer = struct__GtkContainer;
pub const struct__GtkBinPrivate = @OpaqueType();
pub const GtkBinPrivate = struct__GtkBinPrivate;
pub const struct__GtkBin = extern struct {
    container: GtkContainer,
    priv: ?*GtkBinPrivate,
};
pub const GtkBin = struct__GtkBin;
pub const struct__GtkWindowPrivate = @OpaqueType();
pub const GtkWindowPrivate = struct__GtkWindowPrivate;
pub const struct__GtkWindow = extern struct {
    bin: GtkBin,
    priv: ?*GtkWindowPrivate,
};
pub const GtkWindow = struct__GtkWindow;
pub const GtkRcPropertyParser = ?extern fn ([*c]const GParamSpec, [*c]const GString, [*c]GValue) gboolean;
pub const GtkBuilderConnectFunc = ?extern fn ([*c]GtkBuilder, [*c]GObject, [*c]const gchar, [*c]const gchar, [*c]GObject, GConnectFlags, gpointer) void;
pub extern fn atk_get_major_version() guint;
pub extern fn atk_get_minor_version() guint;
pub extern fn atk_get_micro_version() guint;
pub extern fn atk_get_binary_age() guint;
pub extern fn atk_get_interface_age() guint;
pub const ATK_STATE_INVALID = 0;
pub const ATK_STATE_ACTIVE = 1;
pub const ATK_STATE_ARMED = 2;
pub const ATK_STATE_BUSY = 3;
pub const ATK_STATE_CHECKED = 4;
pub const ATK_STATE_DEFUNCT = 5;
pub const ATK_STATE_EDITABLE = 6;
pub const ATK_STATE_ENABLED = 7;
pub const ATK_STATE_EXPANDABLE = 8;
pub const ATK_STATE_EXPANDED = 9;
pub const ATK_STATE_FOCUSABLE = 10;
pub const ATK_STATE_FOCUSED = 11;
pub const ATK_STATE_HORIZONTAL = 12;
pub const ATK_STATE_ICONIFIED = 13;
pub const ATK_STATE_MODAL = 14;
pub const ATK_STATE_MULTI_LINE = 15;
pub const ATK_STATE_MULTISELECTABLE = 16;
pub const ATK_STATE_OPAQUE = 17;
pub const ATK_STATE_PRESSED = 18;
pub const ATK_STATE_RESIZABLE = 19;
pub const ATK_STATE_SELECTABLE = 20;
pub const ATK_STATE_SELECTED = 21;
pub const ATK_STATE_SENSITIVE = 22;
pub const ATK_STATE_SHOWING = 23;
pub const ATK_STATE_SINGLE_LINE = 24;
pub const ATK_STATE_STALE = 25;
pub const ATK_STATE_TRANSIENT = 26;
pub const ATK_STATE_VERTICAL = 27;
pub const ATK_STATE_VISIBLE = 28;
pub const ATK_STATE_MANAGES_DESCENDANTS = 29;
pub const ATK_STATE_INDETERMINATE = 30;
pub const ATK_STATE_TRUNCATED = 31;
pub const ATK_STATE_REQUIRED = 32;
pub const ATK_STATE_INVALID_ENTRY = 33;
pub const ATK_STATE_SUPPORTS_AUTOCOMPLETION = 34;
pub const ATK_STATE_SELECTABLE_TEXT = 35;
pub const ATK_STATE_DEFAULT = 36;
pub const ATK_STATE_ANIMATED = 37;
pub const ATK_STATE_VISITED = 38;
pub const ATK_STATE_CHECKABLE = 39;
pub const ATK_STATE_HAS_POPUP = 40;
pub const ATK_STATE_HAS_TOOLTIP = 41;
pub const ATK_STATE_READ_ONLY = 42;
pub const ATK_STATE_LAST_DEFINED = 43;
pub const AtkStateType = extern enum {
    ATK_STATE_INVALID = 0,
    ATK_STATE_ACTIVE = 1,
    ATK_STATE_ARMED = 2,
    ATK_STATE_BUSY = 3,
    ATK_STATE_CHECKED = 4,
    ATK_STATE_DEFUNCT = 5,
    ATK_STATE_EDITABLE = 6,
    ATK_STATE_ENABLED = 7,
    ATK_STATE_EXPANDABLE = 8,
    ATK_STATE_EXPANDED = 9,
    ATK_STATE_FOCUSABLE = 10,
    ATK_STATE_FOCUSED = 11,
    ATK_STATE_HORIZONTAL = 12,
    ATK_STATE_ICONIFIED = 13,
    ATK_STATE_MODAL = 14,
    ATK_STATE_MULTI_LINE = 15,
    ATK_STATE_MULTISELECTABLE = 16,
    ATK_STATE_OPAQUE = 17,
    ATK_STATE_PRESSED = 18,
    ATK_STATE_RESIZABLE = 19,
    ATK_STATE_SELECTABLE = 20,
    ATK_STATE_SELECTED = 21,
    ATK_STATE_SENSITIVE = 22,
    ATK_STATE_SHOWING = 23,
    ATK_STATE_SINGLE_LINE = 24,
    ATK_STATE_STALE = 25,
    ATK_STATE_TRANSIENT = 26,
    ATK_STATE_VERTICAL = 27,
    ATK_STATE_VISIBLE = 28,
    ATK_STATE_MANAGES_DESCENDANTS = 29,
    ATK_STATE_INDETERMINATE = 30,
    ATK_STATE_TRUNCATED = 31,
    ATK_STATE_REQUIRED = 32,
    ATK_STATE_INVALID_ENTRY = 33,
    ATK_STATE_SUPPORTS_AUTOCOMPLETION = 34,
    ATK_STATE_SELECTABLE_TEXT = 35,
    ATK_STATE_DEFAULT = 36,
    ATK_STATE_ANIMATED = 37,
    ATK_STATE_VISITED = 38,
    ATK_STATE_CHECKABLE = 39,
    ATK_STATE_HAS_POPUP = 40,
    ATK_STATE_HAS_TOOLTIP = 41,
    ATK_STATE_READ_ONLY = 42,
    ATK_STATE_LAST_DEFINED = 43,
};
pub const AtkState = guint64;
pub extern fn atk_state_type_register(name: [*c]const gchar) AtkStateType;
pub extern fn atk_state_type_get_name(type_0: AtkStateType) [*c]const gchar;
pub extern fn atk_state_type_for_name(name: [*c]const gchar) AtkStateType;
pub const ATK_RELATION_NULL = 0;
pub const ATK_RELATION_CONTROLLED_BY = 1;
pub const ATK_RELATION_CONTROLLER_FOR = 2;
pub const ATK_RELATION_LABEL_FOR = 3;
pub const ATK_RELATION_LABELLED_BY = 4;
pub const ATK_RELATION_MEMBER_OF = 5;
pub const ATK_RELATION_NODE_CHILD_OF = 6;
pub const ATK_RELATION_FLOWS_TO = 7;
pub const ATK_RELATION_FLOWS_FROM = 8;
pub const ATK_RELATION_SUBWINDOW_OF = 9;
pub const ATK_RELATION_EMBEDS = 10;
pub const ATK_RELATION_EMBEDDED_BY = 11;
pub const ATK_RELATION_POPUP_FOR = 12;
pub const ATK_RELATION_PARENT_WINDOW_OF = 13;
pub const ATK_RELATION_DESCRIBED_BY = 14;
pub const ATK_RELATION_DESCRIPTION_FOR = 15;
pub const ATK_RELATION_NODE_PARENT_OF = 16;
pub const ATK_RELATION_DETAILS = 17;
pub const ATK_RELATION_DETAILS_FOR = 18;
pub const ATK_RELATION_ERROR_MESSAGE = 19;
pub const ATK_RELATION_ERROR_FOR = 20;
pub const ATK_RELATION_LAST_DEFINED = 21;
pub const AtkRelationType = extern enum {
    ATK_RELATION_NULL = 0,
    ATK_RELATION_CONTROLLED_BY = 1,
    ATK_RELATION_CONTROLLER_FOR = 2,
    ATK_RELATION_LABEL_FOR = 3,
    ATK_RELATION_LABELLED_BY = 4,
    ATK_RELATION_MEMBER_OF = 5,
    ATK_RELATION_NODE_CHILD_OF = 6,
    ATK_RELATION_FLOWS_TO = 7,
    ATK_RELATION_FLOWS_FROM = 8,
    ATK_RELATION_SUBWINDOW_OF = 9,
    ATK_RELATION_EMBEDS = 10,
    ATK_RELATION_EMBEDDED_BY = 11,
    ATK_RELATION_POPUP_FOR = 12,
    ATK_RELATION_PARENT_WINDOW_OF = 13,
    ATK_RELATION_DESCRIBED_BY = 14,
    ATK_RELATION_DESCRIPTION_FOR = 15,
    ATK_RELATION_NODE_PARENT_OF = 16,
    ATK_RELATION_DETAILS = 17,
    ATK_RELATION_DETAILS_FOR = 18,
    ATK_RELATION_ERROR_MESSAGE = 19,
    ATK_RELATION_ERROR_FOR = 20,
    ATK_RELATION_LAST_DEFINED = 21,
};
pub const ATK_ROLE_INVALID = 0;
pub const ATK_ROLE_ACCEL_LABEL = 1;
pub const ATK_ROLE_ALERT = 2;
pub const ATK_ROLE_ANIMATION = 3;
pub const ATK_ROLE_ARROW = 4;
pub const ATK_ROLE_CALENDAR = 5;
pub const ATK_ROLE_CANVAS = 6;
pub const ATK_ROLE_CHECK_BOX = 7;
pub const ATK_ROLE_CHECK_MENU_ITEM = 8;
pub const ATK_ROLE_COLOR_CHOOSER = 9;
pub const ATK_ROLE_COLUMN_HEADER = 10;
pub const ATK_ROLE_COMBO_BOX = 11;
pub const ATK_ROLE_DATE_EDITOR = 12;
pub const ATK_ROLE_DESKTOP_ICON = 13;
pub const ATK_ROLE_DESKTOP_FRAME = 14;
pub const ATK_ROLE_DIAL = 15;
pub const ATK_ROLE_DIALOG = 16;
pub const ATK_ROLE_DIRECTORY_PANE = 17;
pub const ATK_ROLE_DRAWING_AREA = 18;
pub const ATK_ROLE_FILE_CHOOSER = 19;
pub const ATK_ROLE_FILLER = 20;
pub const ATK_ROLE_FONT_CHOOSER = 21;
pub const ATK_ROLE_FRAME = 22;
pub const ATK_ROLE_GLASS_PANE = 23;
pub const ATK_ROLE_HTML_CONTAINER = 24;
pub const ATK_ROLE_ICON = 25;
pub const ATK_ROLE_IMAGE = 26;
pub const ATK_ROLE_INTERNAL_FRAME = 27;
pub const ATK_ROLE_LABEL = 28;
pub const ATK_ROLE_LAYERED_PANE = 29;
pub const ATK_ROLE_LIST = 30;
pub const ATK_ROLE_LIST_ITEM = 31;
pub const ATK_ROLE_MENU = 32;
pub const ATK_ROLE_MENU_BAR = 33;
pub const ATK_ROLE_MENU_ITEM = 34;
pub const ATK_ROLE_OPTION_PANE = 35;
pub const ATK_ROLE_PAGE_TAB = 36;
pub const ATK_ROLE_PAGE_TAB_LIST = 37;
pub const ATK_ROLE_PANEL = 38;
pub const ATK_ROLE_PASSWORD_TEXT = 39;
pub const ATK_ROLE_POPUP_MENU = 40;
pub const ATK_ROLE_PROGRESS_BAR = 41;
pub const ATK_ROLE_PUSH_BUTTON = 42;
pub const ATK_ROLE_RADIO_BUTTON = 43;
pub const ATK_ROLE_RADIO_MENU_ITEM = 44;
pub const ATK_ROLE_ROOT_PANE = 45;
pub const ATK_ROLE_ROW_HEADER = 46;
pub const ATK_ROLE_SCROLL_BAR = 47;
pub const ATK_ROLE_SCROLL_PANE = 48;
pub const ATK_ROLE_SEPARATOR = 49;
pub const ATK_ROLE_SLIDER = 50;
pub const ATK_ROLE_SPLIT_PANE = 51;
pub const ATK_ROLE_SPIN_BUTTON = 52;
pub const ATK_ROLE_STATUSBAR = 53;
pub const ATK_ROLE_TABLE = 54;
pub const ATK_ROLE_TABLE_CELL = 55;
pub const ATK_ROLE_TABLE_COLUMN_HEADER = 56;
pub const ATK_ROLE_TABLE_ROW_HEADER = 57;
pub const ATK_ROLE_TEAR_OFF_MENU_ITEM = 58;
pub const ATK_ROLE_TERMINAL = 59;
pub const ATK_ROLE_TEXT = 60;
pub const ATK_ROLE_TOGGLE_BUTTON = 61;
pub const ATK_ROLE_TOOL_BAR = 62;
pub const ATK_ROLE_TOOL_TIP = 63;
pub const ATK_ROLE_TREE = 64;
pub const ATK_ROLE_TREE_TABLE = 65;
pub const ATK_ROLE_UNKNOWN = 66;
pub const ATK_ROLE_VIEWPORT = 67;
pub const ATK_ROLE_WINDOW = 68;
pub const ATK_ROLE_HEADER = 69;
pub const ATK_ROLE_FOOTER = 70;
pub const ATK_ROLE_PARAGRAPH = 71;
pub const ATK_ROLE_RULER = 72;
pub const ATK_ROLE_APPLICATION = 73;
pub const ATK_ROLE_AUTOCOMPLETE = 74;
pub const ATK_ROLE_EDITBAR = 75;
pub const ATK_ROLE_EMBEDDED = 76;
pub const ATK_ROLE_ENTRY = 77;
pub const ATK_ROLE_CHART = 78;
pub const ATK_ROLE_CAPTION = 79;
pub const ATK_ROLE_DOCUMENT_FRAME = 80;
pub const ATK_ROLE_HEADING = 81;
pub const ATK_ROLE_PAGE = 82;
pub const ATK_ROLE_SECTION = 83;
pub const ATK_ROLE_REDUNDANT_OBJECT = 84;
pub const ATK_ROLE_FORM = 85;
pub const ATK_ROLE_LINK = 86;
pub const ATK_ROLE_INPUT_METHOD_WINDOW = 87;
pub const ATK_ROLE_TABLE_ROW = 88;
pub const ATK_ROLE_TREE_ITEM = 89;
pub const ATK_ROLE_DOCUMENT_SPREADSHEET = 90;
pub const ATK_ROLE_DOCUMENT_PRESENTATION = 91;
pub const ATK_ROLE_DOCUMENT_TEXT = 92;
pub const ATK_ROLE_DOCUMENT_WEB = 93;
pub const ATK_ROLE_DOCUMENT_EMAIL = 94;
pub const ATK_ROLE_COMMENT = 95;
pub const ATK_ROLE_LIST_BOX = 96;
pub const ATK_ROLE_GROUPING = 97;
pub const ATK_ROLE_IMAGE_MAP = 98;
pub const ATK_ROLE_NOTIFICATION = 99;
pub const ATK_ROLE_INFO_BAR = 100;
pub const ATK_ROLE_LEVEL_BAR = 101;
pub const ATK_ROLE_TITLE_BAR = 102;
pub const ATK_ROLE_BLOCK_QUOTE = 103;
pub const ATK_ROLE_AUDIO = 104;
pub const ATK_ROLE_VIDEO = 105;
pub const ATK_ROLE_DEFINITION = 106;
pub const ATK_ROLE_ARTICLE = 107;
pub const ATK_ROLE_LANDMARK = 108;
pub const ATK_ROLE_LOG = 109;
pub const ATK_ROLE_MARQUEE = 110;
pub const ATK_ROLE_MATH = 111;
pub const ATK_ROLE_RATING = 112;
pub const ATK_ROLE_TIMER = 113;
pub const ATK_ROLE_DESCRIPTION_LIST = 114;
pub const ATK_ROLE_DESCRIPTION_TERM = 115;
pub const ATK_ROLE_DESCRIPTION_VALUE = 116;
pub const ATK_ROLE_STATIC = 117;
pub const ATK_ROLE_MATH_FRACTION = 118;
pub const ATK_ROLE_MATH_ROOT = 119;
pub const ATK_ROLE_SUBSCRIPT = 120;
pub const ATK_ROLE_SUPERSCRIPT = 121;
pub const ATK_ROLE_FOOTNOTE = 122;
pub const ATK_ROLE_CONTENT_DELETION = 123;
pub const ATK_ROLE_CONTENT_INSERTION = 124;
pub const ATK_ROLE_LAST_DEFINED = 125;
pub const AtkRole = extern enum {
    ATK_ROLE_INVALID = 0,
    ATK_ROLE_ACCEL_LABEL = 1,
    ATK_ROLE_ALERT = 2,
    ATK_ROLE_ANIMATION = 3,
    ATK_ROLE_ARROW = 4,
    ATK_ROLE_CALENDAR = 5,
    ATK_ROLE_CANVAS = 6,
    ATK_ROLE_CHECK_BOX = 7,
    ATK_ROLE_CHECK_MENU_ITEM = 8,
    ATK_ROLE_COLOR_CHOOSER = 9,
    ATK_ROLE_COLUMN_HEADER = 10,
    ATK_ROLE_COMBO_BOX = 11,
    ATK_ROLE_DATE_EDITOR = 12,
    ATK_ROLE_DESKTOP_ICON = 13,
    ATK_ROLE_DESKTOP_FRAME = 14,
    ATK_ROLE_DIAL = 15,
    ATK_ROLE_DIALOG = 16,
    ATK_ROLE_DIRECTORY_PANE = 17,
    ATK_ROLE_DRAWING_AREA = 18,
    ATK_ROLE_FILE_CHOOSER = 19,
    ATK_ROLE_FILLER = 20,
    ATK_ROLE_FONT_CHOOSER = 21,
    ATK_ROLE_FRAME = 22,
    ATK_ROLE_GLASS_PANE = 23,
    ATK_ROLE_HTML_CONTAINER = 24,
    ATK_ROLE_ICON = 25,
    ATK_ROLE_IMAGE = 26,
    ATK_ROLE_INTERNAL_FRAME = 27,
    ATK_ROLE_LABEL = 28,
    ATK_ROLE_LAYERED_PANE = 29,
    ATK_ROLE_LIST = 30,
    ATK_ROLE_LIST_ITEM = 31,
    ATK_ROLE_MENU = 32,
    ATK_ROLE_MENU_BAR = 33,
    ATK_ROLE_MENU_ITEM = 34,
    ATK_ROLE_OPTION_PANE = 35,
    ATK_ROLE_PAGE_TAB = 36,
    ATK_ROLE_PAGE_TAB_LIST = 37,
    ATK_ROLE_PANEL = 38,
    ATK_ROLE_PASSWORD_TEXT = 39,
    ATK_ROLE_POPUP_MENU = 40,
    ATK_ROLE_PROGRESS_BAR = 41,
    ATK_ROLE_PUSH_BUTTON = 42,
    ATK_ROLE_RADIO_BUTTON = 43,
    ATK_ROLE_RADIO_MENU_ITEM = 44,
    ATK_ROLE_ROOT_PANE = 45,
    ATK_ROLE_ROW_HEADER = 46,
    ATK_ROLE_SCROLL_BAR = 47,
    ATK_ROLE_SCROLL_PANE = 48,
    ATK_ROLE_SEPARATOR = 49,
    ATK_ROLE_SLIDER = 50,
    ATK_ROLE_SPLIT_PANE = 51,
    ATK_ROLE_SPIN_BUTTON = 52,
    ATK_ROLE_STATUSBAR = 53,
    ATK_ROLE_TABLE = 54,
    ATK_ROLE_TABLE_CELL = 55,
    ATK_ROLE_TABLE_COLUMN_HEADER = 56,
    ATK_ROLE_TABLE_ROW_HEADER = 57,
    ATK_ROLE_TEAR_OFF_MENU_ITEM = 58,
    ATK_ROLE_TERMINAL = 59,
    ATK_ROLE_TEXT = 60,
    ATK_ROLE_TOGGLE_BUTTON = 61,
    ATK_ROLE_TOOL_BAR = 62,
    ATK_ROLE_TOOL_TIP = 63,
    ATK_ROLE_TREE = 64,
    ATK_ROLE_TREE_TABLE = 65,
    ATK_ROLE_UNKNOWN = 66,
    ATK_ROLE_VIEWPORT = 67,
    ATK_ROLE_WINDOW = 68,
    ATK_ROLE_HEADER = 69,
    ATK_ROLE_FOOTER = 70,
    ATK_ROLE_PARAGRAPH = 71,
    ATK_ROLE_RULER = 72,
    ATK_ROLE_APPLICATION = 73,
    ATK_ROLE_AUTOCOMPLETE = 74,
    ATK_ROLE_EDITBAR = 75,
    ATK_ROLE_EMBEDDED = 76,
    ATK_ROLE_ENTRY = 77,
    ATK_ROLE_CHART = 78,
    ATK_ROLE_CAPTION = 79,
    ATK_ROLE_DOCUMENT_FRAME = 80,
    ATK_ROLE_HEADING = 81,
    ATK_ROLE_PAGE = 82,
    ATK_ROLE_SECTION = 83,
    ATK_ROLE_REDUNDANT_OBJECT = 84,
    ATK_ROLE_FORM = 85,
    ATK_ROLE_LINK = 86,
    ATK_ROLE_INPUT_METHOD_WINDOW = 87,
    ATK_ROLE_TABLE_ROW = 88,
    ATK_ROLE_TREE_ITEM = 89,
    ATK_ROLE_DOCUMENT_SPREADSHEET = 90,
    ATK_ROLE_DOCUMENT_PRESENTATION = 91,
    ATK_ROLE_DOCUMENT_TEXT = 92,
    ATK_ROLE_DOCUMENT_WEB = 93,
    ATK_ROLE_DOCUMENT_EMAIL = 94,
    ATK_ROLE_COMMENT = 95,
    ATK_ROLE_LIST_BOX = 96,
    ATK_ROLE_GROUPING = 97,
    ATK_ROLE_IMAGE_MAP = 98,
    ATK_ROLE_NOTIFICATION = 99,
    ATK_ROLE_INFO_BAR = 100,
    ATK_ROLE_LEVEL_BAR = 101,
    ATK_ROLE_TITLE_BAR = 102,
    ATK_ROLE_BLOCK_QUOTE = 103,
    ATK_ROLE_AUDIO = 104,
    ATK_ROLE_VIDEO = 105,
    ATK_ROLE_DEFINITION = 106,
    ATK_ROLE_ARTICLE = 107,
    ATK_ROLE_LANDMARK = 108,
    ATK_ROLE_LOG = 109,
    ATK_ROLE_MARQUEE = 110,
    ATK_ROLE_MATH = 111,
    ATK_ROLE_RATING = 112,
    ATK_ROLE_TIMER = 113,
    ATK_ROLE_DESCRIPTION_LIST = 114,
    ATK_ROLE_DESCRIPTION_TERM = 115,
    ATK_ROLE_DESCRIPTION_VALUE = 116,
    ATK_ROLE_STATIC = 117,
    ATK_ROLE_MATH_FRACTION = 118,
    ATK_ROLE_MATH_ROOT = 119,
    ATK_ROLE_SUBSCRIPT = 120,
    ATK_ROLE_SUPERSCRIPT = 121,
    ATK_ROLE_FOOTNOTE = 122,
    ATK_ROLE_CONTENT_DELETION = 123,
    ATK_ROLE_CONTENT_INSERTION = 124,
    ATK_ROLE_LAST_DEFINED = 125,
};
pub const ATK_LAYER_INVALID = 0;
pub const ATK_LAYER_BACKGROUND = 1;
pub const ATK_LAYER_CANVAS = 2;
pub const ATK_LAYER_WIDGET = 3;
pub const ATK_LAYER_MDI = 4;
pub const ATK_LAYER_POPUP = 5;
pub const ATK_LAYER_OVERLAY = 6;
pub const ATK_LAYER_WINDOW = 7;
pub const AtkLayer = extern enum {
    ATK_LAYER_INVALID = 0,
    ATK_LAYER_BACKGROUND = 1,
    ATK_LAYER_CANVAS = 2,
    ATK_LAYER_WIDGET = 3,
    ATK_LAYER_MDI = 4,
    ATK_LAYER_POPUP = 5,
    ATK_LAYER_OVERLAY = 6,
    ATK_LAYER_WINDOW = 7,
};
pub const AtkAttributeSet = GSList;
pub const struct__AtkAttribute = extern struct {
    name: [*c]gchar,
    value: [*c]gchar,
};
pub const AtkAttribute = struct__AtkAttribute;
pub const struct__AtkImplementor = @OpaqueType();
pub const AtkImplementor = struct__AtkImplementor;
pub const struct__AtkRelationSet = extern struct {
    parent: GObject,
    relations: [*c]GPtrArray,
};
pub const AtkRelationSet = struct__AtkRelationSet;
pub const struct__AtkObject = extern struct {
    parent: GObject,
    description: [*c]gchar,
    name: [*c]gchar,
    accessible_parent: [*c]AtkObject,
    role: AtkRole,
    relation_set: [*c]AtkRelationSet,
    layer: AtkLayer,
};
pub const AtkObject = struct__AtkObject;
pub const struct__AtkImplementorIface = extern struct {
    parent: GTypeInterface,
    ref_accessible: ?extern fn (?*AtkImplementor) [*c]AtkObject,
};
pub const AtkImplementorIface = struct__AtkImplementorIface;
pub const struct__AtkStateSet = extern struct {
    parent: GObject,
};
pub const AtkStateSet = struct__AtkStateSet;
pub const struct__AtkPropertyValues = extern struct {
    property_name: [*c]const gchar,
    old_value: GValue,
    new_value: GValue,
};
pub const AtkPropertyValues = struct__AtkPropertyValues;
pub const AtkPropertyChangeHandler = ?extern fn ([*c]AtkObject, [*c]AtkPropertyValues) void;
pub const AtkFunction = ?extern fn (gpointer) gboolean;
pub const struct__AtkObjectClass = extern struct {
    parent: GObjectClass,
    get_name: ?extern fn ([*c]AtkObject) [*c]const gchar,
    get_description: ?extern fn ([*c]AtkObject) [*c]const gchar,
    get_parent: ?extern fn ([*c]AtkObject) [*c]AtkObject,
    get_n_children: ?extern fn ([*c]AtkObject) gint,
    ref_child: ?extern fn ([*c]AtkObject, gint) [*c]AtkObject,
    get_index_in_parent: ?extern fn ([*c]AtkObject) gint,
    ref_relation_set: ?extern fn ([*c]AtkObject) [*c]AtkRelationSet,
    get_role: ?extern fn ([*c]AtkObject) AtkRole,
    get_layer: ?extern fn ([*c]AtkObject) AtkLayer,
    get_mdi_zorder: ?extern fn ([*c]AtkObject) gint,
    ref_state_set: ?extern fn ([*c]AtkObject) [*c]AtkStateSet,
    set_name: ?extern fn ([*c]AtkObject, [*c]const gchar) void,
    set_description: ?extern fn ([*c]AtkObject, [*c]const gchar) void,
    set_parent: ?extern fn ([*c]AtkObject, [*c]AtkObject) void,
    set_role: ?extern fn ([*c]AtkObject, AtkRole) void,
    connect_property_change_handler: ?extern fn ([*c]AtkObject, [*c]AtkPropertyChangeHandler) guint,
    remove_property_change_handler: ?extern fn ([*c]AtkObject, guint) void,
    initialize: ?extern fn ([*c]AtkObject, gpointer) void,
    children_changed: ?extern fn ([*c]AtkObject, guint, gpointer) void,
    focus_event: ?extern fn ([*c]AtkObject, gboolean) void,
    property_change: ?extern fn ([*c]AtkObject, [*c]AtkPropertyValues) void,
    state_change: ?extern fn ([*c]AtkObject, [*c]const gchar, gboolean) void,
    visible_data_changed: ?extern fn ([*c]AtkObject) void,
    active_descendant_changed: ?extern fn ([*c]AtkObject, [*c]gpointer) void,
    get_attributes: ?extern fn ([*c]AtkObject) [*c]AtkAttributeSet,
    get_object_locale: ?extern fn ([*c]AtkObject) [*c]const gchar,
    pad1: AtkFunction,
};
pub const AtkObjectClass = struct__AtkObjectClass;
pub extern fn atk_object_get_type() GType;
pub extern fn atk_implementor_get_type() GType;
pub extern fn atk_implementor_ref_accessible(implementor: ?*AtkImplementor) [*c]AtkObject;
pub extern fn atk_object_get_name(accessible: [*c]AtkObject) [*c]const gchar;
pub extern fn atk_object_get_description(accessible: [*c]AtkObject) [*c]const gchar;
pub extern fn atk_object_get_parent(accessible: [*c]AtkObject) [*c]AtkObject;
pub extern fn atk_object_peek_parent(accessible: [*c]AtkObject) [*c]AtkObject;
pub extern fn atk_object_get_n_accessible_children(accessible: [*c]AtkObject) gint;
pub extern fn atk_object_ref_accessible_child(accessible: [*c]AtkObject, i: gint) [*c]AtkObject;
pub extern fn atk_object_ref_relation_set(accessible: [*c]AtkObject) [*c]AtkRelationSet;
pub extern fn atk_object_get_role(accessible: [*c]AtkObject) AtkRole;
pub extern fn atk_object_get_layer(accessible: [*c]AtkObject) AtkLayer;
pub extern fn atk_object_get_mdi_zorder(accessible: [*c]AtkObject) gint;
pub extern fn atk_object_get_attributes(accessible: [*c]AtkObject) [*c]AtkAttributeSet;
pub extern fn atk_object_ref_state_set(accessible: [*c]AtkObject) [*c]AtkStateSet;
pub extern fn atk_object_get_index_in_parent(accessible: [*c]AtkObject) gint;
pub extern fn atk_object_set_name(accessible: [*c]AtkObject, name: [*c]const gchar) void;
pub extern fn atk_object_set_description(accessible: [*c]AtkObject, description: [*c]const gchar) void;
pub extern fn atk_object_set_parent(accessible: [*c]AtkObject, parent: [*c]AtkObject) void;
pub extern fn atk_object_set_role(accessible: [*c]AtkObject, role: AtkRole) void;
pub extern fn atk_object_connect_property_change_handler(accessible: [*c]AtkObject, handler: [*c]AtkPropertyChangeHandler) guint;
pub extern fn atk_object_remove_property_change_handler(accessible: [*c]AtkObject, handler_id: guint) void;
pub extern fn atk_object_notify_state_change(accessible: [*c]AtkObject, state: AtkState, value: gboolean) void;
pub extern fn atk_object_initialize(accessible: [*c]AtkObject, data: gpointer) void;
pub extern fn atk_role_get_name(role: AtkRole) [*c]const gchar;
pub extern fn atk_role_for_name(name: [*c]const gchar) AtkRole;
pub extern fn atk_object_add_relationship(object: [*c]AtkObject, relationship: AtkRelationType, target: [*c]AtkObject) gboolean;
pub extern fn atk_object_remove_relationship(object: [*c]AtkObject, relationship: AtkRelationType, target: [*c]AtkObject) gboolean;
pub extern fn atk_role_get_localized_name(role: AtkRole) [*c]const gchar;
pub extern fn atk_role_register(name: [*c]const gchar) AtkRole;
pub extern fn atk_object_get_object_locale(accessible: [*c]AtkObject) [*c]const gchar;
pub extern fn atk_object_get_accessible_id(accessible: [*c]AtkObject) [*c]const gchar;
pub extern fn atk_object_set_accessible_id(accessible: [*c]AtkObject, name: [*c]const gchar) void;
pub const struct__AtkAction = @OpaqueType();
pub const AtkAction = struct__AtkAction;
pub const struct__AtkActionIface = extern struct {
    parent: GTypeInterface,
    do_action: ?extern fn (?*AtkAction, gint) gboolean,
    get_n_actions: ?extern fn (?*AtkAction) gint,
    get_description: ?extern fn (?*AtkAction, gint) [*c]const gchar,
    get_name: ?extern fn (?*AtkAction, gint) [*c]const gchar,
    get_keybinding: ?extern fn (?*AtkAction, gint) [*c]const gchar,
    set_description: ?extern fn (?*AtkAction, gint, [*c]const gchar) gboolean,
    get_localized_name: ?extern fn (?*AtkAction, gint) [*c]const gchar,
};
pub const AtkActionIface = struct__AtkActionIface;
pub extern fn atk_action_get_type() GType;
pub extern fn atk_action_do_action(action: ?*AtkAction, i: gint) gboolean;
pub extern fn atk_action_get_n_actions(action: ?*AtkAction) gint;
pub extern fn atk_action_get_description(action: ?*AtkAction, i: gint) [*c]const gchar;
pub extern fn atk_action_get_name(action: ?*AtkAction, i: gint) [*c]const gchar;
pub extern fn atk_action_get_keybinding(action: ?*AtkAction, i: gint) [*c]const gchar;
pub extern fn atk_action_set_description(action: ?*AtkAction, i: gint, desc: [*c]const gchar) gboolean;
pub extern fn atk_action_get_localized_name(action: ?*AtkAction, i: gint) [*c]const gchar;
pub const struct__AtkUtil = extern struct {
    parent: GObject,
};
pub const AtkUtil = struct__AtkUtil;
pub const struct__AtkKeyEventStruct = extern struct {
    type: gint,
    state: guint,
    keyval: guint,
    length: gint,
    string: [*c]gchar,
    keycode: guint16,
    timestamp: guint32,
};
pub const AtkKeyEventStruct = struct__AtkKeyEventStruct;
pub const AtkKeySnoopFunc = ?extern fn ([*c]AtkKeyEventStruct, gpointer) gint;
pub const struct__AtkUtilClass = extern struct {
    parent: GObjectClass,
    add_global_event_listener: ?extern fn (GSignalEmissionHook, [*c]const gchar) guint,
    remove_global_event_listener: ?extern fn (guint) void,
    add_key_event_listener: ?extern fn (AtkKeySnoopFunc, gpointer) guint,
    remove_key_event_listener: ?extern fn (guint) void,
    get_root: ?extern fn () [*c]AtkObject,
    get_toolkit_name: ?extern fn () [*c]const gchar,
    get_toolkit_version: ?extern fn () [*c]const gchar,
};
pub const AtkUtilClass = struct__AtkUtilClass;
pub const AtkEventListener = ?extern fn ([*c]AtkObject) void;
pub const AtkEventListenerInit = ?extern fn () void;
pub const ATK_KEY_EVENT_PRESS = 0;
pub const ATK_KEY_EVENT_RELEASE = 1;
pub const ATK_KEY_EVENT_LAST_DEFINED = 2;
pub const AtkKeyEventType = extern enum {
    ATK_KEY_EVENT_PRESS = 0,
    ATK_KEY_EVENT_RELEASE = 1,
    ATK_KEY_EVENT_LAST_DEFINED = 2,
};
pub extern fn atk_util_get_type() GType;
pub const ATK_XY_SCREEN = 0;
pub const ATK_XY_WINDOW = 1;
pub const ATK_XY_PARENT = 2;
pub const AtkCoordType = extern enum {
    ATK_XY_SCREEN = 0,
    ATK_XY_WINDOW = 1,
    ATK_XY_PARENT = 2,
};
pub extern fn atk_add_focus_tracker(focus_tracker: AtkEventListener) guint;
pub extern fn atk_remove_focus_tracker(tracker_id: guint) void;
pub extern fn atk_focus_tracker_init(init: AtkEventListenerInit) void;
pub extern fn atk_focus_tracker_notify(object: [*c]AtkObject) void;
pub extern fn atk_add_global_event_listener(listener: GSignalEmissionHook, event_type: [*c]const gchar) guint;
pub extern fn atk_remove_global_event_listener(listener_id: guint) void;
pub extern fn atk_add_key_event_listener(listener: AtkKeySnoopFunc, data: gpointer) guint;
pub extern fn atk_remove_key_event_listener(listener_id: guint) void;
pub extern fn atk_get_root() [*c]AtkObject;
pub extern fn atk_get_focus_object() [*c]AtkObject;
pub extern fn atk_get_toolkit_name() [*c]const gchar;
pub extern fn atk_get_toolkit_version() [*c]const gchar;
pub extern fn atk_get_version() [*c]const gchar;
pub const ATK_SCROLL_TOP_LEFT = 0;
pub const ATK_SCROLL_BOTTOM_RIGHT = 1;
pub const ATK_SCROLL_TOP_EDGE = 2;
pub const ATK_SCROLL_BOTTOM_EDGE = 3;
pub const ATK_SCROLL_LEFT_EDGE = 4;
pub const ATK_SCROLL_RIGHT_EDGE = 5;
pub const ATK_SCROLL_ANYWHERE = 6;
pub const AtkScrollType = extern enum {
    ATK_SCROLL_TOP_LEFT = 0,
    ATK_SCROLL_BOTTOM_RIGHT = 1,
    ATK_SCROLL_TOP_EDGE = 2,
    ATK_SCROLL_BOTTOM_EDGE = 3,
    ATK_SCROLL_LEFT_EDGE = 4,
    ATK_SCROLL_RIGHT_EDGE = 5,
    ATK_SCROLL_ANYWHERE = 6,
};
pub const struct__AtkComponent = @OpaqueType();
pub const AtkComponent = struct__AtkComponent;
pub const AtkFocusHandler = ?extern fn ([*c]AtkObject, gboolean) void;
pub const struct__AtkRectangle = extern struct {
    x: gint,
    y: gint,
    width: gint,
    height: gint,
};
pub const AtkRectangle = struct__AtkRectangle;
pub const struct__AtkComponentIface = extern struct {
    parent: GTypeInterface,
    add_focus_handler: ?extern fn (?*AtkComponent, AtkFocusHandler) guint,
    contains: ?extern fn (?*AtkComponent, gint, gint, AtkCoordType) gboolean,
    ref_accessible_at_point: ?extern fn (?*AtkComponent, gint, gint, AtkCoordType) [*c]AtkObject,
    get_extents: ?extern fn (?*AtkComponent, [*c]gint, [*c]gint, [*c]gint, [*c]gint, AtkCoordType) void,
    get_position: ?extern fn (?*AtkComponent, [*c]gint, [*c]gint, AtkCoordType) void,
    get_size: ?extern fn (?*AtkComponent, [*c]gint, [*c]gint) void,
    grab_focus: ?extern fn (?*AtkComponent) gboolean,
    remove_focus_handler: ?extern fn (?*AtkComponent, guint) void,
    set_extents: ?extern fn (?*AtkComponent, gint, gint, gint, gint, AtkCoordType) gboolean,
    set_position: ?extern fn (?*AtkComponent, gint, gint, AtkCoordType) gboolean,
    set_size: ?extern fn (?*AtkComponent, gint, gint) gboolean,
    get_layer: ?extern fn (?*AtkComponent) AtkLayer,
    get_mdi_zorder: ?extern fn (?*AtkComponent) gint,
    bounds_changed: ?extern fn (?*AtkComponent, [*c]AtkRectangle) void,
    get_alpha: ?extern fn (?*AtkComponent) gdouble,
    scroll_to: ?extern fn (?*AtkComponent, AtkScrollType) gboolean,
    scroll_to_point: ?extern fn (?*AtkComponent, AtkCoordType, gint, gint) gboolean,
};
pub const AtkComponentIface = struct__AtkComponentIface;
pub extern fn atk_rectangle_get_type() GType;
pub extern fn atk_component_get_type() GType;
pub extern fn atk_component_add_focus_handler(component: ?*AtkComponent, handler: AtkFocusHandler) guint;
pub extern fn atk_component_contains(component: ?*AtkComponent, x: gint, y: gint, coord_type: AtkCoordType) gboolean;
pub extern fn atk_component_ref_accessible_at_point(component: ?*AtkComponent, x: gint, y: gint, coord_type: AtkCoordType) [*c]AtkObject;
pub extern fn atk_component_get_extents(component: ?*AtkComponent, x: [*c]gint, y: [*c]gint, width: [*c]gint, height: [*c]gint, coord_type: AtkCoordType) void;
pub extern fn atk_component_get_position(component: ?*AtkComponent, x: [*c]gint, y: [*c]gint, coord_type: AtkCoordType) void;
pub extern fn atk_component_get_size(component: ?*AtkComponent, width: [*c]gint, height: [*c]gint) void;
pub extern fn atk_component_get_layer(component: ?*AtkComponent) AtkLayer;
pub extern fn atk_component_get_mdi_zorder(component: ?*AtkComponent) gint;
pub extern fn atk_component_grab_focus(component: ?*AtkComponent) gboolean;
pub extern fn atk_component_remove_focus_handler(component: ?*AtkComponent, handler_id: guint) void;
pub extern fn atk_component_set_extents(component: ?*AtkComponent, x: gint, y: gint, width: gint, height: gint, coord_type: AtkCoordType) gboolean;
pub extern fn atk_component_set_position(component: ?*AtkComponent, x: gint, y: gint, coord_type: AtkCoordType) gboolean;
pub extern fn atk_component_set_size(component: ?*AtkComponent, width: gint, height: gint) gboolean;
pub extern fn atk_component_get_alpha(component: ?*AtkComponent) gdouble;
pub extern fn atk_component_scroll_to(component: ?*AtkComponent, type_0: AtkScrollType) gboolean;
pub extern fn atk_component_scroll_to_point(component: ?*AtkComponent, coords: AtkCoordType, x: gint, y: gint) gboolean;
pub const struct__AtkDocument = @OpaqueType();
pub const AtkDocument = struct__AtkDocument;
pub const struct__AtkDocumentIface = extern struct {
    parent: GTypeInterface,
    get_document_type: ?extern fn (?*AtkDocument) [*c]const gchar,
    get_document: ?extern fn (?*AtkDocument) gpointer,
    get_document_locale: ?extern fn (?*AtkDocument) [*c]const gchar,
    get_document_attributes: ?extern fn (?*AtkDocument) [*c]AtkAttributeSet,
    get_document_attribute_value: ?extern fn (?*AtkDocument, [*c]const gchar) [*c]const gchar,
    set_document_attribute: ?extern fn (?*AtkDocument, [*c]const gchar, [*c]const gchar) gboolean,
    get_current_page_number: ?extern fn (?*AtkDocument) gint,
    get_page_count: ?extern fn (?*AtkDocument) gint,
};
pub const AtkDocumentIface = struct__AtkDocumentIface;
pub extern fn atk_document_get_type() GType;
pub extern fn atk_document_get_document_type(document: ?*AtkDocument) [*c]const gchar;
pub extern fn atk_document_get_document(document: ?*AtkDocument) gpointer;
pub extern fn atk_document_get_locale(document: ?*AtkDocument) [*c]const gchar;
pub extern fn atk_document_get_attributes(document: ?*AtkDocument) [*c]AtkAttributeSet;
pub extern fn atk_document_get_attribute_value(document: ?*AtkDocument, attribute_name: [*c]const gchar) [*c]const gchar;
pub extern fn atk_document_set_attribute_value(document: ?*AtkDocument, attribute_name: [*c]const gchar, attribute_value: [*c]const gchar) gboolean;
pub extern fn atk_document_get_current_page_number(document: ?*AtkDocument) gint;
pub extern fn atk_document_get_page_count(document: ?*AtkDocument) gint;
pub const ATK_TEXT_ATTR_INVALID = 0;
pub const ATK_TEXT_ATTR_LEFT_MARGIN = 1;
pub const ATK_TEXT_ATTR_RIGHT_MARGIN = 2;
pub const ATK_TEXT_ATTR_INDENT = 3;
pub const ATK_TEXT_ATTR_INVISIBLE = 4;
pub const ATK_TEXT_ATTR_EDITABLE = 5;
pub const ATK_TEXT_ATTR_PIXELS_ABOVE_LINES = 6;
pub const ATK_TEXT_ATTR_PIXELS_BELOW_LINES = 7;
pub const ATK_TEXT_ATTR_PIXELS_INSIDE_WRAP = 8;
pub const ATK_TEXT_ATTR_BG_FULL_HEIGHT = 9;
pub const ATK_TEXT_ATTR_RISE = 10;
pub const ATK_TEXT_ATTR_UNDERLINE = 11;
pub const ATK_TEXT_ATTR_STRIKETHROUGH = 12;
pub const ATK_TEXT_ATTR_SIZE = 13;
pub const ATK_TEXT_ATTR_SCALE = 14;
pub const ATK_TEXT_ATTR_WEIGHT = 15;
pub const ATK_TEXT_ATTR_LANGUAGE = 16;
pub const ATK_TEXT_ATTR_FAMILY_NAME = 17;
pub const ATK_TEXT_ATTR_BG_COLOR = 18;
pub const ATK_TEXT_ATTR_FG_COLOR = 19;
pub const ATK_TEXT_ATTR_BG_STIPPLE = 20;
pub const ATK_TEXT_ATTR_FG_STIPPLE = 21;
pub const ATK_TEXT_ATTR_WRAP_MODE = 22;
pub const ATK_TEXT_ATTR_DIRECTION = 23;
pub const ATK_TEXT_ATTR_JUSTIFICATION = 24;
pub const ATK_TEXT_ATTR_STRETCH = 25;
pub const ATK_TEXT_ATTR_VARIANT = 26;
pub const ATK_TEXT_ATTR_STYLE = 27;
pub const ATK_TEXT_ATTR_LAST_DEFINED = 28;
pub const AtkTextAttribute = extern enum {
    ATK_TEXT_ATTR_INVALID = 0,
    ATK_TEXT_ATTR_LEFT_MARGIN = 1,
    ATK_TEXT_ATTR_RIGHT_MARGIN = 2,
    ATK_TEXT_ATTR_INDENT = 3,
    ATK_TEXT_ATTR_INVISIBLE = 4,
    ATK_TEXT_ATTR_EDITABLE = 5,
    ATK_TEXT_ATTR_PIXELS_ABOVE_LINES = 6,
    ATK_TEXT_ATTR_PIXELS_BELOW_LINES = 7,
    ATK_TEXT_ATTR_PIXELS_INSIDE_WRAP = 8,
    ATK_TEXT_ATTR_BG_FULL_HEIGHT = 9,
    ATK_TEXT_ATTR_RISE = 10,
    ATK_TEXT_ATTR_UNDERLINE = 11,
    ATK_TEXT_ATTR_STRIKETHROUGH = 12,
    ATK_TEXT_ATTR_SIZE = 13,
    ATK_TEXT_ATTR_SCALE = 14,
    ATK_TEXT_ATTR_WEIGHT = 15,
    ATK_TEXT_ATTR_LANGUAGE = 16,
    ATK_TEXT_ATTR_FAMILY_NAME = 17,
    ATK_TEXT_ATTR_BG_COLOR = 18,
    ATK_TEXT_ATTR_FG_COLOR = 19,
    ATK_TEXT_ATTR_BG_STIPPLE = 20,
    ATK_TEXT_ATTR_FG_STIPPLE = 21,
    ATK_TEXT_ATTR_WRAP_MODE = 22,
    ATK_TEXT_ATTR_DIRECTION = 23,
    ATK_TEXT_ATTR_JUSTIFICATION = 24,
    ATK_TEXT_ATTR_STRETCH = 25,
    ATK_TEXT_ATTR_VARIANT = 26,
    ATK_TEXT_ATTR_STYLE = 27,
    ATK_TEXT_ATTR_LAST_DEFINED = 28,
};
pub extern fn atk_text_attribute_register(name: [*c]const gchar) AtkTextAttribute;
pub const struct__AtkText = @OpaqueType();
pub const AtkText = struct__AtkText;
pub const ATK_TEXT_BOUNDARY_CHAR = 0;
pub const ATK_TEXT_BOUNDARY_WORD_START = 1;
pub const ATK_TEXT_BOUNDARY_WORD_END = 2;
pub const ATK_TEXT_BOUNDARY_SENTENCE_START = 3;
pub const ATK_TEXT_BOUNDARY_SENTENCE_END = 4;
pub const ATK_TEXT_BOUNDARY_LINE_START = 5;
pub const ATK_TEXT_BOUNDARY_LINE_END = 6;
pub const AtkTextBoundary = extern enum {
    ATK_TEXT_BOUNDARY_CHAR = 0,
    ATK_TEXT_BOUNDARY_WORD_START = 1,
    ATK_TEXT_BOUNDARY_WORD_END = 2,
    ATK_TEXT_BOUNDARY_SENTENCE_START = 3,
    ATK_TEXT_BOUNDARY_SENTENCE_END = 4,
    ATK_TEXT_BOUNDARY_LINE_START = 5,
    ATK_TEXT_BOUNDARY_LINE_END = 6,
};
pub const struct__AtkTextRectangle = extern struct {
    x: gint,
    y: gint,
    width: gint,
    height: gint,
};
pub const AtkTextRectangle = struct__AtkTextRectangle;
pub const struct__AtkTextRange = extern struct {
    bounds: AtkTextRectangle,
    start_offset: gint,
    end_offset: gint,
    content: [*c]gchar,
};
pub const AtkTextRange = struct__AtkTextRange;
pub const ATK_TEXT_CLIP_NONE = 0;
pub const ATK_TEXT_CLIP_MIN = 1;
pub const ATK_TEXT_CLIP_MAX = 2;
pub const ATK_TEXT_CLIP_BOTH = 3;
pub const AtkTextClipType = extern enum {
    ATK_TEXT_CLIP_NONE = 0,
    ATK_TEXT_CLIP_MIN = 1,
    ATK_TEXT_CLIP_MAX = 2,
    ATK_TEXT_CLIP_BOTH = 3,
};
pub const ATK_TEXT_GRANULARITY_CHAR = 0;
pub const ATK_TEXT_GRANULARITY_WORD = 1;
pub const ATK_TEXT_GRANULARITY_SENTENCE = 2;
pub const ATK_TEXT_GRANULARITY_LINE = 3;
pub const ATK_TEXT_GRANULARITY_PARAGRAPH = 4;
pub const AtkTextGranularity = extern enum {
    ATK_TEXT_GRANULARITY_CHAR = 0,
    ATK_TEXT_GRANULARITY_WORD = 1,
    ATK_TEXT_GRANULARITY_SENTENCE = 2,
    ATK_TEXT_GRANULARITY_LINE = 3,
    ATK_TEXT_GRANULARITY_PARAGRAPH = 4,
};
pub const struct__AtkTextIface = extern struct {
    parent: GTypeInterface,
    get_text: ?extern fn (?*AtkText, gint, gint) [*c]gchar,
    get_text_after_offset: ?extern fn (?*AtkText, gint, AtkTextBoundary, [*c]gint, [*c]gint) [*c]gchar,
    get_text_at_offset: ?extern fn (?*AtkText, gint, AtkTextBoundary, [*c]gint, [*c]gint) [*c]gchar,
    get_character_at_offset: ?extern fn (?*AtkText, gint) gunichar,
    get_text_before_offset: ?extern fn (?*AtkText, gint, AtkTextBoundary, [*c]gint, [*c]gint) [*c]gchar,
    get_caret_offset: ?extern fn (?*AtkText) gint,
    get_run_attributes: ?extern fn (?*AtkText, gint, [*c]gint, [*c]gint) [*c]AtkAttributeSet,
    get_default_attributes: ?extern fn (?*AtkText) [*c]AtkAttributeSet,
    get_character_extents: ?extern fn (?*AtkText, gint, [*c]gint, [*c]gint, [*c]gint, [*c]gint, AtkCoordType) void,
    get_character_count: ?extern fn (?*AtkText) gint,
    get_offset_at_point: ?extern fn (?*AtkText, gint, gint, AtkCoordType) gint,
    get_n_selections: ?extern fn (?*AtkText) gint,
    get_selection: ?extern fn (?*AtkText, gint, [*c]gint, [*c]gint) [*c]gchar,
    add_selection: ?extern fn (?*AtkText, gint, gint) gboolean,
    remove_selection: ?extern fn (?*AtkText, gint) gboolean,
    set_selection: ?extern fn (?*AtkText, gint, gint, gint) gboolean,
    set_caret_offset: ?extern fn (?*AtkText, gint) gboolean,
    text_changed: ?extern fn (?*AtkText, gint, gint) void,
    text_caret_moved: ?extern fn (?*AtkText, gint) void,
    text_selection_changed: ?extern fn (?*AtkText) void,
    text_attributes_changed: ?extern fn (?*AtkText) void,
    get_range_extents: ?extern fn (?*AtkText, gint, gint, AtkCoordType, [*c]AtkTextRectangle) void,
    get_bounded_ranges: ?extern fn (?*AtkText, [*c]AtkTextRectangle, AtkCoordType, AtkTextClipType, AtkTextClipType) [*c]([*c]AtkTextRange),
    get_string_at_offset: ?extern fn (?*AtkText, gint, AtkTextGranularity, [*c]gint, [*c]gint) [*c]gchar,
    scroll_substring_to: ?extern fn (?*AtkText, gint, gint, AtkScrollType) gboolean,
    scroll_substring_to_point: ?extern fn (?*AtkText, gint, gint, AtkCoordType, gint, gint) gboolean,
};
pub const AtkTextIface = struct__AtkTextIface;
pub extern fn atk_text_range_get_type() GType;
pub extern fn atk_text_get_type() GType;
pub extern fn atk_text_get_text(text: ?*AtkText, start_offset: gint, end_offset: gint) [*c]gchar;
pub extern fn atk_text_get_character_at_offset(text: ?*AtkText, offset: gint) gunichar;
pub extern fn atk_text_get_text_after_offset(text: ?*AtkText, offset: gint, boundary_type: AtkTextBoundary, start_offset: [*c]gint, end_offset: [*c]gint) [*c]gchar;
pub extern fn atk_text_get_text_at_offset(text: ?*AtkText, offset: gint, boundary_type: AtkTextBoundary, start_offset: [*c]gint, end_offset: [*c]gint) [*c]gchar;
pub extern fn atk_text_get_text_before_offset(text: ?*AtkText, offset: gint, boundary_type: AtkTextBoundary, start_offset: [*c]gint, end_offset: [*c]gint) [*c]gchar;
pub extern fn atk_text_get_string_at_offset(text: ?*AtkText, offset: gint, granularity: AtkTextGranularity, start_offset: [*c]gint, end_offset: [*c]gint) [*c]gchar;
pub extern fn atk_text_get_caret_offset(text: ?*AtkText) gint;
pub extern fn atk_text_get_character_extents(text: ?*AtkText, offset: gint, x: [*c]gint, y: [*c]gint, width: [*c]gint, height: [*c]gint, coords: AtkCoordType) void;
pub extern fn atk_text_get_run_attributes(text: ?*AtkText, offset: gint, start_offset: [*c]gint, end_offset: [*c]gint) [*c]AtkAttributeSet;
pub extern fn atk_text_get_default_attributes(text: ?*AtkText) [*c]AtkAttributeSet;
pub extern fn atk_text_get_character_count(text: ?*AtkText) gint;
pub extern fn atk_text_get_offset_at_point(text: ?*AtkText, x: gint, y: gint, coords: AtkCoordType) gint;
pub extern fn atk_text_get_n_selections(text: ?*AtkText) gint;
pub extern fn atk_text_get_selection(text: ?*AtkText, selection_num: gint, start_offset: [*c]gint, end_offset: [*c]gint) [*c]gchar;
pub extern fn atk_text_add_selection(text: ?*AtkText, start_offset: gint, end_offset: gint) gboolean;
pub extern fn atk_text_remove_selection(text: ?*AtkText, selection_num: gint) gboolean;
pub extern fn atk_text_set_selection(text: ?*AtkText, selection_num: gint, start_offset: gint, end_offset: gint) gboolean;
pub extern fn atk_text_set_caret_offset(text: ?*AtkText, offset: gint) gboolean;
pub extern fn atk_text_get_range_extents(text: ?*AtkText, start_offset: gint, end_offset: gint, coord_type: AtkCoordType, rect: [*c]AtkTextRectangle) void;
pub extern fn atk_text_get_bounded_ranges(text: ?*AtkText, rect: [*c]AtkTextRectangle, coord_type: AtkCoordType, x_clip_type: AtkTextClipType, y_clip_type: AtkTextClipType) [*c]([*c]AtkTextRange);
pub extern fn atk_text_free_ranges(ranges: [*c]([*c]AtkTextRange)) void;
pub extern fn atk_attribute_set_free(attrib_set: [*c]AtkAttributeSet) void;
pub extern fn atk_text_attribute_get_name(attr: AtkTextAttribute) [*c]const gchar;
pub extern fn atk_text_attribute_for_name(name: [*c]const gchar) AtkTextAttribute;
pub extern fn atk_text_attribute_get_value(attr: AtkTextAttribute, index_: gint) [*c]const gchar;
pub extern fn atk_text_scroll_substring_to(text: ?*AtkText, start_offset: gint, end_offset: gint, type_0: AtkScrollType) gboolean;
pub extern fn atk_text_scroll_substring_to_point(text: ?*AtkText, start_offset: gint, end_offset: gint, coords: AtkCoordType, x: gint, y: gint) gboolean;
pub const struct__AtkEditableText = @OpaqueType();
pub const AtkEditableText = struct__AtkEditableText;
pub const struct__AtkEditableTextIface = extern struct {
    parent_interface: GTypeInterface,
    set_run_attributes: ?extern fn (?*AtkEditableText, [*c]AtkAttributeSet, gint, gint) gboolean,
    set_text_contents: ?extern fn (?*AtkEditableText, [*c]const gchar) void,
    insert_text: ?extern fn (?*AtkEditableText, [*c]const gchar, gint, [*c]gint) void,
    copy_text: ?extern fn (?*AtkEditableText, gint, gint) void,
    cut_text: ?extern fn (?*AtkEditableText, gint, gint) void,
    delete_text: ?extern fn (?*AtkEditableText, gint, gint) void,
    paste_text: ?extern fn (?*AtkEditableText, gint) void,
};
pub const AtkEditableTextIface = struct__AtkEditableTextIface;
pub extern fn atk_editable_text_get_type() GType;
pub extern fn atk_editable_text_set_run_attributes(text: ?*AtkEditableText, attrib_set: [*c]AtkAttributeSet, start_offset: gint, end_offset: gint) gboolean;
pub extern fn atk_editable_text_set_text_contents(text: ?*AtkEditableText, string: [*c]const gchar) void;
pub extern fn atk_editable_text_insert_text(text: ?*AtkEditableText, string: [*c]const gchar, length: gint, position: [*c]gint) void;
pub extern fn atk_editable_text_copy_text(text: ?*AtkEditableText, start_pos: gint, end_pos: gint) void;
pub extern fn atk_editable_text_cut_text(text: ?*AtkEditableText, start_pos: gint, end_pos: gint) void;
pub extern fn atk_editable_text_delete_text(text: ?*AtkEditableText, start_pos: gint, end_pos: gint) void;
pub extern fn atk_editable_text_paste_text(text: ?*AtkEditableText, position: gint) void;
pub extern fn atk_scroll_type_get_type() GType;
pub extern fn atk_hyperlink_state_flags_get_type() GType;
pub extern fn atk_role_get_type() GType;
pub extern fn atk_layer_get_type() GType;
pub extern fn atk_relation_type_get_type() GType;
pub extern fn atk_state_type_get_type() GType;
pub extern fn atk_text_attribute_get_type() GType;
pub extern fn atk_text_boundary_get_type() GType;
pub extern fn atk_text_granularity_get_type() GType;
pub extern fn atk_text_clip_type_get_type() GType;
pub extern fn atk_key_event_type_get_type() GType;
pub extern fn atk_coord_type_get_type() GType;
pub extern fn atk_value_type_get_type() GType;
pub const struct__AtkGObjectAccessible = extern struct {
    parent: AtkObject,
};
pub const AtkGObjectAccessible = struct__AtkGObjectAccessible;
pub const struct__AtkGObjectAccessibleClass = extern struct {
    parent_class: AtkObjectClass,
    pad1: AtkFunction,
    pad2: AtkFunction,
};
pub const AtkGObjectAccessibleClass = struct__AtkGObjectAccessibleClass;
pub extern fn atk_gobject_accessible_get_type() GType;
pub extern fn atk_gobject_accessible_for_object(obj: [*c]GObject) [*c]AtkObject;
pub extern fn atk_gobject_accessible_get_object(obj: [*c]AtkGObjectAccessible) [*c]GObject;
pub const ATK_HYPERLINK_IS_INLINE = 1;
pub const AtkHyperlinkStateFlags = extern enum {
    ATK_HYPERLINK_IS_INLINE = 1,
};
pub const struct__AtkHyperlink = extern struct {
    parent: GObject,
};
pub const AtkHyperlink = struct__AtkHyperlink;
pub const struct__AtkHyperlinkClass = extern struct {
    parent: GObjectClass,
    get_uri: ?extern fn ([*c]AtkHyperlink, gint) [*c]gchar,
    get_object: ?extern fn ([*c]AtkHyperlink, gint) [*c]AtkObject,
    get_end_index: ?extern fn ([*c]AtkHyperlink) gint,
    get_start_index: ?extern fn ([*c]AtkHyperlink) gint,
    is_valid: ?extern fn ([*c]AtkHyperlink) gboolean,
    get_n_anchors: ?extern fn ([*c]AtkHyperlink) gint,
    link_state: ?extern fn ([*c]AtkHyperlink) guint,
    is_selected_link: ?extern fn ([*c]AtkHyperlink) gboolean,
    link_activated: ?extern fn ([*c]AtkHyperlink) void,
    pad1: AtkFunction,
};
pub const AtkHyperlinkClass = struct__AtkHyperlinkClass;
pub extern fn atk_hyperlink_get_type() GType;
pub extern fn atk_hyperlink_get_uri(link_: [*c]AtkHyperlink, i: gint) [*c]gchar;
pub extern fn atk_hyperlink_get_object(link_: [*c]AtkHyperlink, i: gint) [*c]AtkObject;
pub extern fn atk_hyperlink_get_end_index(link_: [*c]AtkHyperlink) gint;
pub extern fn atk_hyperlink_get_start_index(link_: [*c]AtkHyperlink) gint;
pub extern fn atk_hyperlink_is_valid(link_: [*c]AtkHyperlink) gboolean;
pub extern fn atk_hyperlink_is_inline(link_: [*c]AtkHyperlink) gboolean;
pub extern fn atk_hyperlink_get_n_anchors(link_: [*c]AtkHyperlink) gint;
pub extern fn atk_hyperlink_is_selected_link(link_: [*c]AtkHyperlink) gboolean;
pub const struct__AtkHyperlinkImpl = @OpaqueType();
pub const AtkHyperlinkImpl = struct__AtkHyperlinkImpl;
pub const struct__AtkHyperlinkImplIface = extern struct {
    parent: GTypeInterface,
    get_hyperlink: ?extern fn (?*AtkHyperlinkImpl) [*c]AtkHyperlink,
};
pub const AtkHyperlinkImplIface = struct__AtkHyperlinkImplIface;
pub extern fn atk_hyperlink_impl_get_type() GType;
pub extern fn atk_hyperlink_impl_get_hyperlink(impl: ?*AtkHyperlinkImpl) [*c]AtkHyperlink;
pub const struct__AtkHypertext = @OpaqueType();
pub const AtkHypertext = struct__AtkHypertext;
pub const struct__AtkHypertextIface = extern struct {
    parent: GTypeInterface,
    get_link: ?extern fn (?*AtkHypertext, gint) [*c]AtkHyperlink,
    get_n_links: ?extern fn (?*AtkHypertext) gint,
    get_link_index: ?extern fn (?*AtkHypertext, gint) gint,
    link_selected: ?extern fn (?*AtkHypertext, gint) void,
};
pub const AtkHypertextIface = struct__AtkHypertextIface;
pub extern fn atk_hypertext_get_type() GType;
pub extern fn atk_hypertext_get_link(hypertext: ?*AtkHypertext, link_index: gint) [*c]AtkHyperlink;
pub extern fn atk_hypertext_get_n_links(hypertext: ?*AtkHypertext) gint;
pub extern fn atk_hypertext_get_link_index(hypertext: ?*AtkHypertext, char_index: gint) gint;
pub const struct__AtkImage = @OpaqueType();
pub const AtkImage = struct__AtkImage;
pub const struct__AtkImageIface = extern struct {
    parent: GTypeInterface,
    get_image_position: ?extern fn (?*AtkImage, [*c]gint, [*c]gint, AtkCoordType) void,
    get_image_description: ?extern fn (?*AtkImage) [*c]const gchar,
    get_image_size: ?extern fn (?*AtkImage, [*c]gint, [*c]gint) void,
    set_image_description: ?extern fn (?*AtkImage, [*c]const gchar) gboolean,
    get_image_locale: ?extern fn (?*AtkImage) [*c]const gchar,
};
pub const AtkImageIface = struct__AtkImageIface;
pub extern fn atk_image_get_type() GType;
pub extern fn atk_image_get_image_description(image: ?*AtkImage) [*c]const gchar;
pub extern fn atk_image_get_image_size(image: ?*AtkImage, width: [*c]gint, height: [*c]gint) void;
pub extern fn atk_image_set_image_description(image: ?*AtkImage, description: [*c]const gchar) gboolean;
pub extern fn atk_image_get_image_position(image: ?*AtkImage, x: [*c]gint, y: [*c]gint, coord_type: AtkCoordType) void;
pub extern fn atk_image_get_image_locale(image: ?*AtkImage) [*c]const gchar;
pub const struct__AtkNoOpObject = extern struct {
    parent: AtkObject,
};
pub const AtkNoOpObject = struct__AtkNoOpObject;
pub const struct__AtkNoOpObjectClass = extern struct {
    parent_class: AtkObjectClass,
};
pub const AtkNoOpObjectClass = struct__AtkNoOpObjectClass;
pub extern fn atk_no_op_object_get_type() GType;
pub extern fn atk_no_op_object_new(obj: [*c]GObject) [*c]AtkObject;
pub const struct__AtkObjectFactory = extern struct {
    parent: GObject,
};
pub const AtkObjectFactory = struct__AtkObjectFactory;
pub const struct__AtkObjectFactoryClass = extern struct {
    parent_class: GObjectClass,
    create_accessible: ?extern fn ([*c]GObject) [*c]AtkObject,
    invalidate: ?extern fn ([*c]AtkObjectFactory) void,
    get_accessible_type: ?extern fn () GType,
    pad1: AtkFunction,
    pad2: AtkFunction,
};
pub const AtkObjectFactoryClass = struct__AtkObjectFactoryClass;
pub extern fn atk_object_factory_get_type() GType;
pub extern fn atk_object_factory_create_accessible(factory: [*c]AtkObjectFactory, obj: [*c]GObject) [*c]AtkObject;
pub extern fn atk_object_factory_invalidate(factory: [*c]AtkObjectFactory) void;
pub extern fn atk_object_factory_get_accessible_type(factory: [*c]AtkObjectFactory) GType;
pub const struct__AtkNoOpObjectFactory = extern struct {
    parent: AtkObjectFactory,
};
pub const AtkNoOpObjectFactory = struct__AtkNoOpObjectFactory;
pub const struct__AtkNoOpObjectFactoryClass = extern struct {
    parent_class: AtkObjectFactoryClass,
};
pub const AtkNoOpObjectFactoryClass = struct__AtkNoOpObjectFactoryClass;
pub extern fn atk_no_op_object_factory_get_type() GType;
pub extern fn atk_no_op_object_factory_new() [*c]AtkObjectFactory;
pub const struct__AtkPlug = extern struct {
    parent: AtkObject,
};
pub const AtkPlug = struct__AtkPlug;
pub const struct__AtkPlugClass = extern struct {
    parent_class: AtkObjectClass,
    get_object_id: ?extern fn ([*c]AtkPlug) [*c]gchar,
};
pub const AtkPlugClass = struct__AtkPlugClass;
pub extern fn atk_plug_get_type() GType;
pub extern fn atk_plug_new() [*c]AtkObject;
pub extern fn atk_plug_get_id(plug: [*c]AtkPlug) [*c]gchar;
pub const struct__AtkRange = @OpaqueType();
pub const AtkRange = struct__AtkRange;
pub extern fn atk_range_get_type() GType;
pub extern fn atk_range_copy(src: ?*AtkRange) ?*AtkRange;
pub extern fn atk_range_free(range: ?*AtkRange) void;
pub extern fn atk_range_get_lower_limit(range: ?*AtkRange) gdouble;
pub extern fn atk_range_get_upper_limit(range: ?*AtkRange) gdouble;
pub extern fn atk_range_get_description(range: ?*AtkRange) [*c]const gchar;
pub extern fn atk_range_new(lower_limit: gdouble, upper_limit: gdouble, description: [*c]const gchar) ?*AtkRange;
pub const struct__AtkRegistry = extern struct {
    parent: GObject,
    factory_type_registry: ?*GHashTable,
    factory_singleton_cache: ?*GHashTable,
};
pub const struct__AtkRegistryClass = extern struct {
    parent_class: GObjectClass,
};
pub const AtkRegistry = struct__AtkRegistry;
pub const AtkRegistryClass = struct__AtkRegistryClass;
pub extern fn atk_registry_get_type() GType;
pub extern fn atk_registry_set_factory_type(registry: [*c]AtkRegistry, type_0: GType, factory_type: GType) void;
pub extern fn atk_registry_get_factory_type(registry: [*c]AtkRegistry, type_0: GType) GType;
pub extern fn atk_registry_get_factory(registry: [*c]AtkRegistry, type_0: GType) [*c]AtkObjectFactory;
pub extern fn atk_get_default_registry() [*c]AtkRegistry;
pub const struct__AtkRelation = extern struct {
    parent: GObject,
    target: [*c]GPtrArray,
    relationship: AtkRelationType,
};
pub const AtkRelation = struct__AtkRelation;
pub const struct__AtkRelationClass = extern struct {
    parent: GObjectClass,
};
pub const AtkRelationClass = struct__AtkRelationClass;
pub extern fn atk_relation_get_type() GType;
pub extern fn atk_relation_type_register(name: [*c]const gchar) AtkRelationType;
pub extern fn atk_relation_type_get_name(type_0: AtkRelationType) [*c]const gchar;
pub extern fn atk_relation_type_for_name(name: [*c]const gchar) AtkRelationType;
pub extern fn atk_relation_new(targets: [*c]([*c]AtkObject), n_targets: gint, relationship: AtkRelationType) [*c]AtkRelation;
pub extern fn atk_relation_get_relation_type(relation: [*c]AtkRelation) AtkRelationType;
pub extern fn atk_relation_get_target(relation: [*c]AtkRelation) [*c]GPtrArray;
pub extern fn atk_relation_add_target(relation: [*c]AtkRelation, target: [*c]AtkObject) void;
pub extern fn atk_relation_remove_target(relation: [*c]AtkRelation, target: [*c]AtkObject) gboolean;
pub const struct__AtkRelationSetClass = extern struct {
    parent: GObjectClass,
    pad1: AtkFunction,
    pad2: AtkFunction,
};
pub const AtkRelationSetClass = struct__AtkRelationSetClass;
pub extern fn atk_relation_set_get_type() GType;
pub extern fn atk_relation_set_new() [*c]AtkRelationSet;
pub extern fn atk_relation_set_contains(set: [*c]AtkRelationSet, relationship: AtkRelationType) gboolean;
pub extern fn atk_relation_set_contains_target(set: [*c]AtkRelationSet, relationship: AtkRelationType, target: [*c]AtkObject) gboolean;
pub extern fn atk_relation_set_remove(set: [*c]AtkRelationSet, relation: [*c]AtkRelation) void;
pub extern fn atk_relation_set_add(set: [*c]AtkRelationSet, relation: [*c]AtkRelation) void;
pub extern fn atk_relation_set_get_n_relations(set: [*c]AtkRelationSet) gint;
pub extern fn atk_relation_set_get_relation(set: [*c]AtkRelationSet, i: gint) [*c]AtkRelation;
pub extern fn atk_relation_set_get_relation_by_type(set: [*c]AtkRelationSet, relationship: AtkRelationType) [*c]AtkRelation;
pub extern fn atk_relation_set_add_relation_by_type(set: [*c]AtkRelationSet, relationship: AtkRelationType, target: [*c]AtkObject) void;
pub const struct__AtkSelection = @OpaqueType();
pub const AtkSelection = struct__AtkSelection;
pub const struct__AtkSelectionIface = extern struct {
    parent: GTypeInterface,
    add_selection: ?extern fn (?*AtkSelection, gint) gboolean,
    clear_selection: ?extern fn (?*AtkSelection) gboolean,
    ref_selection: ?extern fn (?*AtkSelection, gint) [*c]AtkObject,
    get_selection_count: ?extern fn (?*AtkSelection) gint,
    is_child_selected: ?extern fn (?*AtkSelection, gint) gboolean,
    remove_selection: ?extern fn (?*AtkSelection, gint) gboolean,
    select_all_selection: ?extern fn (?*AtkSelection) gboolean,
    selection_changed: ?extern fn (?*AtkSelection) void,
};
pub const AtkSelectionIface = struct__AtkSelectionIface;
pub extern fn atk_selection_get_type() GType;
pub extern fn atk_selection_add_selection(selection: ?*AtkSelection, i: gint) gboolean;
pub extern fn atk_selection_clear_selection(selection: ?*AtkSelection) gboolean;
pub extern fn atk_selection_ref_selection(selection: ?*AtkSelection, i: gint) [*c]AtkObject;
pub extern fn atk_selection_get_selection_count(selection: ?*AtkSelection) gint;
pub extern fn atk_selection_is_child_selected(selection: ?*AtkSelection, i: gint) gboolean;
pub extern fn atk_selection_remove_selection(selection: ?*AtkSelection, i: gint) gboolean;
pub extern fn atk_selection_select_all_selection(selection: ?*AtkSelection) gboolean;
pub const struct__AtkSocket = extern struct {
    parent: AtkObject,
    embedded_plug_id: [*c]gchar,
};
pub const AtkSocket = struct__AtkSocket;
pub const struct__AtkSocketClass = extern struct {
    parent_class: AtkObjectClass,
    embed: ?extern fn ([*c]AtkSocket, [*c]gchar) void,
};
pub const AtkSocketClass = struct__AtkSocketClass;
pub extern fn atk_socket_get_type() GType;
pub extern fn atk_socket_new() [*c]AtkObject;
pub extern fn atk_socket_embed(obj: [*c]AtkSocket, plug_id: [*c]gchar) void;
pub extern fn atk_socket_is_occupied(obj: [*c]AtkSocket) gboolean;
pub const struct__AtkStateSetClass = extern struct {
    parent: GObjectClass,
};
pub const AtkStateSetClass = struct__AtkStateSetClass;
pub extern fn atk_state_set_get_type() GType;
pub extern fn atk_state_set_new() [*c]AtkStateSet;
pub extern fn atk_state_set_is_empty(set: [*c]AtkStateSet) gboolean;
pub extern fn atk_state_set_add_state(set: [*c]AtkStateSet, type_0: AtkStateType) gboolean;
pub extern fn atk_state_set_add_states(set: [*c]AtkStateSet, types: [*c]AtkStateType, n_types: gint) void;
pub extern fn atk_state_set_clear_states(set: [*c]AtkStateSet) void;
pub extern fn atk_state_set_contains_state(set: [*c]AtkStateSet, type_0: AtkStateType) gboolean;
pub extern fn atk_state_set_contains_states(set: [*c]AtkStateSet, types: [*c]AtkStateType, n_types: gint) gboolean;
pub extern fn atk_state_set_remove_state(set: [*c]AtkStateSet, type_0: AtkStateType) gboolean;
pub extern fn atk_state_set_and_sets(set: [*c]AtkStateSet, compare_set: [*c]AtkStateSet) [*c]AtkStateSet;
pub extern fn atk_state_set_or_sets(set: [*c]AtkStateSet, compare_set: [*c]AtkStateSet) [*c]AtkStateSet;
pub extern fn atk_state_set_xor_sets(set: [*c]AtkStateSet, compare_set: [*c]AtkStateSet) [*c]AtkStateSet;
pub const struct__AtkStreamableContent = @OpaqueType();
pub const AtkStreamableContent = struct__AtkStreamableContent;
pub const struct__AtkStreamableContentIface = extern struct {
    parent: GTypeInterface,
    get_n_mime_types: ?extern fn (?*AtkStreamableContent) gint,
    get_mime_type: ?extern fn (?*AtkStreamableContent, gint) [*c]const gchar,
    get_stream: ?extern fn (?*AtkStreamableContent, [*c]const gchar) ?*GIOChannel,
    get_uri: ?extern fn (?*AtkStreamableContent, [*c]const gchar) [*c]const gchar,
    pad1: AtkFunction,
    pad2: AtkFunction,
    pad3: AtkFunction,
};
pub const AtkStreamableContentIface = struct__AtkStreamableContentIface;
pub extern fn atk_streamable_content_get_type() GType;
pub extern fn atk_streamable_content_get_n_mime_types(streamable: ?*AtkStreamableContent) gint;
pub extern fn atk_streamable_content_get_mime_type(streamable: ?*AtkStreamableContent, i: gint) [*c]const gchar;
pub extern fn atk_streamable_content_get_stream(streamable: ?*AtkStreamableContent, mime_type: [*c]const gchar) ?*GIOChannel;
pub extern fn atk_streamable_content_get_uri(streamable: ?*AtkStreamableContent, mime_type: [*c]const gchar) [*c]const gchar;
pub const struct__AtkTable = @OpaqueType();
pub const AtkTable = struct__AtkTable;
pub const struct__AtkTableIface = extern struct {
    parent: GTypeInterface,
    ref_at: ?extern fn (?*AtkTable, gint, gint) [*c]AtkObject,
    get_index_at: ?extern fn (?*AtkTable, gint, gint) gint,
    get_column_at_index: ?extern fn (?*AtkTable, gint) gint,
    get_row_at_index: ?extern fn (?*AtkTable, gint) gint,
    get_n_columns: ?extern fn (?*AtkTable) gint,
    get_n_rows: ?extern fn (?*AtkTable) gint,
    get_column_extent_at: ?extern fn (?*AtkTable, gint, gint) gint,
    get_row_extent_at: ?extern fn (?*AtkTable, gint, gint) gint,
    get_caption: ?extern fn (?*AtkTable) [*c]AtkObject,
    get_column_description: ?extern fn (?*AtkTable, gint) [*c]const gchar,
    get_column_header: ?extern fn (?*AtkTable, gint) [*c]AtkObject,
    get_row_description: ?extern fn (?*AtkTable, gint) [*c]const gchar,
    get_row_header: ?extern fn (?*AtkTable, gint) [*c]AtkObject,
    get_summary: ?extern fn (?*AtkTable) [*c]AtkObject,
    set_caption: ?extern fn (?*AtkTable, [*c]AtkObject) void,
    set_column_description: ?extern fn (?*AtkTable, gint, [*c]const gchar) void,
    set_column_header: ?extern fn (?*AtkTable, gint, [*c]AtkObject) void,
    set_row_description: ?extern fn (?*AtkTable, gint, [*c]const gchar) void,
    set_row_header: ?extern fn (?*AtkTable, gint, [*c]AtkObject) void,
    set_summary: ?extern fn (?*AtkTable, [*c]AtkObject) void,
    get_selected_columns: ?extern fn (?*AtkTable, [*c]([*c]gint)) gint,
    get_selected_rows: ?extern fn (?*AtkTable, [*c]([*c]gint)) gint,
    is_column_selected: ?extern fn (?*AtkTable, gint) gboolean,
    is_row_selected: ?extern fn (?*AtkTable, gint) gboolean,
    is_selected: ?extern fn (?*AtkTable, gint, gint) gboolean,
    add_row_selection: ?extern fn (?*AtkTable, gint) gboolean,
    remove_row_selection: ?extern fn (?*AtkTable, gint) gboolean,
    add_column_selection: ?extern fn (?*AtkTable, gint) gboolean,
    remove_column_selection: ?extern fn (?*AtkTable, gint) gboolean,
    row_inserted: ?extern fn (?*AtkTable, gint, gint) void,
    column_inserted: ?extern fn (?*AtkTable, gint, gint) void,
    row_deleted: ?extern fn (?*AtkTable, gint, gint) void,
    column_deleted: ?extern fn (?*AtkTable, gint, gint) void,
    row_reordered: ?extern fn (?*AtkTable) void,
    column_reordered: ?extern fn (?*AtkTable) void,
    model_changed: ?extern fn (?*AtkTable) void,
};
pub const AtkTableIface = struct__AtkTableIface;
pub extern fn atk_table_get_type() GType;
pub extern fn atk_table_ref_at(table: ?*AtkTable, row: gint, column: gint) [*c]AtkObject;
pub extern fn atk_table_get_index_at(table: ?*AtkTable, row: gint, column: gint) gint;
pub extern fn atk_table_get_column_at_index(table: ?*AtkTable, index_: gint) gint;
pub extern fn atk_table_get_row_at_index(table: ?*AtkTable, index_: gint) gint;
pub extern fn atk_table_get_n_columns(table: ?*AtkTable) gint;
pub extern fn atk_table_get_n_rows(table: ?*AtkTable) gint;
pub extern fn atk_table_get_column_extent_at(table: ?*AtkTable, row: gint, column: gint) gint;
pub extern fn atk_table_get_row_extent_at(table: ?*AtkTable, row: gint, column: gint) gint;
pub extern fn atk_table_get_caption(table: ?*AtkTable) [*c]AtkObject;
pub extern fn atk_table_get_column_description(table: ?*AtkTable, column: gint) [*c]const gchar;
pub extern fn atk_table_get_column_header(table: ?*AtkTable, column: gint) [*c]AtkObject;
pub extern fn atk_table_get_row_description(table: ?*AtkTable, row: gint) [*c]const gchar;
pub extern fn atk_table_get_row_header(table: ?*AtkTable, row: gint) [*c]AtkObject;
pub extern fn atk_table_get_summary(table: ?*AtkTable) [*c]AtkObject;
pub extern fn atk_table_set_caption(table: ?*AtkTable, caption: [*c]AtkObject) void;
pub extern fn atk_table_set_column_description(table: ?*AtkTable, column: gint, description: [*c]const gchar) void;
pub extern fn atk_table_set_column_header(table: ?*AtkTable, column: gint, header: [*c]AtkObject) void;
pub extern fn atk_table_set_row_description(table: ?*AtkTable, row: gint, description: [*c]const gchar) void;
pub extern fn atk_table_set_row_header(table: ?*AtkTable, row: gint, header: [*c]AtkObject) void;
pub extern fn atk_table_set_summary(table: ?*AtkTable, accessible: [*c]AtkObject) void;
pub extern fn atk_table_get_selected_columns(table: ?*AtkTable, selected: [*c]([*c]gint)) gint;
pub extern fn atk_table_get_selected_rows(table: ?*AtkTable, selected: [*c]([*c]gint)) gint;
pub extern fn atk_table_is_column_selected(table: ?*AtkTable, column: gint) gboolean;
pub extern fn atk_table_is_row_selected(table: ?*AtkTable, row: gint) gboolean;
pub extern fn atk_table_is_selected(table: ?*AtkTable, row: gint, column: gint) gboolean;
pub extern fn atk_table_add_row_selection(table: ?*AtkTable, row: gint) gboolean;
pub extern fn atk_table_remove_row_selection(table: ?*AtkTable, row: gint) gboolean;
pub extern fn atk_table_add_column_selection(table: ?*AtkTable, column: gint) gboolean;
pub extern fn atk_table_remove_column_selection(table: ?*AtkTable, column: gint) gboolean;
pub const struct__AtkTableCell = @OpaqueType();
pub const AtkTableCell = struct__AtkTableCell;
pub const struct__AtkTableCellIface = extern struct {
    parent: GTypeInterface,
    get_column_span: ?extern fn (?*AtkTableCell) gint,
    get_column_header_cells: ?extern fn (?*AtkTableCell) [*c]GPtrArray,
    get_position: ?extern fn (?*AtkTableCell, [*c]gint, [*c]gint) gboolean,
    get_row_span: ?extern fn (?*AtkTableCell) gint,
    get_row_header_cells: ?extern fn (?*AtkTableCell) [*c]GPtrArray,
    get_row_column_span: ?extern fn (?*AtkTableCell, [*c]gint, [*c]gint, [*c]gint, [*c]gint) gboolean,
    get_table: ?extern fn (?*AtkTableCell) [*c]AtkObject,
};
pub const AtkTableCellIface = struct__AtkTableCellIface;
pub extern fn atk_table_cell_get_type() GType;
pub extern fn atk_table_cell_get_column_span(cell: ?*AtkTableCell) gint;
pub extern fn atk_table_cell_get_column_header_cells(cell: ?*AtkTableCell) [*c]GPtrArray;
pub extern fn atk_table_cell_get_position(cell: ?*AtkTableCell, row: [*c]gint, column: [*c]gint) gboolean;
pub extern fn atk_table_cell_get_row_span(cell: ?*AtkTableCell) gint;
pub extern fn atk_table_cell_get_row_header_cells(cell: ?*AtkTableCell) [*c]GPtrArray;
pub extern fn atk_table_cell_get_row_column_span(cell: ?*AtkTableCell, row: [*c]gint, column: [*c]gint, row_span: [*c]gint, column_span: [*c]gint) gboolean;
pub extern fn atk_table_cell_get_table(cell: ?*AtkTableCell) [*c]AtkObject;
pub const struct__AtkMisc = extern struct {
    parent: GObject,
};
pub const AtkMisc = struct__AtkMisc;
pub const struct__AtkMiscClass = extern struct {
    parent: GObjectClass,
    threads_enter: ?extern fn ([*c]AtkMisc) void,
    threads_leave: ?extern fn ([*c]AtkMisc) void,
    vfuncs: [32]gpointer,
};
pub const AtkMiscClass = struct__AtkMiscClass;
pub extern var atk_misc_instance: [*c]AtkMisc;
pub extern fn atk_misc_get_type() GType;
pub extern fn atk_misc_threads_enter(misc: [*c]AtkMisc) void;
pub extern fn atk_misc_threads_leave(misc: [*c]AtkMisc) void;
pub extern fn atk_misc_get_instance() [*c]const AtkMisc;
pub const struct__AtkValue = @OpaqueType();
pub const AtkValue = struct__AtkValue;
pub const struct__AtkValueIface = extern struct {
    parent: GTypeInterface,
    get_current_value: ?extern fn (?*AtkValue, [*c]GValue) void,
    get_maximum_value: ?extern fn (?*AtkValue, [*c]GValue) void,
    get_minimum_value: ?extern fn (?*AtkValue, [*c]GValue) void,
    set_current_value: ?extern fn (?*AtkValue, [*c]const GValue) gboolean,
    get_minimum_increment: ?extern fn (?*AtkValue, [*c]GValue) void,
    get_value_and_text: ?extern fn (?*AtkValue, [*c]gdouble, [*c]([*c]gchar)) void,
    get_range: ?extern fn (?*AtkValue) ?*AtkRange,
    get_increment: ?extern fn (?*AtkValue) gdouble,
    get_sub_ranges: ?extern fn (?*AtkValue) [*c]GSList,
    set_value: ?extern fn (?*AtkValue, gdouble) void,
};
pub const AtkValueIface = struct__AtkValueIface;
pub const ATK_VALUE_VERY_WEAK = 0;
pub const ATK_VALUE_WEAK = 1;
pub const ATK_VALUE_ACCEPTABLE = 2;
pub const ATK_VALUE_STRONG = 3;
pub const ATK_VALUE_VERY_STRONG = 4;
pub const ATK_VALUE_VERY_LOW = 5;
pub const ATK_VALUE_LOW = 6;
pub const ATK_VALUE_MEDIUM = 7;
pub const ATK_VALUE_HIGH = 8;
pub const ATK_VALUE_VERY_HIGH = 9;
pub const ATK_VALUE_VERY_BAD = 10;
pub const ATK_VALUE_BAD = 11;
pub const ATK_VALUE_GOOD = 12;
pub const ATK_VALUE_VERY_GOOD = 13;
pub const ATK_VALUE_BEST = 14;
pub const ATK_VALUE_LAST_DEFINED = 15;
pub const AtkValueType = extern enum {
    ATK_VALUE_VERY_WEAK = 0,
    ATK_VALUE_WEAK = 1,
    ATK_VALUE_ACCEPTABLE = 2,
    ATK_VALUE_STRONG = 3,
    ATK_VALUE_VERY_STRONG = 4,
    ATK_VALUE_VERY_LOW = 5,
    ATK_VALUE_LOW = 6,
    ATK_VALUE_MEDIUM = 7,
    ATK_VALUE_HIGH = 8,
    ATK_VALUE_VERY_HIGH = 9,
    ATK_VALUE_VERY_BAD = 10,
    ATK_VALUE_BAD = 11,
    ATK_VALUE_GOOD = 12,
    ATK_VALUE_VERY_GOOD = 13,
    ATK_VALUE_BEST = 14,
    ATK_VALUE_LAST_DEFINED = 15,
};
pub extern fn atk_value_get_type() GType;
pub extern fn atk_value_get_current_value(obj: ?*AtkValue, value: [*c]GValue) void;
pub extern fn atk_value_get_maximum_value(obj: ?*AtkValue, value: [*c]GValue) void;
pub extern fn atk_value_get_minimum_value(obj: ?*AtkValue, value: [*c]GValue) void;
pub extern fn atk_value_set_current_value(obj: ?*AtkValue, value: [*c]const GValue) gboolean;
pub extern fn atk_value_get_minimum_increment(obj: ?*AtkValue, value: [*c]GValue) void;
pub extern fn atk_value_get_value_and_text(obj: ?*AtkValue, value: [*c]gdouble, text: [*c]([*c]gchar)) void;
pub extern fn atk_value_get_range(obj: ?*AtkValue) ?*AtkRange;
pub extern fn atk_value_get_increment(obj: ?*AtkValue) gdouble;
pub extern fn atk_value_get_sub_ranges(obj: ?*AtkValue) [*c]GSList;
pub extern fn atk_value_set_value(obj: ?*AtkValue, new_value: gdouble) void;
pub extern fn atk_value_type_get_name(value_type: AtkValueType) [*c]const gchar;
pub extern fn atk_value_type_get_localized_name(value_type: AtkValueType) [*c]const gchar;
pub const struct__AtkWindow = @OpaqueType();
pub const AtkWindow = struct__AtkWindow;
pub const struct__AtkWindowIface = extern struct {
    parent: GTypeInterface,
};
pub const AtkWindowIface = struct__AtkWindowIface;
pub extern fn atk_window_get_type() GType;
pub const GTK_WIDGET_HELP_TOOLTIP = 0;
pub const GTK_WIDGET_HELP_WHATS_THIS = 1;
pub const GtkWidgetHelpType = extern enum {
    GTK_WIDGET_HELP_TOOLTIP = 0,
    GTK_WIDGET_HELP_WHATS_THIS = 1,
};
pub const GtkAllocation = GdkRectangle;
pub const struct__GtkWidgetClassPrivate = @OpaqueType();
pub const GtkWidgetClassPrivate = struct__GtkWidgetClassPrivate;
pub const struct__GtkWidgetClass = extern struct {
    parent_class: GInitiallyUnownedClass,
    activate_signal: guint,
    dispatch_child_properties_changed: ?extern fn ([*c]GtkWidget, guint, [*c]([*c]GParamSpec)) void,
    destroy: ?extern fn ([*c]GtkWidget) void,
    show: ?extern fn ([*c]GtkWidget) void,
    show_all: ?extern fn ([*c]GtkWidget) void,
    hide: ?extern fn ([*c]GtkWidget) void,
    map: ?extern fn ([*c]GtkWidget) void,
    unmap: ?extern fn ([*c]GtkWidget) void,
    realize: ?extern fn ([*c]GtkWidget) void,
    unrealize: ?extern fn ([*c]GtkWidget) void,
    size_allocate: ?extern fn ([*c]GtkWidget, [*c]GtkAllocation) void,
    state_changed: ?extern fn ([*c]GtkWidget, GtkStateType) void,
    state_flags_changed: ?extern fn ([*c]GtkWidget, GtkStateFlags) void,
    parent_set: ?extern fn ([*c]GtkWidget, [*c]GtkWidget) void,
    hierarchy_changed: ?extern fn ([*c]GtkWidget, [*c]GtkWidget) void,
    style_set: ?extern fn ([*c]GtkWidget, [*c]GtkStyle) void,
    direction_changed: ?extern fn ([*c]GtkWidget, GtkTextDirection) void,
    grab_notify: ?extern fn ([*c]GtkWidget, gboolean) void,
    child_notify: ?extern fn ([*c]GtkWidget, [*c]GParamSpec) void,
    draw: ?extern fn ([*c]GtkWidget, ?*cairo_t) gboolean,
    get_request_mode: ?extern fn ([*c]GtkWidget) GtkSizeRequestMode,
    get_preferred_height: ?extern fn ([*c]GtkWidget, [*c]gint, [*c]gint) void,
    get_preferred_width_for_height: ?extern fn ([*c]GtkWidget, gint, [*c]gint, [*c]gint) void,
    get_preferred_width: ?extern fn ([*c]GtkWidget, [*c]gint, [*c]gint) void,
    get_preferred_height_for_width: ?extern fn ([*c]GtkWidget, gint, [*c]gint, [*c]gint) void,
    mnemonic_activate: ?extern fn ([*c]GtkWidget, gboolean) gboolean,
    grab_focus: ?extern fn ([*c]GtkWidget) void,
    focus: ?extern fn ([*c]GtkWidget, GtkDirectionType) gboolean,
    move_focus: ?extern fn ([*c]GtkWidget, GtkDirectionType) void,
    keynav_failed: ?extern fn ([*c]GtkWidget, GtkDirectionType) gboolean,
    event: ?extern fn ([*c]GtkWidget, [*c]GdkEvent) gboolean,
    button_press_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventButton) gboolean,
    button_release_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventButton) gboolean,
    scroll_event: ?extern fn ([*c]GtkWidget, ?*GdkEventScroll) gboolean,
    motion_notify_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventMotion) gboolean,
    delete_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventAny) gboolean,
    destroy_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventAny) gboolean,
    key_press_event: ?extern fn ([*c]GtkWidget, ?*GdkEventKey) gboolean,
    key_release_event: ?extern fn ([*c]GtkWidget, ?*GdkEventKey) gboolean,
    enter_notify_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventCrossing) gboolean,
    leave_notify_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventCrossing) gboolean,
    configure_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventConfigure) gboolean,
    focus_in_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventFocus) gboolean,
    focus_out_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventFocus) gboolean,
    map_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventAny) gboolean,
    unmap_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventAny) gboolean,
    property_notify_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventProperty) gboolean,
    selection_clear_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventSelection) gboolean,
    selection_request_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventSelection) gboolean,
    selection_notify_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventSelection) gboolean,
    proximity_in_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventProximity) gboolean,
    proximity_out_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventProximity) gboolean,
    visibility_notify_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventVisibility) gboolean,
    window_state_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventWindowState) gboolean,
    damage_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventExpose) gboolean,
    grab_broken_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventGrabBroken) gboolean,
    selection_get: ?extern fn ([*c]GtkWidget, ?*GtkSelectionData, guint, guint) void,
    selection_received: ?extern fn ([*c]GtkWidget, ?*GtkSelectionData, guint) void,
    drag_begin: ?extern fn ([*c]GtkWidget, ?*GdkDragContext) void,
    drag_end: ?extern fn ([*c]GtkWidget, ?*GdkDragContext) void,
    drag_data_get: ?extern fn ([*c]GtkWidget, ?*GdkDragContext, ?*GtkSelectionData, guint, guint) void,
    drag_data_delete: ?extern fn ([*c]GtkWidget, ?*GdkDragContext) void,
    drag_leave: ?extern fn ([*c]GtkWidget, ?*GdkDragContext, guint) void,
    drag_motion: ?extern fn ([*c]GtkWidget, ?*GdkDragContext, gint, gint, guint) gboolean,
    drag_drop: ?extern fn ([*c]GtkWidget, ?*GdkDragContext, gint, gint, guint) gboolean,
    drag_data_received: ?extern fn ([*c]GtkWidget, ?*GdkDragContext, gint, gint, ?*GtkSelectionData, guint, guint) void,
    drag_failed: ?extern fn ([*c]GtkWidget, ?*GdkDragContext, GtkDragResult) gboolean,
    popup_menu: ?extern fn ([*c]GtkWidget) gboolean,
    show_help: ?extern fn ([*c]GtkWidget, GtkWidgetHelpType) gboolean,
    get_accessible: ?extern fn ([*c]GtkWidget) [*c]AtkObject,
    screen_changed: ?extern fn ([*c]GtkWidget, ?*GdkScreen) void,
    can_activate_accel: ?extern fn ([*c]GtkWidget, guint) gboolean,
    composited_changed: ?extern fn ([*c]GtkWidget) void,
    query_tooltip: ?extern fn ([*c]GtkWidget, gint, gint, gboolean, ?*GtkTooltip) gboolean,
    compute_expand: ?extern fn ([*c]GtkWidget, [*c]gboolean, [*c]gboolean) void,
    adjust_size_request: ?extern fn ([*c]GtkWidget, GtkOrientation, [*c]gint, [*c]gint) void,
    adjust_size_allocation: ?extern fn ([*c]GtkWidget, GtkOrientation, [*c]gint, [*c]gint, [*c]gint, [*c]gint) void,
    style_updated: ?extern fn ([*c]GtkWidget) void,
    touch_event: ?extern fn ([*c]GtkWidget, [*c]GdkEventTouch) gboolean,
    get_preferred_height_and_baseline_for_width: ?extern fn ([*c]GtkWidget, gint, [*c]gint, [*c]gint, [*c]gint, [*c]gint) void,
    adjust_baseline_request: ?extern fn ([*c]GtkWidget, [*c]gint, [*c]gint) void,
    adjust_baseline_allocation: ?extern fn ([*c]GtkWidget, [*c]gint) void,
    queue_draw_region: ?extern fn ([*c]GtkWidget, ?*const cairo_region_t) void,
    priv: ?*GtkWidgetClassPrivate,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
};
pub const GtkWidgetClass = struct__GtkWidgetClass;
pub const GtkCallback = ?extern fn ([*c]GtkWidget, gpointer) void;
pub const GtkTickCallback = ?extern fn ([*c]GtkWidget, ?*GdkFrameClock, gpointer) gboolean;
pub extern fn gtk_widget_get_type() GType;
pub extern fn gtk_widget_new(type_0: GType, first_property_name: [*c]const gchar, ...) [*c]GtkWidget;
pub extern fn gtk_widget_destroy(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_destroyed(widget: [*c]GtkWidget, widget_pointer: [*c]([*c]GtkWidget)) void;
pub extern fn gtk_widget_unparent(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_show(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_hide(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_show_now(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_show_all(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_set_no_show_all(widget: [*c]GtkWidget, no_show_all: gboolean) void;
pub extern fn gtk_widget_get_no_show_all(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_map(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_unmap(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_realize(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_unrealize(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_draw(widget: [*c]GtkWidget, cr: ?*cairo_t) void;
pub extern fn gtk_widget_queue_draw(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_queue_draw_area(widget: [*c]GtkWidget, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gtk_widget_queue_draw_region(widget: [*c]GtkWidget, region: ?*const cairo_region_t) void;
pub extern fn gtk_widget_queue_resize(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_queue_resize_no_redraw(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_queue_allocate(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_get_frame_clock(widget: [*c]GtkWidget) ?*GdkFrameClock;
pub extern fn gtk_widget_size_request(widget: [*c]GtkWidget, requisition: [*c]GtkRequisition) void;
pub extern fn gtk_widget_size_allocate(widget: [*c]GtkWidget, allocation: [*c]GtkAllocation) void;
pub extern fn gtk_widget_size_allocate_with_baseline(widget: [*c]GtkWidget, allocation: [*c]GtkAllocation, baseline: gint) void;
pub extern fn gtk_widget_get_request_mode(widget: [*c]GtkWidget) GtkSizeRequestMode;
pub extern fn gtk_widget_get_preferred_width(widget: [*c]GtkWidget, minimum_width: [*c]gint, natural_width: [*c]gint) void;
pub extern fn gtk_widget_get_preferred_height_for_width(widget: [*c]GtkWidget, width: gint, minimum_height: [*c]gint, natural_height: [*c]gint) void;
pub extern fn gtk_widget_get_preferred_height(widget: [*c]GtkWidget, minimum_height: [*c]gint, natural_height: [*c]gint) void;
pub extern fn gtk_widget_get_preferred_width_for_height(widget: [*c]GtkWidget, height: gint, minimum_width: [*c]gint, natural_width: [*c]gint) void;
pub extern fn gtk_widget_get_preferred_height_and_baseline_for_width(widget: [*c]GtkWidget, width: gint, minimum_height: [*c]gint, natural_height: [*c]gint, minimum_baseline: [*c]gint, natural_baseline: [*c]gint) void;
pub extern fn gtk_widget_get_preferred_size(widget: [*c]GtkWidget, minimum_size: [*c]GtkRequisition, natural_size: [*c]GtkRequisition) void;
pub extern fn gtk_widget_get_child_requisition(widget: [*c]GtkWidget, requisition: [*c]GtkRequisition) void;
pub extern fn gtk_widget_add_accelerator(widget: [*c]GtkWidget, accel_signal: [*c]const gchar, accel_group: [*c]GtkAccelGroup, accel_key: guint, accel_mods: GdkModifierType, accel_flags: GtkAccelFlags) void;
pub extern fn gtk_widget_remove_accelerator(widget: [*c]GtkWidget, accel_group: [*c]GtkAccelGroup, accel_key: guint, accel_mods: GdkModifierType) gboolean;
pub extern fn gtk_widget_set_accel_path(widget: [*c]GtkWidget, accel_path: [*c]const gchar, accel_group: [*c]GtkAccelGroup) void;
pub extern fn gtk_widget_list_accel_closures(widget: [*c]GtkWidget) [*c]GList;
pub extern fn gtk_widget_can_activate_accel(widget: [*c]GtkWidget, signal_id: guint) gboolean;
pub extern fn gtk_widget_mnemonic_activate(widget: [*c]GtkWidget, group_cycling: gboolean) gboolean;
pub extern fn gtk_widget_event(widget: [*c]GtkWidget, event: [*c]GdkEvent) gboolean;
pub extern fn gtk_widget_send_expose(widget: [*c]GtkWidget, event: [*c]GdkEvent) gint;
pub extern fn gtk_widget_send_focus_change(widget: [*c]GtkWidget, event: [*c]GdkEvent) gboolean;
pub extern fn gtk_widget_activate(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_reparent(widget: [*c]GtkWidget, new_parent: [*c]GtkWidget) void;
pub extern fn gtk_widget_intersect(widget: [*c]GtkWidget, area: [*c]const GdkRectangle, intersection: [*c]GdkRectangle) gboolean;
pub extern fn gtk_widget_region_intersect(widget: [*c]GtkWidget, region: ?*const cairo_region_t) ?*cairo_region_t;
pub extern fn gtk_widget_freeze_child_notify(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_child_notify(widget: [*c]GtkWidget, child_property: [*c]const gchar) void;
pub extern fn gtk_widget_thaw_child_notify(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_set_can_focus(widget: [*c]GtkWidget, can_focus: gboolean) void;
pub extern fn gtk_widget_get_can_focus(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_has_focus(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_is_focus(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_has_visible_focus(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_grab_focus(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_set_focus_on_click(widget: [*c]GtkWidget, focus_on_click: gboolean) void;
pub extern fn gtk_widget_get_focus_on_click(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_can_default(widget: [*c]GtkWidget, can_default: gboolean) void;
pub extern fn gtk_widget_get_can_default(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_has_default(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_grab_default(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_set_receives_default(widget: [*c]GtkWidget, receives_default: gboolean) void;
pub extern fn gtk_widget_get_receives_default(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_has_grab(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_device_is_shadowed(widget: [*c]GtkWidget, device: ?*GdkDevice) gboolean;
pub extern fn gtk_widget_set_name(widget: [*c]GtkWidget, name: [*c]const gchar) void;
pub extern fn gtk_widget_get_name(widget: [*c]GtkWidget) [*c]const gchar;
pub extern fn gtk_widget_set_state(widget: [*c]GtkWidget, state: GtkStateType) void;
pub extern fn gtk_widget_get_state(widget: [*c]GtkWidget) GtkStateType;
pub extern fn gtk_widget_set_state_flags(widget: [*c]GtkWidget, flags: GtkStateFlags, clear: gboolean) void;
pub extern fn gtk_widget_unset_state_flags(widget: [*c]GtkWidget, flags: GtkStateFlags) void;
pub extern fn gtk_widget_get_state_flags(widget: [*c]GtkWidget) GtkStateFlags;
pub extern fn gtk_widget_set_sensitive(widget: [*c]GtkWidget, sensitive: gboolean) void;
pub extern fn gtk_widget_get_sensitive(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_is_sensitive(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_visible(widget: [*c]GtkWidget, visible: gboolean) void;
pub extern fn gtk_widget_get_visible(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_is_visible(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_has_window(widget: [*c]GtkWidget, has_window: gboolean) void;
pub extern fn gtk_widget_get_has_window(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_is_toplevel(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_is_drawable(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_realized(widget: [*c]GtkWidget, realized: gboolean) void;
pub extern fn gtk_widget_get_realized(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_mapped(widget: [*c]GtkWidget, mapped: gboolean) void;
pub extern fn gtk_widget_get_mapped(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_app_paintable(widget: [*c]GtkWidget, app_paintable: gboolean) void;
pub extern fn gtk_widget_get_app_paintable(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_double_buffered(widget: [*c]GtkWidget, double_buffered: gboolean) void;
pub extern fn gtk_widget_get_double_buffered(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_redraw_on_allocate(widget: [*c]GtkWidget, redraw_on_allocate: gboolean) void;
pub extern fn gtk_widget_set_parent(widget: [*c]GtkWidget, parent: [*c]GtkWidget) void;
pub extern fn gtk_widget_get_parent(widget: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_widget_set_parent_window(widget: [*c]GtkWidget, parent_window: ?*GdkWindow) void;
pub extern fn gtk_widget_get_parent_window(widget: [*c]GtkWidget) ?*GdkWindow;
pub extern fn gtk_widget_set_child_visible(widget: [*c]GtkWidget, is_visible: gboolean) void;
pub extern fn gtk_widget_get_child_visible(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_window(widget: [*c]GtkWidget, window: ?*GdkWindow) void;
pub extern fn gtk_widget_get_window(widget: [*c]GtkWidget) ?*GdkWindow;
pub extern fn gtk_widget_register_window(widget: [*c]GtkWidget, window: ?*GdkWindow) void;
pub extern fn gtk_widget_unregister_window(widget: [*c]GtkWidget, window: ?*GdkWindow) void;
pub extern fn gtk_widget_get_allocated_width(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_get_allocated_height(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_get_allocated_baseline(widget: [*c]GtkWidget) c_int;
pub extern fn gtk_widget_get_allocated_size(widget: [*c]GtkWidget, allocation: [*c]GtkAllocation, baseline: [*c]c_int) void;
pub extern fn gtk_widget_get_allocation(widget: [*c]GtkWidget, allocation: [*c]GtkAllocation) void;
pub extern fn gtk_widget_set_allocation(widget: [*c]GtkWidget, allocation: [*c]const GtkAllocation) void;
pub extern fn gtk_widget_set_clip(widget: [*c]GtkWidget, clip: [*c]const GtkAllocation) void;
pub extern fn gtk_widget_get_clip(widget: [*c]GtkWidget, clip: [*c]GtkAllocation) void;
pub extern fn gtk_widget_get_requisition(widget: [*c]GtkWidget, requisition: [*c]GtkRequisition) void;
pub extern fn gtk_widget_child_focus(widget: [*c]GtkWidget, direction: GtkDirectionType) gboolean;
pub extern fn gtk_widget_keynav_failed(widget: [*c]GtkWidget, direction: GtkDirectionType) gboolean;
pub extern fn gtk_widget_error_bell(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_set_size_request(widget: [*c]GtkWidget, width: gint, height: gint) void;
pub extern fn gtk_widget_get_size_request(widget: [*c]GtkWidget, width: [*c]gint, height: [*c]gint) void;
pub extern fn gtk_widget_set_events(widget: [*c]GtkWidget, events: gint) void;
pub extern fn gtk_widget_add_events(widget: [*c]GtkWidget, events: gint) void;
pub extern fn gtk_widget_set_device_events(widget: [*c]GtkWidget, device: ?*GdkDevice, events: GdkEventMask) void;
pub extern fn gtk_widget_add_device_events(widget: [*c]GtkWidget, device: ?*GdkDevice, events: GdkEventMask) void;
pub extern fn gtk_widget_set_opacity(widget: [*c]GtkWidget, opacity: f64) void;
pub extern fn gtk_widget_get_opacity(widget: [*c]GtkWidget) f64;
pub extern fn gtk_widget_set_device_enabled(widget: [*c]GtkWidget, device: ?*GdkDevice, enabled: gboolean) void;
pub extern fn gtk_widget_get_device_enabled(widget: [*c]GtkWidget, device: ?*GdkDevice) gboolean;
pub extern fn gtk_widget_get_toplevel(widget: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_widget_get_ancestor(widget: [*c]GtkWidget, widget_type: GType) [*c]GtkWidget;
pub extern fn gtk_widget_get_visual(widget: [*c]GtkWidget) ?*GdkVisual;
pub extern fn gtk_widget_set_visual(widget: [*c]GtkWidget, visual: ?*GdkVisual) void;
pub extern fn gtk_widget_get_screen(widget: [*c]GtkWidget) ?*GdkScreen;
pub extern fn gtk_widget_has_screen(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_get_scale_factor(widget: [*c]GtkWidget) gint;
pub extern fn gtk_widget_get_display(widget: [*c]GtkWidget) ?*GdkDisplay;
pub extern fn gtk_widget_get_root_window(widget: [*c]GtkWidget) ?*GdkWindow;
pub extern fn gtk_widget_get_settings(widget: [*c]GtkWidget) [*c]GtkSettings;
pub extern fn gtk_widget_get_clipboard(widget: [*c]GtkWidget, selection: GdkAtom) ?*GtkClipboard;
pub extern fn gtk_widget_get_hexpand(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_hexpand(widget: [*c]GtkWidget, expand: gboolean) void;
pub extern fn gtk_widget_get_hexpand_set(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_hexpand_set(widget: [*c]GtkWidget, set: gboolean) void;
pub extern fn gtk_widget_get_vexpand(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_vexpand(widget: [*c]GtkWidget, expand: gboolean) void;
pub extern fn gtk_widget_get_vexpand_set(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_vexpand_set(widget: [*c]GtkWidget, set: gboolean) void;
pub extern fn gtk_widget_queue_compute_expand(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_compute_expand(widget: [*c]GtkWidget, orientation: GtkOrientation) gboolean;
pub extern fn gtk_widget_get_support_multidevice(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_support_multidevice(widget: [*c]GtkWidget, support_multidevice: gboolean) void;
pub extern fn gtk_widget_class_set_accessible_type(widget_class: [*c]GtkWidgetClass, type_0: GType) void;
pub extern fn gtk_widget_class_set_accessible_role(widget_class: [*c]GtkWidgetClass, role: AtkRole) void;
pub extern fn gtk_widget_get_accessible(widget: [*c]GtkWidget) [*c]AtkObject;
pub extern fn gtk_widget_get_halign(widget: [*c]GtkWidget) GtkAlign;
pub extern fn gtk_widget_set_halign(widget: [*c]GtkWidget, @"align": GtkAlign) void;
pub extern fn gtk_widget_get_valign(widget: [*c]GtkWidget) GtkAlign;
pub extern fn gtk_widget_get_valign_with_baseline(widget: [*c]GtkWidget) GtkAlign;
pub extern fn gtk_widget_set_valign(widget: [*c]GtkWidget, @"align": GtkAlign) void;
pub extern fn gtk_widget_get_margin_left(widget: [*c]GtkWidget) gint;
pub extern fn gtk_widget_set_margin_left(widget: [*c]GtkWidget, margin: gint) void;
pub extern fn gtk_widget_get_margin_right(widget: [*c]GtkWidget) gint;
pub extern fn gtk_widget_set_margin_right(widget: [*c]GtkWidget, margin: gint) void;
pub extern fn gtk_widget_get_margin_start(widget: [*c]GtkWidget) gint;
pub extern fn gtk_widget_set_margin_start(widget: [*c]GtkWidget, margin: gint) void;
pub extern fn gtk_widget_get_margin_end(widget: [*c]GtkWidget) gint;
pub extern fn gtk_widget_set_margin_end(widget: [*c]GtkWidget, margin: gint) void;
pub extern fn gtk_widget_get_margin_top(widget: [*c]GtkWidget) gint;
pub extern fn gtk_widget_set_margin_top(widget: [*c]GtkWidget, margin: gint) void;
pub extern fn gtk_widget_get_margin_bottom(widget: [*c]GtkWidget) gint;
pub extern fn gtk_widget_set_margin_bottom(widget: [*c]GtkWidget, margin: gint) void;
pub extern fn gtk_widget_get_events(widget: [*c]GtkWidget) gint;
pub extern fn gtk_widget_get_device_events(widget: [*c]GtkWidget, device: ?*GdkDevice) GdkEventMask;
pub extern fn gtk_widget_get_pointer(widget: [*c]GtkWidget, x: [*c]gint, y: [*c]gint) void;
pub extern fn gtk_widget_is_ancestor(widget: [*c]GtkWidget, ancestor: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_translate_coordinates(src_widget: [*c]GtkWidget, dest_widget: [*c]GtkWidget, src_x: gint, src_y: gint, dest_x: [*c]gint, dest_y: [*c]gint) gboolean;
pub extern fn gtk_widget_hide_on_delete(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_override_color(widget: [*c]GtkWidget, state: GtkStateFlags, color: [*c]const GdkRGBA) void;
pub extern fn gtk_widget_override_background_color(widget: [*c]GtkWidget, state: GtkStateFlags, color: [*c]const GdkRGBA) void;
pub extern fn gtk_widget_override_font(widget: [*c]GtkWidget, font_desc: ?*const PangoFontDescription) void;
pub extern fn gtk_widget_override_symbolic_color(widget: [*c]GtkWidget, name: [*c]const gchar, color: [*c]const GdkRGBA) void;
pub extern fn gtk_widget_override_cursor(widget: [*c]GtkWidget, cursor: [*c]const GdkRGBA, secondary_cursor: [*c]const GdkRGBA) void;
pub extern fn gtk_widget_reset_style(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_create_pango_context(widget: [*c]GtkWidget) ?*PangoContext;
pub extern fn gtk_widget_get_pango_context(widget: [*c]GtkWidget) ?*PangoContext;
pub extern fn gtk_widget_set_font_options(widget: [*c]GtkWidget, options: ?*const cairo_font_options_t) void;
pub extern fn gtk_widget_get_font_options(widget: [*c]GtkWidget) ?*const cairo_font_options_t;
pub extern fn gtk_widget_create_pango_layout(widget: [*c]GtkWidget, text: [*c]const gchar) ?*PangoLayout;
pub extern fn gtk_widget_render_icon_pixbuf(widget: [*c]GtkWidget, stock_id: [*c]const gchar, size: GtkIconSize) ?*GdkPixbuf;
pub extern fn gtk_widget_set_composite_name(widget: [*c]GtkWidget, name: [*c]const gchar) void;
pub extern fn gtk_widget_get_composite_name(widget: [*c]GtkWidget) [*c]gchar;
pub extern fn gtk_widget_push_composite_child() void;
pub extern fn gtk_widget_pop_composite_child() void;
pub extern fn gtk_widget_class_install_style_property(klass: [*c]GtkWidgetClass, pspec: [*c]GParamSpec) void;
pub extern fn gtk_widget_class_install_style_property_parser(klass: [*c]GtkWidgetClass, pspec: [*c]GParamSpec, parser: GtkRcPropertyParser) void;
pub extern fn gtk_widget_class_find_style_property(klass: [*c]GtkWidgetClass, property_name: [*c]const gchar) [*c]GParamSpec;
pub extern fn gtk_widget_class_list_style_properties(klass: [*c]GtkWidgetClass, n_properties: [*c]guint) [*c]([*c]GParamSpec);
pub extern fn gtk_widget_style_get_property(widget: [*c]GtkWidget, property_name: [*c]const gchar, value: [*c]GValue) void;
pub extern fn gtk_widget_style_get_valist(widget: [*c]GtkWidget, first_property_name: [*c]const gchar, var_args: va_list) void;
pub extern fn gtk_widget_style_get(widget: [*c]GtkWidget, first_property_name: [*c]const gchar, ...) void;
pub extern fn gtk_widget_set_direction(widget: [*c]GtkWidget, dir: GtkTextDirection) void;
pub extern fn gtk_widget_get_direction(widget: [*c]GtkWidget) GtkTextDirection;
pub extern fn gtk_widget_set_default_direction(dir: GtkTextDirection) void;
pub extern fn gtk_widget_get_default_direction() GtkTextDirection;
pub extern fn gtk_widget_is_composited(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_shape_combine_region(widget: [*c]GtkWidget, region: ?*cairo_region_t) void;
pub extern fn gtk_widget_input_shape_combine_region(widget: [*c]GtkWidget, region: ?*cairo_region_t) void;
pub extern fn gtk_widget_list_mnemonic_labels(widget: [*c]GtkWidget) [*c]GList;
pub extern fn gtk_widget_add_mnemonic_label(widget: [*c]GtkWidget, label: [*c]GtkWidget) void;
pub extern fn gtk_widget_remove_mnemonic_label(widget: [*c]GtkWidget, label: [*c]GtkWidget) void;
pub extern fn gtk_widget_set_tooltip_window(widget: [*c]GtkWidget, custom_window: [*c]GtkWindow) void;
pub extern fn gtk_widget_get_tooltip_window(widget: [*c]GtkWidget) [*c]GtkWindow;
pub extern fn gtk_widget_trigger_tooltip_query(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_set_tooltip_text(widget: [*c]GtkWidget, text: [*c]const gchar) void;
pub extern fn gtk_widget_get_tooltip_text(widget: [*c]GtkWidget) [*c]gchar;
pub extern fn gtk_widget_set_tooltip_markup(widget: [*c]GtkWidget, markup: [*c]const gchar) void;
pub extern fn gtk_widget_get_tooltip_markup(widget: [*c]GtkWidget) [*c]gchar;
pub extern fn gtk_widget_set_has_tooltip(widget: [*c]GtkWidget, has_tooltip: gboolean) void;
pub extern fn gtk_widget_get_has_tooltip(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_cairo_should_draw_window(cr: ?*cairo_t, window: ?*GdkWindow) gboolean;
pub extern fn gtk_cairo_transform_to_window(cr: ?*cairo_t, widget: [*c]GtkWidget, window: ?*GdkWindow) void;
pub extern fn gtk_requisition_get_type() GType;
pub extern fn gtk_requisition_new() [*c]GtkRequisition;
pub extern fn gtk_requisition_copy(requisition: [*c]const GtkRequisition) [*c]GtkRequisition;
pub extern fn gtk_requisition_free(requisition: [*c]GtkRequisition) void;
pub extern fn gtk_widget_in_destruction(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_get_style_context(widget: [*c]GtkWidget) [*c]GtkStyleContext;
pub extern fn gtk_widget_get_path(widget: [*c]GtkWidget) ?*GtkWidgetPath;
pub extern fn gtk_widget_class_set_css_name(widget_class: [*c]GtkWidgetClass, name: [*c]const u8) void;
pub extern fn gtk_widget_class_get_css_name(widget_class: [*c]GtkWidgetClass) [*c]const u8;
pub extern fn gtk_widget_get_modifier_mask(widget: [*c]GtkWidget, intent: GdkModifierIntent) GdkModifierType;
pub extern fn gtk_widget_insert_action_group(widget: [*c]GtkWidget, name: [*c]const gchar, group: ?*GActionGroup) void;
pub extern fn gtk_widget_add_tick_callback(widget: [*c]GtkWidget, callback: GtkTickCallback, user_data: gpointer, notify: GDestroyNotify) guint;
pub extern fn gtk_widget_remove_tick_callback(widget: [*c]GtkWidget, id: guint) void;
pub extern fn gtk_widget_init_template(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_get_template_child(widget: [*c]GtkWidget, widget_type: GType, name: [*c]const gchar) [*c]GObject;
pub extern fn gtk_widget_class_set_template(widget_class: [*c]GtkWidgetClass, template_bytes: ?*GBytes) void;
pub extern fn gtk_widget_class_set_template_from_resource(widget_class: [*c]GtkWidgetClass, resource_name: [*c]const gchar) void;
pub extern fn gtk_widget_class_bind_template_callback_full(widget_class: [*c]GtkWidgetClass, callback_name: [*c]const gchar, callback_symbol: GCallback) void;
pub extern fn gtk_widget_class_set_connect_func(widget_class: [*c]GtkWidgetClass, connect_func: GtkBuilderConnectFunc, connect_data: gpointer, connect_data_destroy: GDestroyNotify) void;
pub extern fn gtk_widget_class_bind_template_child_full(widget_class: [*c]GtkWidgetClass, name: [*c]const gchar, internal_child: gboolean, struct_offset: gssize) void;
pub extern fn gtk_widget_get_action_group(widget: [*c]GtkWidget, prefix: [*c]const gchar) ?*GActionGroup;
pub extern fn gtk_widget_list_action_prefixes(widget: [*c]GtkWidget) [*c]([*c]const gchar);
pub extern fn gtk_widget_set_font_map(widget: [*c]GtkWidget, font_map: ?*PangoFontMap) void;
pub extern fn gtk_widget_get_font_map(widget: [*c]GtkWidget) ?*PangoFontMap;
pub const GtkWidget_autoptr = [*c]GtkWidget;
pub const GtkWidget_listautoptr = [*c]GList;
pub const GtkWidget_slistautoptr = [*c]GSList;
pub const GtkWidget_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkWidget(_ptr: [*c]GtkWidget) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkWidget(_ptr: [*c]([*c]GtkWidget)) void {
    glib_autoptr_clear_GtkWidget(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkWidget(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkWidget(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkWidget(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkRequisition_autoptr = [*c]GtkRequisition;
pub const GtkRequisition_listautoptr = [*c]GList;
pub const GtkRequisition_slistautoptr = [*c]GSList;
pub const GtkRequisition_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRequisition(_ptr: [*c]GtkRequisition) void {
    if (_ptr != null) gtk_requisition_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GtkRequisition(_ptr: [*c]([*c]GtkRequisition)) void {
    glib_autoptr_clear_GtkRequisition(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRequisition(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_requisition_free)))));
}
pub fn glib_slistautoptr_cleanup_GtkRequisition(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_requisition_free)))));
}
pub fn glib_queueautoptr_cleanup_GtkRequisition(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_requisition_free)))));
}
pub const struct__GtkApplicationPrivate = @OpaqueType();
pub const GtkApplicationPrivate = struct__GtkApplicationPrivate;
pub const struct__GtkApplication = extern struct {
    parent: GApplication,
    priv: ?*GtkApplicationPrivate,
};
pub const GtkApplication = struct__GtkApplication;
pub const struct__GtkApplicationClass = extern struct {
    parent_class: GApplicationClass,
    window_added: ?extern fn ([*c]GtkApplication, [*c]GtkWindow) void,
    window_removed: ?extern fn ([*c]GtkApplication, [*c]GtkWindow) void,
    padding: [12]gpointer,
};
pub const GtkApplicationClass = struct__GtkApplicationClass;
pub extern fn gtk_application_get_type() GType;
pub extern fn gtk_application_new(application_id: [*c]const gchar, flags: GApplicationFlags) [*c]GtkApplication;
pub extern fn gtk_application_add_window(application: [*c]GtkApplication, window: [*c]GtkWindow) void;
pub extern fn gtk_application_remove_window(application: [*c]GtkApplication, window: [*c]GtkWindow) void;
pub extern fn gtk_application_get_windows(application: [*c]GtkApplication) [*c]GList;
pub extern fn gtk_application_get_app_menu(application: [*c]GtkApplication) [*c]GMenuModel;
pub extern fn gtk_application_set_app_menu(application: [*c]GtkApplication, app_menu: [*c]GMenuModel) void;
pub extern fn gtk_application_get_menubar(application: [*c]GtkApplication) [*c]GMenuModel;
pub extern fn gtk_application_set_menubar(application: [*c]GtkApplication, menubar: [*c]GMenuModel) void;
pub extern fn gtk_application_add_accelerator(application: [*c]GtkApplication, accelerator: [*c]const gchar, action_name: [*c]const gchar, parameter: ?*GVariant) void;
pub extern fn gtk_application_remove_accelerator(application: [*c]GtkApplication, action_name: [*c]const gchar, parameter: ?*GVariant) void;
pub const GTK_APPLICATION_INHIBIT_LOGOUT = 1;
pub const GTK_APPLICATION_INHIBIT_SWITCH = 2;
pub const GTK_APPLICATION_INHIBIT_SUSPEND = 4;
pub const GTK_APPLICATION_INHIBIT_IDLE = 8;
pub const GtkApplicationInhibitFlags = extern enum {
    GTK_APPLICATION_INHIBIT_LOGOUT = 1,
    GTK_APPLICATION_INHIBIT_SWITCH = 2,
    GTK_APPLICATION_INHIBIT_SUSPEND = 4,
    GTK_APPLICATION_INHIBIT_IDLE = 8,
};
pub extern fn gtk_application_inhibit(application: [*c]GtkApplication, window: [*c]GtkWindow, flags: GtkApplicationInhibitFlags, reason: [*c]const gchar) guint;
pub extern fn gtk_application_uninhibit(application: [*c]GtkApplication, cookie: guint) void;
pub extern fn gtk_application_is_inhibited(application: [*c]GtkApplication, flags: GtkApplicationInhibitFlags) gboolean;
pub extern fn gtk_application_get_window_by_id(application: [*c]GtkApplication, id: guint) [*c]GtkWindow;
pub extern fn gtk_application_get_active_window(application: [*c]GtkApplication) [*c]GtkWindow;
pub extern fn gtk_application_list_action_descriptions(application: [*c]GtkApplication) [*c]([*c]gchar);
pub extern fn gtk_application_get_accels_for_action(application: [*c]GtkApplication, detailed_action_name: [*c]const gchar) [*c]([*c]gchar);
pub extern fn gtk_application_get_actions_for_accel(application: [*c]GtkApplication, accel: [*c]const gchar) [*c]([*c]gchar);
pub extern fn gtk_application_set_accels_for_action(application: [*c]GtkApplication, detailed_action_name: [*c]const gchar, accels: [*c]const ([*c]const gchar)) void;
pub extern fn gtk_application_prefers_app_menu(application: [*c]GtkApplication) gboolean;
pub extern fn gtk_application_get_menu_by_id(application: [*c]GtkApplication, id: [*c]const gchar) ?*GMenu;
pub const GtkApplication_autoptr = [*c]GtkApplication;
pub const GtkApplication_listautoptr = [*c]GList;
pub const GtkApplication_slistautoptr = [*c]GSList;
pub const GtkApplication_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkApplication(_ptr: [*c]GtkApplication) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkApplication(_ptr: [*c]([*c]GtkApplication)) void {
    glib_autoptr_clear_GtkApplication(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkApplication(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkApplication(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkApplication(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__GtkContainerClass = @OpaqueType();
pub const GtkContainerClass = struct__GtkContainerClass;
pub const GTK_RESIZE_PARENT = 0;
pub const GTK_RESIZE_QUEUE = 1;
pub const GTK_RESIZE_IMMEDIATE = 2;
pub const GtkResizeMode = extern enum {
    GTK_RESIZE_PARENT = 0,
    GTK_RESIZE_QUEUE = 1,
    GTK_RESIZE_IMMEDIATE = 2,
};
pub extern fn gtk_container_get_type() GType;
pub extern fn gtk_container_set_border_width(container: [*c]GtkContainer, border_width: guint) void;
pub extern fn gtk_container_get_border_width(container: [*c]GtkContainer) guint;
pub extern fn gtk_container_add(container: [*c]GtkContainer, widget: [*c]GtkWidget) void;
pub extern fn gtk_container_remove(container: [*c]GtkContainer, widget: [*c]GtkWidget) void;
pub extern fn gtk_container_set_resize_mode(container: [*c]GtkContainer, resize_mode: GtkResizeMode) void;
pub extern fn gtk_container_get_resize_mode(container: [*c]GtkContainer) GtkResizeMode;
pub extern fn gtk_container_check_resize(container: [*c]GtkContainer) void;
pub extern fn gtk_container_foreach(container: [*c]GtkContainer, callback: GtkCallback, callback_data: gpointer) void;
pub extern fn gtk_container_get_children(container: [*c]GtkContainer) [*c]GList;
pub extern fn gtk_container_propagate_draw(container: [*c]GtkContainer, child: [*c]GtkWidget, cr: ?*cairo_t) void;
pub extern fn gtk_container_set_focus_chain(container: [*c]GtkContainer, focusable_widgets: [*c]GList) void;
pub extern fn gtk_container_get_focus_chain(container: [*c]GtkContainer, focusable_widgets: [*c]([*c]GList)) gboolean;
pub extern fn gtk_container_unset_focus_chain(container: [*c]GtkContainer) void;
pub extern fn gtk_container_set_reallocate_redraws(container: [*c]GtkContainer, needs_redraws: gboolean) void;
pub extern fn gtk_container_set_focus_child(container: [*c]GtkContainer, child: [*c]GtkWidget) void;
pub extern fn gtk_container_get_focus_child(container: [*c]GtkContainer) [*c]GtkWidget;
pub extern fn gtk_container_set_focus_vadjustment(container: [*c]GtkContainer, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_container_get_focus_vadjustment(container: [*c]GtkContainer) [*c]GtkAdjustment;
pub extern fn gtk_container_set_focus_hadjustment(container: [*c]GtkContainer, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_container_get_focus_hadjustment(container: [*c]GtkContainer) [*c]GtkAdjustment;
pub extern fn gtk_container_resize_children(container: [*c]GtkContainer) void;
pub extern fn gtk_container_child_type(container: [*c]GtkContainer) GType;
pub extern fn gtk_container_class_install_child_property(cclass: ?*GtkContainerClass, property_id: guint, pspec: [*c]GParamSpec) void;
pub extern fn gtk_container_class_install_child_properties(cclass: ?*GtkContainerClass, n_pspecs: guint, pspecs: [*c]([*c]GParamSpec)) void;
pub extern fn gtk_container_class_find_child_property(cclass: [*c]GObjectClass, property_name: [*c]const gchar) [*c]GParamSpec;
pub extern fn gtk_container_class_list_child_properties(cclass: [*c]GObjectClass, n_properties: [*c]guint) [*c]([*c]GParamSpec);
pub extern fn gtk_container_add_with_properties(container: [*c]GtkContainer, widget: [*c]GtkWidget, first_prop_name: [*c]const gchar, ...) void;
pub extern fn gtk_container_child_set(container: [*c]GtkContainer, child: [*c]GtkWidget, first_prop_name: [*c]const gchar, ...) void;
pub extern fn gtk_container_child_get(container: [*c]GtkContainer, child: [*c]GtkWidget, first_prop_name: [*c]const gchar, ...) void;
pub extern fn gtk_container_child_set_valist(container: [*c]GtkContainer, child: [*c]GtkWidget, first_property_name: [*c]const gchar, var_args: va_list) void;
pub extern fn gtk_container_child_get_valist(container: [*c]GtkContainer, child: [*c]GtkWidget, first_property_name: [*c]const gchar, var_args: va_list) void;
pub extern fn gtk_container_child_set_property(container: [*c]GtkContainer, child: [*c]GtkWidget, property_name: [*c]const gchar, value: [*c]const GValue) void;
pub extern fn gtk_container_child_get_property(container: [*c]GtkContainer, child: [*c]GtkWidget, property_name: [*c]const gchar, value: [*c]GValue) void;
pub extern fn gtk_container_child_notify(container: [*c]GtkContainer, child: [*c]GtkWidget, child_property: [*c]const gchar) void;
pub extern fn gtk_container_child_notify_by_pspec(container: [*c]GtkContainer, child: [*c]GtkWidget, pspec: [*c]GParamSpec) void;
pub extern fn gtk_container_forall(container: [*c]GtkContainer, callback: GtkCallback, callback_data: gpointer) void;
pub extern fn gtk_container_class_handle_border_width(klass: ?*GtkContainerClass) void;
pub extern fn gtk_container_get_path_for_child(container: [*c]GtkContainer, child: [*c]GtkWidget) ?*GtkWidgetPath;
pub const GtkContainer_autoptr = [*c]GtkContainer;
pub const GtkContainer_listautoptr = [*c]GList;
pub const GtkContainer_slistautoptr = [*c]GSList;
pub const GtkContainer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkContainer(_ptr: [*c]GtkContainer) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkContainer(_ptr: [*c]([*c]GtkContainer)) void {
    glib_autoptr_clear_GtkContainer(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkContainer(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkContainer(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkContainer(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__GtkBinClass = extern struct {
    parent_class: GtkContainerClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkBinClass = struct__GtkBinClass;
pub extern fn gtk_bin_get_type() GType;
pub extern fn gtk_bin_get_child(bin: [*c]GtkBin) [*c]GtkWidget;
pub extern fn _gtk_bin_set_child(bin: [*c]GtkBin, widget: [*c]GtkWidget) void;
pub const GtkBin_autoptr = [*c]GtkBin;
pub const GtkBin_listautoptr = [*c]GList;
pub const GtkBin_slistautoptr = [*c]GSList;
pub const GtkBin_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBin(_ptr: [*c]GtkBin) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkBin(_ptr: [*c]([*c]GtkBin)) void {
    glib_autoptr_clear_GtkBin(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkBin(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkBin(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkBin(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__GtkWindowClass = extern struct {
    parent_class: GtkBinClass,
    set_focus: ?extern fn ([*c]GtkWindow, [*c]GtkWidget) void,
    activate_focus: ?extern fn ([*c]GtkWindow) void,
    activate_default: ?extern fn ([*c]GtkWindow) void,
    keys_changed: ?extern fn ([*c]GtkWindow) void,
    enable_debugging: ?extern fn ([*c]GtkWindow, gboolean) gboolean,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
};
pub const GtkWindowClass = struct__GtkWindowClass;
pub const struct__GtkWindowGeometryInfo = @OpaqueType();
pub const GtkWindowGeometryInfo = struct__GtkWindowGeometryInfo;
pub const struct__GtkWindowGroupPrivate = @OpaqueType();
pub const GtkWindowGroupPrivate = struct__GtkWindowGroupPrivate;
pub const struct__GtkWindowGroup = extern struct {
    parent_instance: GObject,
    priv: ?*GtkWindowGroupPrivate,
};
pub const GtkWindowGroup = struct__GtkWindowGroup;
pub const struct__GtkWindowGroupClass = extern struct {
    parent_class: GObjectClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkWindowGroupClass = struct__GtkWindowGroupClass;
pub const GTK_WINDOW_TOPLEVEL = 0;
pub const GTK_WINDOW_POPUP = 1;
pub const GtkWindowType = extern enum {
    GTK_WINDOW_TOPLEVEL = 0,
    GTK_WINDOW_POPUP = 1,
};
pub const GTK_WIN_POS_NONE = 0;
pub const GTK_WIN_POS_CENTER = 1;
pub const GTK_WIN_POS_MOUSE = 2;
pub const GTK_WIN_POS_CENTER_ALWAYS = 3;
pub const GTK_WIN_POS_CENTER_ON_PARENT = 4;
pub const GtkWindowPosition = extern enum {
    GTK_WIN_POS_NONE = 0,
    GTK_WIN_POS_CENTER = 1,
    GTK_WIN_POS_MOUSE = 2,
    GTK_WIN_POS_CENTER_ALWAYS = 3,
    GTK_WIN_POS_CENTER_ON_PARENT = 4,
};
pub extern fn gtk_window_get_type() GType;
pub extern fn gtk_window_new(type_0: GtkWindowType) [*c]GtkWidget;
pub extern fn gtk_window_set_title(window: [*c]GtkWindow, title: [*c]const gchar) void;
pub extern fn gtk_window_get_title(window: [*c]GtkWindow) [*c]const gchar;
pub extern fn gtk_window_set_wmclass(window: [*c]GtkWindow, wmclass_name: [*c]const gchar, wmclass_class: [*c]const gchar) void;
pub extern fn gtk_window_set_role(window: [*c]GtkWindow, role: [*c]const gchar) void;
pub extern fn gtk_window_set_startup_id(window: [*c]GtkWindow, startup_id: [*c]const gchar) void;
pub extern fn gtk_window_get_role(window: [*c]GtkWindow) [*c]const gchar;
pub extern fn gtk_window_add_accel_group(window: [*c]GtkWindow, accel_group: [*c]GtkAccelGroup) void;
pub extern fn gtk_window_remove_accel_group(window: [*c]GtkWindow, accel_group: [*c]GtkAccelGroup) void;
pub extern fn gtk_window_set_position(window: [*c]GtkWindow, position: GtkWindowPosition) void;
pub extern fn gtk_window_activate_focus(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_focus(window: [*c]GtkWindow, focus: [*c]GtkWidget) void;
pub extern fn gtk_window_get_focus(window: [*c]GtkWindow) [*c]GtkWidget;
pub extern fn gtk_window_set_default(window: [*c]GtkWindow, default_widget: [*c]GtkWidget) void;
pub extern fn gtk_window_get_default_widget(window: [*c]GtkWindow) [*c]GtkWidget;
pub extern fn gtk_window_activate_default(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_transient_for(window: [*c]GtkWindow, parent: [*c]GtkWindow) void;
pub extern fn gtk_window_get_transient_for(window: [*c]GtkWindow) [*c]GtkWindow;
pub extern fn gtk_window_set_attached_to(window: [*c]GtkWindow, attach_widget: [*c]GtkWidget) void;
pub extern fn gtk_window_get_attached_to(window: [*c]GtkWindow) [*c]GtkWidget;
pub extern fn gtk_window_set_opacity(window: [*c]GtkWindow, opacity: gdouble) void;
pub extern fn gtk_window_get_opacity(window: [*c]GtkWindow) gdouble;
pub extern fn gtk_window_set_type_hint(window: [*c]GtkWindow, hint: GdkWindowTypeHint) void;
pub extern fn gtk_window_get_type_hint(window: [*c]GtkWindow) GdkWindowTypeHint;
pub extern fn gtk_window_set_skip_taskbar_hint(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_skip_taskbar_hint(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_skip_pager_hint(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_skip_pager_hint(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_urgency_hint(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_urgency_hint(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_accept_focus(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_accept_focus(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_focus_on_map(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_focus_on_map(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_destroy_with_parent(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_destroy_with_parent(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_hide_titlebar_when_maximized(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_hide_titlebar_when_maximized(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_mnemonics_visible(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_mnemonics_visible(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_focus_visible(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_focus_visible(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_resizable(window: [*c]GtkWindow, resizable: gboolean) void;
pub extern fn gtk_window_get_resizable(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_gravity(window: [*c]GtkWindow, gravity: GdkGravity) void;
pub extern fn gtk_window_get_gravity(window: [*c]GtkWindow) GdkGravity;
pub extern fn gtk_window_set_geometry_hints(window: [*c]GtkWindow, geometry_widget: [*c]GtkWidget, geometry: [*c]GdkGeometry, geom_mask: GdkWindowHints) void;
pub extern fn gtk_window_set_screen(window: [*c]GtkWindow, screen: ?*GdkScreen) void;
pub extern fn gtk_window_get_screen(window: [*c]GtkWindow) ?*GdkScreen;
pub extern fn gtk_window_is_active(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_has_toplevel_focus(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_decorated(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_decorated(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_deletable(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_get_deletable(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_icon_list(window: [*c]GtkWindow, list: [*c]GList) void;
pub extern fn gtk_window_get_icon_list(window: [*c]GtkWindow) [*c]GList;
pub extern fn gtk_window_set_icon(window: [*c]GtkWindow, icon: ?*GdkPixbuf) void;
pub extern fn gtk_window_set_icon_name(window: [*c]GtkWindow, name: [*c]const gchar) void;
pub extern fn gtk_window_set_icon_from_file(window: [*c]GtkWindow, filename: [*c]const gchar, err: [*c]([*c]GError)) gboolean;
pub extern fn gtk_window_get_icon(window: [*c]GtkWindow) ?*GdkPixbuf;
pub extern fn gtk_window_get_icon_name(window: [*c]GtkWindow) [*c]const gchar;
pub extern fn gtk_window_set_default_icon_list(list: [*c]GList) void;
pub extern fn gtk_window_get_default_icon_list() [*c]GList;
pub extern fn gtk_window_set_default_icon(icon: ?*GdkPixbuf) void;
pub extern fn gtk_window_set_default_icon_name(name: [*c]const gchar) void;
pub extern fn gtk_window_get_default_icon_name() [*c]const gchar;
pub extern fn gtk_window_set_default_icon_from_file(filename: [*c]const gchar, err: [*c]([*c]GError)) gboolean;
pub extern fn gtk_window_set_auto_startup_notification(setting: gboolean) void;
pub extern fn gtk_window_set_modal(window: [*c]GtkWindow, modal: gboolean) void;
pub extern fn gtk_window_get_modal(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_list_toplevels() [*c]GList;
pub extern fn gtk_window_set_has_user_ref_count(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_add_mnemonic(window: [*c]GtkWindow, keyval: guint, target: [*c]GtkWidget) void;
pub extern fn gtk_window_remove_mnemonic(window: [*c]GtkWindow, keyval: guint, target: [*c]GtkWidget) void;
pub extern fn gtk_window_mnemonic_activate(window: [*c]GtkWindow, keyval: guint, modifier: GdkModifierType) gboolean;
pub extern fn gtk_window_set_mnemonic_modifier(window: [*c]GtkWindow, modifier: GdkModifierType) void;
pub extern fn gtk_window_get_mnemonic_modifier(window: [*c]GtkWindow) GdkModifierType;
pub extern fn gtk_window_activate_key(window: [*c]GtkWindow, event: ?*GdkEventKey) gboolean;
pub extern fn gtk_window_propagate_key_event(window: [*c]GtkWindow, event: ?*GdkEventKey) gboolean;
pub extern fn gtk_window_present(window: [*c]GtkWindow) void;
pub extern fn gtk_window_present_with_time(window: [*c]GtkWindow, timestamp: guint32) void;
pub extern fn gtk_window_iconify(window: [*c]GtkWindow) void;
pub extern fn gtk_window_deiconify(window: [*c]GtkWindow) void;
pub extern fn gtk_window_stick(window: [*c]GtkWindow) void;
pub extern fn gtk_window_unstick(window: [*c]GtkWindow) void;
pub extern fn gtk_window_maximize(window: [*c]GtkWindow) void;
pub extern fn gtk_window_unmaximize(window: [*c]GtkWindow) void;
pub extern fn gtk_window_fullscreen(window: [*c]GtkWindow) void;
pub extern fn gtk_window_unfullscreen(window: [*c]GtkWindow) void;
pub extern fn gtk_window_fullscreen_on_monitor(window: [*c]GtkWindow, screen: ?*GdkScreen, monitor: gint) void;
pub extern fn gtk_window_close(window: [*c]GtkWindow) void;
pub extern fn gtk_window_set_keep_above(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_set_keep_below(window: [*c]GtkWindow, setting: gboolean) void;
pub extern fn gtk_window_begin_resize_drag(window: [*c]GtkWindow, edge: GdkWindowEdge, button: gint, root_x: gint, root_y: gint, timestamp: guint32) void;
pub extern fn gtk_window_begin_move_drag(window: [*c]GtkWindow, button: gint, root_x: gint, root_y: gint, timestamp: guint32) void;
pub extern fn gtk_window_set_default_size(window: [*c]GtkWindow, width: gint, height: gint) void;
pub extern fn gtk_window_get_default_size(window: [*c]GtkWindow, width: [*c]gint, height: [*c]gint) void;
pub extern fn gtk_window_resize(window: [*c]GtkWindow, width: gint, height: gint) void;
pub extern fn gtk_window_get_size(window: [*c]GtkWindow, width: [*c]gint, height: [*c]gint) void;
pub extern fn gtk_window_move(window: [*c]GtkWindow, x: gint, y: gint) void;
pub extern fn gtk_window_get_position(window: [*c]GtkWindow, root_x: [*c]gint, root_y: [*c]gint) void;
pub extern fn gtk_window_parse_geometry(window: [*c]GtkWindow, geometry: [*c]const gchar) gboolean;
pub extern fn gtk_window_set_default_geometry(window: [*c]GtkWindow, width: gint, height: gint) void;
pub extern fn gtk_window_resize_to_geometry(window: [*c]GtkWindow, width: gint, height: gint) void;
pub extern fn gtk_window_get_group(window: [*c]GtkWindow) [*c]GtkWindowGroup;
pub extern fn gtk_window_has_group(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_reshow_with_initial_size(window: [*c]GtkWindow) void;
pub extern fn gtk_window_get_window_type(window: [*c]GtkWindow) GtkWindowType;
pub extern fn gtk_window_get_application(window: [*c]GtkWindow) [*c]GtkApplication;
pub extern fn gtk_window_set_application(window: [*c]GtkWindow, application: [*c]GtkApplication) void;
pub extern fn gtk_window_set_has_resize_grip(window: [*c]GtkWindow, value: gboolean) void;
pub extern fn gtk_window_get_has_resize_grip(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_resize_grip_is_visible(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_get_resize_grip_area(window: [*c]GtkWindow, rect: [*c]GdkRectangle) gboolean;
pub extern fn gtk_window_set_titlebar(window: [*c]GtkWindow, titlebar: [*c]GtkWidget) void;
pub extern fn gtk_window_get_titlebar(window: [*c]GtkWindow) [*c]GtkWidget;
pub extern fn gtk_window_is_maximized(window: [*c]GtkWindow) gboolean;
pub extern fn gtk_window_set_interactive_debugging(enable: gboolean) void;
pub const GtkWindow_autoptr = [*c]GtkWindow;
pub const GtkWindow_listautoptr = [*c]GList;
pub const GtkWindow_slistautoptr = [*c]GSList;
pub const GtkWindow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkWindow(_ptr: [*c]GtkWindow) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkWindow(_ptr: [*c]([*c]GtkWindow)) void {
    glib_autoptr_clear_GtkWindow(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkWindow(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkWindow(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkWindow(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkWindowGroup_autoptr = [*c]GtkWindowGroup;
pub const GtkWindowGroup_listautoptr = [*c]GList;
pub const GtkWindowGroup_slistautoptr = [*c]GSList;
pub const GtkWindowGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkWindowGroup(_ptr: [*c]GtkWindowGroup) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkWindowGroup(_ptr: [*c]([*c]GtkWindowGroup)) void {
    glib_autoptr_clear_GtkWindowGroup(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkWindowGroup(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkWindowGroup(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkWindowGroup(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GTK_DIALOG_MODAL = 1;
pub const GTK_DIALOG_DESTROY_WITH_PARENT = 2;
pub const GTK_DIALOG_USE_HEADER_BAR = 4;
pub const GtkDialogFlags = extern enum {
    GTK_DIALOG_MODAL = 1,
    GTK_DIALOG_DESTROY_WITH_PARENT = 2,
    GTK_DIALOG_USE_HEADER_BAR = 4,
};
pub const GTK_RESPONSE_NONE = -1;
pub const GTK_RESPONSE_REJECT = -2;
pub const GTK_RESPONSE_ACCEPT = -3;
pub const GTK_RESPONSE_DELETE_EVENT = -4;
pub const GTK_RESPONSE_OK = -5;
pub const GTK_RESPONSE_CANCEL = -6;
pub const GTK_RESPONSE_CLOSE = -7;
pub const GTK_RESPONSE_YES = -8;
pub const GTK_RESPONSE_NO = -9;
pub const GTK_RESPONSE_APPLY = -10;
pub const GTK_RESPONSE_HELP = -11;
pub const GtkResponseType = extern enum {
    GTK_RESPONSE_NONE = -1,
    GTK_RESPONSE_REJECT = -2,
    GTK_RESPONSE_ACCEPT = -3,
    GTK_RESPONSE_DELETE_EVENT = -4,
    GTK_RESPONSE_OK = -5,
    GTK_RESPONSE_CANCEL = -6,
    GTK_RESPONSE_CLOSE = -7,
    GTK_RESPONSE_YES = -8,
    GTK_RESPONSE_NO = -9,
    GTK_RESPONSE_APPLY = -10,
    GTK_RESPONSE_HELP = -11,
};
pub const struct__GtkDialogPrivate = @OpaqueType();
pub const GtkDialogPrivate = struct__GtkDialogPrivate;
pub const struct__GtkDialog = extern struct {
    window: GtkWindow,
    priv: ?*GtkDialogPrivate,
};
pub const GtkDialog = struct__GtkDialog;
pub const struct__GtkDialogClass = extern struct {
    parent_class: GtkWindowClass,
    response: ?extern fn ([*c]GtkDialog, gint) void,
    close: ?extern fn ([*c]GtkDialog) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkDialogClass = struct__GtkDialogClass;
pub extern fn gtk_dialog_get_type() GType;
pub extern fn gtk_dialog_new() [*c]GtkWidget;
pub extern fn gtk_dialog_new_with_buttons(title: [*c]const gchar, parent: [*c]GtkWindow, flags: GtkDialogFlags, first_button_text: [*c]const gchar, ...) [*c]GtkWidget;
pub extern fn gtk_dialog_add_action_widget(dialog: [*c]GtkDialog, child: [*c]GtkWidget, response_id: gint) void;
pub extern fn gtk_dialog_add_button(dialog: [*c]GtkDialog, button_text: [*c]const gchar, response_id: gint) [*c]GtkWidget;
pub extern fn gtk_dialog_add_buttons(dialog: [*c]GtkDialog, first_button_text: [*c]const gchar, ...) void;
pub extern fn gtk_dialog_set_response_sensitive(dialog: [*c]GtkDialog, response_id: gint, setting: gboolean) void;
pub extern fn gtk_dialog_set_default_response(dialog: [*c]GtkDialog, response_id: gint) void;
pub extern fn gtk_dialog_get_widget_for_response(dialog: [*c]GtkDialog, response_id: gint) [*c]GtkWidget;
pub extern fn gtk_dialog_get_response_for_widget(dialog: [*c]GtkDialog, widget: [*c]GtkWidget) gint;
pub extern fn gtk_alternative_dialog_button_order(screen: ?*GdkScreen) gboolean;
pub extern fn gtk_dialog_set_alternative_button_order(dialog: [*c]GtkDialog, first_response_id: gint, ...) void;
pub extern fn gtk_dialog_set_alternative_button_order_from_array(dialog: [*c]GtkDialog, n_params: gint, new_order: [*c]gint) void;
pub extern fn gtk_dialog_response(dialog: [*c]GtkDialog, response_id: gint) void;
pub extern fn gtk_dialog_run(dialog: [*c]GtkDialog) gint;
pub extern fn gtk_dialog_get_action_area(dialog: [*c]GtkDialog) [*c]GtkWidget;
pub extern fn gtk_dialog_get_content_area(dialog: [*c]GtkDialog) [*c]GtkWidget;
pub extern fn gtk_dialog_get_header_bar(dialog: [*c]GtkDialog) [*c]GtkWidget;
pub const GtkDialog_autoptr = [*c]GtkDialog;
pub const GtkDialog_listautoptr = [*c]GList;
pub const GtkDialog_slistautoptr = [*c]GSList;
pub const GtkDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkDialog(_ptr: [*c]GtkDialog) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkDialog(_ptr: [*c]([*c]GtkDialog)) void {
    glib_autoptr_clear_GtkDialog(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkDialog(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkDialog(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkDialog(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__GtkAboutDialogPrivate = @OpaqueType();
pub const GtkAboutDialogPrivate = struct__GtkAboutDialogPrivate;
pub const struct__GtkAboutDialog = extern struct {
    parent_instance: GtkDialog,
    priv: ?*GtkAboutDialogPrivate,
};
pub const GtkAboutDialog = struct__GtkAboutDialog;
pub const struct__GtkAboutDialogClass = extern struct {
    parent_class: GtkDialogClass,
    activate_link: ?extern fn ([*c]GtkAboutDialog, [*c]const gchar) gboolean,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkAboutDialogClass = struct__GtkAboutDialogClass;
pub const GTK_LICENSE_UNKNOWN = 0;
pub const GTK_LICENSE_CUSTOM = 1;
pub const GTK_LICENSE_GPL_2_0 = 2;
pub const GTK_LICENSE_GPL_3_0 = 3;
pub const GTK_LICENSE_LGPL_2_1 = 4;
pub const GTK_LICENSE_LGPL_3_0 = 5;
pub const GTK_LICENSE_BSD = 6;
pub const GTK_LICENSE_MIT_X11 = 7;
pub const GTK_LICENSE_ARTISTIC = 8;
pub const GTK_LICENSE_GPL_2_0_ONLY = 9;
pub const GTK_LICENSE_GPL_3_0_ONLY = 10;
pub const GTK_LICENSE_LGPL_2_1_ONLY = 11;
pub const GTK_LICENSE_LGPL_3_0_ONLY = 12;
pub const GTK_LICENSE_AGPL_3_0 = 13;
pub const GTK_LICENSE_AGPL_3_0_ONLY = 14;
pub const GtkLicense = extern enum {
    GTK_LICENSE_UNKNOWN = 0,
    GTK_LICENSE_CUSTOM = 1,
    GTK_LICENSE_GPL_2_0 = 2,
    GTK_LICENSE_GPL_3_0 = 3,
    GTK_LICENSE_LGPL_2_1 = 4,
    GTK_LICENSE_LGPL_3_0 = 5,
    GTK_LICENSE_BSD = 6,
    GTK_LICENSE_MIT_X11 = 7,
    GTK_LICENSE_ARTISTIC = 8,
    GTK_LICENSE_GPL_2_0_ONLY = 9,
    GTK_LICENSE_GPL_3_0_ONLY = 10,
    GTK_LICENSE_LGPL_2_1_ONLY = 11,
    GTK_LICENSE_LGPL_3_0_ONLY = 12,
    GTK_LICENSE_AGPL_3_0 = 13,
    GTK_LICENSE_AGPL_3_0_ONLY = 14,
};
pub extern fn gtk_about_dialog_get_type() GType;
pub extern fn gtk_about_dialog_new() [*c]GtkWidget;
pub extern fn gtk_show_about_dialog(parent: [*c]GtkWindow, first_property_name: [*c]const gchar, ...) void;
pub extern fn gtk_about_dialog_get_program_name(about: [*c]GtkAboutDialog) [*c]const gchar;
pub extern fn gtk_about_dialog_set_program_name(about: [*c]GtkAboutDialog, name: [*c]const gchar) void;
pub extern fn gtk_about_dialog_get_version(about: [*c]GtkAboutDialog) [*c]const gchar;
pub extern fn gtk_about_dialog_set_version(about: [*c]GtkAboutDialog, version: [*c]const gchar) void;
pub extern fn gtk_about_dialog_get_copyright(about: [*c]GtkAboutDialog) [*c]const gchar;
pub extern fn gtk_about_dialog_set_copyright(about: [*c]GtkAboutDialog, copyright: [*c]const gchar) void;
pub extern fn gtk_about_dialog_get_comments(about: [*c]GtkAboutDialog) [*c]const gchar;
pub extern fn gtk_about_dialog_set_comments(about: [*c]GtkAboutDialog, comments: [*c]const gchar) void;
pub extern fn gtk_about_dialog_get_license(about: [*c]GtkAboutDialog) [*c]const gchar;
pub extern fn gtk_about_dialog_set_license(about: [*c]GtkAboutDialog, license: [*c]const gchar) void;
pub extern fn gtk_about_dialog_set_license_type(about: [*c]GtkAboutDialog, license_type: GtkLicense) void;
pub extern fn gtk_about_dialog_get_license_type(about: [*c]GtkAboutDialog) GtkLicense;
pub extern fn gtk_about_dialog_get_wrap_license(about: [*c]GtkAboutDialog) gboolean;
pub extern fn gtk_about_dialog_set_wrap_license(about: [*c]GtkAboutDialog, wrap_license: gboolean) void;
pub extern fn gtk_about_dialog_get_website(about: [*c]GtkAboutDialog) [*c]const gchar;
pub extern fn gtk_about_dialog_set_website(about: [*c]GtkAboutDialog, website: [*c]const gchar) void;
pub extern fn gtk_about_dialog_get_website_label(about: [*c]GtkAboutDialog) [*c]const gchar;
pub extern fn gtk_about_dialog_set_website_label(about: [*c]GtkAboutDialog, website_label: [*c]const gchar) void;
pub extern fn gtk_about_dialog_get_authors(about: [*c]GtkAboutDialog) [*c]const ([*c]const gchar);
pub extern fn gtk_about_dialog_set_authors(about: [*c]GtkAboutDialog, authors: [*c]([*c]const gchar)) void;
pub extern fn gtk_about_dialog_get_documenters(about: [*c]GtkAboutDialog) [*c]const ([*c]const gchar);
pub extern fn gtk_about_dialog_set_documenters(about: [*c]GtkAboutDialog, documenters: [*c]([*c]const gchar)) void;
pub extern fn gtk_about_dialog_get_artists(about: [*c]GtkAboutDialog) [*c]const ([*c]const gchar);
pub extern fn gtk_about_dialog_set_artists(about: [*c]GtkAboutDialog, artists: [*c]([*c]const gchar)) void;
pub extern fn gtk_about_dialog_get_translator_credits(about: [*c]GtkAboutDialog) [*c]const gchar;
pub extern fn gtk_about_dialog_set_translator_credits(about: [*c]GtkAboutDialog, translator_credits: [*c]const gchar) void;
pub extern fn gtk_about_dialog_get_logo(about: [*c]GtkAboutDialog) ?*GdkPixbuf;
pub extern fn gtk_about_dialog_set_logo(about: [*c]GtkAboutDialog, logo: ?*GdkPixbuf) void;
pub extern fn gtk_about_dialog_get_logo_icon_name(about: [*c]GtkAboutDialog) [*c]const gchar;
pub extern fn gtk_about_dialog_set_logo_icon_name(about: [*c]GtkAboutDialog, icon_name: [*c]const gchar) void;
pub extern fn gtk_about_dialog_add_credit_section(about: [*c]GtkAboutDialog, section_name: [*c]const gchar, people: [*c]([*c]const gchar)) void;
pub const GtkAboutDialog_autoptr = [*c]GtkAboutDialog;
pub const GtkAboutDialog_listautoptr = [*c]GList;
pub const GtkAboutDialog_slistautoptr = [*c]GSList;
pub const GtkAboutDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAboutDialog(_ptr: [*c]GtkAboutDialog) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkAboutDialog(_ptr: [*c]([*c]GtkAboutDialog)) void {
    glib_autoptr_clear_GtkAboutDialog(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkAboutDialog(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkAboutDialog(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkAboutDialog(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__GtkMiscPrivate = @OpaqueType();
pub const GtkMiscPrivate = struct__GtkMiscPrivate;
pub const struct__GtkMisc = extern struct {
    widget: GtkWidget,
    priv: ?*GtkMiscPrivate,
};
pub const GtkMisc = struct__GtkMisc;
pub const struct__GtkMiscClass = extern struct {
    parent_class: GtkWidgetClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkMiscClass = struct__GtkMiscClass;
pub extern fn gtk_misc_get_type() GType;
pub extern fn gtk_misc_set_alignment(misc: [*c]GtkMisc, xalign: gfloat, yalign: gfloat) void;
pub extern fn gtk_misc_get_alignment(misc: [*c]GtkMisc, xalign: [*c]gfloat, yalign: [*c]gfloat) void;
pub extern fn gtk_misc_set_padding(misc: [*c]GtkMisc, xpad: gint, ypad: gint) void;
pub extern fn gtk_misc_get_padding(misc: [*c]GtkMisc, xpad: [*c]gint, ypad: [*c]gint) void;
pub extern fn _gtk_misc_get_padding_and_border(misc: [*c]GtkMisc, border: [*c]GtkBorder) void;
pub const struct__GtkMenuShellPrivate = @OpaqueType();
pub const GtkMenuShellPrivate = struct__GtkMenuShellPrivate;
pub const struct__GtkMenuShell = extern struct {
    container: GtkContainer,
    priv: ?*GtkMenuShellPrivate,
};
pub const GtkMenuShell = struct__GtkMenuShell;
pub const struct__GtkMenuShellClass = @OpaqueType();
pub const GtkMenuShellClass = struct__GtkMenuShellClass;
pub extern fn gtk_menu_shell_get_type() GType;
pub extern fn gtk_menu_shell_append(menu_shell: [*c]GtkMenuShell, child: [*c]GtkWidget) void;
pub extern fn gtk_menu_shell_prepend(menu_shell: [*c]GtkMenuShell, child: [*c]GtkWidget) void;
pub extern fn gtk_menu_shell_insert(menu_shell: [*c]GtkMenuShell, child: [*c]GtkWidget, position: gint) void;
pub extern fn gtk_menu_shell_deactivate(menu_shell: [*c]GtkMenuShell) void;
pub extern fn gtk_menu_shell_select_item(menu_shell: [*c]GtkMenuShell, menu_item: [*c]GtkWidget) void;
pub extern fn gtk_menu_shell_deselect(menu_shell: [*c]GtkMenuShell) void;
pub extern fn gtk_menu_shell_activate_item(menu_shell: [*c]GtkMenuShell, menu_item: [*c]GtkWidget, force_deactivate: gboolean) void;
pub extern fn gtk_menu_shell_select_first(menu_shell: [*c]GtkMenuShell, search_sensitive: gboolean) void;
pub extern fn gtk_menu_shell_cancel(menu_shell: [*c]GtkMenuShell) void;
pub extern fn gtk_menu_shell_get_take_focus(menu_shell: [*c]GtkMenuShell) gboolean;
pub extern fn gtk_menu_shell_set_take_focus(menu_shell: [*c]GtkMenuShell, take_focus: gboolean) void;
pub extern fn gtk_menu_shell_get_selected_item(menu_shell: [*c]GtkMenuShell) [*c]GtkWidget;
pub extern fn gtk_menu_shell_get_parent_shell(menu_shell: [*c]GtkMenuShell) [*c]GtkWidget;
pub extern fn gtk_menu_shell_bind_model(menu_shell: [*c]GtkMenuShell, model: [*c]GMenuModel, action_namespace: [*c]const gchar, with_separators: gboolean) void;
pub const GtkMenuShell_autoptr = [*c]GtkMenuShell;
pub const GtkMenuShell_listautoptr = [*c]GList;
pub const GtkMenuShell_slistautoptr = [*c]GSList;
pub const GtkMenuShell_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMenuShell(_ptr: [*c]GtkMenuShell) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkMenuShell(_ptr: [*c]([*c]GtkMenuShell)) void {
    glib_autoptr_clear_GtkMenuShell(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkMenuShell(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkMenuShell(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkMenuShell(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__GtkMenuPrivate = @OpaqueType();
pub const GtkMenuPrivate = struct__GtkMenuPrivate;
pub const struct__GtkMenu = extern struct {
    menu_shell: GtkMenuShell,
    priv: ?*GtkMenuPrivate,
};
pub const GtkMenu = struct__GtkMenu;
pub const struct__GtkMenuClass = extern struct {
    parent_class: GtkMenuShellClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkMenuClass = struct__GtkMenuClass;
pub const GTK_ARROWS_BOTH = 0;
pub const GTK_ARROWS_START = 1;
pub const GTK_ARROWS_END = 2;
pub const GtkArrowPlacement = extern enum {
    GTK_ARROWS_BOTH = 0,
    GTK_ARROWS_START = 1,
    GTK_ARROWS_END = 2,
};
pub const GtkMenuPositionFunc = ?extern fn ([*c]GtkMenu, [*c]gint, [*c]gint, [*c]gboolean, gpointer) void;
pub const GtkMenuDetachFunc = ?extern fn ([*c]GtkWidget, [*c]GtkMenu) void;
pub extern fn gtk_menu_get_type() GType;
pub extern fn gtk_menu_new() [*c]GtkWidget;
pub extern fn gtk_menu_new_from_model(model: [*c]GMenuModel) [*c]GtkWidget;
pub extern fn gtk_menu_popup(menu: [*c]GtkMenu, parent_menu_shell: [*c]GtkWidget, parent_menu_item: [*c]GtkWidget, func: GtkMenuPositionFunc, data: gpointer, button: guint, activate_time: guint32) void;
pub extern fn gtk_menu_popup_for_device(menu: [*c]GtkMenu, device: ?*GdkDevice, parent_menu_shell: [*c]GtkWidget, parent_menu_item: [*c]GtkWidget, func: GtkMenuPositionFunc, data: gpointer, destroy: GDestroyNotify, button: guint, activate_time: guint32) void;
pub extern fn gtk_menu_popup_at_rect(menu: [*c]GtkMenu, rect_window: ?*GdkWindow, rect: [*c]const GdkRectangle, rect_anchor: GdkGravity, menu_anchor: GdkGravity, trigger_event: [*c]const GdkEvent) void;
pub extern fn gtk_menu_popup_at_widget(menu: [*c]GtkMenu, widget: [*c]GtkWidget, widget_anchor: GdkGravity, menu_anchor: GdkGravity, trigger_event: [*c]const GdkEvent) void;
pub extern fn gtk_menu_popup_at_pointer(menu: [*c]GtkMenu, trigger_event: [*c]const GdkEvent) void;
pub extern fn gtk_menu_reposition(menu: [*c]GtkMenu) void;
pub extern fn gtk_menu_popdown(menu: [*c]GtkMenu) void;
pub extern fn gtk_menu_get_active(menu: [*c]GtkMenu) [*c]GtkWidget;
pub extern fn gtk_menu_set_active(menu: [*c]GtkMenu, index: guint) void;
pub extern fn gtk_menu_set_accel_group(menu: [*c]GtkMenu, accel_group: [*c]GtkAccelGroup) void;
pub extern fn gtk_menu_get_accel_group(menu: [*c]GtkMenu) [*c]GtkAccelGroup;
pub extern fn gtk_menu_set_accel_path(menu: [*c]GtkMenu, accel_path: [*c]const gchar) void;
pub extern fn gtk_menu_get_accel_path(menu: [*c]GtkMenu) [*c]const gchar;
pub extern fn gtk_menu_attach_to_widget(menu: [*c]GtkMenu, attach_widget: [*c]GtkWidget, detacher: GtkMenuDetachFunc) void;
pub extern fn gtk_menu_detach(menu: [*c]GtkMenu) void;
pub extern fn gtk_menu_get_attach_widget(menu: [*c]GtkMenu) [*c]GtkWidget;
pub extern fn gtk_menu_set_tearoff_state(menu: [*c]GtkMenu, torn_off: gboolean) void;
pub extern fn gtk_menu_get_tearoff_state(menu: [*c]GtkMenu) gboolean;
pub extern fn gtk_menu_set_title(menu: [*c]GtkMenu, title: [*c]const gchar) void;
pub extern fn gtk_menu_get_title(menu: [*c]GtkMenu) [*c]const gchar;
pub extern fn gtk_menu_reorder_child(menu: [*c]GtkMenu, child: [*c]GtkWidget, position: gint) void;
pub extern fn gtk_menu_set_screen(menu: [*c]GtkMenu, screen: ?*GdkScreen) void;
pub extern fn gtk_menu_attach(menu: [*c]GtkMenu, child: [*c]GtkWidget, left_attach: guint, right_attach: guint, top_attach: guint, bottom_attach: guint) void;
pub extern fn gtk_menu_set_monitor(menu: [*c]GtkMenu, monitor_num: gint) void;
pub extern fn gtk_menu_get_monitor(menu: [*c]GtkMenu) gint;
pub extern fn gtk_menu_place_on_monitor(menu: [*c]GtkMenu, monitor: ?*GdkMonitor) void;
pub extern fn gtk_menu_get_for_attach_widget(widget: [*c]GtkWidget) [*c]GList;
pub extern fn gtk_menu_set_reserve_toggle_size(menu: [*c]GtkMenu, reserve_toggle_size: gboolean) void;
pub extern fn gtk_menu_get_reserve_toggle_size(menu: [*c]GtkMenu) gboolean;
pub const GtkMenu_autoptr = [*c]GtkMenu;
pub const GtkMenu_listautoptr = [*c]GList;
pub const GtkMenu_slistautoptr = [*c]GSList;
pub const GtkMenu_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMenu(_ptr: [*c]GtkMenu) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkMenu(_ptr: [*c]([*c]GtkMenu)) void {
    glib_autoptr_clear_GtkMenu(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkMenu(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkMenu(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkMenu(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__GtkLabelPrivate = @OpaqueType();
pub const GtkLabelPrivate = struct__GtkLabelPrivate;
pub const struct__GtkLabel = extern struct {
    misc: GtkMisc,
    priv: ?*GtkLabelPrivate,
};
pub const GtkLabel = struct__GtkLabel;
pub const struct__GtkLabelClass = extern struct {
    parent_class: GtkMiscClass,
    move_cursor: ?extern fn ([*c]GtkLabel, GtkMovementStep, gint, gboolean) void,
    copy_clipboard: ?extern fn ([*c]GtkLabel) void,
    populate_popup: ?extern fn ([*c]GtkLabel, [*c]GtkMenu) void,
    activate_link: ?extern fn ([*c]GtkLabel, [*c]const gchar) gboolean,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
    _gtk_reserved8: ?extern fn () void,
};
pub const GtkLabelClass = struct__GtkLabelClass;
pub const struct__GtkLabelSelectionInfo = @OpaqueType();
pub const GtkLabelSelectionInfo = struct__GtkLabelSelectionInfo;
pub extern fn gtk_label_get_type() GType;
pub extern fn gtk_label_new(str: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_label_new_with_mnemonic(str: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_label_set_text(label: [*c]GtkLabel, str: [*c]const gchar) void;
pub extern fn gtk_label_get_text(label: [*c]GtkLabel) [*c]const gchar;
pub extern fn gtk_label_set_attributes(label: [*c]GtkLabel, attrs: ?*PangoAttrList) void;
pub extern fn gtk_label_get_attributes(label: [*c]GtkLabel) ?*PangoAttrList;
pub extern fn gtk_label_set_label(label: [*c]GtkLabel, str: [*c]const gchar) void;
pub extern fn gtk_label_get_label(label: [*c]GtkLabel) [*c]const gchar;
pub extern fn gtk_label_set_markup(label: [*c]GtkLabel, str: [*c]const gchar) void;
pub extern fn gtk_label_set_use_markup(label: [*c]GtkLabel, setting: gboolean) void;
pub extern fn gtk_label_get_use_markup(label: [*c]GtkLabel) gboolean;
pub extern fn gtk_label_set_use_underline(label: [*c]GtkLabel, setting: gboolean) void;
pub extern fn gtk_label_get_use_underline(label: [*c]GtkLabel) gboolean;
pub extern fn gtk_label_set_markup_with_mnemonic(label: [*c]GtkLabel, str: [*c]const gchar) void;
pub extern fn gtk_label_get_mnemonic_keyval(label: [*c]GtkLabel) guint;
pub extern fn gtk_label_set_mnemonic_widget(label: [*c]GtkLabel, widget: [*c]GtkWidget) void;
pub extern fn gtk_label_get_mnemonic_widget(label: [*c]GtkLabel) [*c]GtkWidget;
pub extern fn gtk_label_set_text_with_mnemonic(label: [*c]GtkLabel, str: [*c]const gchar) void;
pub extern fn gtk_label_set_justify(label: [*c]GtkLabel, jtype: GtkJustification) void;
pub extern fn gtk_label_get_justify(label: [*c]GtkLabel) GtkJustification;
pub extern fn gtk_label_set_ellipsize(label: [*c]GtkLabel, mode: PangoEllipsizeMode) void;
pub extern fn gtk_label_get_ellipsize(label: [*c]GtkLabel) PangoEllipsizeMode;
pub extern fn gtk_label_set_width_chars(label: [*c]GtkLabel, n_chars: gint) void;
pub extern fn gtk_label_get_width_chars(label: [*c]GtkLabel) gint;
pub extern fn gtk_label_set_max_width_chars(label: [*c]GtkLabel, n_chars: gint) void;
pub extern fn gtk_label_get_max_width_chars(label: [*c]GtkLabel) gint;
pub extern fn gtk_label_set_lines(label: [*c]GtkLabel, lines: gint) void;
pub extern fn gtk_label_get_lines(label: [*c]GtkLabel) gint;
pub extern fn gtk_label_set_pattern(label: [*c]GtkLabel, pattern: [*c]const gchar) void;
pub extern fn gtk_label_set_line_wrap(label: [*c]GtkLabel, wrap: gboolean) void;
pub extern fn gtk_label_get_line_wrap(label: [*c]GtkLabel) gboolean;
pub extern fn gtk_label_set_line_wrap_mode(label: [*c]GtkLabel, wrap_mode: PangoWrapMode) void;
pub extern fn gtk_label_get_line_wrap_mode(label: [*c]GtkLabel) PangoWrapMode;
pub extern fn gtk_label_set_selectable(label: [*c]GtkLabel, setting: gboolean) void;
pub extern fn gtk_label_get_selectable(label: [*c]GtkLabel) gboolean;
pub extern fn gtk_label_set_angle(label: [*c]GtkLabel, angle: gdouble) void;
pub extern fn gtk_label_get_angle(label: [*c]GtkLabel) gdouble;
pub extern fn gtk_label_select_region(label: [*c]GtkLabel, start_offset: gint, end_offset: gint) void;
pub extern fn gtk_label_get_selection_bounds(label: [*c]GtkLabel, start: [*c]gint, end: [*c]gint) gboolean;
pub extern fn gtk_label_get_layout(label: [*c]GtkLabel) ?*PangoLayout;
pub extern fn gtk_label_get_layout_offsets(label: [*c]GtkLabel, x: [*c]gint, y: [*c]gint) void;
pub extern fn gtk_label_set_single_line_mode(label: [*c]GtkLabel, single_line_mode: gboolean) void;
pub extern fn gtk_label_get_single_line_mode(label: [*c]GtkLabel) gboolean;
pub extern fn gtk_label_get_current_uri(label: [*c]GtkLabel) [*c]const gchar;
pub extern fn gtk_label_set_track_visited_links(label: [*c]GtkLabel, track_links: gboolean) void;
pub extern fn gtk_label_get_track_visited_links(label: [*c]GtkLabel) gboolean;
pub extern fn gtk_label_set_xalign(label: [*c]GtkLabel, xalign: gfloat) void;
pub extern fn gtk_label_get_xalign(label: [*c]GtkLabel) gfloat;
pub extern fn gtk_label_set_yalign(label: [*c]GtkLabel, yalign: gfloat) void;
pub extern fn gtk_label_get_yalign(label: [*c]GtkLabel) gfloat;
pub const GtkLabel_autoptr = [*c]GtkLabel;
pub const GtkLabel_listautoptr = [*c]GList;
pub const GtkLabel_slistautoptr = [*c]GSList;
pub const GtkLabel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkLabel(_ptr: [*c]GtkLabel) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkLabel(_ptr: [*c]([*c]GtkLabel)) void {
    glib_autoptr_clear_GtkLabel(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkLabel(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkLabel(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkLabel(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__GtkAccelLabelPrivate = @OpaqueType();
pub const GtkAccelLabelPrivate = struct__GtkAccelLabelPrivate;
pub const struct__GtkAccelLabel = extern struct {
    label: GtkLabel,
    priv: ?*GtkAccelLabelPrivate,
};
pub const GtkAccelLabel = struct__GtkAccelLabel;
pub const struct__GtkAccelLabelClass = extern struct {
    parent_class: GtkLabelClass,
    signal_quote1: [*c]gchar,
    signal_quote2: [*c]gchar,
    mod_name_shift: [*c]gchar,
    mod_name_control: [*c]gchar,
    mod_name_alt: [*c]gchar,
    mod_separator: [*c]gchar,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkAccelLabelClass = struct__GtkAccelLabelClass;
pub extern fn gtk_accel_label_get_type() GType;
pub extern fn gtk_accel_label_new(string: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_accel_label_get_accel_widget(accel_label: [*c]GtkAccelLabel) [*c]GtkWidget;
pub extern fn gtk_accel_label_get_accel_width(accel_label: [*c]GtkAccelLabel) guint;
pub extern fn gtk_accel_label_set_accel_widget(accel_label: [*c]GtkAccelLabel, accel_widget: [*c]GtkWidget) void;
pub extern fn gtk_accel_label_set_accel_closure(accel_label: [*c]GtkAccelLabel, accel_closure: ?*GClosure) void;
pub extern fn gtk_accel_label_refetch(accel_label: [*c]GtkAccelLabel) gboolean;
pub extern fn gtk_accel_label_set_accel(accel_label: [*c]GtkAccelLabel, accelerator_key: guint, accelerator_mods: GdkModifierType) void;
pub extern fn gtk_accel_label_get_accel(accel_label: [*c]GtkAccelLabel, accelerator_key: [*c]guint, accelerator_mods: [*c]GdkModifierType) void;
pub extern fn _gtk_accel_label_class_get_accelerator_label(klass: [*c]GtkAccelLabelClass, accelerator_key: guint, accelerator_mods: GdkModifierType) [*c]gchar;
pub const GtkAccelLabel_autoptr = [*c]GtkAccelLabel;
pub const GtkAccelLabel_listautoptr = [*c]GList;
pub const GtkAccelLabel_slistautoptr = [*c]GSList;
pub const GtkAccelLabel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAccelLabel(_ptr: [*c]GtkAccelLabel) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkAccelLabel(_ptr: [*c]([*c]GtkAccelLabel)) void {
    glib_autoptr_clear_GtkAccelLabel(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkAccelLabel(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkAccelLabel(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkAccelLabel(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__GtkAccelMap = @OpaqueType();
pub const GtkAccelMap = struct__GtkAccelMap;
pub const struct__GtkAccelMapClass = @OpaqueType();
pub const GtkAccelMapClass = struct__GtkAccelMapClass;
pub const GtkAccelMapForeach = ?extern fn (gpointer, [*c]const gchar, guint, GdkModifierType, gboolean) void;
pub extern fn gtk_accel_map_add_entry(accel_path: [*c]const gchar, accel_key: guint, accel_mods: GdkModifierType) void;
pub extern fn gtk_accel_map_lookup_entry(accel_path: [*c]const gchar, key: ?*GtkAccelKey) gboolean;
pub extern fn gtk_accel_map_change_entry(accel_path: [*c]const gchar, accel_key: guint, accel_mods: GdkModifierType, replace: gboolean) gboolean;
pub extern fn gtk_accel_map_load(file_name: [*c]const gchar) void;
pub extern fn gtk_accel_map_save(file_name: [*c]const gchar) void;
pub extern fn gtk_accel_map_foreach(data: gpointer, foreach_func: GtkAccelMapForeach) void;
pub extern fn gtk_accel_map_load_fd(fd: gint) void;
pub extern fn gtk_accel_map_load_scanner(scanner: [*c]GScanner) void;
pub extern fn gtk_accel_map_save_fd(fd: gint) void;
pub extern fn gtk_accel_map_lock_path(accel_path: [*c]const gchar) void;
pub extern fn gtk_accel_map_unlock_path(accel_path: [*c]const gchar) void;
pub extern fn gtk_accel_map_add_filter(filter_pattern: [*c]const gchar) void;
pub extern fn gtk_accel_map_foreach_unfiltered(data: gpointer, foreach_func: GtkAccelMapForeach) void;
pub extern fn gtk_accel_map_get_type() GType;
pub extern fn gtk_accel_map_get() ?*GtkAccelMap;
pub const GtkAccelMap_autoptr = ?*GtkAccelMap;
pub const GtkAccelMap_listautoptr = [*c]GList;
pub const GtkAccelMap_slistautoptr = [*c]GSList;
pub const GtkAccelMap_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAccelMap(_ptr: ?*GtkAccelMap) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkAccelMap(_ptr: [*c](?*GtkAccelMap)) void {
    glib_autoptr_clear_GtkAccelMap(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkAccelMap(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkAccelMap(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkAccelMap(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__GtkAccessiblePrivate = @OpaqueType();
pub const GtkAccessiblePrivate = struct__GtkAccessiblePrivate;
pub const struct__GtkAccessible = extern struct {
    parent: AtkObject,
    priv: ?*GtkAccessiblePrivate,
};
pub const GtkAccessible = struct__GtkAccessible;
pub const struct__GtkAccessibleClass = extern struct {
    parent_class: AtkObjectClass,
    connect_widget_destroyed: ?extern fn ([*c]GtkAccessible) void,
    widget_set: ?extern fn ([*c]GtkAccessible) void,
    widget_unset: ?extern fn ([*c]GtkAccessible) void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkAccessibleClass = struct__GtkAccessibleClass;
pub extern fn gtk_accessible_get_type() GType;
pub extern fn gtk_accessible_set_widget(accessible: [*c]GtkAccessible, widget: [*c]GtkWidget) void;
pub extern fn gtk_accessible_get_widget(accessible: [*c]GtkAccessible) [*c]GtkWidget;
pub extern fn gtk_accessible_connect_widget_destroyed(accessible: [*c]GtkAccessible) void;
pub const struct__GtkActionable = @OpaqueType();
pub const GtkActionable = struct__GtkActionable;
pub const struct__GtkActionableInterface = extern struct {
    g_iface: GTypeInterface,
    get_action_name: ?extern fn (?*GtkActionable) [*c]const gchar,
    set_action_name: ?extern fn (?*GtkActionable, [*c]const gchar) void,
    get_action_target_value: ?extern fn (?*GtkActionable) ?*GVariant,
    set_action_target_value: ?extern fn (?*GtkActionable, ?*GVariant) void,
};
pub const GtkActionableInterface = struct__GtkActionableInterface;
pub extern fn gtk_actionable_get_type() GType;
pub extern fn gtk_actionable_get_action_name(actionable: ?*GtkActionable) [*c]const gchar;
pub extern fn gtk_actionable_set_action_name(actionable: ?*GtkActionable, action_name: [*c]const gchar) void;
pub extern fn gtk_actionable_get_action_target_value(actionable: ?*GtkActionable) ?*GVariant;
pub extern fn gtk_actionable_set_action_target_value(actionable: ?*GtkActionable, target_value: ?*GVariant) void;
pub extern fn gtk_actionable_set_action_target(actionable: ?*GtkActionable, format_string: [*c]const gchar, ...) void;
pub extern fn gtk_actionable_set_detailed_action_name(actionable: ?*GtkActionable, detailed_action_name: [*c]const gchar) void;
pub const struct__GtkActionBar = extern struct {
    bin: GtkBin,
};
pub const GtkActionBar = struct__GtkActionBar;
pub const struct__GtkActionBarPrivate = @OpaqueType();
pub const GtkActionBarPrivate = struct__GtkActionBarPrivate;
pub const struct__GtkActionBarClass = extern struct {
    parent_class: GtkBinClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkActionBarClass = struct__GtkActionBarClass;
pub extern fn gtk_action_bar_get_type() GType;
pub extern fn gtk_action_bar_new() [*c]GtkWidget;
pub extern fn gtk_action_bar_get_center_widget(action_bar: [*c]GtkActionBar) [*c]GtkWidget;
pub extern fn gtk_action_bar_set_center_widget(action_bar: [*c]GtkActionBar, center_widget: [*c]GtkWidget) void;
pub extern fn gtk_action_bar_pack_start(action_bar: [*c]GtkActionBar, child: [*c]GtkWidget) void;
pub extern fn gtk_action_bar_pack_end(action_bar: [*c]GtkActionBar, child: [*c]GtkWidget) void;
pub const struct__GtkAdjustmentClass = extern struct {
    parent_class: GInitiallyUnownedClass,
    changed: ?extern fn ([*c]GtkAdjustment) void,
    value_changed: ?extern fn ([*c]GtkAdjustment) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkAdjustmentClass = struct__GtkAdjustmentClass;
pub extern fn gtk_adjustment_get_type() GType;
pub extern fn gtk_adjustment_new(value: gdouble, lower: gdouble, upper: gdouble, step_increment: gdouble, page_increment: gdouble, page_size: gdouble) [*c]GtkAdjustment;
pub extern fn gtk_adjustment_changed(adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_adjustment_value_changed(adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_adjustment_clamp_page(adjustment: [*c]GtkAdjustment, lower: gdouble, upper: gdouble) void;
pub extern fn gtk_adjustment_get_value(adjustment: [*c]GtkAdjustment) gdouble;
pub extern fn gtk_adjustment_set_value(adjustment: [*c]GtkAdjustment, value: gdouble) void;
pub extern fn gtk_adjustment_get_lower(adjustment: [*c]GtkAdjustment) gdouble;
pub extern fn gtk_adjustment_set_lower(adjustment: [*c]GtkAdjustment, lower: gdouble) void;
pub extern fn gtk_adjustment_get_upper(adjustment: [*c]GtkAdjustment) gdouble;
pub extern fn gtk_adjustment_set_upper(adjustment: [*c]GtkAdjustment, upper: gdouble) void;
pub extern fn gtk_adjustment_get_step_increment(adjustment: [*c]GtkAdjustment) gdouble;
pub extern fn gtk_adjustment_set_step_increment(adjustment: [*c]GtkAdjustment, step_increment: gdouble) void;
pub extern fn gtk_adjustment_get_page_increment(adjustment: [*c]GtkAdjustment) gdouble;
pub extern fn gtk_adjustment_set_page_increment(adjustment: [*c]GtkAdjustment, page_increment: gdouble) void;
pub extern fn gtk_adjustment_get_page_size(adjustment: [*c]GtkAdjustment) gdouble;
pub extern fn gtk_adjustment_set_page_size(adjustment: [*c]GtkAdjustment, page_size: gdouble) void;
pub extern fn gtk_adjustment_configure(adjustment: [*c]GtkAdjustment, value: gdouble, lower: gdouble, upper: gdouble, step_increment: gdouble, page_increment: gdouble, page_size: gdouble) void;
pub extern fn gtk_adjustment_get_minimum_increment(adjustment: [*c]GtkAdjustment) gdouble;
pub const struct__GtkAppChooser = @OpaqueType();
pub const GtkAppChooser = struct__GtkAppChooser;
pub extern fn gtk_app_chooser_get_type() GType;
pub extern fn gtk_app_chooser_get_app_info(self: ?*GtkAppChooser) ?*GAppInfo;
pub extern fn gtk_app_chooser_get_content_type(self: ?*GtkAppChooser) [*c]gchar;
pub extern fn gtk_app_chooser_refresh(self: ?*GtkAppChooser) void;
pub const struct__GtkAppChooserDialogPrivate = @OpaqueType();
pub const GtkAppChooserDialogPrivate = struct__GtkAppChooserDialogPrivate;
pub const struct__GtkAppChooserDialog = extern struct {
    parent: GtkDialog,
    priv: ?*GtkAppChooserDialogPrivate,
};
pub const GtkAppChooserDialog = struct__GtkAppChooserDialog;
pub const struct__GtkAppChooserDialogClass = extern struct {
    parent_class: GtkDialogClass,
    padding: [16]gpointer,
};
pub const GtkAppChooserDialogClass = struct__GtkAppChooserDialogClass;
pub extern fn gtk_app_chooser_dialog_get_type() GType;
pub extern fn gtk_app_chooser_dialog_new(parent: [*c]GtkWindow, flags: GtkDialogFlags, file: ?*GFile) [*c]GtkWidget;
pub extern fn gtk_app_chooser_dialog_new_for_content_type(parent: [*c]GtkWindow, flags: GtkDialogFlags, content_type: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_app_chooser_dialog_get_widget(self: [*c]GtkAppChooserDialog) [*c]GtkWidget;
pub extern fn gtk_app_chooser_dialog_set_heading(self: [*c]GtkAppChooserDialog, heading: [*c]const gchar) void;
pub extern fn gtk_app_chooser_dialog_get_heading(self: [*c]GtkAppChooserDialog) [*c]const gchar;
pub const struct__GtkBoxPrivate = @OpaqueType();
pub const GtkBoxPrivate = struct__GtkBoxPrivate;
pub const struct__GtkBox = extern struct {
    container: GtkContainer,
    priv: ?*GtkBoxPrivate,
};
pub const GtkBox = struct__GtkBox;
pub const struct__GtkBoxClass = extern struct {
    parent_class: GtkContainerClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkBoxClass = struct__GtkBoxClass;
pub extern fn gtk_box_get_type() GType;
pub extern fn gtk_box_new(orientation: GtkOrientation, spacing: gint) [*c]GtkWidget;
pub extern fn gtk_box_pack_start(box: [*c]GtkBox, child: [*c]GtkWidget, expand: gboolean, fill: gboolean, padding: guint) void;
pub extern fn gtk_box_pack_end(box: [*c]GtkBox, child: [*c]GtkWidget, expand: gboolean, fill: gboolean, padding: guint) void;
pub extern fn gtk_box_set_homogeneous(box: [*c]GtkBox, homogeneous: gboolean) void;
pub extern fn gtk_box_get_homogeneous(box: [*c]GtkBox) gboolean;
pub extern fn gtk_box_set_spacing(box: [*c]GtkBox, spacing: gint) void;
pub extern fn gtk_box_get_spacing(box: [*c]GtkBox) gint;
pub extern fn gtk_box_set_baseline_position(box: [*c]GtkBox, position: GtkBaselinePosition) void;
pub extern fn gtk_box_get_baseline_position(box: [*c]GtkBox) GtkBaselinePosition;
pub extern fn gtk_box_reorder_child(box: [*c]GtkBox, child: [*c]GtkWidget, position: gint) void;
pub extern fn gtk_box_query_child_packing(box: [*c]GtkBox, child: [*c]GtkWidget, expand: [*c]gboolean, fill: [*c]gboolean, padding: [*c]guint, pack_type: [*c]GtkPackType) void;
pub extern fn gtk_box_set_child_packing(box: [*c]GtkBox, child: [*c]GtkWidget, expand: gboolean, fill: gboolean, padding: guint, pack_type: GtkPackType) void;
pub extern fn gtk_box_set_center_widget(box: [*c]GtkBox, widget: [*c]GtkWidget) void;
pub extern fn gtk_box_get_center_widget(box: [*c]GtkBox) [*c]GtkWidget;
pub const struct__GtkAppChooserWidgetPrivate = @OpaqueType();
pub const GtkAppChooserWidgetPrivate = struct__GtkAppChooserWidgetPrivate;
pub const struct__GtkAppChooserWidget = extern struct {
    parent: GtkBox,
    priv: ?*GtkAppChooserWidgetPrivate,
};
pub const GtkAppChooserWidget = struct__GtkAppChooserWidget;
pub const struct__GtkAppChooserWidgetClass = extern struct {
    parent_class: GtkBoxClass,
    application_selected: ?extern fn ([*c]GtkAppChooserWidget, ?*GAppInfo) void,
    application_activated: ?extern fn ([*c]GtkAppChooserWidget, ?*GAppInfo) void,
    populate_popup: ?extern fn ([*c]GtkAppChooserWidget, [*c]GtkMenu, ?*GAppInfo) void,
    padding: [16]gpointer,
};
pub const GtkAppChooserWidgetClass = struct__GtkAppChooserWidgetClass;
pub extern fn gtk_app_chooser_widget_get_type() GType;
pub extern fn gtk_app_chooser_widget_new(content_type: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_app_chooser_widget_set_show_default(self: [*c]GtkAppChooserWidget, setting: gboolean) void;
pub extern fn gtk_app_chooser_widget_get_show_default(self: [*c]GtkAppChooserWidget) gboolean;
pub extern fn gtk_app_chooser_widget_set_show_recommended(self: [*c]GtkAppChooserWidget, setting: gboolean) void;
pub extern fn gtk_app_chooser_widget_get_show_recommended(self: [*c]GtkAppChooserWidget) gboolean;
pub extern fn gtk_app_chooser_widget_set_show_fallback(self: [*c]GtkAppChooserWidget, setting: gboolean) void;
pub extern fn gtk_app_chooser_widget_get_show_fallback(self: [*c]GtkAppChooserWidget) gboolean;
pub extern fn gtk_app_chooser_widget_set_show_other(self: [*c]GtkAppChooserWidget, setting: gboolean) void;
pub extern fn gtk_app_chooser_widget_get_show_other(self: [*c]GtkAppChooserWidget) gboolean;
pub extern fn gtk_app_chooser_widget_set_show_all(self: [*c]GtkAppChooserWidget, setting: gboolean) void;
pub extern fn gtk_app_chooser_widget_get_show_all(self: [*c]GtkAppChooserWidget) gboolean;
pub extern fn gtk_app_chooser_widget_set_default_text(self: [*c]GtkAppChooserWidget, text: [*c]const gchar) void;
pub extern fn gtk_app_chooser_widget_get_default_text(self: [*c]GtkAppChooserWidget) [*c]const gchar;
pub const struct__GtkTreeIter = extern struct {
    stamp: gint,
    user_data: gpointer,
    user_data2: gpointer,
    user_data3: gpointer,
};
pub const GtkTreeIter = struct__GtkTreeIter;
pub const struct__GtkTreePath = @OpaqueType();
pub const GtkTreePath = struct__GtkTreePath;
pub const struct__GtkTreeRowReference = @OpaqueType();
pub const GtkTreeRowReference = struct__GtkTreeRowReference;
pub const struct__GtkTreeModel = @OpaqueType();
pub const GtkTreeModel = struct__GtkTreeModel;
pub const GTK_TREE_MODEL_ITERS_PERSIST = 1;
pub const GTK_TREE_MODEL_LIST_ONLY = 2;
pub const GtkTreeModelFlags = extern enum {
    GTK_TREE_MODEL_ITERS_PERSIST = 1,
    GTK_TREE_MODEL_LIST_ONLY = 2,
};
pub const struct__GtkTreeModelIface = extern struct {
    g_iface: GTypeInterface,
    row_changed: ?extern fn (?*GtkTreeModel, ?*GtkTreePath, [*c]GtkTreeIter) void,
    row_inserted: ?extern fn (?*GtkTreeModel, ?*GtkTreePath, [*c]GtkTreeIter) void,
    row_has_child_toggled: ?extern fn (?*GtkTreeModel, ?*GtkTreePath, [*c]GtkTreeIter) void,
    row_deleted: ?extern fn (?*GtkTreeModel, ?*GtkTreePath) void,
    rows_reordered: ?extern fn (?*GtkTreeModel, ?*GtkTreePath, [*c]GtkTreeIter, [*c]gint) void,
    get_flags: ?extern fn (?*GtkTreeModel) GtkTreeModelFlags,
    get_n_columns: ?extern fn (?*GtkTreeModel) gint,
    get_column_type: ?extern fn (?*GtkTreeModel, gint) GType,
    get_iter: ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter, ?*GtkTreePath) gboolean,
    get_path: ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter) ?*GtkTreePath,
    get_value: ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter, gint, [*c]GValue) void,
    iter_next: ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter) gboolean,
    iter_previous: ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter) gboolean,
    iter_children: ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter, [*c]GtkTreeIter) gboolean,
    iter_has_child: ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter) gboolean,
    iter_n_children: ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter) gint,
    iter_nth_child: ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter, [*c]GtkTreeIter, gint) gboolean,
    iter_parent: ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter, [*c]GtkTreeIter) gboolean,
    ref_node: ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter) void,
    unref_node: ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter) void,
};
pub const GtkTreeModelIface = struct__GtkTreeModelIface;
pub const GtkTreeModelForeachFunc = ?extern fn (?*GtkTreeModel, ?*GtkTreePath, [*c]GtkTreeIter, gpointer) gboolean;
pub extern fn gtk_tree_path_new() ?*GtkTreePath;
pub extern fn gtk_tree_path_new_from_string(path: [*c]const gchar) ?*GtkTreePath;
pub extern fn gtk_tree_path_new_from_indices(first_index: gint, ...) ?*GtkTreePath;
pub extern fn gtk_tree_path_new_from_indicesv(indices: [*c]gint, length: gsize) ?*GtkTreePath;
pub extern fn gtk_tree_path_to_string(path: ?*GtkTreePath) [*c]gchar;
pub extern fn gtk_tree_path_new_first() ?*GtkTreePath;
pub extern fn gtk_tree_path_append_index(path: ?*GtkTreePath, index_: gint) void;
pub extern fn gtk_tree_path_prepend_index(path: ?*GtkTreePath, index_: gint) void;
pub extern fn gtk_tree_path_get_depth(path: ?*GtkTreePath) gint;
pub extern fn gtk_tree_path_get_indices(path: ?*GtkTreePath) [*c]gint;
pub extern fn gtk_tree_path_get_indices_with_depth(path: ?*GtkTreePath, depth: [*c]gint) [*c]gint;
pub extern fn gtk_tree_path_free(path: ?*GtkTreePath) void;
pub extern fn gtk_tree_path_copy(path: ?*const GtkTreePath) ?*GtkTreePath;
pub extern fn gtk_tree_path_get_type() GType;
pub extern fn gtk_tree_path_compare(a: ?*const GtkTreePath, b: ?*const GtkTreePath) gint;
pub extern fn gtk_tree_path_next(path: ?*GtkTreePath) void;
pub extern fn gtk_tree_path_prev(path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_path_up(path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_path_down(path: ?*GtkTreePath) void;
pub extern fn gtk_tree_path_is_ancestor(path: ?*GtkTreePath, descendant: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_path_is_descendant(path: ?*GtkTreePath, ancestor: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_row_reference_get_type() GType;
pub extern fn gtk_tree_row_reference_new(model: ?*GtkTreeModel, path: ?*GtkTreePath) ?*GtkTreeRowReference;
pub extern fn gtk_tree_row_reference_new_proxy(proxy: [*c]GObject, model: ?*GtkTreeModel, path: ?*GtkTreePath) ?*GtkTreeRowReference;
pub extern fn gtk_tree_row_reference_get_path(reference: ?*GtkTreeRowReference) ?*GtkTreePath;
pub extern fn gtk_tree_row_reference_get_model(reference: ?*GtkTreeRowReference) ?*GtkTreeModel;
pub extern fn gtk_tree_row_reference_valid(reference: ?*GtkTreeRowReference) gboolean;
pub extern fn gtk_tree_row_reference_copy(reference: ?*GtkTreeRowReference) ?*GtkTreeRowReference;
pub extern fn gtk_tree_row_reference_free(reference: ?*GtkTreeRowReference) void;
pub extern fn gtk_tree_row_reference_inserted(proxy: [*c]GObject, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_row_reference_deleted(proxy: [*c]GObject, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_row_reference_reordered(proxy: [*c]GObject, path: ?*GtkTreePath, iter: [*c]GtkTreeIter, new_order: [*c]gint) void;
pub extern fn gtk_tree_iter_copy(iter: [*c]GtkTreeIter) [*c]GtkTreeIter;
pub extern fn gtk_tree_iter_free(iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_iter_get_type() GType;
pub extern fn gtk_tree_model_get_type() GType;
pub extern fn gtk_tree_model_get_flags(tree_model: ?*GtkTreeModel) GtkTreeModelFlags;
pub extern fn gtk_tree_model_get_n_columns(tree_model: ?*GtkTreeModel) gint;
pub extern fn gtk_tree_model_get_column_type(tree_model: ?*GtkTreeModel, index_: gint) GType;
pub extern fn gtk_tree_model_get_iter(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_model_get_iter_from_string(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, path_string: [*c]const gchar) gboolean;
pub extern fn gtk_tree_model_get_string_from_iter(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) [*c]gchar;
pub extern fn gtk_tree_model_get_iter_first(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_get_path(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) ?*GtkTreePath;
pub extern fn gtk_tree_model_get_value(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, column: gint, value: [*c]GValue) void;
pub extern fn gtk_tree_model_iter_previous(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_iter_next(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_iter_children(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_iter_has_child(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_iter_n_children(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) gint;
pub extern fn gtk_tree_model_iter_nth_child(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter, n: gint) gboolean;
pub extern fn gtk_tree_model_iter_parent(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, child: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_ref_node(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_unref_node(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_get(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, ...) void;
pub extern fn gtk_tree_model_get_valist(tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, var_args: va_list) void;
pub extern fn gtk_tree_model_foreach(model: ?*GtkTreeModel, func: GtkTreeModelForeachFunc, user_data: gpointer) void;
pub extern fn gtk_tree_model_row_changed(tree_model: ?*GtkTreeModel, path: ?*GtkTreePath, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_row_inserted(tree_model: ?*GtkTreeModel, path: ?*GtkTreePath, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_row_has_child_toggled(tree_model: ?*GtkTreeModel, path: ?*GtkTreePath, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_row_deleted(tree_model: ?*GtkTreeModel, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_model_rows_reordered(tree_model: ?*GtkTreeModel, path: ?*GtkTreePath, iter: [*c]GtkTreeIter, new_order: [*c]gint) void;
pub extern fn gtk_tree_model_rows_reordered_with_length(tree_model: ?*GtkTreeModel, path: ?*GtkTreePath, iter: [*c]GtkTreeIter, new_order: [*c]gint, length: gint) void;
pub const struct__GtkCellEditable = @OpaqueType();
pub const GtkCellEditable = struct__GtkCellEditable;
pub const struct__GtkCellEditableIface = extern struct {
    g_iface: GTypeInterface,
    editing_done: ?extern fn (?*GtkCellEditable) void,
    remove_widget: ?extern fn (?*GtkCellEditable) void,
    start_editing: ?extern fn (?*GtkCellEditable, [*c]GdkEvent) void,
};
pub const GtkCellEditableIface = struct__GtkCellEditableIface;
pub extern fn gtk_cell_editable_get_type() GType;
pub extern fn gtk_cell_editable_start_editing(cell_editable: ?*GtkCellEditable, event: [*c]GdkEvent) void;
pub extern fn gtk_cell_editable_editing_done(cell_editable: ?*GtkCellEditable) void;
pub extern fn gtk_cell_editable_remove_widget(cell_editable: ?*GtkCellEditable) void;
pub const GTK_CELL_RENDERER_SELECTED = 1;
pub const GTK_CELL_RENDERER_PRELIT = 2;
pub const GTK_CELL_RENDERER_INSENSITIVE = 4;
pub const GTK_CELL_RENDERER_SORTED = 8;
pub const GTK_CELL_RENDERER_FOCUSED = 16;
pub const GTK_CELL_RENDERER_EXPANDABLE = 32;
pub const GTK_CELL_RENDERER_EXPANDED = 64;
pub const GtkCellRendererState = extern enum {
    GTK_CELL_RENDERER_SELECTED = 1,
    GTK_CELL_RENDERER_PRELIT = 2,
    GTK_CELL_RENDERER_INSENSITIVE = 4,
    GTK_CELL_RENDERER_SORTED = 8,
    GTK_CELL_RENDERER_FOCUSED = 16,
    GTK_CELL_RENDERER_EXPANDABLE = 32,
    GTK_CELL_RENDERER_EXPANDED = 64,
};
pub const GTK_CELL_RENDERER_MODE_INERT = 0;
pub const GTK_CELL_RENDERER_MODE_ACTIVATABLE = 1;
pub const GTK_CELL_RENDERER_MODE_EDITABLE = 2;
pub const GtkCellRendererMode = extern enum {
    GTK_CELL_RENDERER_MODE_INERT = 0,
    GTK_CELL_RENDERER_MODE_ACTIVATABLE = 1,
    GTK_CELL_RENDERER_MODE_EDITABLE = 2,
};
pub const struct__GtkCellRendererPrivate = @OpaqueType();
pub const GtkCellRendererPrivate = struct__GtkCellRendererPrivate;
pub const struct__GtkCellRenderer = extern struct {
    parent_instance: GInitiallyUnowned,
    priv: ?*GtkCellRendererPrivate,
};
pub const GtkCellRenderer = struct__GtkCellRenderer;
pub const struct__GtkCellRendererClassPrivate = @OpaqueType();
pub const GtkCellRendererClassPrivate = struct__GtkCellRendererClassPrivate;
pub const struct__GtkCellRendererClass = extern struct {
    parent_class: GInitiallyUnownedClass,
    get_request_mode: ?extern fn ([*c]GtkCellRenderer) GtkSizeRequestMode,
    get_preferred_width: ?extern fn ([*c]GtkCellRenderer, [*c]GtkWidget, [*c]gint, [*c]gint) void,
    get_preferred_height_for_width: ?extern fn ([*c]GtkCellRenderer, [*c]GtkWidget, gint, [*c]gint, [*c]gint) void,
    get_preferred_height: ?extern fn ([*c]GtkCellRenderer, [*c]GtkWidget, [*c]gint, [*c]gint) void,
    get_preferred_width_for_height: ?extern fn ([*c]GtkCellRenderer, [*c]GtkWidget, gint, [*c]gint, [*c]gint) void,
    get_aligned_area: ?extern fn ([*c]GtkCellRenderer, [*c]GtkWidget, GtkCellRendererState, [*c]const GdkRectangle, [*c]GdkRectangle) void,
    get_size: ?extern fn ([*c]GtkCellRenderer, [*c]GtkWidget, [*c]const GdkRectangle, [*c]gint, [*c]gint, [*c]gint, [*c]gint) void,
    render: ?extern fn ([*c]GtkCellRenderer, ?*cairo_t, [*c]GtkWidget, [*c]const GdkRectangle, [*c]const GdkRectangle, GtkCellRendererState) void,
    activate: ?extern fn ([*c]GtkCellRenderer, [*c]GdkEvent, [*c]GtkWidget, [*c]const gchar, [*c]const GdkRectangle, [*c]const GdkRectangle, GtkCellRendererState) gboolean,
    start_editing: ?extern fn ([*c]GtkCellRenderer, [*c]GdkEvent, [*c]GtkWidget, [*c]const gchar, [*c]const GdkRectangle, [*c]const GdkRectangle, GtkCellRendererState) ?*GtkCellEditable,
    editing_canceled: ?extern fn ([*c]GtkCellRenderer) void,
    editing_started: ?extern fn ([*c]GtkCellRenderer, ?*GtkCellEditable, [*c]const gchar) void,
    priv: ?*GtkCellRendererClassPrivate,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCellRendererClass = struct__GtkCellRendererClass;
pub extern fn gtk_cell_renderer_get_type() GType;
pub extern fn gtk_cell_renderer_get_request_mode(cell: [*c]GtkCellRenderer) GtkSizeRequestMode;
pub extern fn gtk_cell_renderer_get_preferred_width(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, minimum_size: [*c]gint, natural_size: [*c]gint) void;
pub extern fn gtk_cell_renderer_get_preferred_height_for_width(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, width: gint, minimum_height: [*c]gint, natural_height: [*c]gint) void;
pub extern fn gtk_cell_renderer_get_preferred_height(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, minimum_size: [*c]gint, natural_size: [*c]gint) void;
pub extern fn gtk_cell_renderer_get_preferred_width_for_height(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, height: gint, minimum_width: [*c]gint, natural_width: [*c]gint) void;
pub extern fn gtk_cell_renderer_get_preferred_size(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, minimum_size: [*c]GtkRequisition, natural_size: [*c]GtkRequisition) void;
pub extern fn gtk_cell_renderer_get_aligned_area(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, flags: GtkCellRendererState, cell_area: [*c]const GdkRectangle, aligned_area: [*c]GdkRectangle) void;
pub extern fn gtk_cell_renderer_get_size(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, cell_area: [*c]const GdkRectangle, x_offset: [*c]gint, y_offset: [*c]gint, width: [*c]gint, height: [*c]gint) void;
pub extern fn gtk_cell_renderer_render(cell: [*c]GtkCellRenderer, cr: ?*cairo_t, widget: [*c]GtkWidget, background_area: [*c]const GdkRectangle, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState) void;
pub extern fn gtk_cell_renderer_activate(cell: [*c]GtkCellRenderer, event: [*c]GdkEvent, widget: [*c]GtkWidget, path: [*c]const gchar, background_area: [*c]const GdkRectangle, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState) gboolean;
pub extern fn gtk_cell_renderer_start_editing(cell: [*c]GtkCellRenderer, event: [*c]GdkEvent, widget: [*c]GtkWidget, path: [*c]const gchar, background_area: [*c]const GdkRectangle, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState) ?*GtkCellEditable;
pub extern fn gtk_cell_renderer_set_fixed_size(cell: [*c]GtkCellRenderer, width: gint, height: gint) void;
pub extern fn gtk_cell_renderer_get_fixed_size(cell: [*c]GtkCellRenderer, width: [*c]gint, height: [*c]gint) void;
pub extern fn gtk_cell_renderer_set_alignment(cell: [*c]GtkCellRenderer, xalign: gfloat, yalign: gfloat) void;
pub extern fn gtk_cell_renderer_get_alignment(cell: [*c]GtkCellRenderer, xalign: [*c]gfloat, yalign: [*c]gfloat) void;
pub extern fn gtk_cell_renderer_set_padding(cell: [*c]GtkCellRenderer, xpad: gint, ypad: gint) void;
pub extern fn gtk_cell_renderer_get_padding(cell: [*c]GtkCellRenderer, xpad: [*c]gint, ypad: [*c]gint) void;
pub extern fn gtk_cell_renderer_set_visible(cell: [*c]GtkCellRenderer, visible: gboolean) void;
pub extern fn gtk_cell_renderer_get_visible(cell: [*c]GtkCellRenderer) gboolean;
pub extern fn gtk_cell_renderer_set_sensitive(cell: [*c]GtkCellRenderer, sensitive: gboolean) void;
pub extern fn gtk_cell_renderer_get_sensitive(cell: [*c]GtkCellRenderer) gboolean;
pub extern fn gtk_cell_renderer_is_activatable(cell: [*c]GtkCellRenderer) gboolean;
pub extern fn gtk_cell_renderer_stop_editing(cell: [*c]GtkCellRenderer, canceled: gboolean) void;
pub extern fn _gtk_cell_renderer_calc_offset(cell: [*c]GtkCellRenderer, cell_area: [*c]const GdkRectangle, direction: GtkTextDirection, width: gint, height: gint, x_offset: [*c]gint, y_offset: [*c]gint) void;
pub extern fn gtk_cell_renderer_get_state(cell: [*c]GtkCellRenderer, widget: [*c]GtkWidget, cell_state: GtkCellRendererState) GtkStateFlags;
pub extern fn gtk_cell_renderer_class_set_accessible_type(renderer_class: [*c]GtkCellRendererClass, type_0: GType) void;
pub extern fn _gtk_cell_renderer_get_accessible_type(renderer: [*c]GtkCellRenderer) GType;
pub const struct__GtkTreeSortable = @OpaqueType();
pub const GtkTreeSortable = struct__GtkTreeSortable;
pub const GtkTreeIterCompareFunc = ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter, [*c]GtkTreeIter, gpointer) gint;
pub const struct__GtkTreeSortableIface = extern struct {
    g_iface: GTypeInterface,
    sort_column_changed: ?extern fn (?*GtkTreeSortable) void,
    get_sort_column_id: ?extern fn (?*GtkTreeSortable, [*c]gint, [*c]GtkSortType) gboolean,
    set_sort_column_id: ?extern fn (?*GtkTreeSortable, gint, GtkSortType) void,
    set_sort_func: ?extern fn (?*GtkTreeSortable, gint, GtkTreeIterCompareFunc, gpointer, GDestroyNotify) void,
    set_default_sort_func: ?extern fn (?*GtkTreeSortable, GtkTreeIterCompareFunc, gpointer, GDestroyNotify) void,
    has_default_sort_func: ?extern fn (?*GtkTreeSortable) gboolean,
};
pub const GtkTreeSortableIface = struct__GtkTreeSortableIface;
pub extern fn gtk_tree_sortable_get_type() GType;
pub extern fn gtk_tree_sortable_sort_column_changed(sortable: ?*GtkTreeSortable) void;
pub extern fn gtk_tree_sortable_get_sort_column_id(sortable: ?*GtkTreeSortable, sort_column_id: [*c]gint, order: [*c]GtkSortType) gboolean;
pub extern fn gtk_tree_sortable_set_sort_column_id(sortable: ?*GtkTreeSortable, sort_column_id: gint, order: GtkSortType) void;
pub extern fn gtk_tree_sortable_set_sort_func(sortable: ?*GtkTreeSortable, sort_column_id: gint, sort_func: GtkTreeIterCompareFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_sortable_set_default_sort_func(sortable: ?*GtkTreeSortable, sort_func: GtkTreeIterCompareFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_sortable_has_default_sort_func(sortable: ?*GtkTreeSortable) gboolean;
pub const struct__GtkCellAreaPrivate = @OpaqueType();
pub const GtkCellAreaPrivate = struct__GtkCellAreaPrivate;
pub const struct__GtkCellArea = extern struct {
    parent_instance: GInitiallyUnowned,
    priv: ?*GtkCellAreaPrivate,
};
pub const GtkCellArea = struct__GtkCellArea;
pub const GtkCellCallback = ?extern fn ([*c]GtkCellRenderer, gpointer) gboolean;
pub const struct__GtkCellAreaContextPrivate = @OpaqueType();
pub const GtkCellAreaContextPrivate = struct__GtkCellAreaContextPrivate;
pub const struct__GtkCellAreaContext = extern struct {
    parent_instance: GObject,
    priv: ?*GtkCellAreaContextPrivate,
};
pub const GtkCellAreaContext = struct__GtkCellAreaContext;
pub const GtkCellAllocCallback = ?extern fn ([*c]GtkCellRenderer, [*c]const GdkRectangle, [*c]const GdkRectangle, gpointer) gboolean;
pub const struct__GtkCellAreaClass = extern struct {
    parent_class: GInitiallyUnownedClass,
    add: ?extern fn ([*c]GtkCellArea, [*c]GtkCellRenderer) void,
    remove: ?extern fn ([*c]GtkCellArea, [*c]GtkCellRenderer) void,
    foreach: ?extern fn ([*c]GtkCellArea, GtkCellCallback, gpointer) void,
    foreach_alloc: ?extern fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, [*c]const GdkRectangle, [*c]const GdkRectangle, GtkCellAllocCallback, gpointer) void,
    event: ?extern fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, [*c]GdkEvent, [*c]const GdkRectangle, GtkCellRendererState) gint,
    render: ?extern fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, ?*cairo_t, [*c]const GdkRectangle, [*c]const GdkRectangle, GtkCellRendererState, gboolean) void,
    apply_attributes: ?extern fn ([*c]GtkCellArea, ?*GtkTreeModel, [*c]GtkTreeIter, gboolean, gboolean) void,
    create_context: ?extern fn ([*c]GtkCellArea) [*c]GtkCellAreaContext,
    copy_context: ?extern fn ([*c]GtkCellArea, [*c]GtkCellAreaContext) [*c]GtkCellAreaContext,
    get_request_mode: ?extern fn ([*c]GtkCellArea) GtkSizeRequestMode,
    get_preferred_width: ?extern fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, [*c]gint, [*c]gint) void,
    get_preferred_height_for_width: ?extern fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, gint, [*c]gint, [*c]gint) void,
    get_preferred_height: ?extern fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, [*c]gint, [*c]gint) void,
    get_preferred_width_for_height: ?extern fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, gint, [*c]gint, [*c]gint) void,
    set_cell_property: ?extern fn ([*c]GtkCellArea, [*c]GtkCellRenderer, guint, [*c]const GValue, [*c]GParamSpec) void,
    get_cell_property: ?extern fn ([*c]GtkCellArea, [*c]GtkCellRenderer, guint, [*c]GValue, [*c]GParamSpec) void,
    focus: ?extern fn ([*c]GtkCellArea, GtkDirectionType) gboolean,
    is_activatable: ?extern fn ([*c]GtkCellArea) gboolean,
    activate: ?extern fn ([*c]GtkCellArea, [*c]GtkCellAreaContext, [*c]GtkWidget, [*c]const GdkRectangle, GtkCellRendererState, gboolean) gboolean,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
    _gtk_reserved8: ?extern fn () void,
};
pub const GtkCellAreaClass = struct__GtkCellAreaClass;
pub extern fn gtk_cell_area_get_type() GType;
pub extern fn gtk_cell_area_add(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer) void;
pub extern fn gtk_cell_area_remove(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer) void;
pub extern fn gtk_cell_area_has_renderer(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer) gboolean;
pub extern fn gtk_cell_area_foreach(area: [*c]GtkCellArea, callback: GtkCellCallback, callback_data: gpointer) void;
pub extern fn gtk_cell_area_foreach_alloc(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, cell_area: [*c]const GdkRectangle, background_area: [*c]const GdkRectangle, callback: GtkCellAllocCallback, callback_data: gpointer) void;
pub extern fn gtk_cell_area_event(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, event: [*c]GdkEvent, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState) gint;
pub extern fn gtk_cell_area_render(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, cr: ?*cairo_t, background_area: [*c]const GdkRectangle, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState, paint_focus: gboolean) void;
pub extern fn gtk_cell_area_get_cell_allocation(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, renderer: [*c]GtkCellRenderer, cell_area: [*c]const GdkRectangle, allocation: [*c]GdkRectangle) void;
pub extern fn gtk_cell_area_get_cell_at_position(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, cell_area: [*c]const GdkRectangle, x: gint, y: gint, alloc_area: [*c]GdkRectangle) [*c]GtkCellRenderer;
pub extern fn gtk_cell_area_create_context(area: [*c]GtkCellArea) [*c]GtkCellAreaContext;
pub extern fn gtk_cell_area_copy_context(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext) [*c]GtkCellAreaContext;
pub extern fn gtk_cell_area_get_request_mode(area: [*c]GtkCellArea) GtkSizeRequestMode;
pub extern fn gtk_cell_area_get_preferred_width(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, minimum_width: [*c]gint, natural_width: [*c]gint) void;
pub extern fn gtk_cell_area_get_preferred_height_for_width(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, width: gint, minimum_height: [*c]gint, natural_height: [*c]gint) void;
pub extern fn gtk_cell_area_get_preferred_height(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, minimum_height: [*c]gint, natural_height: [*c]gint) void;
pub extern fn gtk_cell_area_get_preferred_width_for_height(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, height: gint, minimum_width: [*c]gint, natural_width: [*c]gint) void;
pub extern fn gtk_cell_area_get_current_path_string(area: [*c]GtkCellArea) [*c]const gchar;
pub extern fn gtk_cell_area_apply_attributes(area: [*c]GtkCellArea, tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, is_expander: gboolean, is_expanded: gboolean) void;
pub extern fn gtk_cell_area_attribute_connect(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, attribute: [*c]const gchar, column: gint) void;
pub extern fn gtk_cell_area_attribute_disconnect(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, attribute: [*c]const gchar) void;
pub extern fn gtk_cell_area_attribute_get_column(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, attribute: [*c]const gchar) gint;
pub extern fn gtk_cell_area_class_install_cell_property(aclass: [*c]GtkCellAreaClass, property_id: guint, pspec: [*c]GParamSpec) void;
pub extern fn gtk_cell_area_class_find_cell_property(aclass: [*c]GtkCellAreaClass, property_name: [*c]const gchar) [*c]GParamSpec;
pub extern fn gtk_cell_area_class_list_cell_properties(aclass: [*c]GtkCellAreaClass, n_properties: [*c]guint) [*c]([*c]GParamSpec);
pub extern fn gtk_cell_area_add_with_properties(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, first_prop_name: [*c]const gchar, ...) void;
pub extern fn gtk_cell_area_cell_set(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, first_prop_name: [*c]const gchar, ...) void;
pub extern fn gtk_cell_area_cell_get(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, first_prop_name: [*c]const gchar, ...) void;
pub extern fn gtk_cell_area_cell_set_valist(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, first_property_name: [*c]const gchar, var_args: va_list) void;
pub extern fn gtk_cell_area_cell_get_valist(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, first_property_name: [*c]const gchar, var_args: va_list) void;
pub extern fn gtk_cell_area_cell_set_property(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, property_name: [*c]const gchar, value: [*c]const GValue) void;
pub extern fn gtk_cell_area_cell_get_property(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, property_name: [*c]const gchar, value: [*c]GValue) void;
pub extern fn gtk_cell_area_is_activatable(area: [*c]GtkCellArea) gboolean;
pub extern fn gtk_cell_area_activate(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext, widget: [*c]GtkWidget, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState, edit_only: gboolean) gboolean;
pub extern fn gtk_cell_area_focus(area: [*c]GtkCellArea, direction: GtkDirectionType) gboolean;
pub extern fn gtk_cell_area_set_focus_cell(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer) void;
pub extern fn gtk_cell_area_get_focus_cell(area: [*c]GtkCellArea) [*c]GtkCellRenderer;
pub extern fn gtk_cell_area_add_focus_sibling(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, sibling: [*c]GtkCellRenderer) void;
pub extern fn gtk_cell_area_remove_focus_sibling(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, sibling: [*c]GtkCellRenderer) void;
pub extern fn gtk_cell_area_is_focus_sibling(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, sibling: [*c]GtkCellRenderer) gboolean;
pub extern fn gtk_cell_area_get_focus_siblings(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer) [*c]const GList;
pub extern fn gtk_cell_area_get_focus_from_sibling(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer) [*c]GtkCellRenderer;
pub extern fn gtk_cell_area_get_edited_cell(area: [*c]GtkCellArea) [*c]GtkCellRenderer;
pub extern fn gtk_cell_area_get_edit_widget(area: [*c]GtkCellArea) ?*GtkCellEditable;
pub extern fn gtk_cell_area_activate_cell(area: [*c]GtkCellArea, widget: [*c]GtkWidget, renderer: [*c]GtkCellRenderer, event: [*c]GdkEvent, cell_area: [*c]const GdkRectangle, flags: GtkCellRendererState) gboolean;
pub extern fn gtk_cell_area_stop_editing(area: [*c]GtkCellArea, canceled: gboolean) void;
pub extern fn gtk_cell_area_inner_cell_area(area: [*c]GtkCellArea, widget: [*c]GtkWidget, cell_area: [*c]const GdkRectangle, inner_area: [*c]GdkRectangle) void;
pub extern fn gtk_cell_area_request_renderer(area: [*c]GtkCellArea, renderer: [*c]GtkCellRenderer, orientation: GtkOrientation, widget: [*c]GtkWidget, for_size: gint, minimum_size: [*c]gint, natural_size: [*c]gint) void;
pub extern fn _gtk_cell_area_set_cell_data_func_with_proxy(area: [*c]GtkCellArea, cell: [*c]GtkCellRenderer, func: GFunc, func_data: gpointer, destroy: GDestroyNotify, proxy: gpointer) void;
pub const struct__GtkTreeViewColumnPrivate = @OpaqueType();
pub const GtkTreeViewColumnPrivate = struct__GtkTreeViewColumnPrivate;
pub const struct__GtkTreeViewColumn = extern struct {
    parent_instance: GInitiallyUnowned,
    priv: ?*GtkTreeViewColumnPrivate,
};
pub const GtkTreeViewColumn = struct__GtkTreeViewColumn;
pub const struct__GtkTreeViewColumnClass = extern struct {
    parent_class: GInitiallyUnownedClass,
    clicked: ?extern fn ([*c]GtkTreeViewColumn) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkTreeViewColumnClass = struct__GtkTreeViewColumnClass;
pub const GTK_TREE_VIEW_COLUMN_GROW_ONLY = 0;
pub const GTK_TREE_VIEW_COLUMN_AUTOSIZE = 1;
pub const GTK_TREE_VIEW_COLUMN_FIXED = 2;
pub const GtkTreeViewColumnSizing = extern enum {
    GTK_TREE_VIEW_COLUMN_GROW_ONLY = 0,
    GTK_TREE_VIEW_COLUMN_AUTOSIZE = 1,
    GTK_TREE_VIEW_COLUMN_FIXED = 2,
};
pub const GtkTreeCellDataFunc = ?extern fn ([*c]GtkTreeViewColumn, [*c]GtkCellRenderer, ?*GtkTreeModel, [*c]GtkTreeIter, gpointer) void;
pub extern fn gtk_tree_view_column_get_type() GType;
pub extern fn gtk_tree_view_column_new() [*c]GtkTreeViewColumn;
pub extern fn gtk_tree_view_column_new_with_area(area: [*c]GtkCellArea) [*c]GtkTreeViewColumn;
pub extern fn gtk_tree_view_column_new_with_attributes(title: [*c]const gchar, cell: [*c]GtkCellRenderer, ...) [*c]GtkTreeViewColumn;
pub extern fn gtk_tree_view_column_pack_start(tree_column: [*c]GtkTreeViewColumn, cell: [*c]GtkCellRenderer, expand: gboolean) void;
pub extern fn gtk_tree_view_column_pack_end(tree_column: [*c]GtkTreeViewColumn, cell: [*c]GtkCellRenderer, expand: gboolean) void;
pub extern fn gtk_tree_view_column_clear(tree_column: [*c]GtkTreeViewColumn) void;
pub extern fn gtk_tree_view_column_add_attribute(tree_column: [*c]GtkTreeViewColumn, cell_renderer: [*c]GtkCellRenderer, attribute: [*c]const gchar, column: gint) void;
pub extern fn gtk_tree_view_column_set_attributes(tree_column: [*c]GtkTreeViewColumn, cell_renderer: [*c]GtkCellRenderer, ...) void;
pub extern fn gtk_tree_view_column_set_cell_data_func(tree_column: [*c]GtkTreeViewColumn, cell_renderer: [*c]GtkCellRenderer, func: GtkTreeCellDataFunc, func_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_view_column_clear_attributes(tree_column: [*c]GtkTreeViewColumn, cell_renderer: [*c]GtkCellRenderer) void;
pub extern fn gtk_tree_view_column_set_spacing(tree_column: [*c]GtkTreeViewColumn, spacing: gint) void;
pub extern fn gtk_tree_view_column_get_spacing(tree_column: [*c]GtkTreeViewColumn) gint;
pub extern fn gtk_tree_view_column_set_visible(tree_column: [*c]GtkTreeViewColumn, visible: gboolean) void;
pub extern fn gtk_tree_view_column_get_visible(tree_column: [*c]GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_set_resizable(tree_column: [*c]GtkTreeViewColumn, resizable: gboolean) void;
pub extern fn gtk_tree_view_column_get_resizable(tree_column: [*c]GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_set_sizing(tree_column: [*c]GtkTreeViewColumn, type_0: GtkTreeViewColumnSizing) void;
pub extern fn gtk_tree_view_column_get_sizing(tree_column: [*c]GtkTreeViewColumn) GtkTreeViewColumnSizing;
pub extern fn gtk_tree_view_column_get_x_offset(tree_column: [*c]GtkTreeViewColumn) gint;
pub extern fn gtk_tree_view_column_get_width(tree_column: [*c]GtkTreeViewColumn) gint;
pub extern fn gtk_tree_view_column_get_fixed_width(tree_column: [*c]GtkTreeViewColumn) gint;
pub extern fn gtk_tree_view_column_set_fixed_width(tree_column: [*c]GtkTreeViewColumn, fixed_width: gint) void;
pub extern fn gtk_tree_view_column_set_min_width(tree_column: [*c]GtkTreeViewColumn, min_width: gint) void;
pub extern fn gtk_tree_view_column_get_min_width(tree_column: [*c]GtkTreeViewColumn) gint;
pub extern fn gtk_tree_view_column_set_max_width(tree_column: [*c]GtkTreeViewColumn, max_width: gint) void;
pub extern fn gtk_tree_view_column_get_max_width(tree_column: [*c]GtkTreeViewColumn) gint;
pub extern fn gtk_tree_view_column_clicked(tree_column: [*c]GtkTreeViewColumn) void;
pub extern fn gtk_tree_view_column_set_title(tree_column: [*c]GtkTreeViewColumn, title: [*c]const gchar) void;
pub extern fn gtk_tree_view_column_get_title(tree_column: [*c]GtkTreeViewColumn) [*c]const gchar;
pub extern fn gtk_tree_view_column_set_expand(tree_column: [*c]GtkTreeViewColumn, expand: gboolean) void;
pub extern fn gtk_tree_view_column_get_expand(tree_column: [*c]GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_set_clickable(tree_column: [*c]GtkTreeViewColumn, clickable: gboolean) void;
pub extern fn gtk_tree_view_column_get_clickable(tree_column: [*c]GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_set_widget(tree_column: [*c]GtkTreeViewColumn, widget: [*c]GtkWidget) void;
pub extern fn gtk_tree_view_column_get_widget(tree_column: [*c]GtkTreeViewColumn) [*c]GtkWidget;
pub extern fn gtk_tree_view_column_set_alignment(tree_column: [*c]GtkTreeViewColumn, xalign: gfloat) void;
pub extern fn gtk_tree_view_column_get_alignment(tree_column: [*c]GtkTreeViewColumn) gfloat;
pub extern fn gtk_tree_view_column_set_reorderable(tree_column: [*c]GtkTreeViewColumn, reorderable: gboolean) void;
pub extern fn gtk_tree_view_column_get_reorderable(tree_column: [*c]GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_set_sort_column_id(tree_column: [*c]GtkTreeViewColumn, sort_column_id: gint) void;
pub extern fn gtk_tree_view_column_get_sort_column_id(tree_column: [*c]GtkTreeViewColumn) gint;
pub extern fn gtk_tree_view_column_set_sort_indicator(tree_column: [*c]GtkTreeViewColumn, setting: gboolean) void;
pub extern fn gtk_tree_view_column_get_sort_indicator(tree_column: [*c]GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_set_sort_order(tree_column: [*c]GtkTreeViewColumn, order: GtkSortType) void;
pub extern fn gtk_tree_view_column_get_sort_order(tree_column: [*c]GtkTreeViewColumn) GtkSortType;
pub extern fn gtk_tree_view_column_cell_set_cell_data(tree_column: [*c]GtkTreeViewColumn, tree_model: ?*GtkTreeModel, iter: [*c]GtkTreeIter, is_expander: gboolean, is_expanded: gboolean) void;
pub extern fn gtk_tree_view_column_cell_get_size(tree_column: [*c]GtkTreeViewColumn, cell_area: [*c]const GdkRectangle, x_offset: [*c]gint, y_offset: [*c]gint, width: [*c]gint, height: [*c]gint) void;
pub extern fn gtk_tree_view_column_cell_is_visible(tree_column: [*c]GtkTreeViewColumn) gboolean;
pub extern fn gtk_tree_view_column_focus_cell(tree_column: [*c]GtkTreeViewColumn, cell: [*c]GtkCellRenderer) void;
pub extern fn gtk_tree_view_column_cell_get_position(tree_column: [*c]GtkTreeViewColumn, cell_renderer: [*c]GtkCellRenderer, x_offset: [*c]gint, width: [*c]gint) gboolean;
pub extern fn gtk_tree_view_column_queue_resize(tree_column: [*c]GtkTreeViewColumn) void;
pub extern fn gtk_tree_view_column_get_tree_view(tree_column: [*c]GtkTreeViewColumn) [*c]GtkWidget;
pub extern fn gtk_tree_view_column_get_button(tree_column: [*c]GtkTreeViewColumn) [*c]GtkWidget;
pub const struct__GtkTextAttributes = @OpaqueType();
pub const GtkTextAttributes = struct__GtkTextAttributes;
pub const struct__GtkTextAppearance = @OpaqueType();
pub const GtkTextAppearance = struct__GtkTextAppearance;
pub extern fn gtk_text_attributes_new() ?*GtkTextAttributes;
pub extern fn gtk_text_attributes_copy(src: ?*GtkTextAttributes) ?*GtkTextAttributes;
pub extern fn gtk_text_attributes_copy_values(src: ?*GtkTextAttributes, dest: ?*GtkTextAttributes) void;
pub extern fn gtk_text_attributes_unref(values: ?*GtkTextAttributes) void;
pub extern fn gtk_text_attributes_ref(values: ?*GtkTextAttributes) ?*GtkTextAttributes;
pub extern fn gtk_text_attributes_get_type() GType;
pub const struct__GtkTextChildAnchor = extern struct {
    parent_instance: GObject,
    segment: gpointer,
};
pub const GtkTextChildAnchor = struct__GtkTextChildAnchor;
pub const struct__GtkTextChildAnchorClass = extern struct {
    parent_class: GObjectClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkTextChildAnchorClass = struct__GtkTextChildAnchorClass;
pub extern fn gtk_text_child_anchor_get_type() GType;
pub extern fn gtk_text_child_anchor_new() [*c]GtkTextChildAnchor;
pub extern fn gtk_text_child_anchor_get_widgets(anchor: [*c]GtkTextChildAnchor) [*c]GList;
pub extern fn gtk_text_child_anchor_get_deleted(anchor: [*c]GtkTextChildAnchor) gboolean;
pub const struct__GtkTextIter = extern struct {
    dummy1: gpointer,
    dummy2: gpointer,
    dummy3: gint,
    dummy4: gint,
    dummy5: gint,
    dummy6: gint,
    dummy7: gint,
    dummy8: gint,
    dummy9: gpointer,
    dummy10: gpointer,
    dummy11: gint,
    dummy12: gint,
    dummy13: gint,
    dummy14: gpointer,
};
pub const GtkTextIter = struct__GtkTextIter;
pub const struct__GtkTextTagTablePrivate = @OpaqueType();
pub const GtkTextTagTablePrivate = struct__GtkTextTagTablePrivate;
pub const struct__GtkTextTagTable = extern struct {
    parent_instance: GObject,
    priv: ?*GtkTextTagTablePrivate,
};
pub const GtkTextTagTable = struct__GtkTextTagTable;
pub const struct__GtkTextTagPrivate = @OpaqueType();
pub const GtkTextTagPrivate = struct__GtkTextTagPrivate;
pub const struct__GtkTextTag = extern struct {
    parent_instance: GObject,
    priv: ?*GtkTextTagPrivate,
};
pub const GtkTextTag = struct__GtkTextTag;
pub const struct__GtkTextTagClass = extern struct {
    parent_class: GObjectClass,
    event: ?extern fn ([*c]GtkTextTag, [*c]GObject, [*c]GdkEvent, [*c]const GtkTextIter) gboolean,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkTextTagClass = struct__GtkTextTagClass;
pub extern fn gtk_text_tag_get_type() GType;
pub extern fn gtk_text_tag_new(name: [*c]const gchar) [*c]GtkTextTag;
pub extern fn gtk_text_tag_get_priority(tag: [*c]GtkTextTag) gint;
pub extern fn gtk_text_tag_set_priority(tag: [*c]GtkTextTag, priority: gint) void;
pub extern fn gtk_text_tag_event(tag: [*c]GtkTextTag, event_object: [*c]GObject, event: [*c]GdkEvent, iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_tag_changed(tag: [*c]GtkTextTag, size_changed: gboolean) void;
pub const GTK_TEXT_SEARCH_VISIBLE_ONLY = 1;
pub const GTK_TEXT_SEARCH_TEXT_ONLY = 2;
pub const GTK_TEXT_SEARCH_CASE_INSENSITIVE = 4;
pub const GtkTextSearchFlags = extern enum {
    GTK_TEXT_SEARCH_VISIBLE_ONLY = 1,
    GTK_TEXT_SEARCH_TEXT_ONLY = 2,
    GTK_TEXT_SEARCH_CASE_INSENSITIVE = 4,
};
pub const struct__GtkTextBufferPrivate = @OpaqueType();
pub const GtkTextBufferPrivate = struct__GtkTextBufferPrivate;
pub const struct__GtkTextBuffer = extern struct {
    parent_instance: GObject,
    priv: ?*GtkTextBufferPrivate,
};
pub const GtkTextBuffer = struct__GtkTextBuffer;
pub extern fn gtk_text_iter_get_buffer(iter: [*c]const GtkTextIter) [*c]GtkTextBuffer;
pub extern fn gtk_text_iter_copy(iter: [*c]const GtkTextIter) [*c]GtkTextIter;
pub extern fn gtk_text_iter_free(iter: [*c]GtkTextIter) void;
pub extern fn gtk_text_iter_assign(iter: [*c]GtkTextIter, other: [*c]const GtkTextIter) void;
pub extern fn gtk_text_iter_get_type() GType;
pub extern fn gtk_text_iter_get_offset(iter: [*c]const GtkTextIter) gint;
pub extern fn gtk_text_iter_get_line(iter: [*c]const GtkTextIter) gint;
pub extern fn gtk_text_iter_get_line_offset(iter: [*c]const GtkTextIter) gint;
pub extern fn gtk_text_iter_get_line_index(iter: [*c]const GtkTextIter) gint;
pub extern fn gtk_text_iter_get_visible_line_offset(iter: [*c]const GtkTextIter) gint;
pub extern fn gtk_text_iter_get_visible_line_index(iter: [*c]const GtkTextIter) gint;
pub extern fn gtk_text_iter_get_char(iter: [*c]const GtkTextIter) gunichar;
pub extern fn gtk_text_iter_get_slice(start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) [*c]gchar;
pub extern fn gtk_text_iter_get_text(start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) [*c]gchar;
pub extern fn gtk_text_iter_get_visible_slice(start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) [*c]gchar;
pub extern fn gtk_text_iter_get_visible_text(start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) [*c]gchar;
pub extern fn gtk_text_iter_get_pixbuf(iter: [*c]const GtkTextIter) ?*GdkPixbuf;
pub extern fn gtk_text_iter_get_marks(iter: [*c]const GtkTextIter) [*c]GSList;
pub extern fn gtk_text_iter_get_child_anchor(iter: [*c]const GtkTextIter) [*c]GtkTextChildAnchor;
pub extern fn gtk_text_iter_get_toggled_tags(iter: [*c]const GtkTextIter, toggled_on: gboolean) [*c]GSList;
pub extern fn gtk_text_iter_starts_tag(iter: [*c]const GtkTextIter, tag: [*c]GtkTextTag) gboolean;
pub extern fn gtk_text_iter_begins_tag(iter: [*c]const GtkTextIter, tag: [*c]GtkTextTag) gboolean;
pub extern fn gtk_text_iter_ends_tag(iter: [*c]const GtkTextIter, tag: [*c]GtkTextTag) gboolean;
pub extern fn gtk_text_iter_toggles_tag(iter: [*c]const GtkTextIter, tag: [*c]GtkTextTag) gboolean;
pub extern fn gtk_text_iter_has_tag(iter: [*c]const GtkTextIter, tag: [*c]GtkTextTag) gboolean;
pub extern fn gtk_text_iter_get_tags(iter: [*c]const GtkTextIter) [*c]GSList;
pub extern fn gtk_text_iter_editable(iter: [*c]const GtkTextIter, default_setting: gboolean) gboolean;
pub extern fn gtk_text_iter_can_insert(iter: [*c]const GtkTextIter, default_editability: gboolean) gboolean;
pub extern fn gtk_text_iter_starts_word(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_ends_word(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_inside_word(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_starts_sentence(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_ends_sentence(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_inside_sentence(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_starts_line(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_ends_line(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_is_cursor_position(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_get_chars_in_line(iter: [*c]const GtkTextIter) gint;
pub extern fn gtk_text_iter_get_bytes_in_line(iter: [*c]const GtkTextIter) gint;
pub extern fn gtk_text_iter_get_attributes(iter: [*c]const GtkTextIter, values: ?*GtkTextAttributes) gboolean;
pub extern fn gtk_text_iter_get_language(iter: [*c]const GtkTextIter) ?*PangoLanguage;
pub extern fn gtk_text_iter_is_end(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_is_start(iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_char(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_char(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_chars(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_backward_chars(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_forward_line(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_line(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_lines(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_backward_lines(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_forward_word_end(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_word_start(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_word_ends(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_backward_word_starts(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_forward_visible_line(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_visible_line(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_visible_lines(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_backward_visible_lines(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_forward_visible_word_end(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_visible_word_start(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_visible_word_ends(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_backward_visible_word_starts(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_forward_sentence_end(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_sentence_start(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_sentence_ends(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_backward_sentence_starts(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_forward_cursor_position(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_cursor_position(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_cursor_positions(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_backward_cursor_positions(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_forward_visible_cursor_position(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_visible_cursor_position(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_visible_cursor_positions(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_backward_visible_cursor_positions(iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_iter_set_offset(iter: [*c]GtkTextIter, char_offset: gint) void;
pub extern fn gtk_text_iter_set_line(iter: [*c]GtkTextIter, line_number: gint) void;
pub extern fn gtk_text_iter_set_line_offset(iter: [*c]GtkTextIter, char_on_line: gint) void;
pub extern fn gtk_text_iter_set_line_index(iter: [*c]GtkTextIter, byte_on_line: gint) void;
pub extern fn gtk_text_iter_forward_to_end(iter: [*c]GtkTextIter) void;
pub extern fn gtk_text_iter_forward_to_line_end(iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_iter_set_visible_line_offset(iter: [*c]GtkTextIter, char_on_line: gint) void;
pub extern fn gtk_text_iter_set_visible_line_index(iter: [*c]GtkTextIter, byte_on_line: gint) void;
pub extern fn gtk_text_iter_forward_to_tag_toggle(iter: [*c]GtkTextIter, tag: [*c]GtkTextTag) gboolean;
pub extern fn gtk_text_iter_backward_to_tag_toggle(iter: [*c]GtkTextIter, tag: [*c]GtkTextTag) gboolean;
pub const GtkTextCharPredicate = ?extern fn (gunichar, gpointer) gboolean;
pub extern fn gtk_text_iter_forward_find_char(iter: [*c]GtkTextIter, pred: GtkTextCharPredicate, user_data: gpointer, limit: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_find_char(iter: [*c]GtkTextIter, pred: GtkTextCharPredicate, user_data: gpointer, limit: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_forward_search(iter: [*c]const GtkTextIter, str: [*c]const gchar, flags: GtkTextSearchFlags, match_start: [*c]GtkTextIter, match_end: [*c]GtkTextIter, limit: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_backward_search(iter: [*c]const GtkTextIter, str: [*c]const gchar, flags: GtkTextSearchFlags, match_start: [*c]GtkTextIter, match_end: [*c]GtkTextIter, limit: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_equal(lhs: [*c]const GtkTextIter, rhs: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_compare(lhs: [*c]const GtkTextIter, rhs: [*c]const GtkTextIter) gint;
pub extern fn gtk_text_iter_in_range(iter: [*c]const GtkTextIter, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_iter_order(first: [*c]GtkTextIter, second: [*c]GtkTextIter) void;
pub const struct__GtkTargetPair = extern struct {
    target: GdkAtom,
    flags: guint,
    info: guint,
};
pub const GtkTargetPair = struct__GtkTargetPair;
pub const struct__GtkTargetList = @OpaqueType();
pub const GtkTargetList = struct__GtkTargetList;
pub const struct__GtkTargetEntry = extern struct {
    target: [*c]gchar,
    flags: guint,
    info: guint,
};
pub const GtkTargetEntry = struct__GtkTargetEntry;
pub const GTK_TARGET_SAME_APP = 1;
pub const GTK_TARGET_SAME_WIDGET = 2;
pub const GTK_TARGET_OTHER_APP = 4;
pub const GTK_TARGET_OTHER_WIDGET = 8;
pub const GtkTargetFlags = extern enum {
    GTK_TARGET_SAME_APP = 1,
    GTK_TARGET_SAME_WIDGET = 2,
    GTK_TARGET_OTHER_APP = 4,
    GTK_TARGET_OTHER_WIDGET = 8,
};
pub extern fn gtk_target_list_get_type() GType;
pub extern fn gtk_target_list_new(targets: [*c]const GtkTargetEntry, ntargets: guint) ?*GtkTargetList;
pub extern fn gtk_target_list_ref(list: ?*GtkTargetList) ?*GtkTargetList;
pub extern fn gtk_target_list_unref(list: ?*GtkTargetList) void;
pub extern fn gtk_target_list_add(list: ?*GtkTargetList, target: GdkAtom, flags: guint, info: guint) void;
pub extern fn gtk_target_list_add_text_targets(list: ?*GtkTargetList, info: guint) void;
pub extern fn gtk_target_list_add_rich_text_targets(list: ?*GtkTargetList, info: guint, deserializable: gboolean, buffer: [*c]GtkTextBuffer) void;
pub extern fn gtk_target_list_add_image_targets(list: ?*GtkTargetList, info: guint, writable: gboolean) void;
pub extern fn gtk_target_list_add_uri_targets(list: ?*GtkTargetList, info: guint) void;
pub extern fn gtk_target_list_add_table(list: ?*GtkTargetList, targets: [*c]const GtkTargetEntry, ntargets: guint) void;
pub extern fn gtk_target_list_remove(list: ?*GtkTargetList, target: GdkAtom) void;
pub extern fn gtk_target_list_find(list: ?*GtkTargetList, target: GdkAtom, info: [*c]guint) gboolean;
pub extern fn gtk_target_table_new_from_list(list: ?*GtkTargetList, n_targets: [*c]gint) [*c]GtkTargetEntry;
pub extern fn gtk_target_table_free(targets: [*c]GtkTargetEntry, n_targets: gint) void;
pub extern fn gtk_selection_owner_set(widget: [*c]GtkWidget, selection: GdkAtom, time_: guint32) gboolean;
pub extern fn gtk_selection_owner_set_for_display(display: ?*GdkDisplay, widget: [*c]GtkWidget, selection: GdkAtom, time_: guint32) gboolean;
pub extern fn gtk_selection_add_target(widget: [*c]GtkWidget, selection: GdkAtom, target: GdkAtom, info: guint) void;
pub extern fn gtk_selection_add_targets(widget: [*c]GtkWidget, selection: GdkAtom, targets: [*c]const GtkTargetEntry, ntargets: guint) void;
pub extern fn gtk_selection_clear_targets(widget: [*c]GtkWidget, selection: GdkAtom) void;
pub extern fn gtk_selection_convert(widget: [*c]GtkWidget, selection: GdkAtom, target: GdkAtom, time_: guint32) gboolean;
pub extern fn gtk_selection_remove_all(widget: [*c]GtkWidget) void;
pub extern fn gtk_selection_data_get_selection(selection_data: ?*const GtkSelectionData) GdkAtom;
pub extern fn gtk_selection_data_get_target(selection_data: ?*const GtkSelectionData) GdkAtom;
pub extern fn gtk_selection_data_get_data_type(selection_data: ?*const GtkSelectionData) GdkAtom;
pub extern fn gtk_selection_data_get_format(selection_data: ?*const GtkSelectionData) gint;
pub extern fn gtk_selection_data_get_data(selection_data: ?*const GtkSelectionData) [*c]const guchar;
pub extern fn gtk_selection_data_get_length(selection_data: ?*const GtkSelectionData) gint;
pub extern fn gtk_selection_data_get_data_with_length(selection_data: ?*const GtkSelectionData, length: [*c]gint) [*c]const guchar;
pub extern fn gtk_selection_data_get_display(selection_data: ?*const GtkSelectionData) ?*GdkDisplay;
pub extern fn gtk_selection_data_set(selection_data: ?*GtkSelectionData, type_0: GdkAtom, format: gint, data: [*c]const guchar, length: gint) void;
pub extern fn gtk_selection_data_set_text(selection_data: ?*GtkSelectionData, str: [*c]const gchar, len: gint) gboolean;
pub extern fn gtk_selection_data_get_text(selection_data: ?*const GtkSelectionData) [*c]guchar;
pub extern fn gtk_selection_data_set_pixbuf(selection_data: ?*GtkSelectionData, pixbuf: ?*GdkPixbuf) gboolean;
pub extern fn gtk_selection_data_get_pixbuf(selection_data: ?*const GtkSelectionData) ?*GdkPixbuf;
pub extern fn gtk_selection_data_set_uris(selection_data: ?*GtkSelectionData, uris: [*c]([*c]gchar)) gboolean;
pub extern fn gtk_selection_data_get_uris(selection_data: ?*const GtkSelectionData) [*c]([*c]gchar);
pub extern fn gtk_selection_data_get_targets(selection_data: ?*const GtkSelectionData, targets: [*c]([*c]GdkAtom), n_atoms: [*c]gint) gboolean;
pub extern fn gtk_selection_data_targets_include_text(selection_data: ?*const GtkSelectionData) gboolean;
pub extern fn gtk_selection_data_targets_include_rich_text(selection_data: ?*const GtkSelectionData, buffer: [*c]GtkTextBuffer) gboolean;
pub extern fn gtk_selection_data_targets_include_image(selection_data: ?*const GtkSelectionData, writable: gboolean) gboolean;
pub extern fn gtk_selection_data_targets_include_uri(selection_data: ?*const GtkSelectionData) gboolean;
pub extern fn gtk_targets_include_text(targets: [*c]GdkAtom, n_targets: gint) gboolean;
pub extern fn gtk_targets_include_rich_text(targets: [*c]GdkAtom, n_targets: gint, buffer: [*c]GtkTextBuffer) gboolean;
pub extern fn gtk_targets_include_image(targets: [*c]GdkAtom, n_targets: gint, writable: gboolean) gboolean;
pub extern fn gtk_targets_include_uri(targets: [*c]GdkAtom, n_targets: gint) gboolean;
pub extern fn gtk_selection_data_get_type() GType;
pub extern fn gtk_selection_data_copy(data: ?*const GtkSelectionData) ?*GtkSelectionData;
pub extern fn gtk_selection_data_free(data: ?*GtkSelectionData) void;
pub extern fn gtk_target_entry_get_type() GType;
pub extern fn gtk_target_entry_new(target: [*c]const gchar, flags: guint, info: guint) [*c]GtkTargetEntry;
pub extern fn gtk_target_entry_copy(data: [*c]GtkTargetEntry) [*c]GtkTargetEntry;
pub extern fn gtk_target_entry_free(data: [*c]GtkTargetEntry) void;
pub extern fn gtk_drag_get_data(widget: [*c]GtkWidget, context: ?*GdkDragContext, target: GdkAtom, time_: guint32) void;
pub extern fn gtk_drag_finish(context: ?*GdkDragContext, success: gboolean, del: gboolean, time_: guint32) void;
pub extern fn gtk_drag_get_source_widget(context: ?*GdkDragContext) [*c]GtkWidget;
pub extern fn gtk_drag_highlight(widget: [*c]GtkWidget) void;
pub extern fn gtk_drag_unhighlight(widget: [*c]GtkWidget) void;
pub extern fn gtk_drag_begin_with_coordinates(widget: [*c]GtkWidget, targets: ?*GtkTargetList, actions: GdkDragAction, button: gint, event: [*c]GdkEvent, x: gint, y: gint) ?*GdkDragContext;
pub extern fn gtk_drag_begin(widget: [*c]GtkWidget, targets: ?*GtkTargetList, actions: GdkDragAction, button: gint, event: [*c]GdkEvent) ?*GdkDragContext;
pub extern fn gtk_drag_cancel(context: ?*GdkDragContext) void;
pub extern fn gtk_drag_set_icon_widget(context: ?*GdkDragContext, widget: [*c]GtkWidget, hot_x: gint, hot_y: gint) void;
pub extern fn gtk_drag_set_icon_pixbuf(context: ?*GdkDragContext, pixbuf: ?*GdkPixbuf, hot_x: gint, hot_y: gint) void;
pub extern fn gtk_drag_set_icon_stock(context: ?*GdkDragContext, stock_id: [*c]const gchar, hot_x: gint, hot_y: gint) void;
pub extern fn gtk_drag_set_icon_surface(context: ?*GdkDragContext, surface: ?*cairo_surface_t) void;
pub extern fn gtk_drag_set_icon_name(context: ?*GdkDragContext, icon_name: [*c]const gchar, hot_x: gint, hot_y: gint) void;
pub extern fn gtk_drag_set_icon_gicon(context: ?*GdkDragContext, icon: ?*GIcon, hot_x: gint, hot_y: gint) void;
pub extern fn gtk_drag_set_icon_default(context: ?*GdkDragContext) void;
pub extern fn gtk_drag_check_threshold(widget: [*c]GtkWidget, start_x: gint, start_y: gint, current_x: gint, current_y: gint) gboolean;
pub const struct__GtkEditable = @OpaqueType();
pub const GtkEditable = struct__GtkEditable;
pub const struct__GtkEditableInterface = extern struct {
    base_iface: GTypeInterface,
    insert_text: ?extern fn (?*GtkEditable, [*c]const gchar, gint, [*c]gint) void,
    delete_text: ?extern fn (?*GtkEditable, gint, gint) void,
    changed: ?extern fn (?*GtkEditable) void,
    do_insert_text: ?extern fn (?*GtkEditable, [*c]const gchar, gint, [*c]gint) void,
    do_delete_text: ?extern fn (?*GtkEditable, gint, gint) void,
    get_chars: ?extern fn (?*GtkEditable, gint, gint) [*c]gchar,
    set_selection_bounds: ?extern fn (?*GtkEditable, gint, gint) void,
    get_selection_bounds: ?extern fn (?*GtkEditable, [*c]gint, [*c]gint) gboolean,
    set_position: ?extern fn (?*GtkEditable, gint) void,
    get_position: ?extern fn (?*GtkEditable) gint,
};
pub const GtkEditableInterface = struct__GtkEditableInterface;
pub extern fn gtk_editable_get_type() GType;
pub extern fn gtk_editable_select_region(editable: ?*GtkEditable, start_pos: gint, end_pos: gint) void;
pub extern fn gtk_editable_get_selection_bounds(editable: ?*GtkEditable, start_pos: [*c]gint, end_pos: [*c]gint) gboolean;
pub extern fn gtk_editable_insert_text(editable: ?*GtkEditable, new_text: [*c]const gchar, new_text_length: gint, position: [*c]gint) void;
pub extern fn gtk_editable_delete_text(editable: ?*GtkEditable, start_pos: gint, end_pos: gint) void;
pub extern fn gtk_editable_get_chars(editable: ?*GtkEditable, start_pos: gint, end_pos: gint) [*c]gchar;
pub extern fn gtk_editable_cut_clipboard(editable: ?*GtkEditable) void;
pub extern fn gtk_editable_copy_clipboard(editable: ?*GtkEditable) void;
pub extern fn gtk_editable_paste_clipboard(editable: ?*GtkEditable) void;
pub extern fn gtk_editable_delete_selection(editable: ?*GtkEditable) void;
pub extern fn gtk_editable_set_position(editable: ?*GtkEditable, position: gint) void;
pub extern fn gtk_editable_get_position(editable: ?*GtkEditable) gint;
pub extern fn gtk_editable_set_editable(editable: ?*GtkEditable, is_editable: gboolean) void;
pub extern fn gtk_editable_get_editable(editable: ?*GtkEditable) gboolean;
pub const struct__GtkIMContext = extern struct {
    parent_instance: GObject,
};
pub const GtkIMContext = struct__GtkIMContext;
pub const struct__GtkIMContextClass = extern struct {
    parent_class: GObjectClass,
    preedit_start: ?extern fn ([*c]GtkIMContext) void,
    preedit_end: ?extern fn ([*c]GtkIMContext) void,
    preedit_changed: ?extern fn ([*c]GtkIMContext) void,
    commit: ?extern fn ([*c]GtkIMContext, [*c]const gchar) void,
    retrieve_surrounding: ?extern fn ([*c]GtkIMContext) gboolean,
    delete_surrounding: ?extern fn ([*c]GtkIMContext, gint, gint) gboolean,
    set_client_window: ?extern fn ([*c]GtkIMContext, ?*GdkWindow) void,
    get_preedit_string: ?extern fn ([*c]GtkIMContext, [*c]([*c]gchar), [*c](?*PangoAttrList), [*c]gint) void,
    filter_keypress: ?extern fn ([*c]GtkIMContext, ?*GdkEventKey) gboolean,
    focus_in: ?extern fn ([*c]GtkIMContext) void,
    focus_out: ?extern fn ([*c]GtkIMContext) void,
    reset: ?extern fn ([*c]GtkIMContext) void,
    set_cursor_location: ?extern fn ([*c]GtkIMContext, [*c]GdkRectangle) void,
    set_use_preedit: ?extern fn ([*c]GtkIMContext, gboolean) void,
    set_surrounding: ?extern fn ([*c]GtkIMContext, [*c]const gchar, gint, gint) void,
    get_surrounding: ?extern fn ([*c]GtkIMContext, [*c]([*c]gchar), [*c]gint) gboolean,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
};
pub const GtkIMContextClass = struct__GtkIMContextClass;
pub extern fn gtk_im_context_get_type() GType;
pub extern fn gtk_im_context_set_client_window(context: [*c]GtkIMContext, window: ?*GdkWindow) void;
pub extern fn gtk_im_context_get_preedit_string(context: [*c]GtkIMContext, str: [*c]([*c]gchar), attrs: [*c](?*PangoAttrList), cursor_pos: [*c]gint) void;
pub extern fn gtk_im_context_filter_keypress(context: [*c]GtkIMContext, event: ?*GdkEventKey) gboolean;
pub extern fn gtk_im_context_focus_in(context: [*c]GtkIMContext) void;
pub extern fn gtk_im_context_focus_out(context: [*c]GtkIMContext) void;
pub extern fn gtk_im_context_reset(context: [*c]GtkIMContext) void;
pub extern fn gtk_im_context_set_cursor_location(context: [*c]GtkIMContext, area: [*c]const GdkRectangle) void;
pub extern fn gtk_im_context_set_use_preedit(context: [*c]GtkIMContext, use_preedit: gboolean) void;
pub extern fn gtk_im_context_set_surrounding(context: [*c]GtkIMContext, text: [*c]const gchar, len: gint, cursor_index: gint) void;
pub extern fn gtk_im_context_get_surrounding(context: [*c]GtkIMContext, text: [*c]([*c]gchar), cursor_index: [*c]gint) gboolean;
pub extern fn gtk_im_context_delete_surrounding(context: [*c]GtkIMContext, offset: gint, n_chars: gint) gboolean;
pub const struct__GtkEntryBufferPrivate = @OpaqueType();
pub const GtkEntryBufferPrivate = struct__GtkEntryBufferPrivate;
pub const struct__GtkEntryBuffer = extern struct {
    parent_instance: GObject,
    priv: ?*GtkEntryBufferPrivate,
};
pub const GtkEntryBuffer = struct__GtkEntryBuffer;
pub const struct__GtkEntryBufferClass = extern struct {
    parent_class: GObjectClass,
    inserted_text: ?extern fn ([*c]GtkEntryBuffer, guint, [*c]const gchar, guint) void,
    deleted_text: ?extern fn ([*c]GtkEntryBuffer, guint, guint) void,
    get_text: ?extern fn ([*c]GtkEntryBuffer, [*c]gsize) [*c]const gchar,
    get_length: ?extern fn ([*c]GtkEntryBuffer) guint,
    insert_text: ?extern fn ([*c]GtkEntryBuffer, guint, [*c]const gchar, guint) guint,
    delete_text: ?extern fn ([*c]GtkEntryBuffer, guint, guint) guint,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
    _gtk_reserved8: ?extern fn () void,
};
pub const GtkEntryBufferClass = struct__GtkEntryBufferClass;
pub extern fn gtk_entry_buffer_get_type() GType;
pub extern fn gtk_entry_buffer_new(initial_chars: [*c]const gchar, n_initial_chars: gint) [*c]GtkEntryBuffer;
pub extern fn gtk_entry_buffer_get_bytes(buffer: [*c]GtkEntryBuffer) gsize;
pub extern fn gtk_entry_buffer_get_length(buffer: [*c]GtkEntryBuffer) guint;
pub extern fn gtk_entry_buffer_get_text(buffer: [*c]GtkEntryBuffer) [*c]const gchar;
pub extern fn gtk_entry_buffer_set_text(buffer: [*c]GtkEntryBuffer, chars: [*c]const gchar, n_chars: gint) void;
pub extern fn gtk_entry_buffer_set_max_length(buffer: [*c]GtkEntryBuffer, max_length: gint) void;
pub extern fn gtk_entry_buffer_get_max_length(buffer: [*c]GtkEntryBuffer) gint;
pub extern fn gtk_entry_buffer_insert_text(buffer: [*c]GtkEntryBuffer, position: guint, chars: [*c]const gchar, n_chars: gint) guint;
pub extern fn gtk_entry_buffer_delete_text(buffer: [*c]GtkEntryBuffer, position: guint, n_chars: gint) guint;
pub extern fn gtk_entry_buffer_emit_inserted_text(buffer: [*c]GtkEntryBuffer, position: guint, chars: [*c]const gchar, n_chars: guint) void;
pub extern fn gtk_entry_buffer_emit_deleted_text(buffer: [*c]GtkEntryBuffer, position: guint, n_chars: guint) void;
pub const struct__GtkListStorePrivate = @OpaqueType();
pub const GtkListStorePrivate = struct__GtkListStorePrivate;
pub const struct__GtkListStore = extern struct {
    parent: GObject,
    priv: ?*GtkListStorePrivate,
};
pub const GtkListStore = struct__GtkListStore;
pub const struct__GtkListStoreClass = extern struct {
    parent_class: GObjectClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkListStoreClass = struct__GtkListStoreClass;
pub extern fn gtk_list_store_get_type() GType;
pub extern fn gtk_list_store_new(n_columns: gint, ...) [*c]GtkListStore;
pub extern fn gtk_list_store_newv(n_columns: gint, types: [*c]GType) [*c]GtkListStore;
pub extern fn gtk_list_store_set_column_types(list_store: [*c]GtkListStore, n_columns: gint, types: [*c]GType) void;
pub extern fn gtk_list_store_set_value(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, column: gint, value: [*c]GValue) void;
pub extern fn gtk_list_store_set(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, ...) void;
pub extern fn gtk_list_store_set_valuesv(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, columns: [*c]gint, values: [*c]GValue, n_values: gint) void;
pub extern fn gtk_list_store_set_valist(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, var_args: va_list) void;
pub extern fn gtk_list_store_remove(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_list_store_insert(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, position: gint) void;
pub extern fn gtk_list_store_insert_before(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, sibling: [*c]GtkTreeIter) void;
pub extern fn gtk_list_store_insert_after(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, sibling: [*c]GtkTreeIter) void;
pub extern fn gtk_list_store_insert_with_values(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, position: gint, ...) void;
pub extern fn gtk_list_store_insert_with_valuesv(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter, position: gint, columns: [*c]gint, values: [*c]GValue, n_values: gint) void;
pub extern fn gtk_list_store_prepend(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_list_store_append(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_list_store_clear(list_store: [*c]GtkListStore) void;
pub extern fn gtk_list_store_iter_is_valid(list_store: [*c]GtkListStore, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_list_store_reorder(store: [*c]GtkListStore, new_order: [*c]gint) void;
pub extern fn gtk_list_store_swap(store: [*c]GtkListStore, a: [*c]GtkTreeIter, b: [*c]GtkTreeIter) void;
pub extern fn gtk_list_store_move_after(store: [*c]GtkListStore, iter: [*c]GtkTreeIter, position: [*c]GtkTreeIter) void;
pub extern fn gtk_list_store_move_before(store: [*c]GtkListStore, iter: [*c]GtkTreeIter, position: [*c]GtkTreeIter) void;
pub const GtkTreeModelFilterVisibleFunc = ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter, gpointer) gboolean;
pub const GtkTreeModelFilterModifyFunc = ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter, [*c]GValue, gint, gpointer) void;
pub const struct__GtkTreeModelFilterPrivate = @OpaqueType();
pub const GtkTreeModelFilterPrivate = struct__GtkTreeModelFilterPrivate;
pub const struct__GtkTreeModelFilter = extern struct {
    parent: GObject,
    priv: ?*GtkTreeModelFilterPrivate,
};
pub const GtkTreeModelFilter = struct__GtkTreeModelFilter;
pub const struct__GtkTreeModelFilterClass = extern struct {
    parent_class: GObjectClass,
    visible: ?extern fn ([*c]GtkTreeModelFilter, ?*GtkTreeModel, [*c]GtkTreeIter) gboolean,
    modify: ?extern fn ([*c]GtkTreeModelFilter, ?*GtkTreeModel, [*c]GtkTreeIter, [*c]GValue, gint) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkTreeModelFilterClass = struct__GtkTreeModelFilterClass;
pub extern fn gtk_tree_model_filter_get_type() GType;
pub extern fn gtk_tree_model_filter_new(child_model: ?*GtkTreeModel, root: ?*GtkTreePath) ?*GtkTreeModel;
pub extern fn gtk_tree_model_filter_set_visible_func(filter: [*c]GtkTreeModelFilter, func: GtkTreeModelFilterVisibleFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_model_filter_set_modify_func(filter: [*c]GtkTreeModelFilter, n_columns: gint, types: [*c]GType, func: GtkTreeModelFilterModifyFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_model_filter_set_visible_column(filter: [*c]GtkTreeModelFilter, column: gint) void;
pub extern fn gtk_tree_model_filter_get_model(filter: [*c]GtkTreeModelFilter) ?*GtkTreeModel;
pub extern fn gtk_tree_model_filter_convert_child_iter_to_iter(filter: [*c]GtkTreeModelFilter, filter_iter: [*c]GtkTreeIter, child_iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_filter_convert_iter_to_child_iter(filter: [*c]GtkTreeModelFilter, child_iter: [*c]GtkTreeIter, filter_iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_filter_convert_child_path_to_path(filter: [*c]GtkTreeModelFilter, child_path: ?*GtkTreePath) ?*GtkTreePath;
pub extern fn gtk_tree_model_filter_convert_path_to_child_path(filter: [*c]GtkTreeModelFilter, filter_path: ?*GtkTreePath) ?*GtkTreePath;
pub extern fn gtk_tree_model_filter_refilter(filter: [*c]GtkTreeModelFilter) void;
pub extern fn gtk_tree_model_filter_clear_cache(filter: [*c]GtkTreeModelFilter) void;
pub const struct__GtkEntryCompletionPrivate = @OpaqueType();
pub const GtkEntryCompletionPrivate = struct__GtkEntryCompletionPrivate;
pub const struct__GtkEntryCompletion = extern struct {
    parent_instance: GObject,
    priv: ?*GtkEntryCompletionPrivate,
};
pub const GtkEntryCompletion = struct__GtkEntryCompletion;
pub const struct__GtkEntryCompletionClass = extern struct {
    parent_class: GObjectClass,
    match_selected: ?extern fn ([*c]GtkEntryCompletion, ?*GtkTreeModel, [*c]GtkTreeIter) gboolean,
    action_activated: ?extern fn ([*c]GtkEntryCompletion, gint) void,
    insert_prefix: ?extern fn ([*c]GtkEntryCompletion, [*c]const gchar) gboolean,
    cursor_on_match: ?extern fn ([*c]GtkEntryCompletion, ?*GtkTreeModel, [*c]GtkTreeIter) gboolean,
    no_matches: ?extern fn ([*c]GtkEntryCompletion) void,
    _gtk_reserved0: ?extern fn () void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
};
pub const GtkEntryCompletionClass = struct__GtkEntryCompletionClass;
pub const GtkEntryCompletionMatchFunc = ?extern fn ([*c]GtkEntryCompletion, [*c]const gchar, [*c]GtkTreeIter, gpointer) gboolean;
pub extern fn gtk_entry_completion_get_type() GType;
pub extern fn gtk_entry_completion_new() [*c]GtkEntryCompletion;
pub extern fn gtk_entry_completion_new_with_area(area: [*c]GtkCellArea) [*c]GtkEntryCompletion;
pub extern fn gtk_entry_completion_get_entry(completion: [*c]GtkEntryCompletion) [*c]GtkWidget;
pub extern fn gtk_entry_completion_set_model(completion: [*c]GtkEntryCompletion, model: ?*GtkTreeModel) void;
pub extern fn gtk_entry_completion_get_model(completion: [*c]GtkEntryCompletion) ?*GtkTreeModel;
pub extern fn gtk_entry_completion_set_match_func(completion: [*c]GtkEntryCompletion, func: GtkEntryCompletionMatchFunc, func_data: gpointer, func_notify: GDestroyNotify) void;
pub extern fn gtk_entry_completion_set_minimum_key_length(completion: [*c]GtkEntryCompletion, length: gint) void;
pub extern fn gtk_entry_completion_get_minimum_key_length(completion: [*c]GtkEntryCompletion) gint;
pub extern fn gtk_entry_completion_compute_prefix(completion: [*c]GtkEntryCompletion, key: [*c]const u8) [*c]gchar;
pub extern fn gtk_entry_completion_complete(completion: [*c]GtkEntryCompletion) void;
pub extern fn gtk_entry_completion_insert_prefix(completion: [*c]GtkEntryCompletion) void;
pub extern fn gtk_entry_completion_insert_action_text(completion: [*c]GtkEntryCompletion, index_: gint, text: [*c]const gchar) void;
pub extern fn gtk_entry_completion_insert_action_markup(completion: [*c]GtkEntryCompletion, index_: gint, markup: [*c]const gchar) void;
pub extern fn gtk_entry_completion_delete_action(completion: [*c]GtkEntryCompletion, index_: gint) void;
pub extern fn gtk_entry_completion_set_inline_completion(completion: [*c]GtkEntryCompletion, inline_completion: gboolean) void;
pub extern fn gtk_entry_completion_get_inline_completion(completion: [*c]GtkEntryCompletion) gboolean;
pub extern fn gtk_entry_completion_set_inline_selection(completion: [*c]GtkEntryCompletion, inline_selection: gboolean) void;
pub extern fn gtk_entry_completion_get_inline_selection(completion: [*c]GtkEntryCompletion) gboolean;
pub extern fn gtk_entry_completion_set_popup_completion(completion: [*c]GtkEntryCompletion, popup_completion: gboolean) void;
pub extern fn gtk_entry_completion_get_popup_completion(completion: [*c]GtkEntryCompletion) gboolean;
pub extern fn gtk_entry_completion_set_popup_set_width(completion: [*c]GtkEntryCompletion, popup_set_width: gboolean) void;
pub extern fn gtk_entry_completion_get_popup_set_width(completion: [*c]GtkEntryCompletion) gboolean;
pub extern fn gtk_entry_completion_set_popup_single_match(completion: [*c]GtkEntryCompletion, popup_single_match: gboolean) void;
pub extern fn gtk_entry_completion_get_popup_single_match(completion: [*c]GtkEntryCompletion) gboolean;
pub extern fn gtk_entry_completion_get_completion_prefix(completion: [*c]GtkEntryCompletion) [*c]const gchar;
pub extern fn gtk_entry_completion_set_text_column(completion: [*c]GtkEntryCompletion, column: gint) void;
pub extern fn gtk_entry_completion_get_text_column(completion: [*c]GtkEntryCompletion) gint;
pub const struct__GtkImagePrivate = @OpaqueType();
pub const GtkImagePrivate = struct__GtkImagePrivate;
pub const struct__GtkImage = extern struct {
    misc: GtkMisc,
    priv: ?*GtkImagePrivate,
};
pub const GtkImage = struct__GtkImage;
pub const struct__GtkImageClass = extern struct {
    parent_class: GtkMiscClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkImageClass = struct__GtkImageClass;
pub const GTK_IMAGE_EMPTY = 0;
pub const GTK_IMAGE_PIXBUF = 1;
pub const GTK_IMAGE_STOCK = 2;
pub const GTK_IMAGE_ICON_SET = 3;
pub const GTK_IMAGE_ANIMATION = 4;
pub const GTK_IMAGE_ICON_NAME = 5;
pub const GTK_IMAGE_GICON = 6;
pub const GTK_IMAGE_SURFACE = 7;
pub const GtkImageType = extern enum {
    GTK_IMAGE_EMPTY = 0,
    GTK_IMAGE_PIXBUF = 1,
    GTK_IMAGE_STOCK = 2,
    GTK_IMAGE_ICON_SET = 3,
    GTK_IMAGE_ANIMATION = 4,
    GTK_IMAGE_ICON_NAME = 5,
    GTK_IMAGE_GICON = 6,
    GTK_IMAGE_SURFACE = 7,
};
pub extern fn gtk_image_get_type() GType;
pub extern fn gtk_image_new() [*c]GtkWidget;
pub extern fn gtk_image_new_from_file(filename: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_image_new_from_resource(resource_path: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_image_new_from_pixbuf(pixbuf: ?*GdkPixbuf) [*c]GtkWidget;
pub extern fn gtk_image_new_from_stock(stock_id: [*c]const gchar, size: GtkIconSize) [*c]GtkWidget;
pub extern fn gtk_image_new_from_icon_set(icon_set: ?*GtkIconSet, size: GtkIconSize) [*c]GtkWidget;
pub extern fn gtk_image_new_from_animation(animation: ?*GdkPixbufAnimation) [*c]GtkWidget;
pub extern fn gtk_image_new_from_icon_name(icon_name: [*c]const gchar, size: GtkIconSize) [*c]GtkWidget;
pub extern fn gtk_image_new_from_gicon(icon: ?*GIcon, size: GtkIconSize) [*c]GtkWidget;
pub extern fn gtk_image_new_from_surface(surface: ?*cairo_surface_t) [*c]GtkWidget;
pub extern fn gtk_image_clear(image: [*c]GtkImage) void;
pub extern fn gtk_image_set_from_file(image: [*c]GtkImage, filename: [*c]const gchar) void;
pub extern fn gtk_image_set_from_resource(image: [*c]GtkImage, resource_path: [*c]const gchar) void;
pub extern fn gtk_image_set_from_pixbuf(image: [*c]GtkImage, pixbuf: ?*GdkPixbuf) void;
pub extern fn gtk_image_set_from_stock(image: [*c]GtkImage, stock_id: [*c]const gchar, size: GtkIconSize) void;
pub extern fn gtk_image_set_from_icon_set(image: [*c]GtkImage, icon_set: ?*GtkIconSet, size: GtkIconSize) void;
pub extern fn gtk_image_set_from_animation(image: [*c]GtkImage, animation: ?*GdkPixbufAnimation) void;
pub extern fn gtk_image_set_from_icon_name(image: [*c]GtkImage, icon_name: [*c]const gchar, size: GtkIconSize) void;
pub extern fn gtk_image_set_from_gicon(image: [*c]GtkImage, icon: ?*GIcon, size: GtkIconSize) void;
pub extern fn gtk_image_set_from_surface(image: [*c]GtkImage, surface: ?*cairo_surface_t) void;
pub extern fn gtk_image_set_pixel_size(image: [*c]GtkImage, pixel_size: gint) void;
pub extern fn gtk_image_get_storage_type(image: [*c]GtkImage) GtkImageType;
pub extern fn gtk_image_get_pixbuf(image: [*c]GtkImage) ?*GdkPixbuf;
pub extern fn gtk_image_get_stock(image: [*c]GtkImage, stock_id: [*c]([*c]gchar), size: [*c]GtkIconSize) void;
pub extern fn gtk_image_get_icon_set(image: [*c]GtkImage, icon_set: [*c](?*GtkIconSet), size: [*c]GtkIconSize) void;
pub extern fn gtk_image_get_animation(image: [*c]GtkImage) ?*GdkPixbufAnimation;
pub extern fn gtk_image_get_icon_name(image: [*c]GtkImage, icon_name: [*c]([*c]const gchar), size: [*c]GtkIconSize) void;
pub extern fn gtk_image_get_gicon(image: [*c]GtkImage, gicon: [*c](?*GIcon), size: [*c]GtkIconSize) void;
pub extern fn gtk_image_get_pixel_size(image: [*c]GtkImage) gint;
pub const GTK_ENTRY_ICON_PRIMARY = 0;
pub const GTK_ENTRY_ICON_SECONDARY = 1;
pub const GtkEntryIconPosition = extern enum {
    GTK_ENTRY_ICON_PRIMARY = 0,
    GTK_ENTRY_ICON_SECONDARY = 1,
};
pub const struct__GtkEntryPrivate = @OpaqueType();
pub const GtkEntryPrivate = struct__GtkEntryPrivate;
pub const struct__GtkEntry = extern struct {
    parent_instance: GtkWidget,
    priv: ?*GtkEntryPrivate,
};
pub const GtkEntry = struct__GtkEntry;
pub const struct__GtkEntryClass = extern struct {
    parent_class: GtkWidgetClass,
    populate_popup: ?extern fn ([*c]GtkEntry, [*c]GtkWidget) void,
    activate: ?extern fn ([*c]GtkEntry) void,
    move_cursor: ?extern fn ([*c]GtkEntry, GtkMovementStep, gint, gboolean) void,
    insert_at_cursor: ?extern fn ([*c]GtkEntry, [*c]const gchar) void,
    delete_from_cursor: ?extern fn ([*c]GtkEntry, GtkDeleteType, gint) void,
    backspace: ?extern fn ([*c]GtkEntry) void,
    cut_clipboard: ?extern fn ([*c]GtkEntry) void,
    copy_clipboard: ?extern fn ([*c]GtkEntry) void,
    paste_clipboard: ?extern fn ([*c]GtkEntry) void,
    toggle_overwrite: ?extern fn ([*c]GtkEntry) void,
    get_text_area_size: ?extern fn ([*c]GtkEntry, [*c]gint, [*c]gint, [*c]gint, [*c]gint) void,
    get_frame_size: ?extern fn ([*c]GtkEntry, [*c]gint, [*c]gint, [*c]gint, [*c]gint) void,
    insert_emoji: ?extern fn ([*c]GtkEntry) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
};
pub const GtkEntryClass = struct__GtkEntryClass;
pub extern fn gtk_entry_get_type() GType;
pub extern fn gtk_entry_new() [*c]GtkWidget;
pub extern fn gtk_entry_new_with_buffer(buffer: [*c]GtkEntryBuffer) [*c]GtkWidget;
pub extern fn gtk_entry_get_buffer(entry: [*c]GtkEntry) [*c]GtkEntryBuffer;
pub extern fn gtk_entry_set_buffer(entry: [*c]GtkEntry, buffer: [*c]GtkEntryBuffer) void;
pub extern fn gtk_entry_get_text_area(entry: [*c]GtkEntry, text_area: [*c]GdkRectangle) void;
pub extern fn gtk_entry_set_visibility(entry: [*c]GtkEntry, visible: gboolean) void;
pub extern fn gtk_entry_get_visibility(entry: [*c]GtkEntry) gboolean;
pub extern fn gtk_entry_set_invisible_char(entry: [*c]GtkEntry, ch: gunichar) void;
pub extern fn gtk_entry_get_invisible_char(entry: [*c]GtkEntry) gunichar;
pub extern fn gtk_entry_unset_invisible_char(entry: [*c]GtkEntry) void;
pub extern fn gtk_entry_set_has_frame(entry: [*c]GtkEntry, setting: gboolean) void;
pub extern fn gtk_entry_get_has_frame(entry: [*c]GtkEntry) gboolean;
pub extern fn gtk_entry_set_inner_border(entry: [*c]GtkEntry, border: [*c]const GtkBorder) void;
pub extern fn gtk_entry_get_inner_border(entry: [*c]GtkEntry) [*c]const GtkBorder;
pub extern fn gtk_entry_set_overwrite_mode(entry: [*c]GtkEntry, overwrite: gboolean) void;
pub extern fn gtk_entry_get_overwrite_mode(entry: [*c]GtkEntry) gboolean;
pub extern fn gtk_entry_set_max_length(entry: [*c]GtkEntry, max: gint) void;
pub extern fn gtk_entry_get_max_length(entry: [*c]GtkEntry) gint;
pub extern fn gtk_entry_get_text_length(entry: [*c]GtkEntry) guint16;
pub extern fn gtk_entry_set_activates_default(entry: [*c]GtkEntry, setting: gboolean) void;
pub extern fn gtk_entry_get_activates_default(entry: [*c]GtkEntry) gboolean;
pub extern fn gtk_entry_set_width_chars(entry: [*c]GtkEntry, n_chars: gint) void;
pub extern fn gtk_entry_get_width_chars(entry: [*c]GtkEntry) gint;
pub extern fn gtk_entry_set_max_width_chars(entry: [*c]GtkEntry, n_chars: gint) void;
pub extern fn gtk_entry_get_max_width_chars(entry: [*c]GtkEntry) gint;
pub extern fn gtk_entry_set_text(entry: [*c]GtkEntry, text: [*c]const gchar) void;
pub extern fn gtk_entry_get_text(entry: [*c]GtkEntry) [*c]const gchar;
pub extern fn gtk_entry_get_layout(entry: [*c]GtkEntry) ?*PangoLayout;
pub extern fn gtk_entry_get_layout_offsets(entry: [*c]GtkEntry, x: [*c]gint, y: [*c]gint) void;
pub extern fn gtk_entry_set_alignment(entry: [*c]GtkEntry, xalign: gfloat) void;
pub extern fn gtk_entry_get_alignment(entry: [*c]GtkEntry) gfloat;
pub extern fn gtk_entry_set_completion(entry: [*c]GtkEntry, completion: [*c]GtkEntryCompletion) void;
pub extern fn gtk_entry_get_completion(entry: [*c]GtkEntry) [*c]GtkEntryCompletion;
pub extern fn gtk_entry_layout_index_to_text_index(entry: [*c]GtkEntry, layout_index: gint) gint;
pub extern fn gtk_entry_text_index_to_layout_index(entry: [*c]GtkEntry, text_index: gint) gint;
pub extern fn gtk_entry_set_cursor_hadjustment(entry: [*c]GtkEntry, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_entry_get_cursor_hadjustment(entry: [*c]GtkEntry) [*c]GtkAdjustment;
pub extern fn gtk_entry_set_progress_fraction(entry: [*c]GtkEntry, fraction: gdouble) void;
pub extern fn gtk_entry_get_progress_fraction(entry: [*c]GtkEntry) gdouble;
pub extern fn gtk_entry_set_progress_pulse_step(entry: [*c]GtkEntry, fraction: gdouble) void;
pub extern fn gtk_entry_get_progress_pulse_step(entry: [*c]GtkEntry) gdouble;
pub extern fn gtk_entry_progress_pulse(entry: [*c]GtkEntry) void;
pub extern fn gtk_entry_get_placeholder_text(entry: [*c]GtkEntry) [*c]const gchar;
pub extern fn gtk_entry_set_placeholder_text(entry: [*c]GtkEntry, text: [*c]const gchar) void;
pub extern fn gtk_entry_set_icon_from_pixbuf(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, pixbuf: ?*GdkPixbuf) void;
pub extern fn gtk_entry_set_icon_from_stock(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, stock_id: [*c]const gchar) void;
pub extern fn gtk_entry_set_icon_from_icon_name(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, icon_name: [*c]const gchar) void;
pub extern fn gtk_entry_set_icon_from_gicon(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, icon: ?*GIcon) void;
pub extern fn gtk_entry_get_icon_storage_type(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) GtkImageType;
pub extern fn gtk_entry_get_icon_pixbuf(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) ?*GdkPixbuf;
pub extern fn gtk_entry_get_icon_stock(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) [*c]const gchar;
pub extern fn gtk_entry_get_icon_name(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) [*c]const gchar;
pub extern fn gtk_entry_get_icon_gicon(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) ?*GIcon;
pub extern fn gtk_entry_set_icon_activatable(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, activatable: gboolean) void;
pub extern fn gtk_entry_get_icon_activatable(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) gboolean;
pub extern fn gtk_entry_set_icon_sensitive(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, sensitive: gboolean) void;
pub extern fn gtk_entry_get_icon_sensitive(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) gboolean;
pub extern fn gtk_entry_get_icon_at_pos(entry: [*c]GtkEntry, x: gint, y: gint) gint;
pub extern fn gtk_entry_set_icon_tooltip_text(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, tooltip: [*c]const gchar) void;
pub extern fn gtk_entry_get_icon_tooltip_text(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) [*c]gchar;
pub extern fn gtk_entry_set_icon_tooltip_markup(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, tooltip: [*c]const gchar) void;
pub extern fn gtk_entry_get_icon_tooltip_markup(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition) [*c]gchar;
pub extern fn gtk_entry_set_icon_drag_source(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, target_list: ?*GtkTargetList, actions: GdkDragAction) void;
pub extern fn gtk_entry_get_current_icon_drag_source(entry: [*c]GtkEntry) gint;
pub extern fn gtk_entry_get_icon_area(entry: [*c]GtkEntry, icon_pos: GtkEntryIconPosition, icon_area: [*c]GdkRectangle) void;
pub extern fn gtk_entry_im_context_filter_keypress(entry: [*c]GtkEntry, event: ?*GdkEventKey) gboolean;
pub extern fn gtk_entry_reset_im_context(entry: [*c]GtkEntry) void;
pub extern fn gtk_entry_set_input_purpose(entry: [*c]GtkEntry, purpose: GtkInputPurpose) void;
pub extern fn gtk_entry_get_input_purpose(entry: [*c]GtkEntry) GtkInputPurpose;
pub extern fn gtk_entry_set_input_hints(entry: [*c]GtkEntry, hints: GtkInputHints) void;
pub extern fn gtk_entry_get_input_hints(entry: [*c]GtkEntry) GtkInputHints;
pub extern fn gtk_entry_set_attributes(entry: [*c]GtkEntry, attrs: ?*PangoAttrList) void;
pub extern fn gtk_entry_get_attributes(entry: [*c]GtkEntry) ?*PangoAttrList;
pub extern fn gtk_entry_set_tabs(entry: [*c]GtkEntry, tabs: ?*PangoTabArray) void;
pub extern fn gtk_entry_get_tabs(entry: [*c]GtkEntry) ?*PangoTabArray;
pub extern fn gtk_entry_grab_focus_without_selecting(entry: [*c]GtkEntry) void;
pub const GTK_TREE_VIEW_DROP_BEFORE = 0;
pub const GTK_TREE_VIEW_DROP_AFTER = 1;
pub const GTK_TREE_VIEW_DROP_INTO_OR_BEFORE = 2;
pub const GTK_TREE_VIEW_DROP_INTO_OR_AFTER = 3;
pub const GtkTreeViewDropPosition = extern enum {
    GTK_TREE_VIEW_DROP_BEFORE = 0,
    GTK_TREE_VIEW_DROP_AFTER = 1,
    GTK_TREE_VIEW_DROP_INTO_OR_BEFORE = 2,
    GTK_TREE_VIEW_DROP_INTO_OR_AFTER = 3,
};
pub const struct__GtkTreeViewPrivate = @OpaqueType();
pub const GtkTreeViewPrivate = struct__GtkTreeViewPrivate;
pub const struct__GtkTreeView = extern struct {
    parent: GtkContainer,
    priv: ?*GtkTreeViewPrivate,
};
pub const GtkTreeView = struct__GtkTreeView;
pub const struct__GtkTreeViewClass = extern struct {
    parent_class: GtkContainerClass,
    row_activated: ?extern fn ([*c]GtkTreeView, ?*GtkTreePath, [*c]GtkTreeViewColumn) void,
    test_expand_row: ?extern fn ([*c]GtkTreeView, [*c]GtkTreeIter, ?*GtkTreePath) gboolean,
    test_collapse_row: ?extern fn ([*c]GtkTreeView, [*c]GtkTreeIter, ?*GtkTreePath) gboolean,
    row_expanded: ?extern fn ([*c]GtkTreeView, [*c]GtkTreeIter, ?*GtkTreePath) void,
    row_collapsed: ?extern fn ([*c]GtkTreeView, [*c]GtkTreeIter, ?*GtkTreePath) void,
    columns_changed: ?extern fn ([*c]GtkTreeView) void,
    cursor_changed: ?extern fn ([*c]GtkTreeView) void,
    move_cursor: ?extern fn ([*c]GtkTreeView, GtkMovementStep, gint) gboolean,
    select_all: ?extern fn ([*c]GtkTreeView) gboolean,
    unselect_all: ?extern fn ([*c]GtkTreeView) gboolean,
    select_cursor_row: ?extern fn ([*c]GtkTreeView, gboolean) gboolean,
    toggle_cursor_row: ?extern fn ([*c]GtkTreeView) gboolean,
    expand_collapse_cursor_row: ?extern fn ([*c]GtkTreeView, gboolean, gboolean, gboolean) gboolean,
    select_cursor_parent: ?extern fn ([*c]GtkTreeView) gboolean,
    start_interactive_search: ?extern fn ([*c]GtkTreeView) gboolean,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
    _gtk_reserved8: ?extern fn () void,
};
pub const GtkTreeViewClass = struct__GtkTreeViewClass;
pub const struct__GtkTreeSelectionPrivate = @OpaqueType();
pub const GtkTreeSelectionPrivate = struct__GtkTreeSelectionPrivate;
pub const struct__GtkTreeSelection = extern struct {
    parent: GObject,
    priv: ?*GtkTreeSelectionPrivate,
};
pub const GtkTreeSelection = struct__GtkTreeSelection;
pub const struct__GtkTreeSelectionClass = extern struct {
    parent_class: GObjectClass,
    changed: ?extern fn ([*c]GtkTreeSelection) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkTreeSelectionClass = struct__GtkTreeSelectionClass;
pub const GtkTreeViewColumnDropFunc = ?extern fn ([*c]GtkTreeView, [*c]GtkTreeViewColumn, [*c]GtkTreeViewColumn, [*c]GtkTreeViewColumn, gpointer) gboolean;
pub const GtkTreeViewMappingFunc = ?extern fn ([*c]GtkTreeView, ?*GtkTreePath, gpointer) void;
pub const GtkTreeViewSearchEqualFunc = ?extern fn (?*GtkTreeModel, gint, [*c]const gchar, [*c]GtkTreeIter, gpointer) gboolean;
pub const GtkTreeViewRowSeparatorFunc = ?extern fn (?*GtkTreeModel, [*c]GtkTreeIter, gpointer) gboolean;
pub const GtkTreeViewSearchPositionFunc = ?extern fn ([*c]GtkTreeView, [*c]GtkWidget, gpointer) void;
pub extern fn gtk_tree_view_get_type() GType;
pub extern fn gtk_tree_view_new() [*c]GtkWidget;
pub extern fn gtk_tree_view_new_with_model(model: ?*GtkTreeModel) [*c]GtkWidget;
pub extern fn gtk_tree_view_get_model(tree_view: [*c]GtkTreeView) ?*GtkTreeModel;
pub extern fn gtk_tree_view_set_model(tree_view: [*c]GtkTreeView, model: ?*GtkTreeModel) void;
pub extern fn gtk_tree_view_get_selection(tree_view: [*c]GtkTreeView) [*c]GtkTreeSelection;
pub extern fn gtk_tree_view_get_hadjustment(tree_view: [*c]GtkTreeView) [*c]GtkAdjustment;
pub extern fn gtk_tree_view_set_hadjustment(tree_view: [*c]GtkTreeView, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_tree_view_get_vadjustment(tree_view: [*c]GtkTreeView) [*c]GtkAdjustment;
pub extern fn gtk_tree_view_set_vadjustment(tree_view: [*c]GtkTreeView, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_tree_view_get_headers_visible(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_headers_visible(tree_view: [*c]GtkTreeView, headers_visible: gboolean) void;
pub extern fn gtk_tree_view_columns_autosize(tree_view: [*c]GtkTreeView) void;
pub extern fn gtk_tree_view_get_headers_clickable(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_headers_clickable(tree_view: [*c]GtkTreeView, setting: gboolean) void;
pub extern fn gtk_tree_view_set_rules_hint(tree_view: [*c]GtkTreeView, setting: gboolean) void;
pub extern fn gtk_tree_view_get_rules_hint(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_get_activate_on_single_click(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_activate_on_single_click(tree_view: [*c]GtkTreeView, single: gboolean) void;
pub extern fn gtk_tree_view_append_column(tree_view: [*c]GtkTreeView, column: [*c]GtkTreeViewColumn) gint;
pub extern fn gtk_tree_view_remove_column(tree_view: [*c]GtkTreeView, column: [*c]GtkTreeViewColumn) gint;
pub extern fn gtk_tree_view_insert_column(tree_view: [*c]GtkTreeView, column: [*c]GtkTreeViewColumn, position: gint) gint;
pub extern fn gtk_tree_view_insert_column_with_attributes(tree_view: [*c]GtkTreeView, position: gint, title: [*c]const gchar, cell: [*c]GtkCellRenderer, ...) gint;
pub extern fn gtk_tree_view_insert_column_with_data_func(tree_view: [*c]GtkTreeView, position: gint, title: [*c]const gchar, cell: [*c]GtkCellRenderer, func: GtkTreeCellDataFunc, data: gpointer, dnotify: GDestroyNotify) gint;
pub extern fn gtk_tree_view_get_n_columns(tree_view: [*c]GtkTreeView) guint;
pub extern fn gtk_tree_view_get_column(tree_view: [*c]GtkTreeView, n: gint) [*c]GtkTreeViewColumn;
pub extern fn gtk_tree_view_get_columns(tree_view: [*c]GtkTreeView) [*c]GList;
pub extern fn gtk_tree_view_move_column_after(tree_view: [*c]GtkTreeView, column: [*c]GtkTreeViewColumn, base_column: [*c]GtkTreeViewColumn) void;
pub extern fn gtk_tree_view_set_expander_column(tree_view: [*c]GtkTreeView, column: [*c]GtkTreeViewColumn) void;
pub extern fn gtk_tree_view_get_expander_column(tree_view: [*c]GtkTreeView) [*c]GtkTreeViewColumn;
pub extern fn gtk_tree_view_set_column_drag_function(tree_view: [*c]GtkTreeView, func: GtkTreeViewColumnDropFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_view_scroll_to_point(tree_view: [*c]GtkTreeView, tree_x: gint, tree_y: gint) void;
pub extern fn gtk_tree_view_scroll_to_cell(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, column: [*c]GtkTreeViewColumn, use_align: gboolean, row_align: gfloat, col_align: gfloat) void;
pub extern fn gtk_tree_view_row_activated(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, column: [*c]GtkTreeViewColumn) void;
pub extern fn gtk_tree_view_expand_all(tree_view: [*c]GtkTreeView) void;
pub extern fn gtk_tree_view_collapse_all(tree_view: [*c]GtkTreeView) void;
pub extern fn gtk_tree_view_expand_to_path(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_view_expand_row(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, open_all: gboolean) gboolean;
pub extern fn gtk_tree_view_collapse_row(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_view_map_expanded_rows(tree_view: [*c]GtkTreeView, func: GtkTreeViewMappingFunc, data: gpointer) void;
pub extern fn gtk_tree_view_row_expanded(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_view_set_reorderable(tree_view: [*c]GtkTreeView, reorderable: gboolean) void;
pub extern fn gtk_tree_view_get_reorderable(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_cursor(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, focus_column: [*c]GtkTreeViewColumn, start_editing: gboolean) void;
pub extern fn gtk_tree_view_set_cursor_on_cell(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, focus_column: [*c]GtkTreeViewColumn, focus_cell: [*c]GtkCellRenderer, start_editing: gboolean) void;
pub extern fn gtk_tree_view_get_cursor(tree_view: [*c]GtkTreeView, path: [*c](?*GtkTreePath), focus_column: [*c]([*c]GtkTreeViewColumn)) void;
pub extern fn gtk_tree_view_get_bin_window(tree_view: [*c]GtkTreeView) ?*GdkWindow;
pub extern fn gtk_tree_view_get_path_at_pos(tree_view: [*c]GtkTreeView, x: gint, y: gint, path: [*c](?*GtkTreePath), column: [*c]([*c]GtkTreeViewColumn), cell_x: [*c]gint, cell_y: [*c]gint) gboolean;
pub extern fn gtk_tree_view_get_cell_area(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, column: [*c]GtkTreeViewColumn, rect: [*c]GdkRectangle) void;
pub extern fn gtk_tree_view_get_background_area(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, column: [*c]GtkTreeViewColumn, rect: [*c]GdkRectangle) void;
pub extern fn gtk_tree_view_get_visible_rect(tree_view: [*c]GtkTreeView, visible_rect: [*c]GdkRectangle) void;
pub extern fn gtk_tree_view_get_visible_range(tree_view: [*c]GtkTreeView, start_path: [*c](?*GtkTreePath), end_path: [*c](?*GtkTreePath)) gboolean;
pub extern fn gtk_tree_view_is_blank_at_pos(tree_view: [*c]GtkTreeView, x: gint, y: gint, path: [*c](?*GtkTreePath), column: [*c]([*c]GtkTreeViewColumn), cell_x: [*c]gint, cell_y: [*c]gint) gboolean;
pub extern fn gtk_tree_view_enable_model_drag_source(tree_view: [*c]GtkTreeView, start_button_mask: GdkModifierType, targets: [*c]const GtkTargetEntry, n_targets: gint, actions: GdkDragAction) void;
pub extern fn gtk_tree_view_enable_model_drag_dest(tree_view: [*c]GtkTreeView, targets: [*c]const GtkTargetEntry, n_targets: gint, actions: GdkDragAction) void;
pub extern fn gtk_tree_view_unset_rows_drag_source(tree_view: [*c]GtkTreeView) void;
pub extern fn gtk_tree_view_unset_rows_drag_dest(tree_view: [*c]GtkTreeView) void;
pub extern fn gtk_tree_view_set_drag_dest_row(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath, pos: GtkTreeViewDropPosition) void;
pub extern fn gtk_tree_view_get_drag_dest_row(tree_view: [*c]GtkTreeView, path: [*c](?*GtkTreePath), pos: [*c]GtkTreeViewDropPosition) void;
pub extern fn gtk_tree_view_get_dest_row_at_pos(tree_view: [*c]GtkTreeView, drag_x: gint, drag_y: gint, path: [*c](?*GtkTreePath), pos: [*c]GtkTreeViewDropPosition) gboolean;
pub extern fn gtk_tree_view_create_row_drag_icon(tree_view: [*c]GtkTreeView, path: ?*GtkTreePath) ?*cairo_surface_t;
pub extern fn gtk_tree_view_set_enable_search(tree_view: [*c]GtkTreeView, enable_search: gboolean) void;
pub extern fn gtk_tree_view_get_enable_search(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_get_search_column(tree_view: [*c]GtkTreeView) gint;
pub extern fn gtk_tree_view_set_search_column(tree_view: [*c]GtkTreeView, column: gint) void;
pub extern fn gtk_tree_view_get_search_equal_func(tree_view: [*c]GtkTreeView) GtkTreeViewSearchEqualFunc;
pub extern fn gtk_tree_view_set_search_equal_func(tree_view: [*c]GtkTreeView, search_equal_func: GtkTreeViewSearchEqualFunc, search_user_data: gpointer, search_destroy: GDestroyNotify) void;
pub extern fn gtk_tree_view_get_search_entry(tree_view: [*c]GtkTreeView) [*c]GtkEntry;
pub extern fn gtk_tree_view_set_search_entry(tree_view: [*c]GtkTreeView, entry: [*c]GtkEntry) void;
pub extern fn gtk_tree_view_get_search_position_func(tree_view: [*c]GtkTreeView) GtkTreeViewSearchPositionFunc;
pub extern fn gtk_tree_view_set_search_position_func(tree_view: [*c]GtkTreeView, func: GtkTreeViewSearchPositionFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_view_convert_widget_to_tree_coords(tree_view: [*c]GtkTreeView, wx: gint, wy: gint, tx: [*c]gint, ty: [*c]gint) void;
pub extern fn gtk_tree_view_convert_tree_to_widget_coords(tree_view: [*c]GtkTreeView, tx: gint, ty: gint, wx: [*c]gint, wy: [*c]gint) void;
pub extern fn gtk_tree_view_convert_widget_to_bin_window_coords(tree_view: [*c]GtkTreeView, wx: gint, wy: gint, bx: [*c]gint, by: [*c]gint) void;
pub extern fn gtk_tree_view_convert_bin_window_to_widget_coords(tree_view: [*c]GtkTreeView, bx: gint, by: gint, wx: [*c]gint, wy: [*c]gint) void;
pub extern fn gtk_tree_view_convert_tree_to_bin_window_coords(tree_view: [*c]GtkTreeView, tx: gint, ty: gint, bx: [*c]gint, by: [*c]gint) void;
pub extern fn gtk_tree_view_convert_bin_window_to_tree_coords(tree_view: [*c]GtkTreeView, bx: gint, by: gint, tx: [*c]gint, ty: [*c]gint) void;
pub const GtkTreeDestroyCountFunc = ?extern fn ([*c]GtkTreeView, ?*GtkTreePath, gint, gpointer) void;
pub extern fn gtk_tree_view_set_destroy_count_func(tree_view: [*c]GtkTreeView, func: GtkTreeDestroyCountFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_view_set_fixed_height_mode(tree_view: [*c]GtkTreeView, enable: gboolean) void;
pub extern fn gtk_tree_view_get_fixed_height_mode(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_hover_selection(tree_view: [*c]GtkTreeView, hover: gboolean) void;
pub extern fn gtk_tree_view_get_hover_selection(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_hover_expand(tree_view: [*c]GtkTreeView, expand: gboolean) void;
pub extern fn gtk_tree_view_get_hover_expand(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_rubber_banding(tree_view: [*c]GtkTreeView, enable: gboolean) void;
pub extern fn gtk_tree_view_get_rubber_banding(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_is_rubber_banding_active(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_get_row_separator_func(tree_view: [*c]GtkTreeView) GtkTreeViewRowSeparatorFunc;
pub extern fn gtk_tree_view_set_row_separator_func(tree_view: [*c]GtkTreeView, func: GtkTreeViewRowSeparatorFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_view_get_grid_lines(tree_view: [*c]GtkTreeView) GtkTreeViewGridLines;
pub extern fn gtk_tree_view_set_grid_lines(tree_view: [*c]GtkTreeView, grid_lines: GtkTreeViewGridLines) void;
pub extern fn gtk_tree_view_get_enable_tree_lines(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_enable_tree_lines(tree_view: [*c]GtkTreeView, enabled: gboolean) void;
pub extern fn gtk_tree_view_set_show_expanders(tree_view: [*c]GtkTreeView, enabled: gboolean) void;
pub extern fn gtk_tree_view_get_show_expanders(tree_view: [*c]GtkTreeView) gboolean;
pub extern fn gtk_tree_view_set_level_indentation(tree_view: [*c]GtkTreeView, indentation: gint) void;
pub extern fn gtk_tree_view_get_level_indentation(tree_view: [*c]GtkTreeView) gint;
pub extern fn gtk_tree_view_set_tooltip_row(tree_view: [*c]GtkTreeView, tooltip: ?*GtkTooltip, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_view_set_tooltip_cell(tree_view: [*c]GtkTreeView, tooltip: ?*GtkTooltip, path: ?*GtkTreePath, column: [*c]GtkTreeViewColumn, cell: [*c]GtkCellRenderer) void;
pub extern fn gtk_tree_view_get_tooltip_context(tree_view: [*c]GtkTreeView, x: [*c]gint, y: [*c]gint, keyboard_tip: gboolean, model: [*c](?*GtkTreeModel), path: [*c](?*GtkTreePath), iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_view_set_tooltip_column(tree_view: [*c]GtkTreeView, column: gint) void;
pub extern fn gtk_tree_view_get_tooltip_column(tree_view: [*c]GtkTreeView) gint;
pub const struct__GtkComboBoxPrivate = @OpaqueType();
pub const GtkComboBoxPrivate = struct__GtkComboBoxPrivate;
pub const struct__GtkComboBox = extern struct {
    parent_instance: GtkBin,
    priv: ?*GtkComboBoxPrivate,
};
pub const GtkComboBox = struct__GtkComboBox;
pub const struct__GtkComboBoxClass = extern struct {
    parent_class: GtkBinClass,
    changed: ?extern fn ([*c]GtkComboBox) void,
    format_entry_text: ?extern fn ([*c]GtkComboBox, [*c]const gchar) [*c]gchar,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
};
pub const GtkComboBoxClass = struct__GtkComboBoxClass;
pub extern fn gtk_combo_box_get_type() GType;
pub extern fn gtk_combo_box_new() [*c]GtkWidget;
pub extern fn gtk_combo_box_new_with_area(area: [*c]GtkCellArea) [*c]GtkWidget;
pub extern fn gtk_combo_box_new_with_area_and_entry(area: [*c]GtkCellArea) [*c]GtkWidget;
pub extern fn gtk_combo_box_new_with_entry() [*c]GtkWidget;
pub extern fn gtk_combo_box_new_with_model(model: ?*GtkTreeModel) [*c]GtkWidget;
pub extern fn gtk_combo_box_new_with_model_and_entry(model: ?*GtkTreeModel) [*c]GtkWidget;
pub extern fn gtk_combo_box_get_wrap_width(combo_box: [*c]GtkComboBox) gint;
pub extern fn gtk_combo_box_set_wrap_width(combo_box: [*c]GtkComboBox, width: gint) void;
pub extern fn gtk_combo_box_get_row_span_column(combo_box: [*c]GtkComboBox) gint;
pub extern fn gtk_combo_box_set_row_span_column(combo_box: [*c]GtkComboBox, row_span: gint) void;
pub extern fn gtk_combo_box_get_column_span_column(combo_box: [*c]GtkComboBox) gint;
pub extern fn gtk_combo_box_set_column_span_column(combo_box: [*c]GtkComboBox, column_span: gint) void;
pub extern fn gtk_combo_box_get_add_tearoffs(combo_box: [*c]GtkComboBox) gboolean;
pub extern fn gtk_combo_box_set_add_tearoffs(combo_box: [*c]GtkComboBox, add_tearoffs: gboolean) void;
pub extern fn gtk_combo_box_get_title(combo_box: [*c]GtkComboBox) [*c]const gchar;
pub extern fn gtk_combo_box_set_title(combo_box: [*c]GtkComboBox, title: [*c]const gchar) void;
pub extern fn gtk_combo_box_get_focus_on_click(combo: [*c]GtkComboBox) gboolean;
pub extern fn gtk_combo_box_set_focus_on_click(combo: [*c]GtkComboBox, focus_on_click: gboolean) void;
pub extern fn gtk_combo_box_get_active(combo_box: [*c]GtkComboBox) gint;
pub extern fn gtk_combo_box_set_active(combo_box: [*c]GtkComboBox, index_: gint) void;
pub extern fn gtk_combo_box_get_active_iter(combo_box: [*c]GtkComboBox, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_combo_box_set_active_iter(combo_box: [*c]GtkComboBox, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_combo_box_set_model(combo_box: [*c]GtkComboBox, model: ?*GtkTreeModel) void;
pub extern fn gtk_combo_box_get_model(combo_box: [*c]GtkComboBox) ?*GtkTreeModel;
pub extern fn gtk_combo_box_get_row_separator_func(combo_box: [*c]GtkComboBox) GtkTreeViewRowSeparatorFunc;
pub extern fn gtk_combo_box_set_row_separator_func(combo_box: [*c]GtkComboBox, func: GtkTreeViewRowSeparatorFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_combo_box_set_button_sensitivity(combo_box: [*c]GtkComboBox, sensitivity: GtkSensitivityType) void;
pub extern fn gtk_combo_box_get_button_sensitivity(combo_box: [*c]GtkComboBox) GtkSensitivityType;
pub extern fn gtk_combo_box_get_has_entry(combo_box: [*c]GtkComboBox) gboolean;
pub extern fn gtk_combo_box_set_entry_text_column(combo_box: [*c]GtkComboBox, text_column: gint) void;
pub extern fn gtk_combo_box_get_entry_text_column(combo_box: [*c]GtkComboBox) gint;
pub extern fn gtk_combo_box_set_popup_fixed_width(combo_box: [*c]GtkComboBox, fixed: gboolean) void;
pub extern fn gtk_combo_box_get_popup_fixed_width(combo_box: [*c]GtkComboBox) gboolean;
pub extern fn gtk_combo_box_popup(combo_box: [*c]GtkComboBox) void;
pub extern fn gtk_combo_box_popup_for_device(combo_box: [*c]GtkComboBox, device: ?*GdkDevice) void;
pub extern fn gtk_combo_box_popdown(combo_box: [*c]GtkComboBox) void;
pub extern fn gtk_combo_box_get_popup_accessible(combo_box: [*c]GtkComboBox) [*c]AtkObject;
pub extern fn gtk_combo_box_get_id_column(combo_box: [*c]GtkComboBox) gint;
pub extern fn gtk_combo_box_set_id_column(combo_box: [*c]GtkComboBox, id_column: gint) void;
pub extern fn gtk_combo_box_get_active_id(combo_box: [*c]GtkComboBox) [*c]const gchar;
pub extern fn gtk_combo_box_set_active_id(combo_box: [*c]GtkComboBox, active_id: [*c]const gchar) gboolean;
pub const struct__GtkAppChooserButtonPrivate = @OpaqueType();
pub const GtkAppChooserButtonPrivate = struct__GtkAppChooserButtonPrivate;
pub const struct__GtkAppChooserButton = extern struct {
    parent: GtkComboBox,
    priv: ?*GtkAppChooserButtonPrivate,
};
pub const GtkAppChooserButton = struct__GtkAppChooserButton;
pub const struct__GtkAppChooserButtonClass = extern struct {
    parent_class: GtkComboBoxClass,
    custom_item_activated: ?extern fn ([*c]GtkAppChooserButton, [*c]const gchar) void,
    padding: [16]gpointer,
};
pub const GtkAppChooserButtonClass = struct__GtkAppChooserButtonClass;
pub extern fn gtk_app_chooser_button_get_type() GType;
pub extern fn gtk_app_chooser_button_new(content_type: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_app_chooser_button_append_separator(self: [*c]GtkAppChooserButton) void;
pub extern fn gtk_app_chooser_button_append_custom_item(self: [*c]GtkAppChooserButton, name: [*c]const gchar, label: [*c]const gchar, icon: ?*GIcon) void;
pub extern fn gtk_app_chooser_button_set_active_custom_item(self: [*c]GtkAppChooserButton, name: [*c]const gchar) void;
pub extern fn gtk_app_chooser_button_set_show_dialog_item(self: [*c]GtkAppChooserButton, setting: gboolean) void;
pub extern fn gtk_app_chooser_button_get_show_dialog_item(self: [*c]GtkAppChooserButton) gboolean;
pub extern fn gtk_app_chooser_button_set_heading(self: [*c]GtkAppChooserButton, heading: [*c]const gchar) void;
pub extern fn gtk_app_chooser_button_get_heading(self: [*c]GtkAppChooserButton) [*c]const gchar;
pub extern fn gtk_app_chooser_button_set_show_default_item(self: [*c]GtkAppChooserButton, setting: gboolean) void;
pub extern fn gtk_app_chooser_button_get_show_default_item(self: [*c]GtkAppChooserButton) gboolean;
pub const struct__GtkShortcutsWindow = extern struct {
    window: GtkWindow,
};
pub const GtkShortcutsWindow = struct__GtkShortcutsWindow;
pub const struct__GtkShortcutsWindowClass = extern struct {
    parent_class: GtkWindowClass,
    close: ?extern fn ([*c]GtkShortcutsWindow) void,
    search: ?extern fn ([*c]GtkShortcutsWindow) void,
};
pub const GtkShortcutsWindowClass = struct__GtkShortcutsWindowClass;
pub extern fn gtk_shortcuts_window_get_type() GType;
pub const GtkShortcutsWindow_autoptr = [*c]GtkShortcutsWindow;
pub const GtkShortcutsWindow_listautoptr = [*c]GList;
pub const GtkShortcutsWindow_slistautoptr = [*c]GSList;
pub const GtkShortcutsWindow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkShortcutsWindow(_ptr: [*c]GtkShortcutsWindow) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkShortcutsWindow(_ptr: [*c]([*c]GtkShortcutsWindow)) void {
    glib_autoptr_clear_GtkShortcutsWindow(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkShortcutsWindow(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkShortcutsWindow(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkShortcutsWindow(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__GtkApplicationWindowPrivate = @OpaqueType();
pub const GtkApplicationWindowPrivate = struct__GtkApplicationWindowPrivate;
pub const struct__GtkApplicationWindowClass = extern struct {
    parent_class: GtkWindowClass,
    padding: [14]gpointer,
};
pub const GtkApplicationWindowClass = struct__GtkApplicationWindowClass;
pub const struct__GtkApplicationWindow = extern struct {
    parent_instance: GtkWindow,
    priv: ?*GtkApplicationWindowPrivate,
};
pub const GtkApplicationWindow = struct__GtkApplicationWindow;
pub extern fn gtk_application_window_get_type() GType;
pub extern fn gtk_application_window_new(application: [*c]GtkApplication) [*c]GtkWidget;
pub extern fn gtk_application_window_set_show_menubar(window: [*c]GtkApplicationWindow, show_menubar: gboolean) void;
pub extern fn gtk_application_window_get_show_menubar(window: [*c]GtkApplicationWindow) gboolean;
pub extern fn gtk_application_window_get_id(window: [*c]GtkApplicationWindow) guint;
pub extern fn gtk_application_window_set_help_overlay(window: [*c]GtkApplicationWindow, help_overlay: [*c]GtkShortcutsWindow) void;
pub extern fn gtk_application_window_get_help_overlay(window: [*c]GtkApplicationWindow) [*c]GtkShortcutsWindow;
pub const struct__GtkFramePrivate = @OpaqueType();
pub const GtkFramePrivate = struct__GtkFramePrivate;
pub const struct__GtkFrame = extern struct {
    bin: GtkBin,
    priv: ?*GtkFramePrivate,
};
pub const GtkFrame = struct__GtkFrame;
pub const struct__GtkFrameClass = extern struct {
    parent_class: GtkBinClass,
    compute_child_allocation: ?extern fn ([*c]GtkFrame, [*c]GtkAllocation) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkFrameClass = struct__GtkFrameClass;
pub extern fn gtk_frame_get_type() GType;
pub extern fn gtk_frame_new(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_frame_set_label(frame: [*c]GtkFrame, label: [*c]const gchar) void;
pub extern fn gtk_frame_get_label(frame: [*c]GtkFrame) [*c]const gchar;
pub extern fn gtk_frame_set_label_widget(frame: [*c]GtkFrame, label_widget: [*c]GtkWidget) void;
pub extern fn gtk_frame_get_label_widget(frame: [*c]GtkFrame) [*c]GtkWidget;
pub extern fn gtk_frame_set_label_align(frame: [*c]GtkFrame, xalign: gfloat, yalign: gfloat) void;
pub extern fn gtk_frame_get_label_align(frame: [*c]GtkFrame, xalign: [*c]gfloat, yalign: [*c]gfloat) void;
pub extern fn gtk_frame_set_shadow_type(frame: [*c]GtkFrame, type_0: GtkShadowType) void;
pub extern fn gtk_frame_get_shadow_type(frame: [*c]GtkFrame) GtkShadowType;
pub const struct__GtkAspectFramePrivate = @OpaqueType();
pub const GtkAspectFramePrivate = struct__GtkAspectFramePrivate;
pub const struct__GtkAspectFrame = extern struct {
    frame: GtkFrame,
    priv: ?*GtkAspectFramePrivate,
};
pub const GtkAspectFrame = struct__GtkAspectFrame;
pub const struct__GtkAspectFrameClass = extern struct {
    parent_class: GtkFrameClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkAspectFrameClass = struct__GtkAspectFrameClass;
pub extern fn gtk_aspect_frame_get_type() GType;
pub extern fn gtk_aspect_frame_new(label: [*c]const gchar, xalign: gfloat, yalign: gfloat, ratio: gfloat, obey_child: gboolean) [*c]GtkWidget;
pub extern fn gtk_aspect_frame_set(aspect_frame: [*c]GtkAspectFrame, xalign: gfloat, yalign: gfloat, ratio: gfloat, obey_child: gboolean) void;
pub const GTK_ASSISTANT_PAGE_CONTENT = 0;
pub const GTK_ASSISTANT_PAGE_INTRO = 1;
pub const GTK_ASSISTANT_PAGE_CONFIRM = 2;
pub const GTK_ASSISTANT_PAGE_SUMMARY = 3;
pub const GTK_ASSISTANT_PAGE_PROGRESS = 4;
pub const GTK_ASSISTANT_PAGE_CUSTOM = 5;
pub const GtkAssistantPageType = extern enum {
    GTK_ASSISTANT_PAGE_CONTENT = 0,
    GTK_ASSISTANT_PAGE_INTRO = 1,
    GTK_ASSISTANT_PAGE_CONFIRM = 2,
    GTK_ASSISTANT_PAGE_SUMMARY = 3,
    GTK_ASSISTANT_PAGE_PROGRESS = 4,
    GTK_ASSISTANT_PAGE_CUSTOM = 5,
};
pub const struct__GtkAssistantPrivate = @OpaqueType();
pub const GtkAssistantPrivate = struct__GtkAssistantPrivate;
pub const struct__GtkAssistant = extern struct {
    parent: GtkWindow,
    priv: ?*GtkAssistantPrivate,
};
pub const GtkAssistant = struct__GtkAssistant;
pub const struct__GtkAssistantClass = extern struct {
    parent_class: GtkWindowClass,
    prepare: ?extern fn ([*c]GtkAssistant, [*c]GtkWidget) void,
    apply: ?extern fn ([*c]GtkAssistant) void,
    close: ?extern fn ([*c]GtkAssistant) void,
    cancel: ?extern fn ([*c]GtkAssistant) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
};
pub const GtkAssistantClass = struct__GtkAssistantClass;
pub const GtkAssistantPageFunc = ?extern fn (gint, gpointer) gint;
pub extern fn gtk_assistant_get_type() GType;
pub extern fn gtk_assistant_new() [*c]GtkWidget;
pub extern fn gtk_assistant_next_page(assistant: [*c]GtkAssistant) void;
pub extern fn gtk_assistant_previous_page(assistant: [*c]GtkAssistant) void;
pub extern fn gtk_assistant_get_current_page(assistant: [*c]GtkAssistant) gint;
pub extern fn gtk_assistant_set_current_page(assistant: [*c]GtkAssistant, page_num: gint) void;
pub extern fn gtk_assistant_get_n_pages(assistant: [*c]GtkAssistant) gint;
pub extern fn gtk_assistant_get_nth_page(assistant: [*c]GtkAssistant, page_num: gint) [*c]GtkWidget;
pub extern fn gtk_assistant_prepend_page(assistant: [*c]GtkAssistant, page: [*c]GtkWidget) gint;
pub extern fn gtk_assistant_append_page(assistant: [*c]GtkAssistant, page: [*c]GtkWidget) gint;
pub extern fn gtk_assistant_insert_page(assistant: [*c]GtkAssistant, page: [*c]GtkWidget, position: gint) gint;
pub extern fn gtk_assistant_remove_page(assistant: [*c]GtkAssistant, page_num: gint) void;
pub extern fn gtk_assistant_set_forward_page_func(assistant: [*c]GtkAssistant, page_func: GtkAssistantPageFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_assistant_set_page_type(assistant: [*c]GtkAssistant, page: [*c]GtkWidget, type_0: GtkAssistantPageType) void;
pub extern fn gtk_assistant_get_page_type(assistant: [*c]GtkAssistant, page: [*c]GtkWidget) GtkAssistantPageType;
pub extern fn gtk_assistant_set_page_title(assistant: [*c]GtkAssistant, page: [*c]GtkWidget, title: [*c]const gchar) void;
pub extern fn gtk_assistant_get_page_title(assistant: [*c]GtkAssistant, page: [*c]GtkWidget) [*c]const gchar;
pub extern fn gtk_assistant_set_page_header_image(assistant: [*c]GtkAssistant, page: [*c]GtkWidget, pixbuf: ?*GdkPixbuf) void;
pub extern fn gtk_assistant_get_page_header_image(assistant: [*c]GtkAssistant, page: [*c]GtkWidget) ?*GdkPixbuf;
pub extern fn gtk_assistant_set_page_side_image(assistant: [*c]GtkAssistant, page: [*c]GtkWidget, pixbuf: ?*GdkPixbuf) void;
pub extern fn gtk_assistant_get_page_side_image(assistant: [*c]GtkAssistant, page: [*c]GtkWidget) ?*GdkPixbuf;
pub extern fn gtk_assistant_set_page_complete(assistant: [*c]GtkAssistant, page: [*c]GtkWidget, complete: gboolean) void;
pub extern fn gtk_assistant_get_page_complete(assistant: [*c]GtkAssistant, page: [*c]GtkWidget) gboolean;
pub extern fn gtk_assistant_add_action_widget(assistant: [*c]GtkAssistant, child: [*c]GtkWidget) void;
pub extern fn gtk_assistant_remove_action_widget(assistant: [*c]GtkAssistant, child: [*c]GtkWidget) void;
pub extern fn gtk_assistant_update_buttons_state(assistant: [*c]GtkAssistant) void;
pub extern fn gtk_assistant_commit(assistant: [*c]GtkAssistant) void;
pub extern fn gtk_assistant_set_page_has_padding(assistant: [*c]GtkAssistant, page: [*c]GtkWidget, has_padding: gboolean) void;
pub extern fn gtk_assistant_get_page_has_padding(assistant: [*c]GtkAssistant, page: [*c]GtkWidget) gboolean;
pub const struct__GtkButtonBoxPrivate = @OpaqueType();
pub const GtkButtonBoxPrivate = struct__GtkButtonBoxPrivate;
pub const struct__GtkButtonBox = extern struct {
    box: GtkBox,
    priv: ?*GtkButtonBoxPrivate,
};
pub const GtkButtonBox = struct__GtkButtonBox;
pub const struct__GtkButtonBoxClass = extern struct {
    parent_class: GtkBoxClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkButtonBoxClass = struct__GtkButtonBoxClass;
pub const GTK_BUTTONBOX_SPREAD = 1;
pub const GTK_BUTTONBOX_EDGE = 2;
pub const GTK_BUTTONBOX_START = 3;
pub const GTK_BUTTONBOX_END = 4;
pub const GTK_BUTTONBOX_CENTER = 5;
pub const GTK_BUTTONBOX_EXPAND = 6;
pub const GtkButtonBoxStyle = extern enum {
    GTK_BUTTONBOX_SPREAD = 1,
    GTK_BUTTONBOX_EDGE = 2,
    GTK_BUTTONBOX_START = 3,
    GTK_BUTTONBOX_END = 4,
    GTK_BUTTONBOX_CENTER = 5,
    GTK_BUTTONBOX_EXPAND = 6,
};
pub extern fn gtk_button_box_get_type() GType;
pub extern fn gtk_button_box_new(orientation: GtkOrientation) [*c]GtkWidget;
pub extern fn gtk_button_box_get_layout(widget: [*c]GtkButtonBox) GtkButtonBoxStyle;
pub extern fn gtk_button_box_set_layout(widget: [*c]GtkButtonBox, layout_style: GtkButtonBoxStyle) void;
pub extern fn gtk_button_box_get_child_secondary(widget: [*c]GtkButtonBox, child: [*c]GtkWidget) gboolean;
pub extern fn gtk_button_box_set_child_secondary(widget: [*c]GtkButtonBox, child: [*c]GtkWidget, is_secondary: gboolean) void;
pub extern fn gtk_button_box_get_child_non_homogeneous(widget: [*c]GtkButtonBox, child: [*c]GtkWidget) gboolean;
pub extern fn gtk_button_box_set_child_non_homogeneous(widget: [*c]GtkButtonBox, child: [*c]GtkWidget, non_homogeneous: gboolean) void;
pub const struct__GtkBindingSet = @OpaqueType();
pub const GtkBindingSet = struct__GtkBindingSet;
pub const struct__GtkBindingEntry = @OpaqueType();
pub const GtkBindingEntry = struct__GtkBindingEntry;
pub const GtkBindingSignal = struct__GtkBindingSignal;
pub const struct__GtkBindingArg = extern struct {
    arg_type: GType,
    d: extern union {
        long_data: glong,
        double_data: gdouble,
        string_data: [*c]gchar,
    },
};
pub const GtkBindingArg = struct__GtkBindingArg;
pub const struct__GtkBindingSignal = extern struct {
    next: [*c]GtkBindingSignal,
    signal_name: [*c]gchar,
    n_args: guint,
    args: [*c]GtkBindingArg,
};
pub extern fn gtk_binding_set_new(set_name: [*c]const gchar) ?*GtkBindingSet;
pub extern fn gtk_binding_set_by_class(object_class: gpointer) ?*GtkBindingSet;
pub extern fn gtk_binding_set_find(set_name: [*c]const gchar) ?*GtkBindingSet;
pub extern fn gtk_bindings_activate(object: [*c]GObject, keyval: guint, modifiers: GdkModifierType) gboolean;
pub extern fn gtk_bindings_activate_event(object: [*c]GObject, event: ?*GdkEventKey) gboolean;
pub extern fn gtk_binding_set_activate(binding_set: ?*GtkBindingSet, keyval: guint, modifiers: GdkModifierType, object: [*c]GObject) gboolean;
pub extern fn gtk_binding_entry_skip(binding_set: ?*GtkBindingSet, keyval: guint, modifiers: GdkModifierType) void;
pub extern fn gtk_binding_entry_add_signal(binding_set: ?*GtkBindingSet, keyval: guint, modifiers: GdkModifierType, signal_name: [*c]const gchar, n_args: guint, ...) void;
pub extern fn gtk_binding_entry_add_signall(binding_set: ?*GtkBindingSet, keyval: guint, modifiers: GdkModifierType, signal_name: [*c]const gchar, binding_args: [*c]GSList) void;
pub extern fn gtk_binding_entry_add_signal_from_string(binding_set: ?*GtkBindingSet, signal_desc: [*c]const gchar) GTokenType;
pub extern fn gtk_binding_entry_remove(binding_set: ?*GtkBindingSet, keyval: guint, modifiers: GdkModifierType) void;
pub const struct__GtkBuilderClass = extern struct {
    parent_class: GObjectClass,
    get_type_from_name: ?extern fn ([*c]GtkBuilder, [*c]const u8) GType,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
    _gtk_reserved8: ?extern fn () void,
};
pub const GtkBuilderClass = struct__GtkBuilderClass;
pub const GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION = 0;
pub const GTK_BUILDER_ERROR_UNHANDLED_TAG = 1;
pub const GTK_BUILDER_ERROR_MISSING_ATTRIBUTE = 2;
pub const GTK_BUILDER_ERROR_INVALID_ATTRIBUTE = 3;
pub const GTK_BUILDER_ERROR_INVALID_TAG = 4;
pub const GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE = 5;
pub const GTK_BUILDER_ERROR_INVALID_VALUE = 6;
pub const GTK_BUILDER_ERROR_VERSION_MISMATCH = 7;
pub const GTK_BUILDER_ERROR_DUPLICATE_ID = 8;
pub const GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED = 9;
pub const GTK_BUILDER_ERROR_TEMPLATE_MISMATCH = 10;
pub const GTK_BUILDER_ERROR_INVALID_PROPERTY = 11;
pub const GTK_BUILDER_ERROR_INVALID_SIGNAL = 12;
pub const GTK_BUILDER_ERROR_INVALID_ID = 13;
pub const GtkBuilderError = extern enum {
    GTK_BUILDER_ERROR_INVALID_TYPE_FUNCTION = 0,
    GTK_BUILDER_ERROR_UNHANDLED_TAG = 1,
    GTK_BUILDER_ERROR_MISSING_ATTRIBUTE = 2,
    GTK_BUILDER_ERROR_INVALID_ATTRIBUTE = 3,
    GTK_BUILDER_ERROR_INVALID_TAG = 4,
    GTK_BUILDER_ERROR_MISSING_PROPERTY_VALUE = 5,
    GTK_BUILDER_ERROR_INVALID_VALUE = 6,
    GTK_BUILDER_ERROR_VERSION_MISMATCH = 7,
    GTK_BUILDER_ERROR_DUPLICATE_ID = 8,
    GTK_BUILDER_ERROR_OBJECT_TYPE_REFUSED = 9,
    GTK_BUILDER_ERROR_TEMPLATE_MISMATCH = 10,
    GTK_BUILDER_ERROR_INVALID_PROPERTY = 11,
    GTK_BUILDER_ERROR_INVALID_SIGNAL = 12,
    GTK_BUILDER_ERROR_INVALID_ID = 13,
};
pub extern fn gtk_builder_error_quark() GQuark;
pub extern fn gtk_builder_get_type() GType;
pub extern fn gtk_builder_new() [*c]GtkBuilder;
pub extern fn gtk_builder_add_from_file(builder: [*c]GtkBuilder, filename: [*c]const gchar, @"error": [*c]([*c]GError)) guint;
pub extern fn gtk_builder_add_from_resource(builder: [*c]GtkBuilder, resource_path: [*c]const gchar, @"error": [*c]([*c]GError)) guint;
pub extern fn gtk_builder_add_from_string(builder: [*c]GtkBuilder, buffer: [*c]const gchar, length: gsize, @"error": [*c]([*c]GError)) guint;
pub extern fn gtk_builder_add_objects_from_file(builder: [*c]GtkBuilder, filename: [*c]const gchar, object_ids: [*c]([*c]gchar), @"error": [*c]([*c]GError)) guint;
pub extern fn gtk_builder_add_objects_from_resource(builder: [*c]GtkBuilder, resource_path: [*c]const gchar, object_ids: [*c]([*c]gchar), @"error": [*c]([*c]GError)) guint;
pub extern fn gtk_builder_add_objects_from_string(builder: [*c]GtkBuilder, buffer: [*c]const gchar, length: gsize, object_ids: [*c]([*c]gchar), @"error": [*c]([*c]GError)) guint;
pub extern fn gtk_builder_get_object(builder: [*c]GtkBuilder, name: [*c]const gchar) [*c]GObject;
pub extern fn gtk_builder_get_objects(builder: [*c]GtkBuilder) [*c]GSList;
pub extern fn gtk_builder_expose_object(builder: [*c]GtkBuilder, name: [*c]const gchar, object: [*c]GObject) void;
pub extern fn gtk_builder_connect_signals(builder: [*c]GtkBuilder, user_data: gpointer) void;
pub extern fn gtk_builder_connect_signals_full(builder: [*c]GtkBuilder, func: GtkBuilderConnectFunc, user_data: gpointer) void;
pub extern fn gtk_builder_set_translation_domain(builder: [*c]GtkBuilder, domain: [*c]const gchar) void;
pub extern fn gtk_builder_get_translation_domain(builder: [*c]GtkBuilder) [*c]const gchar;
pub extern fn gtk_builder_get_type_from_name(builder: [*c]GtkBuilder, type_name: [*c]const u8) GType;
pub extern fn gtk_builder_value_from_string(builder: [*c]GtkBuilder, pspec: [*c]GParamSpec, string: [*c]const gchar, value: [*c]GValue, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_builder_value_from_string_type(builder: [*c]GtkBuilder, type_0: GType, string: [*c]const gchar, value: [*c]GValue, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_builder_new_from_file(filename: [*c]const gchar) [*c]GtkBuilder;
pub extern fn gtk_builder_new_from_resource(resource_path: [*c]const gchar) [*c]GtkBuilder;
pub extern fn gtk_builder_new_from_string(string: [*c]const gchar, length: gssize) [*c]GtkBuilder;
pub extern fn gtk_builder_add_callback_symbol(builder: [*c]GtkBuilder, callback_name: [*c]const gchar, callback_symbol: GCallback) void;
pub extern fn gtk_builder_add_callback_symbols(builder: [*c]GtkBuilder, first_callback_name: [*c]const gchar, first_callback_symbol: GCallback, ...) void;
pub extern fn gtk_builder_lookup_callback_symbol(builder: [*c]GtkBuilder, callback_name: [*c]const gchar) GCallback;
pub extern fn gtk_builder_set_application(builder: [*c]GtkBuilder, application: [*c]GtkApplication) void;
pub extern fn gtk_builder_get_application(builder: [*c]GtkBuilder) [*c]GtkApplication;
pub extern fn gtk_builder_extend_with_template(builder: [*c]GtkBuilder, widget: [*c]GtkWidget, template_type: GType, buffer: [*c]const gchar, length: gsize, @"error": [*c]([*c]GError)) guint;
pub const struct__GtkBuildable = @OpaqueType();
pub const GtkBuildable = struct__GtkBuildable;
pub const struct__GtkBuildableIface = extern struct {
    g_iface: GTypeInterface,
    set_name: ?extern fn (?*GtkBuildable, [*c]const gchar) void,
    get_name: ?extern fn (?*GtkBuildable) [*c]const gchar,
    add_child: ?extern fn (?*GtkBuildable, [*c]GtkBuilder, [*c]GObject, [*c]const gchar) void,
    set_buildable_property: ?extern fn (?*GtkBuildable, [*c]GtkBuilder, [*c]const gchar, [*c]const GValue) void,
    construct_child: ?extern fn (?*GtkBuildable, [*c]GtkBuilder, [*c]const gchar) [*c]GObject,
    custom_tag_start: ?extern fn (?*GtkBuildable, [*c]GtkBuilder, [*c]GObject, [*c]const gchar, [*c]GMarkupParser, [*c]gpointer) gboolean,
    custom_tag_end: ?extern fn (?*GtkBuildable, [*c]GtkBuilder, [*c]GObject, [*c]const gchar, [*c]gpointer) void,
    custom_finished: ?extern fn (?*GtkBuildable, [*c]GtkBuilder, [*c]GObject, [*c]const gchar, gpointer) void,
    parser_finished: ?extern fn (?*GtkBuildable, [*c]GtkBuilder) void,
    get_internal_child: ?extern fn (?*GtkBuildable, [*c]GtkBuilder, [*c]const gchar) [*c]GObject,
};
pub const GtkBuildableIface = struct__GtkBuildableIface;
pub extern fn gtk_buildable_get_type() GType;
pub extern fn gtk_buildable_set_name(buildable: ?*GtkBuildable, name: [*c]const gchar) void;
pub extern fn gtk_buildable_get_name(buildable: ?*GtkBuildable) [*c]const gchar;
pub extern fn gtk_buildable_add_child(buildable: ?*GtkBuildable, builder: [*c]GtkBuilder, child: [*c]GObject, type_0: [*c]const gchar) void;
pub extern fn gtk_buildable_set_buildable_property(buildable: ?*GtkBuildable, builder: [*c]GtkBuilder, name: [*c]const gchar, value: [*c]const GValue) void;
pub extern fn gtk_buildable_construct_child(buildable: ?*GtkBuildable, builder: [*c]GtkBuilder, name: [*c]const gchar) [*c]GObject;
pub extern fn gtk_buildable_custom_tag_start(buildable: ?*GtkBuildable, builder: [*c]GtkBuilder, child: [*c]GObject, tagname: [*c]const gchar, parser: [*c]GMarkupParser, data: [*c]gpointer) gboolean;
pub extern fn gtk_buildable_custom_tag_end(buildable: ?*GtkBuildable, builder: [*c]GtkBuilder, child: [*c]GObject, tagname: [*c]const gchar, data: [*c]gpointer) void;
pub extern fn gtk_buildable_custom_finished(buildable: ?*GtkBuildable, builder: [*c]GtkBuilder, child: [*c]GObject, tagname: [*c]const gchar, data: gpointer) void;
pub extern fn gtk_buildable_parser_finished(buildable: ?*GtkBuildable, builder: [*c]GtkBuilder) void;
pub extern fn gtk_buildable_get_internal_child(buildable: ?*GtkBuildable, builder: [*c]GtkBuilder, childname: [*c]const gchar) [*c]GObject;
pub const struct__GtkButtonPrivate = @OpaqueType();
pub const GtkButtonPrivate = struct__GtkButtonPrivate;
pub const struct__GtkButton = extern struct {
    bin: GtkBin,
    priv: ?*GtkButtonPrivate,
};
pub const GtkButton = struct__GtkButton;
pub const struct__GtkButtonClass = extern struct {
    parent_class: GtkBinClass,
    pressed: ?extern fn ([*c]GtkButton) void,
    released: ?extern fn ([*c]GtkButton) void,
    clicked: ?extern fn ([*c]GtkButton) void,
    enter: ?extern fn ([*c]GtkButton) void,
    leave: ?extern fn ([*c]GtkButton) void,
    activate: ?extern fn ([*c]GtkButton) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkButtonClass = struct__GtkButtonClass;
pub extern fn gtk_button_get_type() GType;
pub extern fn gtk_button_new() [*c]GtkWidget;
pub extern fn gtk_button_new_with_label(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_button_new_from_icon_name(icon_name: [*c]const gchar, size: GtkIconSize) [*c]GtkWidget;
pub extern fn gtk_button_new_from_stock(stock_id: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_button_new_with_mnemonic(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_button_clicked(button: [*c]GtkButton) void;
pub extern fn gtk_button_pressed(button: [*c]GtkButton) void;
pub extern fn gtk_button_released(button: [*c]GtkButton) void;
pub extern fn gtk_button_enter(button: [*c]GtkButton) void;
pub extern fn gtk_button_leave(button: [*c]GtkButton) void;
pub extern fn gtk_button_set_relief(button: [*c]GtkButton, relief: GtkReliefStyle) void;
pub extern fn gtk_button_get_relief(button: [*c]GtkButton) GtkReliefStyle;
pub extern fn gtk_button_set_label(button: [*c]GtkButton, label: [*c]const gchar) void;
pub extern fn gtk_button_get_label(button: [*c]GtkButton) [*c]const gchar;
pub extern fn gtk_button_set_use_underline(button: [*c]GtkButton, use_underline: gboolean) void;
pub extern fn gtk_button_get_use_underline(button: [*c]GtkButton) gboolean;
pub extern fn gtk_button_set_use_stock(button: [*c]GtkButton, use_stock: gboolean) void;
pub extern fn gtk_button_get_use_stock(button: [*c]GtkButton) gboolean;
pub extern fn gtk_button_set_focus_on_click(button: [*c]GtkButton, focus_on_click: gboolean) void;
pub extern fn gtk_button_get_focus_on_click(button: [*c]GtkButton) gboolean;
pub extern fn gtk_button_set_alignment(button: [*c]GtkButton, xalign: gfloat, yalign: gfloat) void;
pub extern fn gtk_button_get_alignment(button: [*c]GtkButton, xalign: [*c]gfloat, yalign: [*c]gfloat) void;
pub extern fn gtk_button_set_image(button: [*c]GtkButton, image: [*c]GtkWidget) void;
pub extern fn gtk_button_get_image(button: [*c]GtkButton) [*c]GtkWidget;
pub extern fn gtk_button_set_image_position(button: [*c]GtkButton, position: GtkPositionType) void;
pub extern fn gtk_button_get_image_position(button: [*c]GtkButton) GtkPositionType;
pub extern fn gtk_button_set_always_show_image(button: [*c]GtkButton, always_show: gboolean) void;
pub extern fn gtk_button_get_always_show_image(button: [*c]GtkButton) gboolean;
pub extern fn gtk_button_get_event_window(button: [*c]GtkButton) ?*GdkWindow;
pub const struct__GtkCalendarPrivate = @OpaqueType();
pub const GtkCalendarPrivate = struct__GtkCalendarPrivate;
pub const struct__GtkCalendar = extern struct {
    widget: GtkWidget,
    priv: ?*GtkCalendarPrivate,
};
pub const GtkCalendar = struct__GtkCalendar;
pub const struct__GtkCalendarClass = extern struct {
    parent_class: GtkWidgetClass,
    month_changed: ?extern fn ([*c]GtkCalendar) void,
    day_selected: ?extern fn ([*c]GtkCalendar) void,
    day_selected_double_click: ?extern fn ([*c]GtkCalendar) void,
    prev_month: ?extern fn ([*c]GtkCalendar) void,
    next_month: ?extern fn ([*c]GtkCalendar) void,
    prev_year: ?extern fn ([*c]GtkCalendar) void,
    next_year: ?extern fn ([*c]GtkCalendar) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCalendarClass = struct__GtkCalendarClass;
pub const GTK_CALENDAR_SHOW_HEADING = 1;
pub const GTK_CALENDAR_SHOW_DAY_NAMES = 2;
pub const GTK_CALENDAR_NO_MONTH_CHANGE = 4;
pub const GTK_CALENDAR_SHOW_WEEK_NUMBERS = 8;
pub const GTK_CALENDAR_SHOW_DETAILS = 32;
pub const GtkCalendarDisplayOptions = extern enum {
    GTK_CALENDAR_SHOW_HEADING = 1,
    GTK_CALENDAR_SHOW_DAY_NAMES = 2,
    GTK_CALENDAR_NO_MONTH_CHANGE = 4,
    GTK_CALENDAR_SHOW_WEEK_NUMBERS = 8,
    GTK_CALENDAR_SHOW_DETAILS = 32,
};
pub const GtkCalendarDetailFunc = ?extern fn ([*c]GtkCalendar, guint, guint, guint, gpointer) [*c]gchar;
pub extern fn gtk_calendar_get_type() GType;
pub extern fn gtk_calendar_new() [*c]GtkWidget;
pub extern fn gtk_calendar_select_month(calendar: [*c]GtkCalendar, month: guint, year: guint) void;
pub extern fn gtk_calendar_select_day(calendar: [*c]GtkCalendar, day: guint) void;
pub extern fn gtk_calendar_mark_day(calendar: [*c]GtkCalendar, day: guint) void;
pub extern fn gtk_calendar_unmark_day(calendar: [*c]GtkCalendar, day: guint) void;
pub extern fn gtk_calendar_clear_marks(calendar: [*c]GtkCalendar) void;
pub extern fn gtk_calendar_set_display_options(calendar: [*c]GtkCalendar, flags: GtkCalendarDisplayOptions) void;
pub extern fn gtk_calendar_get_display_options(calendar: [*c]GtkCalendar) GtkCalendarDisplayOptions;
pub extern fn gtk_calendar_get_date(calendar: [*c]GtkCalendar, year: [*c]guint, month: [*c]guint, day: [*c]guint) void;
pub extern fn gtk_calendar_set_detail_func(calendar: [*c]GtkCalendar, func: GtkCalendarDetailFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_calendar_set_detail_width_chars(calendar: [*c]GtkCalendar, chars: gint) void;
pub extern fn gtk_calendar_set_detail_height_rows(calendar: [*c]GtkCalendar, rows: gint) void;
pub extern fn gtk_calendar_get_detail_width_chars(calendar: [*c]GtkCalendar) gint;
pub extern fn gtk_calendar_get_detail_height_rows(calendar: [*c]GtkCalendar) gint;
pub extern fn gtk_calendar_get_day_is_marked(calendar: [*c]GtkCalendar, day: guint) gboolean;
pub const struct__GtkCellAreaBoxPrivate = @OpaqueType();
pub const GtkCellAreaBoxPrivate = struct__GtkCellAreaBoxPrivate;
pub const struct__GtkCellAreaBox = extern struct {
    parent_instance: GtkCellArea,
    priv: ?*GtkCellAreaBoxPrivate,
};
pub const GtkCellAreaBox = struct__GtkCellAreaBox;
pub const struct__GtkCellAreaBoxClass = extern struct {
    parent_class: GtkCellAreaClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCellAreaBoxClass = struct__GtkCellAreaBoxClass;
pub extern fn gtk_cell_area_box_get_type() GType;
pub extern fn gtk_cell_area_box_new() [*c]GtkCellArea;
pub extern fn gtk_cell_area_box_pack_start(box: [*c]GtkCellAreaBox, renderer: [*c]GtkCellRenderer, expand: gboolean, @"align": gboolean, fixed: gboolean) void;
pub extern fn gtk_cell_area_box_pack_end(box: [*c]GtkCellAreaBox, renderer: [*c]GtkCellRenderer, expand: gboolean, @"align": gboolean, fixed: gboolean) void;
pub extern fn gtk_cell_area_box_get_spacing(box: [*c]GtkCellAreaBox) gint;
pub extern fn gtk_cell_area_box_set_spacing(box: [*c]GtkCellAreaBox, spacing: gint) void;
pub extern fn _gtk_cell_area_box_group_visible(box: [*c]GtkCellAreaBox, group_idx: gint) gboolean;
pub const struct__GtkCellAreaContextClass = extern struct {
    parent_class: GObjectClass,
    allocate: ?extern fn ([*c]GtkCellAreaContext, gint, gint) void,
    reset: ?extern fn ([*c]GtkCellAreaContext) void,
    get_preferred_height_for_width: ?extern fn ([*c]GtkCellAreaContext, gint, [*c]gint, [*c]gint) void,
    get_preferred_width_for_height: ?extern fn ([*c]GtkCellAreaContext, gint, [*c]gint, [*c]gint) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
};
pub const GtkCellAreaContextClass = struct__GtkCellAreaContextClass;
pub extern fn gtk_cell_area_context_get_type() GType;
pub extern fn gtk_cell_area_context_get_area(context: [*c]GtkCellAreaContext) [*c]GtkCellArea;
pub extern fn gtk_cell_area_context_allocate(context: [*c]GtkCellAreaContext, width: gint, height: gint) void;
pub extern fn gtk_cell_area_context_reset(context: [*c]GtkCellAreaContext) void;
pub extern fn gtk_cell_area_context_get_preferred_width(context: [*c]GtkCellAreaContext, minimum_width: [*c]gint, natural_width: [*c]gint) void;
pub extern fn gtk_cell_area_context_get_preferred_height(context: [*c]GtkCellAreaContext, minimum_height: [*c]gint, natural_height: [*c]gint) void;
pub extern fn gtk_cell_area_context_get_preferred_height_for_width(context: [*c]GtkCellAreaContext, width: gint, minimum_height: [*c]gint, natural_height: [*c]gint) void;
pub extern fn gtk_cell_area_context_get_preferred_width_for_height(context: [*c]GtkCellAreaContext, height: gint, minimum_width: [*c]gint, natural_width: [*c]gint) void;
pub extern fn gtk_cell_area_context_get_allocation(context: [*c]GtkCellAreaContext, width: [*c]gint, height: [*c]gint) void;
pub extern fn gtk_cell_area_context_push_preferred_width(context: [*c]GtkCellAreaContext, minimum_width: gint, natural_width: gint) void;
pub extern fn gtk_cell_area_context_push_preferred_height(context: [*c]GtkCellAreaContext, minimum_height: gint, natural_height: gint) void;
pub const struct__GtkCellLayout = @OpaqueType();
pub const GtkCellLayout = struct__GtkCellLayout;
pub const GtkCellLayoutDataFunc = ?extern fn (?*GtkCellLayout, [*c]GtkCellRenderer, ?*GtkTreeModel, [*c]GtkTreeIter, gpointer) void;
pub const struct__GtkCellLayoutIface = extern struct {
    g_iface: GTypeInterface,
    pack_start: ?extern fn (?*GtkCellLayout, [*c]GtkCellRenderer, gboolean) void,
    pack_end: ?extern fn (?*GtkCellLayout, [*c]GtkCellRenderer, gboolean) void,
    clear: ?extern fn (?*GtkCellLayout) void,
    add_attribute: ?extern fn (?*GtkCellLayout, [*c]GtkCellRenderer, [*c]const gchar, gint) void,
    set_cell_data_func: ?extern fn (?*GtkCellLayout, [*c]GtkCellRenderer, GtkCellLayoutDataFunc, gpointer, GDestroyNotify) void,
    clear_attributes: ?extern fn (?*GtkCellLayout, [*c]GtkCellRenderer) void,
    reorder: ?extern fn (?*GtkCellLayout, [*c]GtkCellRenderer, gint) void,
    get_cells: ?extern fn (?*GtkCellLayout) [*c]GList,
    get_area: ?extern fn (?*GtkCellLayout) [*c]GtkCellArea,
};
pub const GtkCellLayoutIface = struct__GtkCellLayoutIface;
pub extern fn gtk_cell_layout_get_type() GType;
pub extern fn gtk_cell_layout_pack_start(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer, expand: gboolean) void;
pub extern fn gtk_cell_layout_pack_end(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer, expand: gboolean) void;
pub extern fn gtk_cell_layout_get_cells(cell_layout: ?*GtkCellLayout) [*c]GList;
pub extern fn gtk_cell_layout_clear(cell_layout: ?*GtkCellLayout) void;
pub extern fn gtk_cell_layout_set_attributes(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer, ...) void;
pub extern fn gtk_cell_layout_add_attribute(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer, attribute: [*c]const gchar, column: gint) void;
pub extern fn gtk_cell_layout_set_cell_data_func(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer, func: GtkCellLayoutDataFunc, func_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_cell_layout_clear_attributes(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer) void;
pub extern fn gtk_cell_layout_reorder(cell_layout: ?*GtkCellLayout, cell: [*c]GtkCellRenderer, position: gint) void;
pub extern fn gtk_cell_layout_get_area(cell_layout: ?*GtkCellLayout) [*c]GtkCellArea;
pub extern fn _gtk_cell_layout_buildable_custom_tag_start(buildable: ?*GtkBuildable, builder: [*c]GtkBuilder, child: [*c]GObject, tagname: [*c]const gchar, parser: [*c]GMarkupParser, data: [*c]gpointer) gboolean;
pub extern fn _gtk_cell_layout_buildable_custom_tag_end(buildable: ?*GtkBuildable, builder: [*c]GtkBuilder, child: [*c]GObject, tagname: [*c]const gchar, data: [*c]gpointer) gboolean;
pub extern fn _gtk_cell_layout_buildable_add_child(buildable: ?*GtkBuildable, builder: [*c]GtkBuilder, child: [*c]GObject, type_0: [*c]const gchar) void;
pub const struct__GtkCellRendererTextPrivate = @OpaqueType();
pub const GtkCellRendererTextPrivate = struct__GtkCellRendererTextPrivate;
pub const struct__GtkCellRendererText = extern struct {
    parent: GtkCellRenderer,
    priv: ?*GtkCellRendererTextPrivate,
};
pub const GtkCellRendererText = struct__GtkCellRendererText;
pub const struct__GtkCellRendererTextClass = extern struct {
    parent_class: GtkCellRendererClass,
    edited: ?extern fn ([*c]GtkCellRendererText, [*c]const gchar, [*c]const gchar) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCellRendererTextClass = struct__GtkCellRendererTextClass;
pub extern fn gtk_cell_renderer_text_get_type() GType;
pub extern fn gtk_cell_renderer_text_new() [*c]GtkCellRenderer;
pub extern fn gtk_cell_renderer_text_set_fixed_height_from_font(renderer: [*c]GtkCellRendererText, number_of_rows: gint) void;
pub const struct__GtkCellRendererAccelPrivate = @OpaqueType();
pub const GtkCellRendererAccelPrivate = struct__GtkCellRendererAccelPrivate;
pub const struct__GtkCellRendererAccel = extern struct {
    parent: GtkCellRendererText,
    priv: ?*GtkCellRendererAccelPrivate,
};
pub const GtkCellRendererAccel = struct__GtkCellRendererAccel;
pub const struct__GtkCellRendererAccelClass = extern struct {
    parent_class: GtkCellRendererTextClass,
    accel_edited: ?extern fn ([*c]GtkCellRendererAccel, [*c]const gchar, guint, GdkModifierType, guint) void,
    accel_cleared: ?extern fn ([*c]GtkCellRendererAccel, [*c]const gchar) void,
    _gtk_reserved0: ?extern fn () void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCellRendererAccelClass = struct__GtkCellRendererAccelClass;
pub const GTK_CELL_RENDERER_ACCEL_MODE_GTK = 0;
pub const GTK_CELL_RENDERER_ACCEL_MODE_OTHER = 1;
pub const GtkCellRendererAccelMode = extern enum {
    GTK_CELL_RENDERER_ACCEL_MODE_GTK = 0,
    GTK_CELL_RENDERER_ACCEL_MODE_OTHER = 1,
};
pub extern fn gtk_cell_renderer_accel_get_type() GType;
pub extern fn gtk_cell_renderer_accel_new() [*c]GtkCellRenderer;
pub const struct__GtkCellRendererComboPrivate = @OpaqueType();
pub const GtkCellRendererComboPrivate = struct__GtkCellRendererComboPrivate;
pub const struct__GtkCellRendererCombo = extern struct {
    parent: GtkCellRendererText,
    priv: ?*GtkCellRendererComboPrivate,
};
pub const GtkCellRendererCombo = struct__GtkCellRendererCombo;
pub const struct__GtkCellRendererComboClass = extern struct {
    parent: GtkCellRendererTextClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCellRendererComboClass = struct__GtkCellRendererComboClass;
pub extern fn gtk_cell_renderer_combo_get_type() GType;
pub extern fn gtk_cell_renderer_combo_new() [*c]GtkCellRenderer;
pub const struct__GtkCellRendererPixbufPrivate = @OpaqueType();
pub const GtkCellRendererPixbufPrivate = struct__GtkCellRendererPixbufPrivate;
pub const struct__GtkCellRendererPixbuf = extern struct {
    parent: GtkCellRenderer,
    priv: ?*GtkCellRendererPixbufPrivate,
};
pub const GtkCellRendererPixbuf = struct__GtkCellRendererPixbuf;
pub const struct__GtkCellRendererPixbufClass = extern struct {
    parent_class: GtkCellRendererClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCellRendererPixbufClass = struct__GtkCellRendererPixbufClass;
pub extern fn gtk_cell_renderer_pixbuf_get_type() GType;
pub extern fn gtk_cell_renderer_pixbuf_new() [*c]GtkCellRenderer;
pub const struct__GtkCellRendererProgressPrivate = @OpaqueType();
pub const GtkCellRendererProgressPrivate = struct__GtkCellRendererProgressPrivate;
pub const struct__GtkCellRendererProgress = extern struct {
    parent_instance: GtkCellRenderer,
    priv: ?*GtkCellRendererProgressPrivate,
};
pub const GtkCellRendererProgress = struct__GtkCellRendererProgress;
pub const struct__GtkCellRendererProgressClass = extern struct {
    parent_class: GtkCellRendererClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCellRendererProgressClass = struct__GtkCellRendererProgressClass;
pub extern fn gtk_cell_renderer_progress_get_type() GType;
pub extern fn gtk_cell_renderer_progress_new() [*c]GtkCellRenderer;
pub const struct__GtkCellRendererSpinPrivate = @OpaqueType();
pub const GtkCellRendererSpinPrivate = struct__GtkCellRendererSpinPrivate;
pub const struct__GtkCellRendererSpin = extern struct {
    parent: GtkCellRendererText,
    priv: ?*GtkCellRendererSpinPrivate,
};
pub const GtkCellRendererSpin = struct__GtkCellRendererSpin;
pub const struct__GtkCellRendererSpinClass = extern struct {
    parent: GtkCellRendererTextClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCellRendererSpinClass = struct__GtkCellRendererSpinClass;
pub extern fn gtk_cell_renderer_spin_get_type() GType;
pub extern fn gtk_cell_renderer_spin_new() [*c]GtkCellRenderer;
pub const struct__GtkCellRendererSpinnerPrivate = @OpaqueType();
pub const GtkCellRendererSpinnerPrivate = struct__GtkCellRendererSpinnerPrivate;
pub const struct__GtkCellRendererSpinner = extern struct {
    parent: GtkCellRenderer,
    priv: ?*GtkCellRendererSpinnerPrivate,
};
pub const GtkCellRendererSpinner = struct__GtkCellRendererSpinner;
pub const struct__GtkCellRendererSpinnerClass = extern struct {
    parent_class: GtkCellRendererClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCellRendererSpinnerClass = struct__GtkCellRendererSpinnerClass;
pub extern fn gtk_cell_renderer_spinner_get_type() GType;
pub extern fn gtk_cell_renderer_spinner_new() [*c]GtkCellRenderer;
pub const struct__GtkCellRendererTogglePrivate = @OpaqueType();
pub const GtkCellRendererTogglePrivate = struct__GtkCellRendererTogglePrivate;
pub const struct__GtkCellRendererToggle = extern struct {
    parent: GtkCellRenderer,
    priv: ?*GtkCellRendererTogglePrivate,
};
pub const GtkCellRendererToggle = struct__GtkCellRendererToggle;
pub const struct__GtkCellRendererToggleClass = extern struct {
    parent_class: GtkCellRendererClass,
    toggled: ?extern fn ([*c]GtkCellRendererToggle, [*c]const gchar) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCellRendererToggleClass = struct__GtkCellRendererToggleClass;
pub extern fn gtk_cell_renderer_toggle_get_type() GType;
pub extern fn gtk_cell_renderer_toggle_new() [*c]GtkCellRenderer;
pub extern fn gtk_cell_renderer_toggle_get_radio(toggle: [*c]GtkCellRendererToggle) gboolean;
pub extern fn gtk_cell_renderer_toggle_set_radio(toggle: [*c]GtkCellRendererToggle, radio: gboolean) void;
pub extern fn gtk_cell_renderer_toggle_get_active(toggle: [*c]GtkCellRendererToggle) gboolean;
pub extern fn gtk_cell_renderer_toggle_set_active(toggle: [*c]GtkCellRendererToggle, setting: gboolean) void;
pub extern fn gtk_cell_renderer_toggle_get_activatable(toggle: [*c]GtkCellRendererToggle) gboolean;
pub extern fn gtk_cell_renderer_toggle_set_activatable(toggle: [*c]GtkCellRendererToggle, setting: gboolean) void;
pub const struct__GtkCellViewPrivate = @OpaqueType();
pub const GtkCellViewPrivate = struct__GtkCellViewPrivate;
pub const struct__GtkCellView = extern struct {
    parent_instance: GtkWidget,
    priv: ?*GtkCellViewPrivate,
};
pub const GtkCellView = struct__GtkCellView;
pub const struct__GtkCellViewClass = extern struct {
    parent_class: GtkWidgetClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCellViewClass = struct__GtkCellViewClass;
pub extern fn gtk_cell_view_get_type() GType;
pub extern fn gtk_cell_view_new() [*c]GtkWidget;
pub extern fn gtk_cell_view_new_with_context(area: [*c]GtkCellArea, context: [*c]GtkCellAreaContext) [*c]GtkWidget;
pub extern fn gtk_cell_view_new_with_text(text: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_cell_view_new_with_markup(markup: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_cell_view_new_with_pixbuf(pixbuf: ?*GdkPixbuf) [*c]GtkWidget;
pub extern fn gtk_cell_view_set_model(cell_view: [*c]GtkCellView, model: ?*GtkTreeModel) void;
pub extern fn gtk_cell_view_get_model(cell_view: [*c]GtkCellView) ?*GtkTreeModel;
pub extern fn gtk_cell_view_set_displayed_row(cell_view: [*c]GtkCellView, path: ?*GtkTreePath) void;
pub extern fn gtk_cell_view_get_displayed_row(cell_view: [*c]GtkCellView) ?*GtkTreePath;
pub extern fn gtk_cell_view_set_background_rgba(cell_view: [*c]GtkCellView, rgba: [*c]const GdkRGBA) void;
pub extern fn gtk_cell_view_get_draw_sensitive(cell_view: [*c]GtkCellView) gboolean;
pub extern fn gtk_cell_view_set_draw_sensitive(cell_view: [*c]GtkCellView, draw_sensitive: gboolean) void;
pub extern fn gtk_cell_view_get_fit_model(cell_view: [*c]GtkCellView) gboolean;
pub extern fn gtk_cell_view_set_fit_model(cell_view: [*c]GtkCellView, fit_model: gboolean) void;
pub extern fn gtk_cell_view_get_size_of_row(cell_view: [*c]GtkCellView, path: ?*GtkTreePath, requisition: [*c]GtkRequisition) gboolean;
pub extern fn gtk_cell_view_set_background_color(cell_view: [*c]GtkCellView, color: [*c]const GdkColor) void;
pub const struct__GtkToggleButtonPrivate = @OpaqueType();
pub const GtkToggleButtonPrivate = struct__GtkToggleButtonPrivate;
pub const struct__GtkToggleButton = extern struct {
    button: GtkButton,
    priv: ?*GtkToggleButtonPrivate,
};
pub const GtkToggleButton = struct__GtkToggleButton;
pub const struct__GtkToggleButtonClass = extern struct {
    parent_class: GtkButtonClass,
    toggled: ?extern fn ([*c]GtkToggleButton) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkToggleButtonClass = struct__GtkToggleButtonClass;
pub extern fn gtk_toggle_button_get_type() GType;
pub extern fn gtk_toggle_button_new() [*c]GtkWidget;
pub extern fn gtk_toggle_button_new_with_label(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_toggle_button_new_with_mnemonic(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_toggle_button_set_mode(toggle_button: [*c]GtkToggleButton, draw_indicator: gboolean) void;
pub extern fn gtk_toggle_button_get_mode(toggle_button: [*c]GtkToggleButton) gboolean;
pub extern fn gtk_toggle_button_set_active(toggle_button: [*c]GtkToggleButton, is_active: gboolean) void;
pub extern fn gtk_toggle_button_get_active(toggle_button: [*c]GtkToggleButton) gboolean;
pub extern fn gtk_toggle_button_toggled(toggle_button: [*c]GtkToggleButton) void;
pub extern fn gtk_toggle_button_set_inconsistent(toggle_button: [*c]GtkToggleButton, setting: gboolean) void;
pub extern fn gtk_toggle_button_get_inconsistent(toggle_button: [*c]GtkToggleButton) gboolean;
pub const struct__GtkCheckButton = extern struct {
    toggle_button: GtkToggleButton,
};
pub const GtkCheckButton = struct__GtkCheckButton;
pub const struct__GtkCheckButtonClass = extern struct {
    parent_class: GtkToggleButtonClass,
    draw_indicator: ?extern fn ([*c]GtkCheckButton, ?*cairo_t) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCheckButtonClass = struct__GtkCheckButtonClass;
pub extern fn gtk_check_button_get_type() GType;
pub extern fn gtk_check_button_new() [*c]GtkWidget;
pub extern fn gtk_check_button_new_with_label(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_check_button_new_with_mnemonic(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn _gtk_check_button_get_props(check_button: [*c]GtkCheckButton, indicator_size: [*c]gint, indicator_spacing: [*c]gint) void;
pub const struct__GtkMenuItemPrivate = @OpaqueType();
pub const GtkMenuItemPrivate = struct__GtkMenuItemPrivate;
pub const struct__GtkMenuItem = extern struct {
    bin: GtkBin,
    priv: ?*GtkMenuItemPrivate,
};
pub const GtkMenuItem = struct__GtkMenuItem;
pub const struct__GtkMenuItemClass = @OpaqueType();
pub const GtkMenuItemClass = struct__GtkMenuItemClass;
pub extern fn gtk_menu_item_get_type() GType;
pub extern fn gtk_menu_item_new() [*c]GtkWidget;
pub extern fn gtk_menu_item_new_with_label(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_menu_item_new_with_mnemonic(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_menu_item_set_submenu(menu_item: [*c]GtkMenuItem, submenu: [*c]GtkWidget) void;
pub extern fn gtk_menu_item_get_submenu(menu_item: [*c]GtkMenuItem) [*c]GtkWidget;
pub extern fn gtk_menu_item_select(menu_item: [*c]GtkMenuItem) void;
pub extern fn gtk_menu_item_deselect(menu_item: [*c]GtkMenuItem) void;
pub extern fn gtk_menu_item_activate(menu_item: [*c]GtkMenuItem) void;
pub extern fn gtk_menu_item_toggle_size_request(menu_item: [*c]GtkMenuItem, requisition: [*c]gint) void;
pub extern fn gtk_menu_item_toggle_size_allocate(menu_item: [*c]GtkMenuItem, allocation: gint) void;
pub extern fn gtk_menu_item_set_right_justified(menu_item: [*c]GtkMenuItem, right_justified: gboolean) void;
pub extern fn gtk_menu_item_get_right_justified(menu_item: [*c]GtkMenuItem) gboolean;
pub extern fn gtk_menu_item_set_accel_path(menu_item: [*c]GtkMenuItem, accel_path: [*c]const gchar) void;
pub extern fn gtk_menu_item_get_accel_path(menu_item: [*c]GtkMenuItem) [*c]const gchar;
pub extern fn gtk_menu_item_set_label(menu_item: [*c]GtkMenuItem, label: [*c]const gchar) void;
pub extern fn gtk_menu_item_get_label(menu_item: [*c]GtkMenuItem) [*c]const gchar;
pub extern fn gtk_menu_item_set_use_underline(menu_item: [*c]GtkMenuItem, setting: gboolean) void;
pub extern fn gtk_menu_item_get_use_underline(menu_item: [*c]GtkMenuItem) gboolean;
pub extern fn gtk_menu_item_set_reserve_indicator(menu_item: [*c]GtkMenuItem, reserve: gboolean) void;
pub extern fn gtk_menu_item_get_reserve_indicator(menu_item: [*c]GtkMenuItem) gboolean;
pub const struct__GtkCheckMenuItemPrivate = @OpaqueType();
pub const GtkCheckMenuItemPrivate = struct__GtkCheckMenuItemPrivate;
pub const struct__GtkCheckMenuItem = extern struct {
    menu_item: GtkMenuItem,
    priv: ?*GtkCheckMenuItemPrivate,
};
pub const GtkCheckMenuItem = struct__GtkCheckMenuItem;
pub const struct__GtkCheckMenuItemClass = extern struct {
    parent_class: GtkMenuItemClass,
    toggled: ?extern fn ([*c]GtkCheckMenuItem) void,
    draw_indicator: ?extern fn ([*c]GtkCheckMenuItem, ?*cairo_t) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCheckMenuItemClass = struct__GtkCheckMenuItemClass;
pub extern fn gtk_check_menu_item_get_type() GType;
pub extern fn gtk_check_menu_item_new() [*c]GtkWidget;
pub extern fn gtk_check_menu_item_new_with_label(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_check_menu_item_new_with_mnemonic(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_check_menu_item_set_active(check_menu_item: [*c]GtkCheckMenuItem, is_active: gboolean) void;
pub extern fn gtk_check_menu_item_get_active(check_menu_item: [*c]GtkCheckMenuItem) gboolean;
pub extern fn gtk_check_menu_item_toggled(check_menu_item: [*c]GtkCheckMenuItem) void;
pub extern fn gtk_check_menu_item_set_inconsistent(check_menu_item: [*c]GtkCheckMenuItem, setting: gboolean) void;
pub extern fn gtk_check_menu_item_get_inconsistent(check_menu_item: [*c]GtkCheckMenuItem) gboolean;
pub extern fn gtk_check_menu_item_set_draw_as_radio(check_menu_item: [*c]GtkCheckMenuItem, draw_as_radio: gboolean) void;
pub extern fn gtk_check_menu_item_get_draw_as_radio(check_menu_item: [*c]GtkCheckMenuItem) gboolean;
pub const GtkClipboardReceivedFunc = ?extern fn (?*GtkClipboard, ?*GtkSelectionData, gpointer) void;
pub const GtkClipboardTextReceivedFunc = ?extern fn (?*GtkClipboard, [*c]const gchar, gpointer) void;
pub const GtkClipboardRichTextReceivedFunc = ?extern fn (?*GtkClipboard, GdkAtom, [*c]const guint8, gsize, gpointer) void;
pub const GtkClipboardImageReceivedFunc = ?extern fn (?*GtkClipboard, ?*GdkPixbuf, gpointer) void;
pub const GtkClipboardURIReceivedFunc = ?extern fn (?*GtkClipboard, [*c]([*c]gchar), gpointer) void;
pub const GtkClipboardTargetsReceivedFunc = ?extern fn (?*GtkClipboard, [*c]GdkAtom, gint, gpointer) void;
pub const GtkClipboardGetFunc = ?extern fn (?*GtkClipboard, ?*GtkSelectionData, guint, gpointer) void;
pub const GtkClipboardClearFunc = ?extern fn (?*GtkClipboard, gpointer) void;
pub extern fn gtk_clipboard_get_type() GType;
pub extern fn gtk_clipboard_get_for_display(display: ?*GdkDisplay, selection: GdkAtom) ?*GtkClipboard;
pub extern fn gtk_clipboard_get(selection: GdkAtom) ?*GtkClipboard;
pub extern fn gtk_clipboard_get_default(display: ?*GdkDisplay) ?*GtkClipboard;
pub extern fn gtk_clipboard_get_display(clipboard: ?*GtkClipboard) ?*GdkDisplay;
pub extern fn gtk_clipboard_set_with_data(clipboard: ?*GtkClipboard, targets: [*c]const GtkTargetEntry, n_targets: guint, get_func: GtkClipboardGetFunc, clear_func: GtkClipboardClearFunc, user_data: gpointer) gboolean;
pub extern fn gtk_clipboard_set_with_owner(clipboard: ?*GtkClipboard, targets: [*c]const GtkTargetEntry, n_targets: guint, get_func: GtkClipboardGetFunc, clear_func: GtkClipboardClearFunc, owner: [*c]GObject) gboolean;
pub extern fn gtk_clipboard_get_owner(clipboard: ?*GtkClipboard) [*c]GObject;
pub extern fn gtk_clipboard_clear(clipboard: ?*GtkClipboard) void;
pub extern fn gtk_clipboard_set_text(clipboard: ?*GtkClipboard, text: [*c]const gchar, len: gint) void;
pub extern fn gtk_clipboard_set_image(clipboard: ?*GtkClipboard, pixbuf: ?*GdkPixbuf) void;
pub extern fn gtk_clipboard_request_contents(clipboard: ?*GtkClipboard, target: GdkAtom, callback: GtkClipboardReceivedFunc, user_data: gpointer) void;
pub extern fn gtk_clipboard_request_text(clipboard: ?*GtkClipboard, callback: GtkClipboardTextReceivedFunc, user_data: gpointer) void;
pub extern fn gtk_clipboard_request_rich_text(clipboard: ?*GtkClipboard, buffer: [*c]GtkTextBuffer, callback: GtkClipboardRichTextReceivedFunc, user_data: gpointer) void;
pub extern fn gtk_clipboard_request_image(clipboard: ?*GtkClipboard, callback: GtkClipboardImageReceivedFunc, user_data: gpointer) void;
pub extern fn gtk_clipboard_request_uris(clipboard: ?*GtkClipboard, callback: GtkClipboardURIReceivedFunc, user_data: gpointer) void;
pub extern fn gtk_clipboard_request_targets(clipboard: ?*GtkClipboard, callback: GtkClipboardTargetsReceivedFunc, user_data: gpointer) void;
pub extern fn gtk_clipboard_wait_for_contents(clipboard: ?*GtkClipboard, target: GdkAtom) ?*GtkSelectionData;
pub extern fn gtk_clipboard_wait_for_text(clipboard: ?*GtkClipboard) [*c]gchar;
pub extern fn gtk_clipboard_wait_for_rich_text(clipboard: ?*GtkClipboard, buffer: [*c]GtkTextBuffer, format: [*c]GdkAtom, length: [*c]gsize) [*c]guint8;
pub extern fn gtk_clipboard_wait_for_image(clipboard: ?*GtkClipboard) ?*GdkPixbuf;
pub extern fn gtk_clipboard_wait_for_uris(clipboard: ?*GtkClipboard) [*c]([*c]gchar);
pub extern fn gtk_clipboard_wait_for_targets(clipboard: ?*GtkClipboard, targets: [*c]([*c]GdkAtom), n_targets: [*c]gint) gboolean;
pub extern fn gtk_clipboard_wait_is_text_available(clipboard: ?*GtkClipboard) gboolean;
pub extern fn gtk_clipboard_wait_is_rich_text_available(clipboard: ?*GtkClipboard, buffer: [*c]GtkTextBuffer) gboolean;
pub extern fn gtk_clipboard_wait_is_image_available(clipboard: ?*GtkClipboard) gboolean;
pub extern fn gtk_clipboard_wait_is_uris_available(clipboard: ?*GtkClipboard) gboolean;
pub extern fn gtk_clipboard_wait_is_target_available(clipboard: ?*GtkClipboard, target: GdkAtom) gboolean;
pub extern fn gtk_clipboard_set_can_store(clipboard: ?*GtkClipboard, targets: [*c]const GtkTargetEntry, n_targets: gint) void;
pub extern fn gtk_clipboard_store(clipboard: ?*GtkClipboard) void;
pub extern fn gtk_clipboard_get_selection(clipboard: ?*GtkClipboard) GdkAtom;
pub const struct__GtkColorButtonPrivate = @OpaqueType();
pub const GtkColorButtonPrivate = struct__GtkColorButtonPrivate;
pub const struct__GtkColorButton = extern struct {
    button: GtkButton,
    priv: ?*GtkColorButtonPrivate,
};
pub const GtkColorButton = struct__GtkColorButton;
pub const struct__GtkColorButtonClass = extern struct {
    parent_class: GtkButtonClass,
    color_set: ?extern fn ([*c]GtkColorButton) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkColorButtonClass = struct__GtkColorButtonClass;
pub extern fn gtk_color_button_get_type() GType;
pub extern fn gtk_color_button_new() [*c]GtkWidget;
pub extern fn gtk_color_button_new_with_rgba(rgba: [*c]const GdkRGBA) [*c]GtkWidget;
pub extern fn gtk_color_button_set_title(button: [*c]GtkColorButton, title: [*c]const gchar) void;
pub extern fn gtk_color_button_get_title(button: [*c]GtkColorButton) [*c]const gchar;
pub extern fn gtk_color_button_new_with_color(color: [*c]const GdkColor) [*c]GtkWidget;
pub extern fn gtk_color_button_set_color(button: [*c]GtkColorButton, color: [*c]const GdkColor) void;
pub extern fn gtk_color_button_get_color(button: [*c]GtkColorButton, color: [*c]GdkColor) void;
pub extern fn gtk_color_button_set_alpha(button: [*c]GtkColorButton, alpha: guint16) void;
pub extern fn gtk_color_button_get_alpha(button: [*c]GtkColorButton) guint16;
pub extern fn gtk_color_button_set_use_alpha(button: [*c]GtkColorButton, use_alpha: gboolean) void;
pub extern fn gtk_color_button_get_use_alpha(button: [*c]GtkColorButton) gboolean;
pub extern fn gtk_color_button_set_rgba(button: [*c]GtkColorButton, rgba: [*c]const GdkRGBA) void;
pub extern fn gtk_color_button_get_rgba(button: [*c]GtkColorButton, rgba: [*c]GdkRGBA) void;
pub const struct__GtkColorChooser = @OpaqueType();
pub const GtkColorChooser = struct__GtkColorChooser;
pub const struct__GtkColorChooserInterface = extern struct {
    base_interface: GTypeInterface,
    get_rgba: ?extern fn (?*GtkColorChooser, [*c]GdkRGBA) void,
    set_rgba: ?extern fn (?*GtkColorChooser, [*c]const GdkRGBA) void,
    add_palette: ?extern fn (?*GtkColorChooser, GtkOrientation, gint, gint, [*c]GdkRGBA) void,
    color_activated: ?extern fn (?*GtkColorChooser, [*c]const GdkRGBA) void,
    padding: [12]gpointer,
};
pub const GtkColorChooserInterface = struct__GtkColorChooserInterface;
pub extern fn gtk_color_chooser_get_type() GType;
pub extern fn gtk_color_chooser_get_rgba(chooser: ?*GtkColorChooser, color: [*c]GdkRGBA) void;
pub extern fn gtk_color_chooser_set_rgba(chooser: ?*GtkColorChooser, color: [*c]const GdkRGBA) void;
pub extern fn gtk_color_chooser_get_use_alpha(chooser: ?*GtkColorChooser) gboolean;
pub extern fn gtk_color_chooser_set_use_alpha(chooser: ?*GtkColorChooser, use_alpha: gboolean) void;
pub extern fn gtk_color_chooser_add_palette(chooser: ?*GtkColorChooser, orientation: GtkOrientation, colors_per_line: gint, n_colors: gint, colors: [*c]GdkRGBA) void;
pub const struct__GtkColorChooserDialogPrivate = @OpaqueType();
pub const GtkColorChooserDialogPrivate = struct__GtkColorChooserDialogPrivate;
pub const struct__GtkColorChooserDialog = extern struct {
    parent_instance: GtkDialog,
    priv: ?*GtkColorChooserDialogPrivate,
};
pub const GtkColorChooserDialog = struct__GtkColorChooserDialog;
pub const struct__GtkColorChooserDialogClass = extern struct {
    parent_class: GtkDialogClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkColorChooserDialogClass = struct__GtkColorChooserDialogClass;
pub extern fn gtk_color_chooser_dialog_get_type() GType;
pub extern fn gtk_color_chooser_dialog_new(title: [*c]const gchar, parent: [*c]GtkWindow) [*c]GtkWidget;
pub const struct__GtkColorChooserWidgetPrivate = @OpaqueType();
pub const GtkColorChooserWidgetPrivate = struct__GtkColorChooserWidgetPrivate;
pub const struct__GtkColorChooserWidget = extern struct {
    parent_instance: GtkBox,
    priv: ?*GtkColorChooserWidgetPrivate,
};
pub const GtkColorChooserWidget = struct__GtkColorChooserWidget;
pub const struct__GtkColorChooserWidgetClass = extern struct {
    parent_class: GtkBoxClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
    _gtk_reserved8: ?extern fn () void,
};
pub const GtkColorChooserWidgetClass = struct__GtkColorChooserWidgetClass;
pub extern fn gtk_color_chooser_widget_get_type() GType;
pub extern fn gtk_color_chooser_widget_new() [*c]GtkWidget;
pub extern fn gtk_hsv_to_rgb(h: gdouble, s: gdouble, v: gdouble, r: [*c]gdouble, g: [*c]gdouble, b: [*c]gdouble) void;
pub extern fn gtk_rgb_to_hsv(r: gdouble, g: gdouble, b: gdouble, h: [*c]gdouble, s: [*c]gdouble, v: [*c]gdouble) void;
pub const struct__GtkComboBoxTextPrivate = @OpaqueType();
pub const GtkComboBoxTextPrivate = struct__GtkComboBoxTextPrivate;
pub const struct__GtkComboBoxText = extern struct {
    parent_instance: GtkComboBox,
    priv: ?*GtkComboBoxTextPrivate,
};
pub const GtkComboBoxText = struct__GtkComboBoxText;
pub const struct__GtkComboBoxTextClass = extern struct {
    parent_class: GtkComboBoxClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkComboBoxTextClass = struct__GtkComboBoxTextClass;
pub extern fn gtk_combo_box_text_get_type() GType;
pub extern fn gtk_combo_box_text_new() [*c]GtkWidget;
pub extern fn gtk_combo_box_text_new_with_entry() [*c]GtkWidget;
pub extern fn gtk_combo_box_text_append_text(combo_box: [*c]GtkComboBoxText, text: [*c]const gchar) void;
pub extern fn gtk_combo_box_text_insert_text(combo_box: [*c]GtkComboBoxText, position: gint, text: [*c]const gchar) void;
pub extern fn gtk_combo_box_text_prepend_text(combo_box: [*c]GtkComboBoxText, text: [*c]const gchar) void;
pub extern fn gtk_combo_box_text_remove(combo_box: [*c]GtkComboBoxText, position: gint) void;
pub extern fn gtk_combo_box_text_remove_all(combo_box: [*c]GtkComboBoxText) void;
pub extern fn gtk_combo_box_text_get_active_text(combo_box: [*c]GtkComboBoxText) [*c]gchar;
pub extern fn gtk_combo_box_text_insert(combo_box: [*c]GtkComboBoxText, position: gint, id: [*c]const gchar, text: [*c]const gchar) void;
pub extern fn gtk_combo_box_text_append(combo_box: [*c]GtkComboBoxText, id: [*c]const gchar, text: [*c]const gchar) void;
pub extern fn gtk_combo_box_text_prepend(combo_box: [*c]GtkComboBoxText, id: [*c]const gchar, text: [*c]const gchar) void;
pub const GTK_CSS_SECTION_DOCUMENT = 0;
pub const GTK_CSS_SECTION_IMPORT = 1;
pub const GTK_CSS_SECTION_COLOR_DEFINITION = 2;
pub const GTK_CSS_SECTION_BINDING_SET = 3;
pub const GTK_CSS_SECTION_RULESET = 4;
pub const GTK_CSS_SECTION_SELECTOR = 5;
pub const GTK_CSS_SECTION_DECLARATION = 6;
pub const GTK_CSS_SECTION_VALUE = 7;
pub const GTK_CSS_SECTION_KEYFRAMES = 8;
pub const GtkCssSectionType = extern enum {
    GTK_CSS_SECTION_DOCUMENT = 0,
    GTK_CSS_SECTION_IMPORT = 1,
    GTK_CSS_SECTION_COLOR_DEFINITION = 2,
    GTK_CSS_SECTION_BINDING_SET = 3,
    GTK_CSS_SECTION_RULESET = 4,
    GTK_CSS_SECTION_SELECTOR = 5,
    GTK_CSS_SECTION_DECLARATION = 6,
    GTK_CSS_SECTION_VALUE = 7,
    GTK_CSS_SECTION_KEYFRAMES = 8,
};
pub const struct__GtkCssSection = @OpaqueType();
pub const GtkCssSection = struct__GtkCssSection;
pub extern fn gtk_css_section_get_type() GType;
pub extern fn gtk_css_section_ref(section: ?*GtkCssSection) ?*GtkCssSection;
pub extern fn gtk_css_section_unref(section: ?*GtkCssSection) void;
pub extern fn gtk_css_section_get_section_type(section: ?*const GtkCssSection) GtkCssSectionType;
pub extern fn gtk_css_section_get_parent(section: ?*const GtkCssSection) ?*GtkCssSection;
pub extern fn gtk_css_section_get_file(section: ?*const GtkCssSection) ?*GFile;
pub extern fn gtk_css_section_get_start_line(section: ?*const GtkCssSection) guint;
pub extern fn gtk_css_section_get_start_position(section: ?*const GtkCssSection) guint;
pub extern fn gtk_css_section_get_end_line(section: ?*const GtkCssSection) guint;
pub extern fn gtk_css_section_get_end_position(section: ?*const GtkCssSection) guint;
pub const GTK_CSS_PROVIDER_ERROR_FAILED = 0;
pub const GTK_CSS_PROVIDER_ERROR_SYNTAX = 1;
pub const GTK_CSS_PROVIDER_ERROR_IMPORT = 2;
pub const GTK_CSS_PROVIDER_ERROR_NAME = 3;
pub const GTK_CSS_PROVIDER_ERROR_DEPRECATED = 4;
pub const GTK_CSS_PROVIDER_ERROR_UNKNOWN_VALUE = 5;
pub const GtkCssProviderError = extern enum {
    GTK_CSS_PROVIDER_ERROR_FAILED = 0,
    GTK_CSS_PROVIDER_ERROR_SYNTAX = 1,
    GTK_CSS_PROVIDER_ERROR_IMPORT = 2,
    GTK_CSS_PROVIDER_ERROR_NAME = 3,
    GTK_CSS_PROVIDER_ERROR_DEPRECATED = 4,
    GTK_CSS_PROVIDER_ERROR_UNKNOWN_VALUE = 5,
};
pub extern fn gtk_css_provider_error_quark() GQuark;
pub const struct__GtkCssProviderPrivate = @OpaqueType();
pub const GtkCssProviderPrivate = struct__GtkCssProviderPrivate;
pub const struct__GtkCssProvider = extern struct {
    parent_instance: GObject,
    priv: ?*GtkCssProviderPrivate,
};
pub const GtkCssProvider = struct__GtkCssProvider;
pub const struct__GtkCssProviderClass = extern struct {
    parent_class: GObjectClass,
    parsing_error: ?extern fn ([*c]GtkCssProvider, ?*GtkCssSection, [*c]const GError) void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkCssProviderClass = struct__GtkCssProviderClass;
pub extern fn gtk_css_provider_get_type() GType;
pub extern fn gtk_css_provider_new() [*c]GtkCssProvider;
pub extern fn gtk_css_provider_to_string(provider: [*c]GtkCssProvider) [*c]u8;
pub extern fn gtk_css_provider_load_from_data(css_provider: [*c]GtkCssProvider, data: [*c]const gchar, length: gssize, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_css_provider_load_from_file(css_provider: [*c]GtkCssProvider, file: ?*GFile, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_css_provider_load_from_path(css_provider: [*c]GtkCssProvider, path: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_css_provider_load_from_resource(css_provider: [*c]GtkCssProvider, resource_path: [*c]const gchar) void;
pub extern fn gtk_css_provider_get_default() [*c]GtkCssProvider;
pub extern fn gtk_css_provider_get_named(name: [*c]const gchar, variant: [*c]const gchar) [*c]GtkCssProvider;
pub const GTK_DEBUG_MISC = 1;
pub const GTK_DEBUG_PLUGSOCKET = 2;
pub const GTK_DEBUG_TEXT = 4;
pub const GTK_DEBUG_TREE = 8;
pub const GTK_DEBUG_UPDATES = 16;
pub const GTK_DEBUG_KEYBINDINGS = 32;
pub const GTK_DEBUG_MULTIHEAD = 64;
pub const GTK_DEBUG_MODULES = 128;
pub const GTK_DEBUG_GEOMETRY = 256;
pub const GTK_DEBUG_ICONTHEME = 512;
pub const GTK_DEBUG_PRINTING = 1024;
pub const GTK_DEBUG_BUILDER = 2048;
pub const GTK_DEBUG_SIZE_REQUEST = 4096;
pub const GTK_DEBUG_NO_CSS_CACHE = 8192;
pub const GTK_DEBUG_BASELINES = 16384;
pub const GTK_DEBUG_PIXEL_CACHE = 32768;
pub const GTK_DEBUG_NO_PIXEL_CACHE = 65536;
pub const GTK_DEBUG_INTERACTIVE = 131072;
pub const GTK_DEBUG_TOUCHSCREEN = 262144;
pub const GTK_DEBUG_ACTIONS = 524288;
pub const GTK_DEBUG_RESIZE = 1048576;
pub const GTK_DEBUG_LAYOUT = 2097152;
pub const GtkDebugFlag = extern enum {
    GTK_DEBUG_MISC = 1,
    GTK_DEBUG_PLUGSOCKET = 2,
    GTK_DEBUG_TEXT = 4,
    GTK_DEBUG_TREE = 8,
    GTK_DEBUG_UPDATES = 16,
    GTK_DEBUG_KEYBINDINGS = 32,
    GTK_DEBUG_MULTIHEAD = 64,
    GTK_DEBUG_MODULES = 128,
    GTK_DEBUG_GEOMETRY = 256,
    GTK_DEBUG_ICONTHEME = 512,
    GTK_DEBUG_PRINTING = 1024,
    GTK_DEBUG_BUILDER = 2048,
    GTK_DEBUG_SIZE_REQUEST = 4096,
    GTK_DEBUG_NO_CSS_CACHE = 8192,
    GTK_DEBUG_BASELINES = 16384,
    GTK_DEBUG_PIXEL_CACHE = 32768,
    GTK_DEBUG_NO_PIXEL_CACHE = 65536,
    GTK_DEBUG_INTERACTIVE = 131072,
    GTK_DEBUG_TOUCHSCREEN = 262144,
    GTK_DEBUG_ACTIONS = 524288,
    GTK_DEBUG_RESIZE = 1048576,
    GTK_DEBUG_LAYOUT = 2097152,
};
pub extern fn gtk_get_debug_flags() guint;
pub extern fn gtk_set_debug_flags(flags: guint) void;
pub const GTK_DEST_DEFAULT_MOTION = 1;
pub const GTK_DEST_DEFAULT_HIGHLIGHT = 2;
pub const GTK_DEST_DEFAULT_DROP = 4;
pub const GTK_DEST_DEFAULT_ALL = 7;
pub const GtkDestDefaults = extern enum {
    GTK_DEST_DEFAULT_MOTION = 1,
    GTK_DEST_DEFAULT_HIGHLIGHT = 2,
    GTK_DEST_DEFAULT_DROP = 4,
    GTK_DEST_DEFAULT_ALL = 7,
};
pub extern fn gtk_drag_dest_set(widget: [*c]GtkWidget, flags: GtkDestDefaults, targets: [*c]const GtkTargetEntry, n_targets: gint, actions: GdkDragAction) void;
pub extern fn gtk_drag_dest_set_proxy(widget: [*c]GtkWidget, proxy_window: ?*GdkWindow, protocol: GdkDragProtocol, use_coordinates: gboolean) void;
pub extern fn gtk_drag_dest_unset(widget: [*c]GtkWidget) void;
pub extern fn gtk_drag_dest_find_target(widget: [*c]GtkWidget, context: ?*GdkDragContext, target_list: ?*GtkTargetList) GdkAtom;
pub extern fn gtk_drag_dest_get_target_list(widget: [*c]GtkWidget) ?*GtkTargetList;
pub extern fn gtk_drag_dest_set_target_list(widget: [*c]GtkWidget, target_list: ?*GtkTargetList) void;
pub extern fn gtk_drag_dest_add_text_targets(widget: [*c]GtkWidget) void;
pub extern fn gtk_drag_dest_add_image_targets(widget: [*c]GtkWidget) void;
pub extern fn gtk_drag_dest_add_uri_targets(widget: [*c]GtkWidget) void;
pub extern fn gtk_drag_dest_set_track_motion(widget: [*c]GtkWidget, track_motion: gboolean) void;
pub extern fn gtk_drag_dest_get_track_motion(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_drag_source_set(widget: [*c]GtkWidget, start_button_mask: GdkModifierType, targets: [*c]const GtkTargetEntry, n_targets: gint, actions: GdkDragAction) void;
pub extern fn gtk_drag_source_unset(widget: [*c]GtkWidget) void;
pub extern fn gtk_drag_source_get_target_list(widget: [*c]GtkWidget) ?*GtkTargetList;
pub extern fn gtk_drag_source_set_target_list(widget: [*c]GtkWidget, target_list: ?*GtkTargetList) void;
pub extern fn gtk_drag_source_add_text_targets(widget: [*c]GtkWidget) void;
pub extern fn gtk_drag_source_add_image_targets(widget: [*c]GtkWidget) void;
pub extern fn gtk_drag_source_add_uri_targets(widget: [*c]GtkWidget) void;
pub extern fn gtk_drag_source_set_icon_pixbuf(widget: [*c]GtkWidget, pixbuf: ?*GdkPixbuf) void;
pub extern fn gtk_drag_source_set_icon_stock(widget: [*c]GtkWidget, stock_id: [*c]const gchar) void;
pub extern fn gtk_drag_source_set_icon_name(widget: [*c]GtkWidget, icon_name: [*c]const gchar) void;
pub extern fn gtk_drag_source_set_icon_gicon(widget: [*c]GtkWidget, icon: ?*GIcon) void;
pub const struct__GtkDrawingArea = extern struct {
    widget: GtkWidget,
    dummy: gpointer,
};
pub const GtkDrawingArea = struct__GtkDrawingArea;
pub const struct__GtkDrawingAreaClass = extern struct {
    parent_class: GtkWidgetClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkDrawingAreaClass = struct__GtkDrawingAreaClass;
pub extern fn gtk_drawing_area_get_type() GType;
pub extern fn gtk_drawing_area_new() [*c]GtkWidget;
pub const struct__GtkEventBoxPrivate = @OpaqueType();
pub const GtkEventBoxPrivate = struct__GtkEventBoxPrivate;
pub const struct__GtkEventBox = extern struct {
    bin: GtkBin,
    priv: ?*GtkEventBoxPrivate,
};
pub const GtkEventBox = struct__GtkEventBox;
pub const struct__GtkEventBoxClass = extern struct {
    parent_class: GtkBinClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkEventBoxClass = struct__GtkEventBoxClass;
pub extern fn gtk_event_box_get_type() GType;
pub extern fn gtk_event_box_new() [*c]GtkWidget;
pub extern fn gtk_event_box_get_visible_window(event_box: [*c]GtkEventBox) gboolean;
pub extern fn gtk_event_box_set_visible_window(event_box: [*c]GtkEventBox, visible_window: gboolean) void;
pub extern fn gtk_event_box_get_above_child(event_box: [*c]GtkEventBox) gboolean;
pub extern fn gtk_event_box_set_above_child(event_box: [*c]GtkEventBox, above_child: gboolean) void;
pub const struct__GtkEventController = @OpaqueType();
pub const GtkEventController = struct__GtkEventController;
pub const struct__GtkEventControllerClass = @OpaqueType();
pub const GtkEventControllerClass = struct__GtkEventControllerClass;
pub extern fn gtk_event_controller_get_type() GType;
pub extern fn gtk_event_controller_get_widget(controller: ?*GtkEventController) [*c]GtkWidget;
pub extern fn gtk_event_controller_handle_event(controller: ?*GtkEventController, event: [*c]const GdkEvent) gboolean;
pub extern fn gtk_event_controller_reset(controller: ?*GtkEventController) void;
pub extern fn gtk_event_controller_get_propagation_phase(controller: ?*GtkEventController) GtkPropagationPhase;
pub extern fn gtk_event_controller_set_propagation_phase(controller: ?*GtkEventController, phase: GtkPropagationPhase) void;
pub const struct__GtkEventControllerKey = @OpaqueType();
pub const GtkEventControllerKey = struct__GtkEventControllerKey;
pub const struct__GtkEventControllerKeyClass = @OpaqueType();
pub const GtkEventControllerKeyClass = struct__GtkEventControllerKeyClass;
pub extern fn gtk_event_controller_key_get_type() GType;
pub extern fn gtk_event_controller_key_new(widget: [*c]GtkWidget) ?*GtkEventController;
pub extern fn gtk_event_controller_key_set_im_context(controller: ?*GtkEventControllerKey, im_context: [*c]GtkIMContext) void;
pub extern fn gtk_event_controller_key_get_im_context(controller: ?*GtkEventControllerKey) [*c]GtkIMContext;
pub extern fn gtk_event_controller_key_forward(controller: ?*GtkEventControllerKey, widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_event_controller_key_get_group(controller: ?*GtkEventControllerKey) guint;
pub const struct__GtkEventControllerMotion = @OpaqueType();
pub const GtkEventControllerMotion = struct__GtkEventControllerMotion;
pub const struct__GtkEventControllerMotionClass = @OpaqueType();
pub const GtkEventControllerMotionClass = struct__GtkEventControllerMotionClass;
pub extern fn gtk_event_controller_motion_get_type() GType;
pub extern fn gtk_event_controller_motion_new(widget: [*c]GtkWidget) ?*GtkEventController;
pub const struct__GtkEventControllerScroll = @OpaqueType();
pub const GtkEventControllerScroll = struct__GtkEventControllerScroll;
pub const struct__GtkEventControllerScrollClass = @OpaqueType();
pub const GtkEventControllerScrollClass = struct__GtkEventControllerScrollClass;
pub const GTK_EVENT_CONTROLLER_SCROLL_NONE = 0;
pub const GTK_EVENT_CONTROLLER_SCROLL_VERTICAL = 1;
pub const GTK_EVENT_CONTROLLER_SCROLL_HORIZONTAL = 2;
pub const GTK_EVENT_CONTROLLER_SCROLL_DISCRETE = 4;
pub const GTK_EVENT_CONTROLLER_SCROLL_KINETIC = 8;
pub const GTK_EVENT_CONTROLLER_SCROLL_BOTH_AXES = 3;
pub const GtkEventControllerScrollFlags = extern enum {
    GTK_EVENT_CONTROLLER_SCROLL_NONE = 0,
    GTK_EVENT_CONTROLLER_SCROLL_VERTICAL = 1,
    GTK_EVENT_CONTROLLER_SCROLL_HORIZONTAL = 2,
    GTK_EVENT_CONTROLLER_SCROLL_DISCRETE = 4,
    GTK_EVENT_CONTROLLER_SCROLL_KINETIC = 8,
    GTK_EVENT_CONTROLLER_SCROLL_BOTH_AXES = 3,
};
pub extern fn gtk_event_controller_scroll_get_type() GType;
pub extern fn gtk_event_controller_scroll_new(widget: [*c]GtkWidget, flags: GtkEventControllerScrollFlags) ?*GtkEventController;
pub extern fn gtk_event_controller_scroll_set_flags(controller: ?*GtkEventControllerScroll, flags: GtkEventControllerScrollFlags) void;
pub extern fn gtk_event_controller_scroll_get_flags(controller: ?*GtkEventControllerScroll) GtkEventControllerScrollFlags;
pub const struct__GtkExpanderPrivate = @OpaqueType();
pub const GtkExpanderPrivate = struct__GtkExpanderPrivate;
pub const struct__GtkExpander = extern struct {
    bin: GtkBin,
    priv: ?*GtkExpanderPrivate,
};
pub const GtkExpander = struct__GtkExpander;
pub const struct__GtkExpanderClass = extern struct {
    parent_class: GtkBinClass,
    activate: ?extern fn ([*c]GtkExpander) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkExpanderClass = struct__GtkExpanderClass;
pub extern fn gtk_expander_get_type() GType;
pub extern fn gtk_expander_new(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_expander_new_with_mnemonic(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_expander_set_expanded(expander: [*c]GtkExpander, expanded: gboolean) void;
pub extern fn gtk_expander_get_expanded(expander: [*c]GtkExpander) gboolean;
pub extern fn gtk_expander_set_spacing(expander: [*c]GtkExpander, spacing: gint) void;
pub extern fn gtk_expander_get_spacing(expander: [*c]GtkExpander) gint;
pub extern fn gtk_expander_set_label(expander: [*c]GtkExpander, label: [*c]const gchar) void;
pub extern fn gtk_expander_get_label(expander: [*c]GtkExpander) [*c]const gchar;
pub extern fn gtk_expander_set_use_underline(expander: [*c]GtkExpander, use_underline: gboolean) void;
pub extern fn gtk_expander_get_use_underline(expander: [*c]GtkExpander) gboolean;
pub extern fn gtk_expander_set_use_markup(expander: [*c]GtkExpander, use_markup: gboolean) void;
pub extern fn gtk_expander_get_use_markup(expander: [*c]GtkExpander) gboolean;
pub extern fn gtk_expander_set_label_widget(expander: [*c]GtkExpander, label_widget: [*c]GtkWidget) void;
pub extern fn gtk_expander_get_label_widget(expander: [*c]GtkExpander) [*c]GtkWidget;
pub extern fn gtk_expander_set_label_fill(expander: [*c]GtkExpander, label_fill: gboolean) void;
pub extern fn gtk_expander_get_label_fill(expander: [*c]GtkExpander) gboolean;
pub extern fn gtk_expander_set_resize_toplevel(expander: [*c]GtkExpander, resize_toplevel: gboolean) void;
pub extern fn gtk_expander_get_resize_toplevel(expander: [*c]GtkExpander) gboolean;
pub const struct__GtkFixedPrivate = @OpaqueType();
pub const GtkFixedPrivate = struct__GtkFixedPrivate;
pub const struct__GtkFixed = extern struct {
    container: GtkContainer,
    priv: ?*GtkFixedPrivate,
};
pub const GtkFixed = struct__GtkFixed;
pub const struct__GtkFixedClass = extern struct {
    parent_class: GtkContainerClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkFixedClass = struct__GtkFixedClass;
pub const struct__GtkFixedChild = extern struct {
    widget: [*c]GtkWidget,
    x: gint,
    y: gint,
};
pub const GtkFixedChild = struct__GtkFixedChild;
pub extern fn gtk_fixed_get_type() GType;
pub extern fn gtk_fixed_new() [*c]GtkWidget;
pub extern fn gtk_fixed_put(fixed: [*c]GtkFixed, widget: [*c]GtkWidget, x: gint, y: gint) void;
pub extern fn gtk_fixed_move(fixed: [*c]GtkFixed, widget: [*c]GtkWidget, x: gint, y: gint) void;
pub const struct__GtkFileFilter = @OpaqueType();
pub const GtkFileFilter = struct__GtkFileFilter;
pub const GTK_FILE_FILTER_FILENAME = 1;
pub const GTK_FILE_FILTER_URI = 2;
pub const GTK_FILE_FILTER_DISPLAY_NAME = 4;
pub const GTK_FILE_FILTER_MIME_TYPE = 8;
pub const GtkFileFilterFlags = extern enum {
    GTK_FILE_FILTER_FILENAME = 1,
    GTK_FILE_FILTER_URI = 2,
    GTK_FILE_FILTER_DISPLAY_NAME = 4,
    GTK_FILE_FILTER_MIME_TYPE = 8,
};
pub const struct__GtkFileFilterInfo = extern struct {
    contains: GtkFileFilterFlags,
    filename: [*c]const gchar,
    uri: [*c]const gchar,
    display_name: [*c]const gchar,
    mime_type: [*c]const gchar,
};
pub const GtkFileFilterInfo = struct__GtkFileFilterInfo;
pub const GtkFileFilterFunc = ?extern fn ([*c]const GtkFileFilterInfo, gpointer) gboolean;
pub extern fn gtk_file_filter_get_type() GType;
pub extern fn gtk_file_filter_new() ?*GtkFileFilter;
pub extern fn gtk_file_filter_set_name(filter: ?*GtkFileFilter, name: [*c]const gchar) void;
pub extern fn gtk_file_filter_get_name(filter: ?*GtkFileFilter) [*c]const gchar;
pub extern fn gtk_file_filter_add_mime_type(filter: ?*GtkFileFilter, mime_type: [*c]const gchar) void;
pub extern fn gtk_file_filter_add_pattern(filter: ?*GtkFileFilter, pattern: [*c]const gchar) void;
pub extern fn gtk_file_filter_add_pixbuf_formats(filter: ?*GtkFileFilter) void;
pub extern fn gtk_file_filter_add_custom(filter: ?*GtkFileFilter, needed: GtkFileFilterFlags, func: GtkFileFilterFunc, data: gpointer, notify: GDestroyNotify) void;
pub extern fn gtk_file_filter_get_needed(filter: ?*GtkFileFilter) GtkFileFilterFlags;
pub extern fn gtk_file_filter_filter(filter: ?*GtkFileFilter, filter_info: [*c]const GtkFileFilterInfo) gboolean;
pub extern fn gtk_file_filter_to_gvariant(filter: ?*GtkFileFilter) ?*GVariant;
pub extern fn gtk_file_filter_new_from_gvariant(variant: ?*GVariant) ?*GtkFileFilter;
pub const struct__GtkFileChooser = @OpaqueType();
pub const GtkFileChooser = struct__GtkFileChooser;
pub const GTK_FILE_CHOOSER_ACTION_OPEN = 0;
pub const GTK_FILE_CHOOSER_ACTION_SAVE = 1;
pub const GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER = 2;
pub const GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER = 3;
pub const GtkFileChooserAction = extern enum {
    GTK_FILE_CHOOSER_ACTION_OPEN = 0,
    GTK_FILE_CHOOSER_ACTION_SAVE = 1,
    GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER = 2,
    GTK_FILE_CHOOSER_ACTION_CREATE_FOLDER = 3,
};
pub const GTK_FILE_CHOOSER_CONFIRMATION_CONFIRM = 0;
pub const GTK_FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME = 1;
pub const GTK_FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN = 2;
pub const GtkFileChooserConfirmation = extern enum {
    GTK_FILE_CHOOSER_CONFIRMATION_CONFIRM = 0,
    GTK_FILE_CHOOSER_CONFIRMATION_ACCEPT_FILENAME = 1,
    GTK_FILE_CHOOSER_CONFIRMATION_SELECT_AGAIN = 2,
};
pub extern fn gtk_file_chooser_get_type() GType;
pub const GTK_FILE_CHOOSER_ERROR_NONEXISTENT = 0;
pub const GTK_FILE_CHOOSER_ERROR_BAD_FILENAME = 1;
pub const GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS = 2;
pub const GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME = 3;
pub const GtkFileChooserError = extern enum {
    GTK_FILE_CHOOSER_ERROR_NONEXISTENT = 0,
    GTK_FILE_CHOOSER_ERROR_BAD_FILENAME = 1,
    GTK_FILE_CHOOSER_ERROR_ALREADY_EXISTS = 2,
    GTK_FILE_CHOOSER_ERROR_INCOMPLETE_HOSTNAME = 3,
};
pub extern fn gtk_file_chooser_error_quark() GQuark;
pub extern fn gtk_file_chooser_set_action(chooser: ?*GtkFileChooser, action: GtkFileChooserAction) void;
pub extern fn gtk_file_chooser_get_action(chooser: ?*GtkFileChooser) GtkFileChooserAction;
pub extern fn gtk_file_chooser_set_local_only(chooser: ?*GtkFileChooser, local_only: gboolean) void;
pub extern fn gtk_file_chooser_get_local_only(chooser: ?*GtkFileChooser) gboolean;
pub extern fn gtk_file_chooser_set_select_multiple(chooser: ?*GtkFileChooser, select_multiple: gboolean) void;
pub extern fn gtk_file_chooser_get_select_multiple(chooser: ?*GtkFileChooser) gboolean;
pub extern fn gtk_file_chooser_set_show_hidden(chooser: ?*GtkFileChooser, show_hidden: gboolean) void;
pub extern fn gtk_file_chooser_get_show_hidden(chooser: ?*GtkFileChooser) gboolean;
pub extern fn gtk_file_chooser_set_do_overwrite_confirmation(chooser: ?*GtkFileChooser, do_overwrite_confirmation: gboolean) void;
pub extern fn gtk_file_chooser_get_do_overwrite_confirmation(chooser: ?*GtkFileChooser) gboolean;
pub extern fn gtk_file_chooser_set_create_folders(chooser: ?*GtkFileChooser, create_folders: gboolean) void;
pub extern fn gtk_file_chooser_get_create_folders(chooser: ?*GtkFileChooser) gboolean;
pub extern fn gtk_file_chooser_set_current_name(chooser: ?*GtkFileChooser, name: [*c]const gchar) void;
pub extern fn gtk_file_chooser_get_current_name(chooser: ?*GtkFileChooser) [*c]gchar;
pub extern fn gtk_file_chooser_get_filename(chooser: ?*GtkFileChooser) [*c]gchar;
pub extern fn gtk_file_chooser_set_filename(chooser: ?*GtkFileChooser, filename: [*c]const u8) gboolean;
pub extern fn gtk_file_chooser_select_filename(chooser: ?*GtkFileChooser, filename: [*c]const u8) gboolean;
pub extern fn gtk_file_chooser_unselect_filename(chooser: ?*GtkFileChooser, filename: [*c]const u8) void;
pub extern fn gtk_file_chooser_select_all(chooser: ?*GtkFileChooser) void;
pub extern fn gtk_file_chooser_unselect_all(chooser: ?*GtkFileChooser) void;
pub extern fn gtk_file_chooser_get_filenames(chooser: ?*GtkFileChooser) [*c]GSList;
pub extern fn gtk_file_chooser_set_current_folder(chooser: ?*GtkFileChooser, filename: [*c]const gchar) gboolean;
pub extern fn gtk_file_chooser_get_current_folder(chooser: ?*GtkFileChooser) [*c]gchar;
pub extern fn gtk_file_chooser_get_uri(chooser: ?*GtkFileChooser) [*c]gchar;
pub extern fn gtk_file_chooser_set_uri(chooser: ?*GtkFileChooser, uri: [*c]const u8) gboolean;
pub extern fn gtk_file_chooser_select_uri(chooser: ?*GtkFileChooser, uri: [*c]const u8) gboolean;
pub extern fn gtk_file_chooser_unselect_uri(chooser: ?*GtkFileChooser, uri: [*c]const u8) void;
pub extern fn gtk_file_chooser_get_uris(chooser: ?*GtkFileChooser) [*c]GSList;
pub extern fn gtk_file_chooser_set_current_folder_uri(chooser: ?*GtkFileChooser, uri: [*c]const gchar) gboolean;
pub extern fn gtk_file_chooser_get_current_folder_uri(chooser: ?*GtkFileChooser) [*c]gchar;
pub extern fn gtk_file_chooser_get_file(chooser: ?*GtkFileChooser) ?*GFile;
pub extern fn gtk_file_chooser_set_file(chooser: ?*GtkFileChooser, file: ?*GFile, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_file_chooser_select_file(chooser: ?*GtkFileChooser, file: ?*GFile, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_file_chooser_unselect_file(chooser: ?*GtkFileChooser, file: ?*GFile) void;
pub extern fn gtk_file_chooser_get_files(chooser: ?*GtkFileChooser) [*c]GSList;
pub extern fn gtk_file_chooser_set_current_folder_file(chooser: ?*GtkFileChooser, file: ?*GFile, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_file_chooser_get_current_folder_file(chooser: ?*GtkFileChooser) ?*GFile;
pub extern fn gtk_file_chooser_set_preview_widget(chooser: ?*GtkFileChooser, preview_widget: [*c]GtkWidget) void;
pub extern fn gtk_file_chooser_get_preview_widget(chooser: ?*GtkFileChooser) [*c]GtkWidget;
pub extern fn gtk_file_chooser_set_preview_widget_active(chooser: ?*GtkFileChooser, active: gboolean) void;
pub extern fn gtk_file_chooser_get_preview_widget_active(chooser: ?*GtkFileChooser) gboolean;
pub extern fn gtk_file_chooser_set_use_preview_label(chooser: ?*GtkFileChooser, use_label: gboolean) void;
pub extern fn gtk_file_chooser_get_use_preview_label(chooser: ?*GtkFileChooser) gboolean;
pub extern fn gtk_file_chooser_get_preview_filename(chooser: ?*GtkFileChooser) [*c]u8;
pub extern fn gtk_file_chooser_get_preview_uri(chooser: ?*GtkFileChooser) [*c]u8;
pub extern fn gtk_file_chooser_get_preview_file(chooser: ?*GtkFileChooser) ?*GFile;
pub extern fn gtk_file_chooser_set_extra_widget(chooser: ?*GtkFileChooser, extra_widget: [*c]GtkWidget) void;
pub extern fn gtk_file_chooser_get_extra_widget(chooser: ?*GtkFileChooser) [*c]GtkWidget;
pub extern fn gtk_file_chooser_add_filter(chooser: ?*GtkFileChooser, filter: ?*GtkFileFilter) void;
pub extern fn gtk_file_chooser_remove_filter(chooser: ?*GtkFileChooser, filter: ?*GtkFileFilter) void;
pub extern fn gtk_file_chooser_list_filters(chooser: ?*GtkFileChooser) [*c]GSList;
pub extern fn gtk_file_chooser_set_filter(chooser: ?*GtkFileChooser, filter: ?*GtkFileFilter) void;
pub extern fn gtk_file_chooser_get_filter(chooser: ?*GtkFileChooser) ?*GtkFileFilter;
pub extern fn gtk_file_chooser_add_shortcut_folder(chooser: ?*GtkFileChooser, folder: [*c]const u8, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_file_chooser_remove_shortcut_folder(chooser: ?*GtkFileChooser, folder: [*c]const u8, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_file_chooser_list_shortcut_folders(chooser: ?*GtkFileChooser) [*c]GSList;
pub extern fn gtk_file_chooser_add_shortcut_folder_uri(chooser: ?*GtkFileChooser, uri: [*c]const u8, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_file_chooser_remove_shortcut_folder_uri(chooser: ?*GtkFileChooser, uri: [*c]const u8, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_file_chooser_list_shortcut_folder_uris(chooser: ?*GtkFileChooser) [*c]GSList;
pub extern fn gtk_file_chooser_add_choice(chooser: ?*GtkFileChooser, id: [*c]const u8, label: [*c]const u8, options: [*c]([*c]const u8), option_labels: [*c]([*c]const u8)) void;
pub extern fn gtk_file_chooser_remove_choice(chooser: ?*GtkFileChooser, id: [*c]const u8) void;
pub extern fn gtk_file_chooser_set_choice(chooser: ?*GtkFileChooser, id: [*c]const u8, option: [*c]const u8) void;
pub extern fn gtk_file_chooser_get_choice(chooser: ?*GtkFileChooser, id: [*c]const u8) [*c]const u8;
pub const struct__GtkFileChooserButtonPrivate = @OpaqueType();
pub const GtkFileChooserButtonPrivate = struct__GtkFileChooserButtonPrivate;
pub const struct__GtkFileChooserButton = extern struct {
    parent: GtkBox,
    priv: ?*GtkFileChooserButtonPrivate,
};
pub const GtkFileChooserButton = struct__GtkFileChooserButton;
pub const struct__GtkFileChooserButtonClass = extern struct {
    parent_class: GtkBoxClass,
    file_set: ?extern fn ([*c]GtkFileChooserButton) void,
    __gtk_reserved1: ?extern fn () void,
    __gtk_reserved2: ?extern fn () void,
    __gtk_reserved3: ?extern fn () void,
    __gtk_reserved4: ?extern fn () void,
};
pub const GtkFileChooserButtonClass = struct__GtkFileChooserButtonClass;
pub extern fn gtk_file_chooser_button_get_type() GType;
pub extern fn gtk_file_chooser_button_new(title: [*c]const gchar, action: GtkFileChooserAction) [*c]GtkWidget;
pub extern fn gtk_file_chooser_button_new_with_dialog(dialog: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_file_chooser_button_get_title(button: [*c]GtkFileChooserButton) [*c]const gchar;
pub extern fn gtk_file_chooser_button_set_title(button: [*c]GtkFileChooserButton, title: [*c]const gchar) void;
pub extern fn gtk_file_chooser_button_get_width_chars(button: [*c]GtkFileChooserButton) gint;
pub extern fn gtk_file_chooser_button_set_width_chars(button: [*c]GtkFileChooserButton, n_chars: gint) void;
pub extern fn gtk_file_chooser_button_get_focus_on_click(button: [*c]GtkFileChooserButton) gboolean;
pub extern fn gtk_file_chooser_button_set_focus_on_click(button: [*c]GtkFileChooserButton, focus_on_click: gboolean) void;
pub const struct__GtkFileChooserDialogPrivate = @OpaqueType();
pub const GtkFileChooserDialogPrivate = struct__GtkFileChooserDialogPrivate;
pub const struct__GtkFileChooserDialog = extern struct {
    parent_instance: GtkDialog,
    priv: ?*GtkFileChooserDialogPrivate,
};
pub const GtkFileChooserDialog = struct__GtkFileChooserDialog;
pub const struct__GtkFileChooserDialogClass = extern struct {
    parent_class: GtkDialogClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkFileChooserDialogClass = struct__GtkFileChooserDialogClass;
pub extern fn gtk_file_chooser_dialog_get_type() GType;
pub extern fn gtk_file_chooser_dialog_new(title: [*c]const gchar, parent: [*c]GtkWindow, action: GtkFileChooserAction, first_button_text: [*c]const gchar, ...) [*c]GtkWidget;
pub extern fn gtk_native_dialog_get_type() GType;
pub const struct__GtkNativeDialog = extern struct {
    parent_instance: GObject,
};
pub const GtkNativeDialog = struct__GtkNativeDialog;
pub const struct__GtkNativeDialogClass = extern struct {
    parent_class: GObjectClass,
    response: ?extern fn ([*c]GtkNativeDialog, gint) void,
    show: ?extern fn ([*c]GtkNativeDialog) void,
    hide: ?extern fn ([*c]GtkNativeDialog) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkNativeDialogClass = struct__GtkNativeDialogClass;
pub const GtkNativeDialog_autoptr = [*c]GtkNativeDialog;
pub const GtkNativeDialog_listautoptr = [*c]GList;
pub const GtkNativeDialog_slistautoptr = [*c]GSList;
pub const GtkNativeDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNativeDialog(_ptr: [*c]GtkNativeDialog) void {
    if (_ptr != null) glib_autoptr_clear_GObject.?(@ptrCast([*c]GObject, @alignCast(@alignOf(GObject), _ptr)));
}
pub fn glib_autoptr_cleanup_GtkNativeDialog(_ptr: [*c]([*c]GtkNativeDialog)) void {
    glib_autoptr_clear_GtkNativeDialog(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkNativeDialog(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), glib_autoptr_clear_GObject)))));
}
pub fn glib_slistautoptr_cleanup_GtkNativeDialog(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), glib_autoptr_clear_GObject)))));
}
pub fn glib_queueautoptr_cleanup_GtkNativeDialog(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), glib_autoptr_clear_GObject)))));
}
pub fn GTK_NATIVE_DIALOG(ptr: gpointer) [*c]GtkNativeDialog {
    return @ptrCast([*c]GtkNativeDialog, @alignCast(@alignOf(GtkNativeDialog), g_type_check_instance_cast(@ptrCast([*c]GTypeInstance, @alignCast(@alignOf(GTypeInstance), ptr)), gtk_native_dialog_get_type())));
}
pub fn GTK_NATIVE_DIALOG_CLASS(ptr: gpointer) [*c]GtkNativeDialogClass {
    return @ptrCast([*c]GtkNativeDialogClass, @alignCast(@alignOf(GtkNativeDialogClass), g_type_check_class_cast(@ptrCast([*c]GTypeClass, @alignCast(@alignOf(GTypeClass), ptr)), gtk_native_dialog_get_type())));
}
pub fn GTK_IS_NATIVE_DIALOG(ptr: gpointer) gboolean {
    return g_type_check_instance_is_a(@ptrCast([*c]GTypeInstance, @alignCast(@alignOf(GTypeInstance), ptr)), gtk_native_dialog_get_type());
}
pub fn GTK_IS_NATIVE_DIALOG_CLASS(ptr: gpointer) gboolean {
    return g_type_check_class_is_a(@ptrCast([*c]GTypeClass, @alignCast(@alignOf(GTypeClass), ptr)), gtk_native_dialog_get_type());
}
pub fn GTK_NATIVE_DIALOG_GET_CLASS(ptr: gpointer) [*c]GtkNativeDialogClass {
    return @ptrCast([*c]GtkNativeDialogClass, @alignCast(@alignOf(GtkNativeDialogClass), @ptrCast([*c]GTypeInstance, @alignCast(@alignOf(GTypeInstance), ptr)).?.g_class));
}
pub extern fn gtk_native_dialog_show(self: [*c]GtkNativeDialog) void;
pub extern fn gtk_native_dialog_hide(self: [*c]GtkNativeDialog) void;
pub extern fn gtk_native_dialog_destroy(self: [*c]GtkNativeDialog) void;
pub extern fn gtk_native_dialog_get_visible(self: [*c]GtkNativeDialog) gboolean;
pub extern fn gtk_native_dialog_set_modal(self: [*c]GtkNativeDialog, modal: gboolean) void;
pub extern fn gtk_native_dialog_get_modal(self: [*c]GtkNativeDialog) gboolean;
pub extern fn gtk_native_dialog_set_title(self: [*c]GtkNativeDialog, title: [*c]const u8) void;
pub extern fn gtk_native_dialog_get_title(self: [*c]GtkNativeDialog) [*c]const u8;
pub extern fn gtk_native_dialog_set_transient_for(self: [*c]GtkNativeDialog, parent: [*c]GtkWindow) void;
pub extern fn gtk_native_dialog_get_transient_for(self: [*c]GtkNativeDialog) [*c]GtkWindow;
pub extern fn gtk_native_dialog_run(self: [*c]GtkNativeDialog) gint;
pub extern fn gtk_file_chooser_native_get_type() GType;
pub const struct__GtkFileChooserNative = @OpaqueType();
pub const GtkFileChooserNative = struct__GtkFileChooserNative;
pub const GtkFileChooserNativeClass = extern struct {
    parent_class: GtkNativeDialogClass,
};
pub const GtkFileChooserNative_autoptr = ?*GtkFileChooserNative;
pub const GtkFileChooserNative_listautoptr = [*c]GList;
pub const GtkFileChooserNative_slistautoptr = [*c]GSList;
pub const GtkFileChooserNative_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileChooserNative(_ptr: ?*GtkFileChooserNative) void {
    if (_ptr != null) glib_autoptr_clear_GtkNativeDialog.?(@ptrCast([*c]GtkNativeDialog, @alignCast(@alignOf(GtkNativeDialog), _ptr)));
}
pub fn glib_autoptr_cleanup_GtkFileChooserNative(_ptr: [*c](?*GtkFileChooserNative)) void {
    glib_autoptr_clear_GtkFileChooserNative(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkFileChooserNative(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), glib_autoptr_clear_GtkNativeDialog)))));
}
pub fn glib_slistautoptr_cleanup_GtkFileChooserNative(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), glib_autoptr_clear_GtkNativeDialog)))));
}
pub fn glib_queueautoptr_cleanup_GtkFileChooserNative(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), glib_autoptr_clear_GtkNativeDialog)))));
}
pub fn GTK_FILE_CHOOSER_NATIVE(ptr: gpointer) ?*GtkFileChooserNative {
    return @ptrCast(?*GtkFileChooserNative, @alignCast(@alignOf(GtkFileChooserNative), g_type_check_instance_cast(@ptrCast([*c]GTypeInstance, @alignCast(@alignOf(GTypeInstance), ptr)), gtk_file_chooser_native_get_type())));
}
pub fn GTK_IS_FILE_CHOOSER_NATIVE(ptr: gpointer) gboolean {
    return g_type_check_instance_is_a(@ptrCast([*c]GTypeInstance, @alignCast(@alignOf(GTypeInstance), ptr)), gtk_file_chooser_native_get_type());
}
pub extern fn gtk_file_chooser_native_new(title: [*c]const gchar, parent: [*c]GtkWindow, action: GtkFileChooserAction, accept_label: [*c]const gchar, cancel_label: [*c]const gchar) ?*GtkFileChooserNative;
pub extern fn gtk_file_chooser_native_get_accept_label(self: ?*GtkFileChooserNative) [*c]const u8;
pub extern fn gtk_file_chooser_native_set_accept_label(self: ?*GtkFileChooserNative, accept_label: [*c]const u8) void;
pub extern fn gtk_file_chooser_native_get_cancel_label(self: ?*GtkFileChooserNative) [*c]const u8;
pub extern fn gtk_file_chooser_native_set_cancel_label(self: ?*GtkFileChooserNative, cancel_label: [*c]const u8) void;
pub const struct__GtkFileChooserWidgetPrivate = @OpaqueType();
pub const GtkFileChooserWidgetPrivate = struct__GtkFileChooserWidgetPrivate;
pub const struct__GtkFileChooserWidget = extern struct {
    parent_instance: GtkBox,
    priv: ?*GtkFileChooserWidgetPrivate,
};
pub const GtkFileChooserWidget = struct__GtkFileChooserWidget;
pub const struct__GtkFileChooserWidgetClass = extern struct {
    parent_class: GtkBoxClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkFileChooserWidgetClass = struct__GtkFileChooserWidgetClass;
pub extern fn gtk_file_chooser_widget_get_type() GType;
pub extern fn gtk_file_chooser_widget_new(action: GtkFileChooserAction) [*c]GtkWidget;
pub const struct__GtkFlowBox = extern struct {
    container: GtkContainer,
};
pub const GtkFlowBox = struct__GtkFlowBox;
pub const struct__GtkFlowBoxChild = extern struct {
    parent_instance: GtkBin,
};
pub const GtkFlowBoxChild = struct__GtkFlowBoxChild;
pub const struct__GtkFlowBoxClass = extern struct {
    parent_class: GtkContainerClass,
    child_activated: ?extern fn ([*c]GtkFlowBox, [*c]GtkFlowBoxChild) void,
    selected_children_changed: ?extern fn ([*c]GtkFlowBox) void,
    activate_cursor_child: ?extern fn ([*c]GtkFlowBox) void,
    toggle_cursor_child: ?extern fn ([*c]GtkFlowBox) void,
    move_cursor: ?extern fn ([*c]GtkFlowBox, GtkMovementStep, gint) gboolean,
    select_all: ?extern fn ([*c]GtkFlowBox) void,
    unselect_all: ?extern fn ([*c]GtkFlowBox) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
};
pub const GtkFlowBoxClass = struct__GtkFlowBoxClass;
pub const struct__GtkFlowBoxChildClass = extern struct {
    parent_class: GtkBinClass,
    activate: ?extern fn ([*c]GtkFlowBoxChild) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
};
pub const GtkFlowBoxChildClass = struct__GtkFlowBoxChildClass;
pub const GtkFlowBoxCreateWidgetFunc = ?extern fn (gpointer, gpointer) [*c]GtkWidget;
pub extern fn gtk_flow_box_child_get_type() GType;
pub extern fn gtk_flow_box_child_new() [*c]GtkWidget;
pub extern fn gtk_flow_box_child_get_index(child: [*c]GtkFlowBoxChild) gint;
pub extern fn gtk_flow_box_child_is_selected(child: [*c]GtkFlowBoxChild) gboolean;
pub extern fn gtk_flow_box_child_changed(child: [*c]GtkFlowBoxChild) void;
pub extern fn gtk_flow_box_get_type() GType;
pub extern fn gtk_flow_box_new() [*c]GtkWidget;
pub extern fn gtk_flow_box_bind_model(box: [*c]GtkFlowBox, model: ?*GListModel, create_widget_func: GtkFlowBoxCreateWidgetFunc, user_data: gpointer, user_data_free_func: GDestroyNotify) void;
pub extern fn gtk_flow_box_set_homogeneous(box: [*c]GtkFlowBox, homogeneous: gboolean) void;
pub extern fn gtk_flow_box_get_homogeneous(box: [*c]GtkFlowBox) gboolean;
pub extern fn gtk_flow_box_set_row_spacing(box: [*c]GtkFlowBox, spacing: guint) void;
pub extern fn gtk_flow_box_get_row_spacing(box: [*c]GtkFlowBox) guint;
pub extern fn gtk_flow_box_set_column_spacing(box: [*c]GtkFlowBox, spacing: guint) void;
pub extern fn gtk_flow_box_get_column_spacing(box: [*c]GtkFlowBox) guint;
pub extern fn gtk_flow_box_set_min_children_per_line(box: [*c]GtkFlowBox, n_children: guint) void;
pub extern fn gtk_flow_box_get_min_children_per_line(box: [*c]GtkFlowBox) guint;
pub extern fn gtk_flow_box_set_max_children_per_line(box: [*c]GtkFlowBox, n_children: guint) void;
pub extern fn gtk_flow_box_get_max_children_per_line(box: [*c]GtkFlowBox) guint;
pub extern fn gtk_flow_box_set_activate_on_single_click(box: [*c]GtkFlowBox, single: gboolean) void;
pub extern fn gtk_flow_box_get_activate_on_single_click(box: [*c]GtkFlowBox) gboolean;
pub extern fn gtk_flow_box_insert(box: [*c]GtkFlowBox, widget: [*c]GtkWidget, position: gint) void;
pub extern fn gtk_flow_box_get_child_at_index(box: [*c]GtkFlowBox, idx: gint) [*c]GtkFlowBoxChild;
pub extern fn gtk_flow_box_get_child_at_pos(box: [*c]GtkFlowBox, x: gint, y: gint) [*c]GtkFlowBoxChild;
pub const GtkFlowBoxForeachFunc = ?extern fn ([*c]GtkFlowBox, [*c]GtkFlowBoxChild, gpointer) void;
pub extern fn gtk_flow_box_selected_foreach(box: [*c]GtkFlowBox, func: GtkFlowBoxForeachFunc, data: gpointer) void;
pub extern fn gtk_flow_box_get_selected_children(box: [*c]GtkFlowBox) [*c]GList;
pub extern fn gtk_flow_box_select_child(box: [*c]GtkFlowBox, child: [*c]GtkFlowBoxChild) void;
pub extern fn gtk_flow_box_unselect_child(box: [*c]GtkFlowBox, child: [*c]GtkFlowBoxChild) void;
pub extern fn gtk_flow_box_select_all(box: [*c]GtkFlowBox) void;
pub extern fn gtk_flow_box_unselect_all(box: [*c]GtkFlowBox) void;
pub extern fn gtk_flow_box_set_selection_mode(box: [*c]GtkFlowBox, mode: GtkSelectionMode) void;
pub extern fn gtk_flow_box_get_selection_mode(box: [*c]GtkFlowBox) GtkSelectionMode;
pub extern fn gtk_flow_box_set_hadjustment(box: [*c]GtkFlowBox, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_flow_box_set_vadjustment(box: [*c]GtkFlowBox, adjustment: [*c]GtkAdjustment) void;
pub const GtkFlowBoxFilterFunc = ?extern fn ([*c]GtkFlowBoxChild, gpointer) gboolean;
pub extern fn gtk_flow_box_set_filter_func(box: [*c]GtkFlowBox, filter_func: GtkFlowBoxFilterFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_flow_box_invalidate_filter(box: [*c]GtkFlowBox) void;
pub const GtkFlowBoxSortFunc = ?extern fn ([*c]GtkFlowBoxChild, [*c]GtkFlowBoxChild, gpointer) gint;
pub extern fn gtk_flow_box_set_sort_func(box: [*c]GtkFlowBox, sort_func: GtkFlowBoxSortFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_flow_box_invalidate_sort(box: [*c]GtkFlowBox) void;
pub const struct__GtkFontButtonPrivate = @OpaqueType();
pub const GtkFontButtonPrivate = struct__GtkFontButtonPrivate;
pub const struct__GtkFontButton = extern struct {
    button: GtkButton,
    priv: ?*GtkFontButtonPrivate,
};
pub const GtkFontButton = struct__GtkFontButton;
pub const struct__GtkFontButtonClass = extern struct {
    parent_class: GtkButtonClass,
    font_set: ?extern fn ([*c]GtkFontButton) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkFontButtonClass = struct__GtkFontButtonClass;
pub extern fn gtk_font_button_get_type() GType;
pub extern fn gtk_font_button_new() [*c]GtkWidget;
pub extern fn gtk_font_button_new_with_font(fontname: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_font_button_get_title(font_button: [*c]GtkFontButton) [*c]const gchar;
pub extern fn gtk_font_button_set_title(font_button: [*c]GtkFontButton, title: [*c]const gchar) void;
pub extern fn gtk_font_button_get_use_font(font_button: [*c]GtkFontButton) gboolean;
pub extern fn gtk_font_button_set_use_font(font_button: [*c]GtkFontButton, use_font: gboolean) void;
pub extern fn gtk_font_button_get_use_size(font_button: [*c]GtkFontButton) gboolean;
pub extern fn gtk_font_button_set_use_size(font_button: [*c]GtkFontButton, use_size: gboolean) void;
pub extern fn gtk_font_button_get_font_name(font_button: [*c]GtkFontButton) [*c]const gchar;
pub extern fn gtk_font_button_set_font_name(font_button: [*c]GtkFontButton, fontname: [*c]const gchar) gboolean;
pub extern fn gtk_font_button_get_show_style(font_button: [*c]GtkFontButton) gboolean;
pub extern fn gtk_font_button_set_show_style(font_button: [*c]GtkFontButton, show_style: gboolean) void;
pub extern fn gtk_font_button_get_show_size(font_button: [*c]GtkFontButton) gboolean;
pub extern fn gtk_font_button_set_show_size(font_button: [*c]GtkFontButton, show_size: gboolean) void;
pub const GtkFontFilterFunc = ?extern fn (?*const PangoFontFamily, ?*const PangoFontFace, gpointer) gboolean;
pub const GTK_FONT_CHOOSER_LEVEL_FAMILY = 0;
pub const GTK_FONT_CHOOSER_LEVEL_STYLE = 1;
pub const GTK_FONT_CHOOSER_LEVEL_SIZE = 2;
pub const GTK_FONT_CHOOSER_LEVEL_VARIATIONS = 4;
pub const GTK_FONT_CHOOSER_LEVEL_FEATURES = 8;
pub const GtkFontChooserLevel = extern enum {
    GTK_FONT_CHOOSER_LEVEL_FAMILY = 0,
    GTK_FONT_CHOOSER_LEVEL_STYLE = 1,
    GTK_FONT_CHOOSER_LEVEL_SIZE = 2,
    GTK_FONT_CHOOSER_LEVEL_VARIATIONS = 4,
    GTK_FONT_CHOOSER_LEVEL_FEATURES = 8,
};
pub const struct__GtkFontChooser = @OpaqueType();
pub const GtkFontChooser = struct__GtkFontChooser;
pub const struct__GtkFontChooserIface = extern struct {
    base_iface: GTypeInterface,
    get_font_family: ?extern fn (?*GtkFontChooser) ?*PangoFontFamily,
    get_font_face: ?extern fn (?*GtkFontChooser) ?*PangoFontFace,
    get_font_size: ?extern fn (?*GtkFontChooser) gint,
    set_filter_func: ?extern fn (?*GtkFontChooser, GtkFontFilterFunc, gpointer, GDestroyNotify) void,
    font_activated: ?extern fn (?*GtkFontChooser, [*c]const gchar) void,
    set_font_map: ?extern fn (?*GtkFontChooser, ?*PangoFontMap) void,
    get_font_map: ?extern fn (?*GtkFontChooser) ?*PangoFontMap,
    padding: [10]gpointer,
};
pub const GtkFontChooserIface = struct__GtkFontChooserIface;
pub extern fn gtk_font_chooser_get_type() GType;
pub extern fn gtk_font_chooser_get_font_family(fontchooser: ?*GtkFontChooser) ?*PangoFontFamily;
pub extern fn gtk_font_chooser_get_font_face(fontchooser: ?*GtkFontChooser) ?*PangoFontFace;
pub extern fn gtk_font_chooser_get_font_size(fontchooser: ?*GtkFontChooser) gint;
pub extern fn gtk_font_chooser_get_font_desc(fontchooser: ?*GtkFontChooser) ?*PangoFontDescription;
pub extern fn gtk_font_chooser_set_font_desc(fontchooser: ?*GtkFontChooser, font_desc: ?*const PangoFontDescription) void;
pub extern fn gtk_font_chooser_get_font(fontchooser: ?*GtkFontChooser) [*c]gchar;
pub extern fn gtk_font_chooser_set_font(fontchooser: ?*GtkFontChooser, fontname: [*c]const gchar) void;
pub extern fn gtk_font_chooser_get_preview_text(fontchooser: ?*GtkFontChooser) [*c]gchar;
pub extern fn gtk_font_chooser_set_preview_text(fontchooser: ?*GtkFontChooser, text: [*c]const gchar) void;
pub extern fn gtk_font_chooser_get_show_preview_entry(fontchooser: ?*GtkFontChooser) gboolean;
pub extern fn gtk_font_chooser_set_show_preview_entry(fontchooser: ?*GtkFontChooser, show_preview_entry: gboolean) void;
pub extern fn gtk_font_chooser_set_filter_func(fontchooser: ?*GtkFontChooser, filter: GtkFontFilterFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_font_chooser_set_font_map(fontchooser: ?*GtkFontChooser, fontmap: ?*PangoFontMap) void;
pub extern fn gtk_font_chooser_get_font_map(fontchooser: ?*GtkFontChooser) ?*PangoFontMap;
pub extern fn gtk_font_chooser_set_level(fontchooser: ?*GtkFontChooser, level: GtkFontChooserLevel) void;
pub extern fn gtk_font_chooser_get_level(fontchooser: ?*GtkFontChooser) GtkFontChooserLevel;
pub extern fn gtk_font_chooser_get_font_features(fontchooser: ?*GtkFontChooser) [*c]u8;
pub extern fn gtk_font_chooser_get_language(fontchooser: ?*GtkFontChooser) [*c]u8;
pub extern fn gtk_font_chooser_set_language(fontchooser: ?*GtkFontChooser, language: [*c]const u8) void;
pub const struct__GtkFontChooserDialogPrivate = @OpaqueType();
pub const GtkFontChooserDialogPrivate = struct__GtkFontChooserDialogPrivate;
pub const struct__GtkFontChooserDialog = extern struct {
    parent_instance: GtkDialog,
    priv: ?*GtkFontChooserDialogPrivate,
};
pub const GtkFontChooserDialog = struct__GtkFontChooserDialog;
pub const struct__GtkFontChooserDialogClass = extern struct {
    parent_class: GtkDialogClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkFontChooserDialogClass = struct__GtkFontChooserDialogClass;
pub extern fn gtk_font_chooser_dialog_get_type() GType;
pub extern fn gtk_font_chooser_dialog_new(title: [*c]const gchar, parent: [*c]GtkWindow) [*c]GtkWidget;
pub const struct__GtkFontChooserWidgetPrivate = @OpaqueType();
pub const GtkFontChooserWidgetPrivate = struct__GtkFontChooserWidgetPrivate;
pub const struct__GtkFontChooserWidget = extern struct {
    parent_instance: GtkBox,
    priv: ?*GtkFontChooserWidgetPrivate,
};
pub const GtkFontChooserWidget = struct__GtkFontChooserWidget;
pub const struct__GtkFontChooserWidgetClass = extern struct {
    parent_class: GtkBoxClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
    _gtk_reserved8: ?extern fn () void,
};
pub const GtkFontChooserWidgetClass = struct__GtkFontChooserWidgetClass;
pub extern fn gtk_font_chooser_widget_get_type() GType;
pub extern fn gtk_font_chooser_widget_new() [*c]GtkWidget;
pub const struct__GtkGesture = @OpaqueType();
pub const GtkGesture = struct__GtkGesture;
pub const struct__GtkGestureClass = @OpaqueType();
pub const GtkGestureClass = struct__GtkGestureClass;
pub extern fn gtk_gesture_get_type() GType;
pub extern fn gtk_gesture_get_device(gesture: ?*GtkGesture) ?*GdkDevice;
pub extern fn gtk_gesture_set_state(gesture: ?*GtkGesture, state: GtkEventSequenceState) gboolean;
pub extern fn gtk_gesture_get_sequence_state(gesture: ?*GtkGesture, sequence: ?*GdkEventSequence) GtkEventSequenceState;
pub extern fn gtk_gesture_set_sequence_state(gesture: ?*GtkGesture, sequence: ?*GdkEventSequence, state: GtkEventSequenceState) gboolean;
pub extern fn gtk_gesture_get_sequences(gesture: ?*GtkGesture) [*c]GList;
pub extern fn gtk_gesture_get_last_updated_sequence(gesture: ?*GtkGesture) ?*GdkEventSequence;
pub extern fn gtk_gesture_handles_sequence(gesture: ?*GtkGesture, sequence: ?*GdkEventSequence) gboolean;
pub extern fn gtk_gesture_get_last_event(gesture: ?*GtkGesture, sequence: ?*GdkEventSequence) [*c]const GdkEvent;
pub extern fn gtk_gesture_get_point(gesture: ?*GtkGesture, sequence: ?*GdkEventSequence, x: [*c]gdouble, y: [*c]gdouble) gboolean;
pub extern fn gtk_gesture_get_bounding_box(gesture: ?*GtkGesture, rect: [*c]GdkRectangle) gboolean;
pub extern fn gtk_gesture_get_bounding_box_center(gesture: ?*GtkGesture, x: [*c]gdouble, y: [*c]gdouble) gboolean;
pub extern fn gtk_gesture_is_active(gesture: ?*GtkGesture) gboolean;
pub extern fn gtk_gesture_is_recognized(gesture: ?*GtkGesture) gboolean;
pub extern fn gtk_gesture_get_window(gesture: ?*GtkGesture) ?*GdkWindow;
pub extern fn gtk_gesture_set_window(gesture: ?*GtkGesture, window: ?*GdkWindow) void;
pub extern fn gtk_gesture_group(group_gesture: ?*GtkGesture, gesture: ?*GtkGesture) void;
pub extern fn gtk_gesture_ungroup(gesture: ?*GtkGesture) void;
pub extern fn gtk_gesture_get_group(gesture: ?*GtkGesture) [*c]GList;
pub extern fn gtk_gesture_is_grouped_with(gesture: ?*GtkGesture, other: ?*GtkGesture) gboolean;
pub const struct__GtkGestureSingle = @OpaqueType();
pub const GtkGestureSingle = struct__GtkGestureSingle;
pub const struct__GtkGestureSingleClass = @OpaqueType();
pub const GtkGestureSingleClass = struct__GtkGestureSingleClass;
pub extern fn gtk_gesture_single_get_type() GType;
pub extern fn gtk_gesture_single_get_touch_only(gesture: ?*GtkGestureSingle) gboolean;
pub extern fn gtk_gesture_single_set_touch_only(gesture: ?*GtkGestureSingle, touch_only: gboolean) void;
pub extern fn gtk_gesture_single_get_exclusive(gesture: ?*GtkGestureSingle) gboolean;
pub extern fn gtk_gesture_single_set_exclusive(gesture: ?*GtkGestureSingle, exclusive: gboolean) void;
pub extern fn gtk_gesture_single_get_button(gesture: ?*GtkGestureSingle) guint;
pub extern fn gtk_gesture_single_set_button(gesture: ?*GtkGestureSingle, button: guint) void;
pub extern fn gtk_gesture_single_get_current_button(gesture: ?*GtkGestureSingle) guint;
pub extern fn gtk_gesture_single_get_current_sequence(gesture: ?*GtkGestureSingle) ?*GdkEventSequence;
pub const struct__GtkGestureDrag = @OpaqueType();
pub const GtkGestureDrag = struct__GtkGestureDrag;
pub const struct__GtkGestureDragClass = @OpaqueType();
pub const GtkGestureDragClass = struct__GtkGestureDragClass;
pub extern fn gtk_gesture_drag_get_type() GType;
pub extern fn gtk_gesture_drag_new(widget: [*c]GtkWidget) ?*GtkGesture;
pub extern fn gtk_gesture_drag_get_start_point(gesture: ?*GtkGestureDrag, x: [*c]gdouble, y: [*c]gdouble) gboolean;
pub extern fn gtk_gesture_drag_get_offset(gesture: ?*GtkGestureDrag, x: [*c]gdouble, y: [*c]gdouble) gboolean;
pub const struct__GtkGestureLongPress = @OpaqueType();
pub const GtkGestureLongPress = struct__GtkGestureLongPress;
pub const struct__GtkGestureLongPressClass = @OpaqueType();
pub const GtkGestureLongPressClass = struct__GtkGestureLongPressClass;
pub extern fn gtk_gesture_long_press_get_type() GType;
pub extern fn gtk_gesture_long_press_new(widget: [*c]GtkWidget) ?*GtkGesture;
pub const struct__GtkGestureMultiPress = @OpaqueType();
pub const GtkGestureMultiPress = struct__GtkGestureMultiPress;
pub const struct__GtkGestureMultiPressClass = @OpaqueType();
pub const GtkGestureMultiPressClass = struct__GtkGestureMultiPressClass;
pub extern fn gtk_gesture_multi_press_get_type() GType;
pub extern fn gtk_gesture_multi_press_new(widget: [*c]GtkWidget) ?*GtkGesture;
pub extern fn gtk_gesture_multi_press_set_area(gesture: ?*GtkGestureMultiPress, rect: [*c]const GdkRectangle) void;
pub extern fn gtk_gesture_multi_press_get_area(gesture: ?*GtkGestureMultiPress, rect: [*c]GdkRectangle) gboolean;
pub const struct__GtkGesturePan = @OpaqueType();
pub const GtkGesturePan = struct__GtkGesturePan;
pub const struct__GtkGesturePanClass = @OpaqueType();
pub const GtkGesturePanClass = struct__GtkGesturePanClass;
pub extern fn gtk_gesture_pan_get_type() GType;
pub extern fn gtk_gesture_pan_new(widget: [*c]GtkWidget, orientation: GtkOrientation) ?*GtkGesture;
pub extern fn gtk_gesture_pan_get_orientation(gesture: ?*GtkGesturePan) GtkOrientation;
pub extern fn gtk_gesture_pan_set_orientation(gesture: ?*GtkGesturePan, orientation: GtkOrientation) void;
pub const struct__GtkGestureRotate = @OpaqueType();
pub const GtkGestureRotate = struct__GtkGestureRotate;
pub const struct__GtkGestureRotateClass = @OpaqueType();
pub const GtkGestureRotateClass = struct__GtkGestureRotateClass;
pub extern fn gtk_gesture_rotate_get_type() GType;
pub extern fn gtk_gesture_rotate_new(widget: [*c]GtkWidget) ?*GtkGesture;
pub extern fn gtk_gesture_rotate_get_angle_delta(gesture: ?*GtkGestureRotate) gdouble;
pub const struct__GtkGestureStylus = @OpaqueType();
pub const GtkGestureStylus = struct__GtkGestureStylus;
pub const struct__GtkGestureStylusClass = @OpaqueType();
pub const GtkGestureStylusClass = struct__GtkGestureStylusClass;
pub extern fn gtk_gesture_stylus_get_type() GType;
pub extern fn gtk_gesture_stylus_new(widget: [*c]GtkWidget) ?*GtkGesture;
pub extern fn gtk_gesture_stylus_get_axis(gesture: ?*GtkGestureStylus, axis: GdkAxisUse, value: [*c]gdouble) gboolean;
pub extern fn gtk_gesture_stylus_get_axes(gesture: ?*GtkGestureStylus, axes: [*c]GdkAxisUse, values: [*c]([*c]gdouble)) gboolean;
pub extern fn gtk_gesture_stylus_get_device_tool(gesture: ?*GtkGestureStylus) ?*GdkDeviceTool;
pub const struct__GtkGestureSwipe = @OpaqueType();
pub const GtkGestureSwipe = struct__GtkGestureSwipe;
pub const struct__GtkGestureSwipeClass = @OpaqueType();
pub const GtkGestureSwipeClass = struct__GtkGestureSwipeClass;
pub extern fn gtk_gesture_swipe_get_type() GType;
pub extern fn gtk_gesture_swipe_new(widget: [*c]GtkWidget) ?*GtkGesture;
pub extern fn gtk_gesture_swipe_get_velocity(gesture: ?*GtkGestureSwipe, velocity_x: [*c]gdouble, velocity_y: [*c]gdouble) gboolean;
pub const struct__GtkGestureZoom = @OpaqueType();
pub const GtkGestureZoom = struct__GtkGestureZoom;
pub const struct__GtkGestureZoomClass = @OpaqueType();
pub const GtkGestureZoomClass = struct__GtkGestureZoomClass;
pub extern fn gtk_gesture_zoom_get_type() GType;
pub extern fn gtk_gesture_zoom_new(widget: [*c]GtkWidget) ?*GtkGesture;
pub extern fn gtk_gesture_zoom_get_scale_delta(gesture: ?*GtkGestureZoom) gdouble;
pub const struct__GtkGLArea = extern struct {
    parent_instance: GtkWidget,
};
pub const GtkGLArea = struct__GtkGLArea;
pub const struct__GtkGLAreaClass = extern struct {
    parent_class: GtkWidgetClass,
    render: ?extern fn ([*c]GtkGLArea, ?*GdkGLContext) gboolean,
    resize: ?extern fn ([*c]GtkGLArea, c_int, c_int) void,
    create_context: ?extern fn ([*c]GtkGLArea) ?*GdkGLContext,
    _padding: [6]gpointer,
};
pub const GtkGLAreaClass = struct__GtkGLAreaClass;
pub extern fn gtk_gl_area_get_type() GType;
pub extern fn gtk_gl_area_new() [*c]GtkWidget;
pub extern fn gtk_gl_area_set_use_es(area: [*c]GtkGLArea, use_es: gboolean) void;
pub extern fn gtk_gl_area_get_use_es(area: [*c]GtkGLArea) gboolean;
pub extern fn gtk_gl_area_set_required_version(area: [*c]GtkGLArea, major: gint, minor: gint) void;
pub extern fn gtk_gl_area_get_required_version(area: [*c]GtkGLArea, major: [*c]gint, minor: [*c]gint) void;
pub extern fn gtk_gl_area_get_has_alpha(area: [*c]GtkGLArea) gboolean;
pub extern fn gtk_gl_area_set_has_alpha(area: [*c]GtkGLArea, has_alpha: gboolean) void;
pub extern fn gtk_gl_area_get_has_depth_buffer(area: [*c]GtkGLArea) gboolean;
pub extern fn gtk_gl_area_set_has_depth_buffer(area: [*c]GtkGLArea, has_depth_buffer: gboolean) void;
pub extern fn gtk_gl_area_get_has_stencil_buffer(area: [*c]GtkGLArea) gboolean;
pub extern fn gtk_gl_area_set_has_stencil_buffer(area: [*c]GtkGLArea, has_stencil_buffer: gboolean) void;
pub extern fn gtk_gl_area_get_auto_render(area: [*c]GtkGLArea) gboolean;
pub extern fn gtk_gl_area_set_auto_render(area: [*c]GtkGLArea, auto_render: gboolean) void;
pub extern fn gtk_gl_area_queue_render(area: [*c]GtkGLArea) void;
pub extern fn gtk_gl_area_get_context(area: [*c]GtkGLArea) ?*GdkGLContext;
pub extern fn gtk_gl_area_make_current(area: [*c]GtkGLArea) void;
pub extern fn gtk_gl_area_attach_buffers(area: [*c]GtkGLArea) void;
pub extern fn gtk_gl_area_set_error(area: [*c]GtkGLArea, @"error": [*c]const GError) void;
pub extern fn gtk_gl_area_get_error(area: [*c]GtkGLArea) [*c]GError;
pub const struct__GtkGridPrivate = @OpaqueType();
pub const GtkGridPrivate = struct__GtkGridPrivate;
pub const struct__GtkGrid = extern struct {
    container: GtkContainer,
    priv: ?*GtkGridPrivate,
};
pub const GtkGrid = struct__GtkGrid;
pub const struct__GtkGridClass = extern struct {
    parent_class: GtkContainerClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
    _gtk_reserved8: ?extern fn () void,
};
pub const GtkGridClass = struct__GtkGridClass;
pub extern fn gtk_grid_get_type() GType;
pub extern fn gtk_grid_new() [*c]GtkWidget;
pub extern fn gtk_grid_attach(grid: [*c]GtkGrid, child: [*c]GtkWidget, left: gint, top: gint, width: gint, height: gint) void;
pub extern fn gtk_grid_attach_next_to(grid: [*c]GtkGrid, child: [*c]GtkWidget, sibling: [*c]GtkWidget, side: GtkPositionType, width: gint, height: gint) void;
pub extern fn gtk_grid_get_child_at(grid: [*c]GtkGrid, left: gint, top: gint) [*c]GtkWidget;
pub extern fn gtk_grid_insert_row(grid: [*c]GtkGrid, position: gint) void;
pub extern fn gtk_grid_insert_column(grid: [*c]GtkGrid, position: gint) void;
pub extern fn gtk_grid_remove_row(grid: [*c]GtkGrid, position: gint) void;
pub extern fn gtk_grid_remove_column(grid: [*c]GtkGrid, position: gint) void;
pub extern fn gtk_grid_insert_next_to(grid: [*c]GtkGrid, sibling: [*c]GtkWidget, side: GtkPositionType) void;
pub extern fn gtk_grid_set_row_homogeneous(grid: [*c]GtkGrid, homogeneous: gboolean) void;
pub extern fn gtk_grid_get_row_homogeneous(grid: [*c]GtkGrid) gboolean;
pub extern fn gtk_grid_set_row_spacing(grid: [*c]GtkGrid, spacing: guint) void;
pub extern fn gtk_grid_get_row_spacing(grid: [*c]GtkGrid) guint;
pub extern fn gtk_grid_set_column_homogeneous(grid: [*c]GtkGrid, homogeneous: gboolean) void;
pub extern fn gtk_grid_get_column_homogeneous(grid: [*c]GtkGrid) gboolean;
pub extern fn gtk_grid_set_column_spacing(grid: [*c]GtkGrid, spacing: guint) void;
pub extern fn gtk_grid_get_column_spacing(grid: [*c]GtkGrid) guint;
pub extern fn gtk_grid_set_row_baseline_position(grid: [*c]GtkGrid, row: gint, pos: GtkBaselinePosition) void;
pub extern fn gtk_grid_get_row_baseline_position(grid: [*c]GtkGrid, row: gint) GtkBaselinePosition;
pub extern fn gtk_grid_set_baseline_row(grid: [*c]GtkGrid, row: gint) void;
pub extern fn gtk_grid_get_baseline_row(grid: [*c]GtkGrid) gint;
pub const struct__GtkHeaderBar = extern struct {
    container: GtkContainer,
};
pub const GtkHeaderBar = struct__GtkHeaderBar;
pub const struct__GtkHeaderBarPrivate = @OpaqueType();
pub const GtkHeaderBarPrivate = struct__GtkHeaderBarPrivate;
pub const struct__GtkHeaderBarClass = extern struct {
    parent_class: GtkContainerClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkHeaderBarClass = struct__GtkHeaderBarClass;
pub extern fn gtk_header_bar_get_type() GType;
pub extern fn gtk_header_bar_new() [*c]GtkWidget;
pub extern fn gtk_header_bar_set_title(bar: [*c]GtkHeaderBar, title: [*c]const gchar) void;
pub extern fn gtk_header_bar_get_title(bar: [*c]GtkHeaderBar) [*c]const gchar;
pub extern fn gtk_header_bar_set_subtitle(bar: [*c]GtkHeaderBar, subtitle: [*c]const gchar) void;
pub extern fn gtk_header_bar_get_subtitle(bar: [*c]GtkHeaderBar) [*c]const gchar;
pub extern fn gtk_header_bar_set_custom_title(bar: [*c]GtkHeaderBar, title_widget: [*c]GtkWidget) void;
pub extern fn gtk_header_bar_get_custom_title(bar: [*c]GtkHeaderBar) [*c]GtkWidget;
pub extern fn gtk_header_bar_pack_start(bar: [*c]GtkHeaderBar, child: [*c]GtkWidget) void;
pub extern fn gtk_header_bar_pack_end(bar: [*c]GtkHeaderBar, child: [*c]GtkWidget) void;
pub extern fn gtk_header_bar_get_show_close_button(bar: [*c]GtkHeaderBar) gboolean;
pub extern fn gtk_header_bar_set_show_close_button(bar: [*c]GtkHeaderBar, setting: gboolean) void;
pub extern fn gtk_header_bar_set_has_subtitle(bar: [*c]GtkHeaderBar, setting: gboolean) void;
pub extern fn gtk_header_bar_get_has_subtitle(bar: [*c]GtkHeaderBar) gboolean;
pub extern fn gtk_header_bar_set_decoration_layout(bar: [*c]GtkHeaderBar, layout: [*c]const gchar) void;
pub extern fn gtk_header_bar_get_decoration_layout(bar: [*c]GtkHeaderBar) [*c]const gchar;
pub const struct__GtkIconFactoryPrivate = @OpaqueType();
pub const GtkIconFactoryPrivate = struct__GtkIconFactoryPrivate;
pub const struct__GtkIconFactory = extern struct {
    parent_instance: GObject,
    priv: ?*GtkIconFactoryPrivate,
};
pub const GtkIconFactory = struct__GtkIconFactory;
pub const struct__GtkIconFactoryClass = extern struct {
    parent_class: GObjectClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkIconFactoryClass = struct__GtkIconFactoryClass;
pub extern fn gtk_icon_factory_get_type() GType;
pub extern fn gtk_icon_factory_new() [*c]GtkIconFactory;
pub extern fn gtk_icon_factory_add(factory: [*c]GtkIconFactory, stock_id: [*c]const gchar, icon_set: ?*GtkIconSet) void;
pub extern fn gtk_icon_factory_lookup(factory: [*c]GtkIconFactory, stock_id: [*c]const gchar) ?*GtkIconSet;
pub extern fn gtk_icon_factory_add_default(factory: [*c]GtkIconFactory) void;
pub extern fn gtk_icon_factory_remove_default(factory: [*c]GtkIconFactory) void;
pub extern fn gtk_icon_factory_lookup_default(stock_id: [*c]const gchar) ?*GtkIconSet;
pub extern fn gtk_icon_size_lookup(size: GtkIconSize, width: [*c]gint, height: [*c]gint) gboolean;
pub extern fn gtk_icon_size_lookup_for_settings(settings: [*c]GtkSettings, size: GtkIconSize, width: [*c]gint, height: [*c]gint) gboolean;
pub extern fn gtk_icon_size_register(name: [*c]const gchar, width: gint, height: gint) GtkIconSize;
pub extern fn gtk_icon_size_register_alias(alias: [*c]const gchar, target: GtkIconSize) void;
pub extern fn gtk_icon_size_from_name(name: [*c]const gchar) GtkIconSize;
pub extern fn gtk_icon_size_get_name(size: GtkIconSize) [*c]const gchar;
pub extern fn gtk_icon_set_get_type() GType;
pub extern fn gtk_icon_set_new() ?*GtkIconSet;
pub extern fn gtk_icon_set_new_from_pixbuf(pixbuf: ?*GdkPixbuf) ?*GtkIconSet;
pub extern fn gtk_icon_set_ref(icon_set: ?*GtkIconSet) ?*GtkIconSet;
pub extern fn gtk_icon_set_unref(icon_set: ?*GtkIconSet) void;
pub extern fn gtk_icon_set_copy(icon_set: ?*GtkIconSet) ?*GtkIconSet;
pub extern fn gtk_icon_set_render_icon(icon_set: ?*GtkIconSet, style: [*c]GtkStyle, direction: GtkTextDirection, state: GtkStateType, size: GtkIconSize, widget: [*c]GtkWidget, detail: [*c]const gchar) ?*GdkPixbuf;
pub extern fn gtk_icon_set_add_source(icon_set: ?*GtkIconSet, source: ?*const GtkIconSource) void;
pub extern fn gtk_icon_set_get_sizes(icon_set: ?*GtkIconSet, sizes: [*c]([*c]GtkIconSize), n_sizes: [*c]gint) void;
pub extern fn gtk_icon_source_get_type() GType;
pub extern fn gtk_icon_source_new() ?*GtkIconSource;
pub extern fn gtk_icon_source_copy(source: ?*const GtkIconSource) ?*GtkIconSource;
pub extern fn gtk_icon_source_free(source: ?*GtkIconSource) void;
pub extern fn gtk_icon_source_set_filename(source: ?*GtkIconSource, filename: [*c]const gchar) void;
pub extern fn gtk_icon_source_set_icon_name(source: ?*GtkIconSource, icon_name: [*c]const gchar) void;
pub extern fn gtk_icon_source_set_pixbuf(source: ?*GtkIconSource, pixbuf: ?*GdkPixbuf) void;
pub extern fn gtk_icon_source_get_filename(source: ?*const GtkIconSource) [*c]const gchar;
pub extern fn gtk_icon_source_get_icon_name(source: ?*const GtkIconSource) [*c]const gchar;
pub extern fn gtk_icon_source_get_pixbuf(source: ?*const GtkIconSource) ?*GdkPixbuf;
pub extern fn gtk_icon_source_set_direction_wildcarded(source: ?*GtkIconSource, setting: gboolean) void;
pub extern fn gtk_icon_source_set_state_wildcarded(source: ?*GtkIconSource, setting: gboolean) void;
pub extern fn gtk_icon_source_set_size_wildcarded(source: ?*GtkIconSource, setting: gboolean) void;
pub extern fn gtk_icon_source_get_size_wildcarded(source: ?*const GtkIconSource) gboolean;
pub extern fn gtk_icon_source_get_state_wildcarded(source: ?*const GtkIconSource) gboolean;
pub extern fn gtk_icon_source_get_direction_wildcarded(source: ?*const GtkIconSource) gboolean;
pub extern fn gtk_icon_source_set_direction(source: ?*GtkIconSource, direction: GtkTextDirection) void;
pub extern fn gtk_icon_source_set_state(source: ?*GtkIconSource, state: GtkStateType) void;
pub extern fn gtk_icon_source_set_size(source: ?*GtkIconSource, size: GtkIconSize) void;
pub extern fn gtk_icon_source_get_direction(source: ?*const GtkIconSource) GtkTextDirection;
pub extern fn gtk_icon_source_get_state(source: ?*const GtkIconSource) GtkStateType;
pub extern fn gtk_icon_source_get_size(source: ?*const GtkIconSource) GtkIconSize;
pub const struct__GtkStylePropertiesPrivate = @OpaqueType();
pub const GtkStylePropertiesPrivate = struct__GtkStylePropertiesPrivate;
pub const struct__GtkStyleProperties = extern struct {
    parent_object: GObject,
    priv: ?*GtkStylePropertiesPrivate,
};
pub const GtkStyleProperties = struct__GtkStyleProperties;
pub const struct__GtkStylePropertiesClass = extern struct {
    parent_class: GObjectClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkStylePropertiesClass = struct__GtkStylePropertiesClass;
pub const struct__GtkSymbolicColor = @OpaqueType();
pub const GtkSymbolicColor = struct__GtkSymbolicColor;
pub const struct__GtkGradient = @OpaqueType();
pub const GtkGradient = struct__GtkGradient;
pub const GtkStylePropertyParser = ?extern fn ([*c]const gchar, [*c]GValue, [*c]([*c]GError)) gboolean;
pub extern fn gtk_style_properties_get_type() GType;
pub extern fn gtk_style_properties_register_property(parse_func: GtkStylePropertyParser, pspec: [*c]GParamSpec) void;
pub extern fn gtk_style_properties_lookup_property(property_name: [*c]const gchar, parse_func: [*c]GtkStylePropertyParser, pspec: [*c]([*c]GParamSpec)) gboolean;
pub extern fn gtk_style_properties_new() [*c]GtkStyleProperties;
pub extern fn gtk_style_properties_map_color(props: [*c]GtkStyleProperties, name: [*c]const gchar, color: ?*GtkSymbolicColor) void;
pub extern fn gtk_style_properties_lookup_color(props: [*c]GtkStyleProperties, name: [*c]const gchar) ?*GtkSymbolicColor;
pub extern fn gtk_style_properties_set_property(props: [*c]GtkStyleProperties, property: [*c]const gchar, state: GtkStateFlags, value: [*c]const GValue) void;
pub extern fn gtk_style_properties_set_valist(props: [*c]GtkStyleProperties, state: GtkStateFlags, args: va_list) void;
pub extern fn gtk_style_properties_set(props: [*c]GtkStyleProperties, state: GtkStateFlags, ...) void;
pub extern fn gtk_style_properties_get_property(props: [*c]GtkStyleProperties, property: [*c]const gchar, state: GtkStateFlags, value: [*c]GValue) gboolean;
pub extern fn gtk_style_properties_get_valist(props: [*c]GtkStyleProperties, state: GtkStateFlags, args: va_list) void;
pub extern fn gtk_style_properties_get(props: [*c]GtkStyleProperties, state: GtkStateFlags, ...) void;
pub extern fn gtk_style_properties_unset_property(props: [*c]GtkStyleProperties, property: [*c]const gchar, state: GtkStateFlags) void;
pub extern fn gtk_style_properties_clear(props: [*c]GtkStyleProperties) void;
pub extern fn gtk_style_properties_merge(props: [*c]GtkStyleProperties, props_to_merge: [*c]const GtkStyleProperties, replace: gboolean) void;
pub const struct__GtkStyleProvider = @OpaqueType();
pub const GtkStyleProvider = struct__GtkStyleProvider;
pub const struct__GtkStyleProviderIface = extern struct {
    g_iface: GTypeInterface,
    get_style: ?extern fn (?*GtkStyleProvider, ?*GtkWidgetPath) [*c]GtkStyleProperties,
    get_style_property: ?extern fn (?*GtkStyleProvider, ?*GtkWidgetPath, GtkStateFlags, [*c]GParamSpec, [*c]GValue) gboolean,
    get_icon_factory: ?extern fn (?*GtkStyleProvider, ?*GtkWidgetPath) [*c]GtkIconFactory,
};
pub const GtkStyleProviderIface = struct__GtkStyleProviderIface;
pub extern fn gtk_style_provider_get_type() GType;
pub extern fn gtk_style_provider_get_style(provider: ?*GtkStyleProvider, path: ?*GtkWidgetPath) [*c]GtkStyleProperties;
pub extern fn gtk_style_provider_get_style_property(provider: ?*GtkStyleProvider, path: ?*GtkWidgetPath, state: GtkStateFlags, pspec: [*c]GParamSpec, value: [*c]GValue) gboolean;
pub extern fn gtk_style_provider_get_icon_factory(provider: ?*GtkStyleProvider, path: ?*GtkWidgetPath) [*c]GtkIconFactory;
pub const struct__GtkStyleContextClass = extern struct {
    parent_class: GObjectClass,
    changed: ?extern fn ([*c]GtkStyleContext) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkStyleContextClass = struct__GtkStyleContextClass;
pub extern fn gtk_style_context_get_type() GType;
pub extern fn gtk_style_context_new() [*c]GtkStyleContext;
pub extern fn gtk_style_context_add_provider_for_screen(screen: ?*GdkScreen, provider: ?*GtkStyleProvider, priority: guint) void;
pub extern fn gtk_style_context_remove_provider_for_screen(screen: ?*GdkScreen, provider: ?*GtkStyleProvider) void;
pub extern fn gtk_style_context_add_provider(context: [*c]GtkStyleContext, provider: ?*GtkStyleProvider, priority: guint) void;
pub extern fn gtk_style_context_remove_provider(context: [*c]GtkStyleContext, provider: ?*GtkStyleProvider) void;
pub extern fn gtk_style_context_save(context: [*c]GtkStyleContext) void;
pub extern fn gtk_style_context_restore(context: [*c]GtkStyleContext) void;
pub extern fn gtk_style_context_get_section(context: [*c]GtkStyleContext, property: [*c]const gchar) ?*GtkCssSection;
pub extern fn gtk_style_context_get_property(context: [*c]GtkStyleContext, property: [*c]const gchar, state: GtkStateFlags, value: [*c]GValue) void;
pub extern fn gtk_style_context_get_valist(context: [*c]GtkStyleContext, state: GtkStateFlags, args: va_list) void;
pub extern fn gtk_style_context_get(context: [*c]GtkStyleContext, state: GtkStateFlags, ...) void;
pub extern fn gtk_style_context_set_state(context: [*c]GtkStyleContext, flags: GtkStateFlags) void;
pub extern fn gtk_style_context_get_state(context: [*c]GtkStyleContext) GtkStateFlags;
pub extern fn gtk_style_context_set_scale(context: [*c]GtkStyleContext, scale: gint) void;
pub extern fn gtk_style_context_get_scale(context: [*c]GtkStyleContext) gint;
pub extern fn gtk_style_context_state_is_running(context: [*c]GtkStyleContext, state: GtkStateType, progress: [*c]gdouble) gboolean;
pub extern fn gtk_style_context_set_path(context: [*c]GtkStyleContext, path: ?*GtkWidgetPath) void;
pub extern fn gtk_style_context_get_path(context: [*c]GtkStyleContext) ?*const GtkWidgetPath;
pub extern fn gtk_style_context_set_parent(context: [*c]GtkStyleContext, parent: [*c]GtkStyleContext) void;
pub extern fn gtk_style_context_get_parent(context: [*c]GtkStyleContext) [*c]GtkStyleContext;
pub extern fn gtk_style_context_list_classes(context: [*c]GtkStyleContext) [*c]GList;
pub extern fn gtk_style_context_add_class(context: [*c]GtkStyleContext, class_name: [*c]const gchar) void;
pub extern fn gtk_style_context_remove_class(context: [*c]GtkStyleContext, class_name: [*c]const gchar) void;
pub extern fn gtk_style_context_has_class(context: [*c]GtkStyleContext, class_name: [*c]const gchar) gboolean;
pub extern fn gtk_style_context_list_regions(context: [*c]GtkStyleContext) [*c]GList;
pub extern fn gtk_style_context_add_region(context: [*c]GtkStyleContext, region_name: [*c]const gchar, flags: GtkRegionFlags) void;
pub extern fn gtk_style_context_remove_region(context: [*c]GtkStyleContext, region_name: [*c]const gchar) void;
pub extern fn gtk_style_context_has_region(context: [*c]GtkStyleContext, region_name: [*c]const gchar, flags_return: [*c]GtkRegionFlags) gboolean;
pub extern fn gtk_style_context_get_style_property(context: [*c]GtkStyleContext, property_name: [*c]const gchar, value: [*c]GValue) void;
pub extern fn gtk_style_context_get_style_valist(context: [*c]GtkStyleContext, args: va_list) void;
pub extern fn gtk_style_context_get_style(context: [*c]GtkStyleContext, ...) void;
pub extern fn gtk_style_context_lookup_icon_set(context: [*c]GtkStyleContext, stock_id: [*c]const gchar) ?*GtkIconSet;
pub extern fn gtk_icon_set_render_icon_pixbuf(icon_set: ?*GtkIconSet, context: [*c]GtkStyleContext, size: GtkIconSize) ?*GdkPixbuf;
pub extern fn gtk_icon_set_render_icon_surface(icon_set: ?*GtkIconSet, context: [*c]GtkStyleContext, size: GtkIconSize, scale: c_int, for_window: ?*GdkWindow) ?*cairo_surface_t;
pub extern fn gtk_style_context_set_screen(context: [*c]GtkStyleContext, screen: ?*GdkScreen) void;
pub extern fn gtk_style_context_get_screen(context: [*c]GtkStyleContext) ?*GdkScreen;
pub extern fn gtk_style_context_set_frame_clock(context: [*c]GtkStyleContext, frame_clock: ?*GdkFrameClock) void;
pub extern fn gtk_style_context_get_frame_clock(context: [*c]GtkStyleContext) ?*GdkFrameClock;
pub extern fn gtk_style_context_set_direction(context: [*c]GtkStyleContext, direction: GtkTextDirection) void;
pub extern fn gtk_style_context_get_direction(context: [*c]GtkStyleContext) GtkTextDirection;
pub extern fn gtk_style_context_set_junction_sides(context: [*c]GtkStyleContext, sides: GtkJunctionSides) void;
pub extern fn gtk_style_context_get_junction_sides(context: [*c]GtkStyleContext) GtkJunctionSides;
pub extern fn gtk_style_context_lookup_color(context: [*c]GtkStyleContext, color_name: [*c]const gchar, color: [*c]GdkRGBA) gboolean;
pub extern fn gtk_style_context_notify_state_change(context: [*c]GtkStyleContext, window: ?*GdkWindow, region_id: gpointer, state: GtkStateType, state_value: gboolean) void;
pub extern fn gtk_style_context_cancel_animations(context: [*c]GtkStyleContext, region_id: gpointer) void;
pub extern fn gtk_style_context_scroll_animations(context: [*c]GtkStyleContext, window: ?*GdkWindow, dx: gint, dy: gint) void;
pub extern fn gtk_style_context_push_animatable_region(context: [*c]GtkStyleContext, region_id: gpointer) void;
pub extern fn gtk_style_context_pop_animatable_region(context: [*c]GtkStyleContext) void;
pub extern fn gtk_style_context_get_color(context: [*c]GtkStyleContext, state: GtkStateFlags, color: [*c]GdkRGBA) void;
pub extern fn gtk_style_context_get_background_color(context: [*c]GtkStyleContext, state: GtkStateFlags, color: [*c]GdkRGBA) void;
pub extern fn gtk_style_context_get_border_color(context: [*c]GtkStyleContext, state: GtkStateFlags, color: [*c]GdkRGBA) void;
pub extern fn gtk_style_context_get_font(context: [*c]GtkStyleContext, state: GtkStateFlags) ?*const PangoFontDescription;
pub extern fn gtk_style_context_get_border(context: [*c]GtkStyleContext, state: GtkStateFlags, border: [*c]GtkBorder) void;
pub extern fn gtk_style_context_get_padding(context: [*c]GtkStyleContext, state: GtkStateFlags, padding: [*c]GtkBorder) void;
pub extern fn gtk_style_context_get_margin(context: [*c]GtkStyleContext, state: GtkStateFlags, margin: [*c]GtkBorder) void;
pub extern fn gtk_style_context_invalidate(context: [*c]GtkStyleContext) void;
pub extern fn gtk_style_context_reset_widgets(screen: ?*GdkScreen) void;
pub extern fn gtk_style_context_set_background(context: [*c]GtkStyleContext, window: ?*GdkWindow) void;
pub extern fn gtk_render_insertion_cursor(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: gdouble, y: gdouble, layout: ?*PangoLayout, index: c_int, direction: PangoDirection) void;
pub extern fn gtk_draw_insertion_cursor(widget: [*c]GtkWidget, cr: ?*cairo_t, location: [*c]const GdkRectangle, is_primary: gboolean, direction: GtkTextDirection, draw_arrow: gboolean) void;
pub const GTK_STYLE_CONTEXT_PRINT_NONE = 0;
pub const GTK_STYLE_CONTEXT_PRINT_RECURSE = 1;
pub const GTK_STYLE_CONTEXT_PRINT_SHOW_STYLE = 2;
pub const GtkStyleContextPrintFlags = extern enum {
    GTK_STYLE_CONTEXT_PRINT_NONE = 0,
    GTK_STYLE_CONTEXT_PRINT_RECURSE = 1,
    GTK_STYLE_CONTEXT_PRINT_SHOW_STYLE = 2,
};
pub extern fn gtk_style_context_to_string(context: [*c]GtkStyleContext, flags: GtkStyleContextPrintFlags) [*c]u8;
pub const struct__GtkIconInfo = @OpaqueType();
pub const GtkIconInfo = struct__GtkIconInfo;
pub const struct__GtkIconInfoClass = @OpaqueType();
pub const GtkIconInfoClass = struct__GtkIconInfoClass;
pub const struct__GtkIconThemePrivate = @OpaqueType();
pub const GtkIconThemePrivate = struct__GtkIconThemePrivate;
pub const struct__GtkIconTheme = extern struct {
    parent_instance: GObject,
    priv: ?*GtkIconThemePrivate,
};
pub const GtkIconTheme = struct__GtkIconTheme;
pub const struct__GtkIconThemeClass = extern struct {
    parent_class: GObjectClass,
    changed: ?extern fn ([*c]GtkIconTheme) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkIconThemeClass = struct__GtkIconThemeClass;
pub const GTK_ICON_LOOKUP_NO_SVG = 1;
pub const GTK_ICON_LOOKUP_FORCE_SVG = 2;
pub const GTK_ICON_LOOKUP_USE_BUILTIN = 4;
pub const GTK_ICON_LOOKUP_GENERIC_FALLBACK = 8;
pub const GTK_ICON_LOOKUP_FORCE_SIZE = 16;
pub const GTK_ICON_LOOKUP_FORCE_REGULAR = 32;
pub const GTK_ICON_LOOKUP_FORCE_SYMBOLIC = 64;
pub const GTK_ICON_LOOKUP_DIR_LTR = 128;
pub const GTK_ICON_LOOKUP_DIR_RTL = 256;
pub const GtkIconLookupFlags = extern enum {
    GTK_ICON_LOOKUP_NO_SVG = 1,
    GTK_ICON_LOOKUP_FORCE_SVG = 2,
    GTK_ICON_LOOKUP_USE_BUILTIN = 4,
    GTK_ICON_LOOKUP_GENERIC_FALLBACK = 8,
    GTK_ICON_LOOKUP_FORCE_SIZE = 16,
    GTK_ICON_LOOKUP_FORCE_REGULAR = 32,
    GTK_ICON_LOOKUP_FORCE_SYMBOLIC = 64,
    GTK_ICON_LOOKUP_DIR_LTR = 128,
    GTK_ICON_LOOKUP_DIR_RTL = 256,
};
pub const GTK_ICON_THEME_NOT_FOUND = 0;
pub const GTK_ICON_THEME_FAILED = 1;
pub const GtkIconThemeError = extern enum {
    GTK_ICON_THEME_NOT_FOUND = 0,
    GTK_ICON_THEME_FAILED = 1,
};
pub extern fn gtk_icon_theme_error_quark() GQuark;
pub extern fn gtk_icon_theme_get_type() GType;
pub extern fn gtk_icon_theme_new() [*c]GtkIconTheme;
pub extern fn gtk_icon_theme_get_default() [*c]GtkIconTheme;
pub extern fn gtk_icon_theme_get_for_screen(screen: ?*GdkScreen) [*c]GtkIconTheme;
pub extern fn gtk_icon_theme_set_screen(icon_theme: [*c]GtkIconTheme, screen: ?*GdkScreen) void;
pub extern fn gtk_icon_theme_set_search_path(icon_theme: [*c]GtkIconTheme, path: [*c]([*c]const gchar), n_elements: gint) void;
pub extern fn gtk_icon_theme_get_search_path(icon_theme: [*c]GtkIconTheme, path: [*c]([*c]([*c]gchar)), n_elements: [*c]gint) void;
pub extern fn gtk_icon_theme_append_search_path(icon_theme: [*c]GtkIconTheme, path: [*c]const gchar) void;
pub extern fn gtk_icon_theme_prepend_search_path(icon_theme: [*c]GtkIconTheme, path: [*c]const gchar) void;
pub extern fn gtk_icon_theme_add_resource_path(icon_theme: [*c]GtkIconTheme, path: [*c]const gchar) void;
pub extern fn gtk_icon_theme_set_custom_theme(icon_theme: [*c]GtkIconTheme, theme_name: [*c]const gchar) void;
pub extern fn gtk_icon_theme_has_icon(icon_theme: [*c]GtkIconTheme, icon_name: [*c]const gchar) gboolean;
pub extern fn gtk_icon_theme_get_icon_sizes(icon_theme: [*c]GtkIconTheme, icon_name: [*c]const gchar) [*c]gint;
pub extern fn gtk_icon_theme_lookup_icon(icon_theme: [*c]GtkIconTheme, icon_name: [*c]const gchar, size: gint, flags: GtkIconLookupFlags) ?*GtkIconInfo;
pub extern fn gtk_icon_theme_lookup_icon_for_scale(icon_theme: [*c]GtkIconTheme, icon_name: [*c]const gchar, size: gint, scale: gint, flags: GtkIconLookupFlags) ?*GtkIconInfo;
pub extern fn gtk_icon_theme_choose_icon(icon_theme: [*c]GtkIconTheme, icon_names: [*c]([*c]const gchar), size: gint, flags: GtkIconLookupFlags) ?*GtkIconInfo;
pub extern fn gtk_icon_theme_choose_icon_for_scale(icon_theme: [*c]GtkIconTheme, icon_names: [*c]([*c]const gchar), size: gint, scale: gint, flags: GtkIconLookupFlags) ?*GtkIconInfo;
pub extern fn gtk_icon_theme_load_icon(icon_theme: [*c]GtkIconTheme, icon_name: [*c]const gchar, size: gint, flags: GtkIconLookupFlags, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gtk_icon_theme_load_icon_for_scale(icon_theme: [*c]GtkIconTheme, icon_name: [*c]const gchar, size: gint, scale: gint, flags: GtkIconLookupFlags, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gtk_icon_theme_load_surface(icon_theme: [*c]GtkIconTheme, icon_name: [*c]const gchar, size: gint, scale: gint, for_window: ?*GdkWindow, flags: GtkIconLookupFlags, @"error": [*c]([*c]GError)) ?*cairo_surface_t;
pub extern fn gtk_icon_theme_lookup_by_gicon(icon_theme: [*c]GtkIconTheme, icon: ?*GIcon, size: gint, flags: GtkIconLookupFlags) ?*GtkIconInfo;
pub extern fn gtk_icon_theme_lookup_by_gicon_for_scale(icon_theme: [*c]GtkIconTheme, icon: ?*GIcon, size: gint, scale: gint, flags: GtkIconLookupFlags) ?*GtkIconInfo;
pub extern fn gtk_icon_theme_list_icons(icon_theme: [*c]GtkIconTheme, context: [*c]const gchar) [*c]GList;
pub extern fn gtk_icon_theme_list_contexts(icon_theme: [*c]GtkIconTheme) [*c]GList;
pub extern fn gtk_icon_theme_get_example_icon_name(icon_theme: [*c]GtkIconTheme) [*c]u8;
pub extern fn gtk_icon_theme_rescan_if_needed(icon_theme: [*c]GtkIconTheme) gboolean;
pub extern fn gtk_icon_theme_add_builtin_icon(icon_name: [*c]const gchar, size: gint, pixbuf: ?*GdkPixbuf) void;
pub extern fn gtk_icon_info_get_type() GType;
pub extern fn gtk_icon_info_copy(icon_info: ?*GtkIconInfo) ?*GtkIconInfo;
pub extern fn gtk_icon_info_free(icon_info: ?*GtkIconInfo) void;
pub extern fn gtk_icon_info_new_for_pixbuf(icon_theme: [*c]GtkIconTheme, pixbuf: ?*GdkPixbuf) ?*GtkIconInfo;
pub extern fn gtk_icon_info_get_base_size(icon_info: ?*GtkIconInfo) gint;
pub extern fn gtk_icon_info_get_base_scale(icon_info: ?*GtkIconInfo) gint;
pub extern fn gtk_icon_info_get_filename(icon_info: ?*GtkIconInfo) [*c]const gchar;
pub extern fn gtk_icon_info_get_builtin_pixbuf(icon_info: ?*GtkIconInfo) ?*GdkPixbuf;
pub extern fn gtk_icon_info_is_symbolic(icon_info: ?*GtkIconInfo) gboolean;
pub extern fn gtk_icon_info_load_icon(icon_info: ?*GtkIconInfo, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gtk_icon_info_load_surface(icon_info: ?*GtkIconInfo, for_window: ?*GdkWindow, @"error": [*c]([*c]GError)) ?*cairo_surface_t;
pub extern fn gtk_icon_info_load_icon_async(icon_info: ?*GtkIconInfo, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_icon_info_load_icon_finish(icon_info: ?*GtkIconInfo, res: ?*GAsyncResult, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gtk_icon_info_load_symbolic(icon_info: ?*GtkIconInfo, fg: [*c]const GdkRGBA, success_color: [*c]const GdkRGBA, warning_color: [*c]const GdkRGBA, error_color: [*c]const GdkRGBA, was_symbolic: [*c]gboolean, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gtk_icon_info_load_symbolic_async(icon_info: ?*GtkIconInfo, fg: [*c]const GdkRGBA, success_color: [*c]const GdkRGBA, warning_color: [*c]const GdkRGBA, error_color: [*c]const GdkRGBA, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_icon_info_load_symbolic_finish(icon_info: ?*GtkIconInfo, res: ?*GAsyncResult, was_symbolic: [*c]gboolean, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gtk_icon_info_load_symbolic_for_context(icon_info: ?*GtkIconInfo, context: [*c]GtkStyleContext, was_symbolic: [*c]gboolean, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gtk_icon_info_load_symbolic_for_context_async(icon_info: ?*GtkIconInfo, context: [*c]GtkStyleContext, cancellable: [*c]GCancellable, callback: GAsyncReadyCallback, user_data: gpointer) void;
pub extern fn gtk_icon_info_load_symbolic_for_context_finish(icon_info: ?*GtkIconInfo, res: ?*GAsyncResult, was_symbolic: [*c]gboolean, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gtk_icon_info_load_symbolic_for_style(icon_info: ?*GtkIconInfo, style: [*c]GtkStyle, state: GtkStateType, was_symbolic: [*c]gboolean, @"error": [*c]([*c]GError)) ?*GdkPixbuf;
pub extern fn gtk_icon_info_set_raw_coordinates(icon_info: ?*GtkIconInfo, raw_coordinates: gboolean) void;
pub extern fn gtk_icon_info_get_embedded_rect(icon_info: ?*GtkIconInfo, rectangle: [*c]GdkRectangle) gboolean;
pub extern fn gtk_icon_info_get_attach_points(icon_info: ?*GtkIconInfo, points: [*c]([*c]GdkPoint), n_points: [*c]gint) gboolean;
pub extern fn gtk_icon_info_get_display_name(icon_info: ?*GtkIconInfo) [*c]const gchar;
pub extern fn gtk_tooltip_get_type() GType;
pub extern fn gtk_tooltip_set_markup(tooltip: ?*GtkTooltip, markup: [*c]const gchar) void;
pub extern fn gtk_tooltip_set_text(tooltip: ?*GtkTooltip, text: [*c]const gchar) void;
pub extern fn gtk_tooltip_set_icon(tooltip: ?*GtkTooltip, pixbuf: ?*GdkPixbuf) void;
pub extern fn gtk_tooltip_set_icon_from_stock(tooltip: ?*GtkTooltip, stock_id: [*c]const gchar, size: GtkIconSize) void;
pub extern fn gtk_tooltip_set_icon_from_icon_name(tooltip: ?*GtkTooltip, icon_name: [*c]const gchar, size: GtkIconSize) void;
pub extern fn gtk_tooltip_set_icon_from_gicon(tooltip: ?*GtkTooltip, gicon: ?*GIcon, size: GtkIconSize) void;
pub extern fn gtk_tooltip_set_custom(tooltip: ?*GtkTooltip, custom_widget: [*c]GtkWidget) void;
pub extern fn gtk_tooltip_set_tip_area(tooltip: ?*GtkTooltip, rect: [*c]const GdkRectangle) void;
pub extern fn gtk_tooltip_trigger_tooltip_query(display: ?*GdkDisplay) void;
pub const struct__GtkIconViewPrivate = @OpaqueType();
pub const GtkIconViewPrivate = struct__GtkIconViewPrivate;
pub const struct__GtkIconView = extern struct {
    parent: GtkContainer,
    priv: ?*GtkIconViewPrivate,
};
pub const GtkIconView = struct__GtkIconView;
pub const struct__GtkIconViewClass = extern struct {
    parent_class: GtkContainerClass,
    item_activated: ?extern fn ([*c]GtkIconView, ?*GtkTreePath) void,
    selection_changed: ?extern fn ([*c]GtkIconView) void,
    select_all: ?extern fn ([*c]GtkIconView) void,
    unselect_all: ?extern fn ([*c]GtkIconView) void,
    select_cursor_item: ?extern fn ([*c]GtkIconView) void,
    toggle_cursor_item: ?extern fn ([*c]GtkIconView) void,
    move_cursor: ?extern fn ([*c]GtkIconView, GtkMovementStep, gint) gboolean,
    activate_cursor_item: ?extern fn ([*c]GtkIconView) gboolean,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkIconViewClass = struct__GtkIconViewClass;
pub const GtkIconViewForeachFunc = ?extern fn ([*c]GtkIconView, ?*GtkTreePath, gpointer) void;
pub const GTK_ICON_VIEW_NO_DROP = 0;
pub const GTK_ICON_VIEW_DROP_INTO = 1;
pub const GTK_ICON_VIEW_DROP_LEFT = 2;
pub const GTK_ICON_VIEW_DROP_RIGHT = 3;
pub const GTK_ICON_VIEW_DROP_ABOVE = 4;
pub const GTK_ICON_VIEW_DROP_BELOW = 5;
pub const GtkIconViewDropPosition = extern enum {
    GTK_ICON_VIEW_NO_DROP = 0,
    GTK_ICON_VIEW_DROP_INTO = 1,
    GTK_ICON_VIEW_DROP_LEFT = 2,
    GTK_ICON_VIEW_DROP_RIGHT = 3,
    GTK_ICON_VIEW_DROP_ABOVE = 4,
    GTK_ICON_VIEW_DROP_BELOW = 5,
};
pub extern fn gtk_icon_view_get_type() GType;
pub extern fn gtk_icon_view_new() [*c]GtkWidget;
pub extern fn gtk_icon_view_new_with_area(area: [*c]GtkCellArea) [*c]GtkWidget;
pub extern fn gtk_icon_view_new_with_model(model: ?*GtkTreeModel) [*c]GtkWidget;
pub extern fn gtk_icon_view_set_model(icon_view: [*c]GtkIconView, model: ?*GtkTreeModel) void;
pub extern fn gtk_icon_view_get_model(icon_view: [*c]GtkIconView) ?*GtkTreeModel;
pub extern fn gtk_icon_view_set_text_column(icon_view: [*c]GtkIconView, column: gint) void;
pub extern fn gtk_icon_view_get_text_column(icon_view: [*c]GtkIconView) gint;
pub extern fn gtk_icon_view_set_markup_column(icon_view: [*c]GtkIconView, column: gint) void;
pub extern fn gtk_icon_view_get_markup_column(icon_view: [*c]GtkIconView) gint;
pub extern fn gtk_icon_view_set_pixbuf_column(icon_view: [*c]GtkIconView, column: gint) void;
pub extern fn gtk_icon_view_get_pixbuf_column(icon_view: [*c]GtkIconView) gint;
pub extern fn gtk_icon_view_set_item_orientation(icon_view: [*c]GtkIconView, orientation: GtkOrientation) void;
pub extern fn gtk_icon_view_get_item_orientation(icon_view: [*c]GtkIconView) GtkOrientation;
pub extern fn gtk_icon_view_set_columns(icon_view: [*c]GtkIconView, columns: gint) void;
pub extern fn gtk_icon_view_get_columns(icon_view: [*c]GtkIconView) gint;
pub extern fn gtk_icon_view_set_item_width(icon_view: [*c]GtkIconView, item_width: gint) void;
pub extern fn gtk_icon_view_get_item_width(icon_view: [*c]GtkIconView) gint;
pub extern fn gtk_icon_view_set_spacing(icon_view: [*c]GtkIconView, spacing: gint) void;
pub extern fn gtk_icon_view_get_spacing(icon_view: [*c]GtkIconView) gint;
pub extern fn gtk_icon_view_set_row_spacing(icon_view: [*c]GtkIconView, row_spacing: gint) void;
pub extern fn gtk_icon_view_get_row_spacing(icon_view: [*c]GtkIconView) gint;
pub extern fn gtk_icon_view_set_column_spacing(icon_view: [*c]GtkIconView, column_spacing: gint) void;
pub extern fn gtk_icon_view_get_column_spacing(icon_view: [*c]GtkIconView) gint;
pub extern fn gtk_icon_view_set_margin(icon_view: [*c]GtkIconView, margin: gint) void;
pub extern fn gtk_icon_view_get_margin(icon_view: [*c]GtkIconView) gint;
pub extern fn gtk_icon_view_set_item_padding(icon_view: [*c]GtkIconView, item_padding: gint) void;
pub extern fn gtk_icon_view_get_item_padding(icon_view: [*c]GtkIconView) gint;
pub extern fn gtk_icon_view_get_path_at_pos(icon_view: [*c]GtkIconView, x: gint, y: gint) ?*GtkTreePath;
pub extern fn gtk_icon_view_get_item_at_pos(icon_view: [*c]GtkIconView, x: gint, y: gint, path: [*c](?*GtkTreePath), cell: [*c]([*c]GtkCellRenderer)) gboolean;
pub extern fn gtk_icon_view_get_visible_range(icon_view: [*c]GtkIconView, start_path: [*c](?*GtkTreePath), end_path: [*c](?*GtkTreePath)) gboolean;
pub extern fn gtk_icon_view_set_activate_on_single_click(icon_view: [*c]GtkIconView, single: gboolean) void;
pub extern fn gtk_icon_view_get_activate_on_single_click(icon_view: [*c]GtkIconView) gboolean;
pub extern fn gtk_icon_view_selected_foreach(icon_view: [*c]GtkIconView, func: GtkIconViewForeachFunc, data: gpointer) void;
pub extern fn gtk_icon_view_set_selection_mode(icon_view: [*c]GtkIconView, mode: GtkSelectionMode) void;
pub extern fn gtk_icon_view_get_selection_mode(icon_view: [*c]GtkIconView) GtkSelectionMode;
pub extern fn gtk_icon_view_select_path(icon_view: [*c]GtkIconView, path: ?*GtkTreePath) void;
pub extern fn gtk_icon_view_unselect_path(icon_view: [*c]GtkIconView, path: ?*GtkTreePath) void;
pub extern fn gtk_icon_view_path_is_selected(icon_view: [*c]GtkIconView, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_icon_view_get_item_row(icon_view: [*c]GtkIconView, path: ?*GtkTreePath) gint;
pub extern fn gtk_icon_view_get_item_column(icon_view: [*c]GtkIconView, path: ?*GtkTreePath) gint;
pub extern fn gtk_icon_view_get_selected_items(icon_view: [*c]GtkIconView) [*c]GList;
pub extern fn gtk_icon_view_select_all(icon_view: [*c]GtkIconView) void;
pub extern fn gtk_icon_view_unselect_all(icon_view: [*c]GtkIconView) void;
pub extern fn gtk_icon_view_item_activated(icon_view: [*c]GtkIconView, path: ?*GtkTreePath) void;
pub extern fn gtk_icon_view_set_cursor(icon_view: [*c]GtkIconView, path: ?*GtkTreePath, cell: [*c]GtkCellRenderer, start_editing: gboolean) void;
pub extern fn gtk_icon_view_get_cursor(icon_view: [*c]GtkIconView, path: [*c](?*GtkTreePath), cell: [*c]([*c]GtkCellRenderer)) gboolean;
pub extern fn gtk_icon_view_scroll_to_path(icon_view: [*c]GtkIconView, path: ?*GtkTreePath, use_align: gboolean, row_align: gfloat, col_align: gfloat) void;
pub extern fn gtk_icon_view_enable_model_drag_source(icon_view: [*c]GtkIconView, start_button_mask: GdkModifierType, targets: [*c]const GtkTargetEntry, n_targets: gint, actions: GdkDragAction) void;
pub extern fn gtk_icon_view_enable_model_drag_dest(icon_view: [*c]GtkIconView, targets: [*c]const GtkTargetEntry, n_targets: gint, actions: GdkDragAction) void;
pub extern fn gtk_icon_view_unset_model_drag_source(icon_view: [*c]GtkIconView) void;
pub extern fn gtk_icon_view_unset_model_drag_dest(icon_view: [*c]GtkIconView) void;
pub extern fn gtk_icon_view_set_reorderable(icon_view: [*c]GtkIconView, reorderable: gboolean) void;
pub extern fn gtk_icon_view_get_reorderable(icon_view: [*c]GtkIconView) gboolean;
pub extern fn gtk_icon_view_set_drag_dest_item(icon_view: [*c]GtkIconView, path: ?*GtkTreePath, pos: GtkIconViewDropPosition) void;
pub extern fn gtk_icon_view_get_drag_dest_item(icon_view: [*c]GtkIconView, path: [*c](?*GtkTreePath), pos: [*c]GtkIconViewDropPosition) void;
pub extern fn gtk_icon_view_get_dest_item_at_pos(icon_view: [*c]GtkIconView, drag_x: gint, drag_y: gint, path: [*c](?*GtkTreePath), pos: [*c]GtkIconViewDropPosition) gboolean;
pub extern fn gtk_icon_view_create_drag_icon(icon_view: [*c]GtkIconView, path: ?*GtkTreePath) ?*cairo_surface_t;
pub extern fn gtk_icon_view_convert_widget_to_bin_window_coords(icon_view: [*c]GtkIconView, wx: gint, wy: gint, bx: [*c]gint, by: [*c]gint) void;
pub extern fn gtk_icon_view_get_cell_rect(icon_view: [*c]GtkIconView, path: ?*GtkTreePath, cell: [*c]GtkCellRenderer, rect: [*c]GdkRectangle) gboolean;
pub extern fn gtk_icon_view_set_tooltip_item(icon_view: [*c]GtkIconView, tooltip: ?*GtkTooltip, path: ?*GtkTreePath) void;
pub extern fn gtk_icon_view_set_tooltip_cell(icon_view: [*c]GtkIconView, tooltip: ?*GtkTooltip, path: ?*GtkTreePath, cell: [*c]GtkCellRenderer) void;
pub extern fn gtk_icon_view_get_tooltip_context(icon_view: [*c]GtkIconView, x: [*c]gint, y: [*c]gint, keyboard_tip: gboolean, model: [*c](?*GtkTreeModel), path: [*c](?*GtkTreePath), iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_icon_view_set_tooltip_column(icon_view: [*c]GtkIconView, column: gint) void;
pub extern fn gtk_icon_view_get_tooltip_column(icon_view: [*c]GtkIconView) gint;
pub const struct__GtkIMContextInfo = extern struct {
    context_id: [*c]const gchar,
    context_name: [*c]const gchar,
    domain: [*c]const gchar,
    domain_dirname: [*c]const gchar,
    default_locales: [*c]const gchar,
};
pub const GtkIMContextInfo = struct__GtkIMContextInfo;
pub const struct__GtkIMContextSimplePrivate = @OpaqueType();
pub const GtkIMContextSimplePrivate = struct__GtkIMContextSimplePrivate;
pub const struct__GtkIMContextSimple = extern struct {
    object: GtkIMContext,
    priv: ?*GtkIMContextSimplePrivate,
};
pub const GtkIMContextSimple = struct__GtkIMContextSimple;
pub const struct__GtkIMContextSimpleClass = extern struct {
    parent_class: GtkIMContextClass,
};
pub const GtkIMContextSimpleClass = struct__GtkIMContextSimpleClass;
pub extern fn gtk_im_context_simple_get_type() GType;
pub extern fn gtk_im_context_simple_new() [*c]GtkIMContext;
pub extern fn gtk_im_context_simple_add_table(context_simple: [*c]GtkIMContextSimple, data: [*c]guint16, max_seq_len: gint, n_seqs: gint) void;
pub extern fn gtk_im_context_simple_add_compose_file(context_simple: [*c]GtkIMContextSimple, compose_file: [*c]const gchar) void;
pub const struct__GtkIMMulticontextPrivate = @OpaqueType();
pub const GtkIMMulticontextPrivate = struct__GtkIMMulticontextPrivate;
pub const struct__GtkIMMulticontext = extern struct {
    object: GtkIMContext,
    priv: ?*GtkIMMulticontextPrivate,
};
pub const GtkIMMulticontext = struct__GtkIMMulticontext;
pub const struct__GtkIMMulticontextClass = extern struct {
    parent_class: GtkIMContextClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkIMMulticontextClass = struct__GtkIMMulticontextClass;
pub extern fn gtk_im_multicontext_get_type() GType;
pub extern fn gtk_im_multicontext_new() [*c]GtkIMContext;
pub extern fn gtk_im_multicontext_append_menuitems(context: [*c]GtkIMMulticontext, menushell: [*c]GtkMenuShell) void;
pub extern fn gtk_im_multicontext_get_context_id(context: [*c]GtkIMMulticontext) [*c]const u8;
pub extern fn gtk_im_multicontext_set_context_id(context: [*c]GtkIMMulticontext, context_id: [*c]const u8) void;
pub const struct__GtkInfoBarPrivate = @OpaqueType();
pub const GtkInfoBarPrivate = struct__GtkInfoBarPrivate;
pub const struct__GtkInfoBar = extern struct {
    parent: GtkBox,
    priv: ?*GtkInfoBarPrivate,
};
pub const GtkInfoBar = struct__GtkInfoBar;
pub const struct__GtkInfoBarClass = extern struct {
    parent_class: GtkBoxClass,
    response: ?extern fn ([*c]GtkInfoBar, gint) void,
    close: ?extern fn ([*c]GtkInfoBar) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkInfoBarClass = struct__GtkInfoBarClass;
pub extern fn gtk_info_bar_get_type() GType;
pub extern fn gtk_info_bar_new() [*c]GtkWidget;
pub extern fn gtk_info_bar_new_with_buttons(first_button_text: [*c]const gchar, ...) [*c]GtkWidget;
pub extern fn gtk_info_bar_get_action_area(info_bar: [*c]GtkInfoBar) [*c]GtkWidget;
pub extern fn gtk_info_bar_get_content_area(info_bar: [*c]GtkInfoBar) [*c]GtkWidget;
pub extern fn gtk_info_bar_add_action_widget(info_bar: [*c]GtkInfoBar, child: [*c]GtkWidget, response_id: gint) void;
pub extern fn gtk_info_bar_add_button(info_bar: [*c]GtkInfoBar, button_text: [*c]const gchar, response_id: gint) [*c]GtkWidget;
pub extern fn gtk_info_bar_add_buttons(info_bar: [*c]GtkInfoBar, first_button_text: [*c]const gchar, ...) void;
pub extern fn gtk_info_bar_set_response_sensitive(info_bar: [*c]GtkInfoBar, response_id: gint, setting: gboolean) void;
pub extern fn gtk_info_bar_set_default_response(info_bar: [*c]GtkInfoBar, response_id: gint) void;
pub extern fn gtk_info_bar_response(info_bar: [*c]GtkInfoBar, response_id: gint) void;
pub extern fn gtk_info_bar_set_message_type(info_bar: [*c]GtkInfoBar, message_type: GtkMessageType) void;
pub extern fn gtk_info_bar_get_message_type(info_bar: [*c]GtkInfoBar) GtkMessageType;
pub extern fn gtk_info_bar_set_show_close_button(info_bar: [*c]GtkInfoBar, setting: gboolean) void;
pub extern fn gtk_info_bar_get_show_close_button(info_bar: [*c]GtkInfoBar) gboolean;
pub extern fn gtk_info_bar_set_revealed(info_bar: [*c]GtkInfoBar, revealed: gboolean) void;
pub extern fn gtk_info_bar_get_revealed(info_bar: [*c]GtkInfoBar) gboolean;
pub const struct__GtkInvisiblePrivate = @OpaqueType();
pub const GtkInvisiblePrivate = struct__GtkInvisiblePrivate;
pub const struct__GtkInvisible = extern struct {
    widget: GtkWidget,
    priv: ?*GtkInvisiblePrivate,
};
pub const GtkInvisible = struct__GtkInvisible;
pub const struct__GtkInvisibleClass = extern struct {
    parent_class: GtkWidgetClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkInvisibleClass = struct__GtkInvisibleClass;
pub extern fn gtk_invisible_get_type() GType;
pub extern fn gtk_invisible_new() [*c]GtkWidget;
pub extern fn gtk_invisible_new_for_screen(screen: ?*GdkScreen) [*c]GtkWidget;
pub extern fn gtk_invisible_set_screen(invisible: [*c]GtkInvisible, screen: ?*GdkScreen) void;
pub extern fn gtk_invisible_get_screen(invisible: [*c]GtkInvisible) ?*GdkScreen;
pub const struct__GtkLayoutPrivate = @OpaqueType();
pub const GtkLayoutPrivate = struct__GtkLayoutPrivate;
pub const struct__GtkLayout = extern struct {
    container: GtkContainer,
    priv: ?*GtkLayoutPrivate,
};
pub const GtkLayout = struct__GtkLayout;
pub const struct__GtkLayoutClass = extern struct {
    parent_class: GtkContainerClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkLayoutClass = struct__GtkLayoutClass;
pub extern fn gtk_layout_get_type() GType;
pub extern fn gtk_layout_new(hadjustment: [*c]GtkAdjustment, vadjustment: [*c]GtkAdjustment) [*c]GtkWidget;
pub extern fn gtk_layout_get_bin_window(layout: [*c]GtkLayout) ?*GdkWindow;
pub extern fn gtk_layout_put(layout: [*c]GtkLayout, child_widget: [*c]GtkWidget, x: gint, y: gint) void;
pub extern fn gtk_layout_move(layout: [*c]GtkLayout, child_widget: [*c]GtkWidget, x: gint, y: gint) void;
pub extern fn gtk_layout_set_size(layout: [*c]GtkLayout, width: guint, height: guint) void;
pub extern fn gtk_layout_get_size(layout: [*c]GtkLayout, width: [*c]guint, height: [*c]guint) void;
pub extern fn gtk_layout_get_hadjustment(layout: [*c]GtkLayout) [*c]GtkAdjustment;
pub extern fn gtk_layout_get_vadjustment(layout: [*c]GtkLayout) [*c]GtkAdjustment;
pub extern fn gtk_layout_set_hadjustment(layout: [*c]GtkLayout, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_layout_set_vadjustment(layout: [*c]GtkLayout, adjustment: [*c]GtkAdjustment) void;
pub const struct__GtkLevelBarPrivate = @OpaqueType();
pub const GtkLevelBarPrivate = struct__GtkLevelBarPrivate;
pub const struct__GtkLevelBar = extern struct {
    parent: GtkWidget,
    priv: ?*GtkLevelBarPrivate,
};
pub const GtkLevelBar = struct__GtkLevelBar;
pub const struct__GtkLevelBarClass = extern struct {
    parent_class: GtkWidgetClass,
    offset_changed: ?extern fn ([*c]GtkLevelBar, [*c]const gchar) void,
    padding: [16]gpointer,
};
pub const GtkLevelBarClass = struct__GtkLevelBarClass;
pub extern fn gtk_level_bar_get_type() GType;
pub extern fn gtk_level_bar_new() [*c]GtkWidget;
pub extern fn gtk_level_bar_new_for_interval(min_value: gdouble, max_value: gdouble) [*c]GtkWidget;
pub extern fn gtk_level_bar_set_mode(self: [*c]GtkLevelBar, mode: GtkLevelBarMode) void;
pub extern fn gtk_level_bar_get_mode(self: [*c]GtkLevelBar) GtkLevelBarMode;
pub extern fn gtk_level_bar_set_value(self: [*c]GtkLevelBar, value: gdouble) void;
pub extern fn gtk_level_bar_get_value(self: [*c]GtkLevelBar) gdouble;
pub extern fn gtk_level_bar_set_min_value(self: [*c]GtkLevelBar, value: gdouble) void;
pub extern fn gtk_level_bar_get_min_value(self: [*c]GtkLevelBar) gdouble;
pub extern fn gtk_level_bar_set_max_value(self: [*c]GtkLevelBar, value: gdouble) void;
pub extern fn gtk_level_bar_get_max_value(self: [*c]GtkLevelBar) gdouble;
pub extern fn gtk_level_bar_set_inverted(self: [*c]GtkLevelBar, inverted: gboolean) void;
pub extern fn gtk_level_bar_get_inverted(self: [*c]GtkLevelBar) gboolean;
pub extern fn gtk_level_bar_add_offset_value(self: [*c]GtkLevelBar, name: [*c]const gchar, value: gdouble) void;
pub extern fn gtk_level_bar_remove_offset_value(self: [*c]GtkLevelBar, name: [*c]const gchar) void;
pub extern fn gtk_level_bar_get_offset_value(self: [*c]GtkLevelBar, name: [*c]const gchar, value: [*c]gdouble) gboolean;
pub const struct__GtkLinkButtonPrivate = @OpaqueType();
pub const GtkLinkButtonPrivate = struct__GtkLinkButtonPrivate;
pub const struct__GtkLinkButton = extern struct {
    parent_instance: GtkButton,
    priv: ?*GtkLinkButtonPrivate,
};
pub const GtkLinkButton = struct__GtkLinkButton;
pub const struct__GtkLinkButtonClass = extern struct {
    parent_class: GtkButtonClass,
    activate_link: ?extern fn ([*c]GtkLinkButton) gboolean,
    _gtk_padding1: ?extern fn () void,
    _gtk_padding2: ?extern fn () void,
    _gtk_padding3: ?extern fn () void,
    _gtk_padding4: ?extern fn () void,
};
pub const GtkLinkButtonClass = struct__GtkLinkButtonClass;
pub extern fn gtk_link_button_get_type() GType;
pub extern fn gtk_link_button_new(uri: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_link_button_new_with_label(uri: [*c]const gchar, label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_link_button_get_uri(link_button: [*c]GtkLinkButton) [*c]const gchar;
pub extern fn gtk_link_button_set_uri(link_button: [*c]GtkLinkButton, uri: [*c]const gchar) void;
pub extern fn gtk_link_button_get_visited(link_button: [*c]GtkLinkButton) gboolean;
pub extern fn gtk_link_button_set_visited(link_button: [*c]GtkLinkButton, visited: gboolean) void;
pub const struct__GtkListBox = extern struct {
    parent_instance: GtkContainer,
};
pub const GtkListBox = struct__GtkListBox;
pub const struct__GtkListBoxRow = extern struct {
    parent_instance: GtkBin,
};
pub const GtkListBoxRow = struct__GtkListBoxRow;
pub const struct__GtkListBoxClass = extern struct {
    parent_class: GtkContainerClass,
    row_selected: ?extern fn ([*c]GtkListBox, [*c]GtkListBoxRow) void,
    row_activated: ?extern fn ([*c]GtkListBox, [*c]GtkListBoxRow) void,
    activate_cursor_row: ?extern fn ([*c]GtkListBox) void,
    toggle_cursor_row: ?extern fn ([*c]GtkListBox) void,
    move_cursor: ?extern fn ([*c]GtkListBox, GtkMovementStep, gint) void,
    selected_rows_changed: ?extern fn ([*c]GtkListBox) void,
    select_all: ?extern fn ([*c]GtkListBox) void,
    unselect_all: ?extern fn ([*c]GtkListBox) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
};
pub const GtkListBoxClass = struct__GtkListBoxClass;
pub const struct__GtkListBoxRowClass = extern struct {
    parent_class: GtkBinClass,
    activate: ?extern fn ([*c]GtkListBoxRow) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
};
pub const GtkListBoxRowClass = struct__GtkListBoxRowClass;
pub const GtkListBoxFilterFunc = ?extern fn ([*c]GtkListBoxRow, gpointer) gboolean;
pub const GtkListBoxSortFunc = ?extern fn ([*c]GtkListBoxRow, [*c]GtkListBoxRow, gpointer) gint;
pub const GtkListBoxUpdateHeaderFunc = ?extern fn ([*c]GtkListBoxRow, [*c]GtkListBoxRow, gpointer) void;
pub const GtkListBoxCreateWidgetFunc = ?extern fn (gpointer, gpointer) [*c]GtkWidget;
pub extern fn gtk_list_box_row_get_type() GType;
pub extern fn gtk_list_box_row_new() [*c]GtkWidget;
pub extern fn gtk_list_box_row_get_header(row: [*c]GtkListBoxRow) [*c]GtkWidget;
pub extern fn gtk_list_box_row_set_header(row: [*c]GtkListBoxRow, header: [*c]GtkWidget) void;
pub extern fn gtk_list_box_row_get_index(row: [*c]GtkListBoxRow) gint;
pub extern fn gtk_list_box_row_changed(row: [*c]GtkListBoxRow) void;
pub extern fn gtk_list_box_row_is_selected(row: [*c]GtkListBoxRow) gboolean;
pub extern fn gtk_list_box_row_set_selectable(row: [*c]GtkListBoxRow, selectable: gboolean) void;
pub extern fn gtk_list_box_row_get_selectable(row: [*c]GtkListBoxRow) gboolean;
pub extern fn gtk_list_box_row_set_activatable(row: [*c]GtkListBoxRow, activatable: gboolean) void;
pub extern fn gtk_list_box_row_get_activatable(row: [*c]GtkListBoxRow) gboolean;
pub extern fn gtk_list_box_get_type() GType;
pub extern fn gtk_list_box_prepend(box: [*c]GtkListBox, child: [*c]GtkWidget) void;
pub extern fn gtk_list_box_insert(box: [*c]GtkListBox, child: [*c]GtkWidget, position: gint) void;
pub extern fn gtk_list_box_get_selected_row(box: [*c]GtkListBox) [*c]GtkListBoxRow;
pub extern fn gtk_list_box_get_row_at_index(box: [*c]GtkListBox, index_: gint) [*c]GtkListBoxRow;
pub extern fn gtk_list_box_get_row_at_y(box: [*c]GtkListBox, y: gint) [*c]GtkListBoxRow;
pub extern fn gtk_list_box_select_row(box: [*c]GtkListBox, row: [*c]GtkListBoxRow) void;
pub extern fn gtk_list_box_set_placeholder(box: [*c]GtkListBox, placeholder: [*c]GtkWidget) void;
pub extern fn gtk_list_box_set_adjustment(box: [*c]GtkListBox, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_list_box_get_adjustment(box: [*c]GtkListBox) [*c]GtkAdjustment;
pub const GtkListBoxForeachFunc = ?extern fn ([*c]GtkListBox, [*c]GtkListBoxRow, gpointer) void;
pub extern fn gtk_list_box_selected_foreach(box: [*c]GtkListBox, func: GtkListBoxForeachFunc, data: gpointer) void;
pub extern fn gtk_list_box_get_selected_rows(box: [*c]GtkListBox) [*c]GList;
pub extern fn gtk_list_box_unselect_row(box: [*c]GtkListBox, row: [*c]GtkListBoxRow) void;
pub extern fn gtk_list_box_select_all(box: [*c]GtkListBox) void;
pub extern fn gtk_list_box_unselect_all(box: [*c]GtkListBox) void;
pub extern fn gtk_list_box_set_selection_mode(box: [*c]GtkListBox, mode: GtkSelectionMode) void;
pub extern fn gtk_list_box_get_selection_mode(box: [*c]GtkListBox) GtkSelectionMode;
pub extern fn gtk_list_box_set_filter_func(box: [*c]GtkListBox, filter_func: GtkListBoxFilterFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_list_box_set_header_func(box: [*c]GtkListBox, update_header: GtkListBoxUpdateHeaderFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_list_box_invalidate_filter(box: [*c]GtkListBox) void;
pub extern fn gtk_list_box_invalidate_sort(box: [*c]GtkListBox) void;
pub extern fn gtk_list_box_invalidate_headers(box: [*c]GtkListBox) void;
pub extern fn gtk_list_box_set_sort_func(box: [*c]GtkListBox, sort_func: GtkListBoxSortFunc, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_list_box_set_activate_on_single_click(box: [*c]GtkListBox, single: gboolean) void;
pub extern fn gtk_list_box_get_activate_on_single_click(box: [*c]GtkListBox) gboolean;
pub extern fn gtk_list_box_drag_unhighlight_row(box: [*c]GtkListBox) void;
pub extern fn gtk_list_box_drag_highlight_row(box: [*c]GtkListBox, row: [*c]GtkListBoxRow) void;
pub extern fn gtk_list_box_new() [*c]GtkWidget;
pub extern fn gtk_list_box_bind_model(box: [*c]GtkListBox, model: ?*GListModel, create_widget_func: GtkListBoxCreateWidgetFunc, user_data: gpointer, user_data_free_func: GDestroyNotify) void;
pub const GtkListBox_autoptr = [*c]GtkListBox;
pub const GtkListBox_listautoptr = [*c]GList;
pub const GtkListBox_slistautoptr = [*c]GSList;
pub const GtkListBox_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkListBox(_ptr: [*c]GtkListBox) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkListBox(_ptr: [*c]([*c]GtkListBox)) void {
    glib_autoptr_clear_GtkListBox(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkListBox(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkListBox(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkListBox(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkListBoxRow_autoptr = [*c]GtkListBoxRow;
pub const GtkListBoxRow_listautoptr = [*c]GList;
pub const GtkListBoxRow_slistautoptr = [*c]GSList;
pub const GtkListBoxRow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkListBoxRow(_ptr: [*c]GtkListBoxRow) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkListBoxRow(_ptr: [*c]([*c]GtkListBoxRow)) void {
    glib_autoptr_clear_GtkListBoxRow(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkListBoxRow(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkListBoxRow(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkListBoxRow(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const struct__GtkLockButtonPrivate = @OpaqueType();
pub const GtkLockButtonPrivate = struct__GtkLockButtonPrivate;
pub const struct__GtkLockButton = extern struct {
    parent: GtkButton,
    priv: ?*GtkLockButtonPrivate,
};
pub const GtkLockButton = struct__GtkLockButton;
pub const struct__GtkLockButtonClass = extern struct {
    parent_class: GtkButtonClass,
    reserved0: ?extern fn () void,
    reserved1: ?extern fn () void,
    reserved2: ?extern fn () void,
    reserved3: ?extern fn () void,
    reserved4: ?extern fn () void,
    reserved5: ?extern fn () void,
    reserved6: ?extern fn () void,
    reserved7: ?extern fn () void,
};
pub const GtkLockButtonClass = struct__GtkLockButtonClass;
pub extern fn gtk_lock_button_get_type() GType;
pub extern fn gtk_lock_button_new(permission: [*c]GPermission) [*c]GtkWidget;
pub extern fn gtk_lock_button_get_permission(button: [*c]GtkLockButton) [*c]GPermission;
pub extern fn gtk_lock_button_set_permission(button: [*c]GtkLockButton, permission: [*c]GPermission) void;
pub const GtkKeySnoopFunc = ?extern fn ([*c]GtkWidget, ?*GdkEventKey, gpointer) gint;
pub extern fn gtk_get_major_version() guint;
pub extern fn gtk_get_minor_version() guint;
pub extern fn gtk_get_micro_version() guint;
pub extern fn gtk_get_binary_age() guint;
pub extern fn gtk_get_interface_age() guint;
pub extern fn gtk_check_version(required_major: guint, required_minor: guint, required_micro: guint) [*c]const gchar;
pub extern fn gtk_parse_args(argc: [*c]c_int, argv: [*c]([*c]([*c]u8))) gboolean;
pub extern fn gtk_init(argc: [*c]c_int, argv: [*c]([*c]([*c]u8))) void;
pub extern fn gtk_init_check(argc: [*c]c_int, argv: [*c]([*c]([*c]u8))) gboolean;
pub extern fn gtk_init_with_args(argc: [*c]gint, argv: [*c]([*c]([*c]gchar)), parameter_string: [*c]const gchar, entries: [*c]const GOptionEntry, translation_domain: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_get_option_group(open_default_display: gboolean) ?*GOptionGroup;
pub extern fn gtk_init_abi_check(argc: [*c]c_int, argv: [*c]([*c]([*c]u8)), num_checks: c_int, sizeof_GtkWindow: usize, sizeof_GtkBox: usize) void;
pub extern fn gtk_init_check_abi_check(argc: [*c]c_int, argv: [*c]([*c]([*c]u8)), num_checks: c_int, sizeof_GtkWindow: usize, sizeof_GtkBox: usize) gboolean;
pub extern fn gtk_disable_setlocale() void;
pub extern fn gtk_get_default_language() ?*PangoLanguage;
pub extern fn gtk_get_locale_direction() GtkTextDirection;
pub extern fn gtk_events_pending() gboolean;
pub extern fn gtk_main_do_event(event: [*c]GdkEvent) void;
pub extern fn gtk_main() void;
pub extern fn gtk_main_level() guint;
pub extern fn gtk_main_quit() void;
pub extern fn gtk_main_iteration() gboolean;
pub extern fn gtk_main_iteration_do(blocking: gboolean) gboolean;
pub extern fn gtk_true() gboolean;
pub extern fn gtk_false() gboolean;
pub extern fn gtk_grab_add(widget: [*c]GtkWidget) void;
pub extern fn gtk_grab_get_current() [*c]GtkWidget;
pub extern fn gtk_grab_remove(widget: [*c]GtkWidget) void;
pub extern fn gtk_device_grab_add(widget: [*c]GtkWidget, device: ?*GdkDevice, block_others: gboolean) void;
pub extern fn gtk_device_grab_remove(widget: [*c]GtkWidget, device: ?*GdkDevice) void;
pub extern fn gtk_key_snooper_install(snooper: GtkKeySnoopFunc, func_data: gpointer) guint;
pub extern fn gtk_key_snooper_remove(snooper_handler_id: guint) void;
pub extern fn gtk_get_current_event() [*c]GdkEvent;
pub extern fn gtk_get_current_event_time() guint32;
pub extern fn gtk_get_current_event_state(state: [*c]GdkModifierType) gboolean;
pub extern fn gtk_get_current_event_device() ?*GdkDevice;
pub extern fn gtk_get_event_widget(event: [*c]GdkEvent) [*c]GtkWidget;
pub extern fn gtk_propagate_event(widget: [*c]GtkWidget, event: [*c]GdkEvent) void;
pub const struct__GtkMenuBarPrivate = @OpaqueType();
pub const GtkMenuBarPrivate = struct__GtkMenuBarPrivate;
pub const struct__GtkMenuBar = extern struct {
    menu_shell: GtkMenuShell,
    priv: ?*GtkMenuBarPrivate,
};
pub const GtkMenuBar = struct__GtkMenuBar;
pub const struct__GtkMenuBarClass = extern struct {
    parent_class: GtkMenuShellClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkMenuBarClass = struct__GtkMenuBarClass;
pub extern fn gtk_menu_bar_get_type() GType;
pub extern fn gtk_menu_bar_new() [*c]GtkWidget;
pub extern fn gtk_menu_bar_new_from_model(model: [*c]GMenuModel) [*c]GtkWidget;
pub extern fn gtk_menu_bar_get_pack_direction(menubar: [*c]GtkMenuBar) GtkPackDirection;
pub extern fn gtk_menu_bar_set_pack_direction(menubar: [*c]GtkMenuBar, pack_dir: GtkPackDirection) void;
pub extern fn gtk_menu_bar_get_child_pack_direction(menubar: [*c]GtkMenuBar) GtkPackDirection;
pub extern fn gtk_menu_bar_set_child_pack_direction(menubar: [*c]GtkMenuBar, child_pack_dir: GtkPackDirection) void;
pub extern fn _gtk_menu_bar_cycle_focus(menubar: [*c]GtkMenuBar, dir: GtkDirectionType) void;
pub extern fn _gtk_menu_bar_get_viewable_menu_bars(window: [*c]GtkWindow) [*c]GList;
pub const struct__GtkPopoverPrivate = @OpaqueType();
pub const GtkPopoverPrivate = struct__GtkPopoverPrivate;
pub const struct__GtkPopover = extern struct {
    parent_instance: GtkBin,
    priv: ?*GtkPopoverPrivate,
};
pub const GtkPopover = struct__GtkPopover;
pub const struct__GtkPopoverClass = extern struct {
    parent_class: GtkBinClass,
    closed: ?extern fn ([*c]GtkPopover) void,
    reserved: [10]gpointer,
};
pub const GtkPopoverClass = struct__GtkPopoverClass;
pub extern fn gtk_popover_get_type() GType;
pub extern fn gtk_popover_new(relative_to: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_popover_new_from_model(relative_to: [*c]GtkWidget, model: [*c]GMenuModel) [*c]GtkWidget;
pub extern fn gtk_popover_set_relative_to(popover: [*c]GtkPopover, relative_to: [*c]GtkWidget) void;
pub extern fn gtk_popover_get_relative_to(popover: [*c]GtkPopover) [*c]GtkWidget;
pub extern fn gtk_popover_set_pointing_to(popover: [*c]GtkPopover, rect: [*c]const GdkRectangle) void;
pub extern fn gtk_popover_get_pointing_to(popover: [*c]GtkPopover, rect: [*c]GdkRectangle) gboolean;
pub extern fn gtk_popover_set_position(popover: [*c]GtkPopover, position: GtkPositionType) void;
pub extern fn gtk_popover_get_position(popover: [*c]GtkPopover) GtkPositionType;
pub extern fn gtk_popover_set_modal(popover: [*c]GtkPopover, modal: gboolean) void;
pub extern fn gtk_popover_get_modal(popover: [*c]GtkPopover) gboolean;
pub extern fn gtk_popover_bind_model(popover: [*c]GtkPopover, model: [*c]GMenuModel, action_namespace: [*c]const gchar) void;
pub extern fn gtk_popover_set_transitions_enabled(popover: [*c]GtkPopover, transitions_enabled: gboolean) void;
pub extern fn gtk_popover_get_transitions_enabled(popover: [*c]GtkPopover) gboolean;
pub extern fn gtk_popover_set_default_widget(popover: [*c]GtkPopover, widget: [*c]GtkWidget) void;
pub extern fn gtk_popover_get_default_widget(popover: [*c]GtkPopover) [*c]GtkWidget;
pub extern fn gtk_popover_set_constrain_to(popover: [*c]GtkPopover, constraint: GtkPopoverConstraint) void;
pub extern fn gtk_popover_get_constrain_to(popover: [*c]GtkPopover) GtkPopoverConstraint;
pub extern fn gtk_popover_popup(popover: [*c]GtkPopover) void;
pub extern fn gtk_popover_popdown(popover: [*c]GtkPopover) void;
pub const struct__GtkMenuButtonPrivate = @OpaqueType();
pub const GtkMenuButtonPrivate = struct__GtkMenuButtonPrivate;
pub const struct__GtkMenuButton = extern struct {
    parent: GtkToggleButton,
    priv: ?*GtkMenuButtonPrivate,
};
pub const GtkMenuButton = struct__GtkMenuButton;
pub const struct__GtkMenuButtonClass = extern struct {
    parent_class: GtkToggleButtonClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkMenuButtonClass = struct__GtkMenuButtonClass;
pub extern fn gtk_menu_button_get_type() GType;
pub extern fn gtk_menu_button_new() [*c]GtkWidget;
pub extern fn gtk_menu_button_set_popup(menu_button: [*c]GtkMenuButton, menu: [*c]GtkWidget) void;
pub extern fn gtk_menu_button_get_popup(menu_button: [*c]GtkMenuButton) [*c]GtkMenu;
pub extern fn gtk_menu_button_set_popover(menu_button: [*c]GtkMenuButton, popover: [*c]GtkWidget) void;
pub extern fn gtk_menu_button_get_popover(menu_button: [*c]GtkMenuButton) [*c]GtkPopover;
pub extern fn gtk_menu_button_set_direction(menu_button: [*c]GtkMenuButton, direction: GtkArrowType) void;
pub extern fn gtk_menu_button_get_direction(menu_button: [*c]GtkMenuButton) GtkArrowType;
pub extern fn gtk_menu_button_set_menu_model(menu_button: [*c]GtkMenuButton, menu_model: [*c]GMenuModel) void;
pub extern fn gtk_menu_button_get_menu_model(menu_button: [*c]GtkMenuButton) [*c]GMenuModel;
pub extern fn gtk_menu_button_set_align_widget(menu_button: [*c]GtkMenuButton, align_widget: [*c]GtkWidget) void;
pub extern fn gtk_menu_button_get_align_widget(menu_button: [*c]GtkMenuButton) [*c]GtkWidget;
pub extern fn gtk_menu_button_set_use_popover(menu_button: [*c]GtkMenuButton, use_popover: gboolean) void;
pub extern fn gtk_menu_button_get_use_popover(menu_button: [*c]GtkMenuButton) gboolean;
pub const struct__GtkSizeGroupPrivate = @OpaqueType();
pub const GtkSizeGroupPrivate = struct__GtkSizeGroupPrivate;
pub const struct__GtkSizeGroup = extern struct {
    parent_instance: GObject,
    priv: ?*GtkSizeGroupPrivate,
};
pub const GtkSizeGroup = struct__GtkSizeGroup;
pub const struct__GtkSizeGroupClass = extern struct {
    parent_class: GObjectClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkSizeGroupClass = struct__GtkSizeGroupClass;
pub extern fn gtk_size_group_get_type() GType;
pub extern fn gtk_size_group_new(mode: GtkSizeGroupMode) [*c]GtkSizeGroup;
pub extern fn gtk_size_group_set_mode(size_group: [*c]GtkSizeGroup, mode: GtkSizeGroupMode) void;
pub extern fn gtk_size_group_get_mode(size_group: [*c]GtkSizeGroup) GtkSizeGroupMode;
pub extern fn gtk_size_group_set_ignore_hidden(size_group: [*c]GtkSizeGroup, ignore_hidden: gboolean) void;
pub extern fn gtk_size_group_get_ignore_hidden(size_group: [*c]GtkSizeGroup) gboolean;
pub extern fn gtk_size_group_add_widget(size_group: [*c]GtkSizeGroup, widget: [*c]GtkWidget) void;
pub extern fn gtk_size_group_remove_widget(size_group: [*c]GtkSizeGroup, widget: [*c]GtkWidget) void;
pub extern fn gtk_size_group_get_widgets(size_group: [*c]GtkSizeGroup) [*c]GSList;
pub const struct__GtkToolItemPrivate = @OpaqueType();
pub const GtkToolItemPrivate = struct__GtkToolItemPrivate;
pub const struct__GtkToolItem = extern struct {
    parent: GtkBin,
    priv: ?*GtkToolItemPrivate,
};
pub const GtkToolItem = struct__GtkToolItem;
pub const struct__GtkToolItemClass = extern struct {
    parent_class: GtkBinClass,
    create_menu_proxy: ?extern fn ([*c]GtkToolItem) gboolean,
    toolbar_reconfigured: ?extern fn ([*c]GtkToolItem) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkToolItemClass = struct__GtkToolItemClass;
pub extern fn gtk_tool_item_get_type() GType;
pub extern fn gtk_tool_item_new() [*c]GtkToolItem;
pub extern fn gtk_tool_item_set_homogeneous(tool_item: [*c]GtkToolItem, homogeneous: gboolean) void;
pub extern fn gtk_tool_item_get_homogeneous(tool_item: [*c]GtkToolItem) gboolean;
pub extern fn gtk_tool_item_set_expand(tool_item: [*c]GtkToolItem, expand: gboolean) void;
pub extern fn gtk_tool_item_get_expand(tool_item: [*c]GtkToolItem) gboolean;
pub extern fn gtk_tool_item_set_tooltip_text(tool_item: [*c]GtkToolItem, text: [*c]const gchar) void;
pub extern fn gtk_tool_item_set_tooltip_markup(tool_item: [*c]GtkToolItem, markup: [*c]const gchar) void;
pub extern fn gtk_tool_item_set_use_drag_window(tool_item: [*c]GtkToolItem, use_drag_window: gboolean) void;
pub extern fn gtk_tool_item_get_use_drag_window(tool_item: [*c]GtkToolItem) gboolean;
pub extern fn gtk_tool_item_set_visible_horizontal(tool_item: [*c]GtkToolItem, visible_horizontal: gboolean) void;
pub extern fn gtk_tool_item_get_visible_horizontal(tool_item: [*c]GtkToolItem) gboolean;
pub extern fn gtk_tool_item_set_visible_vertical(tool_item: [*c]GtkToolItem, visible_vertical: gboolean) void;
pub extern fn gtk_tool_item_get_visible_vertical(tool_item: [*c]GtkToolItem) gboolean;
pub extern fn gtk_tool_item_get_is_important(tool_item: [*c]GtkToolItem) gboolean;
pub extern fn gtk_tool_item_set_is_important(tool_item: [*c]GtkToolItem, is_important: gboolean) void;
pub extern fn gtk_tool_item_get_ellipsize_mode(tool_item: [*c]GtkToolItem) PangoEllipsizeMode;
pub extern fn gtk_tool_item_get_icon_size(tool_item: [*c]GtkToolItem) GtkIconSize;
pub extern fn gtk_tool_item_get_orientation(tool_item: [*c]GtkToolItem) GtkOrientation;
pub extern fn gtk_tool_item_get_toolbar_style(tool_item: [*c]GtkToolItem) GtkToolbarStyle;
pub extern fn gtk_tool_item_get_relief_style(tool_item: [*c]GtkToolItem) GtkReliefStyle;
pub extern fn gtk_tool_item_get_text_alignment(tool_item: [*c]GtkToolItem) gfloat;
pub extern fn gtk_tool_item_get_text_orientation(tool_item: [*c]GtkToolItem) GtkOrientation;
pub extern fn gtk_tool_item_get_text_size_group(tool_item: [*c]GtkToolItem) [*c]GtkSizeGroup;
pub extern fn gtk_tool_item_retrieve_proxy_menu_item(tool_item: [*c]GtkToolItem) [*c]GtkWidget;
pub extern fn gtk_tool_item_get_proxy_menu_item(tool_item: [*c]GtkToolItem, menu_item_id: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_tool_item_set_proxy_menu_item(tool_item: [*c]GtkToolItem, menu_item_id: [*c]const gchar, menu_item: [*c]GtkWidget) void;
pub extern fn gtk_tool_item_rebuild_menu(tool_item: [*c]GtkToolItem) void;
pub extern fn gtk_tool_item_toolbar_reconfigured(tool_item: [*c]GtkToolItem) void;
pub extern fn _gtk_tool_item_create_menu_proxy(tool_item: [*c]GtkToolItem) gboolean;
pub const struct__GtkToolButtonPrivate = @OpaqueType();
pub const GtkToolButtonPrivate = struct__GtkToolButtonPrivate;
pub const struct__GtkToolButton = extern struct {
    parent: GtkToolItem,
    priv: ?*GtkToolButtonPrivate,
};
pub const GtkToolButton = struct__GtkToolButton;
pub const struct__GtkToolButtonClass = extern struct {
    parent_class: GtkToolItemClass,
    button_type: GType,
    clicked: ?extern fn ([*c]GtkToolButton) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkToolButtonClass = struct__GtkToolButtonClass;
pub extern fn gtk_tool_button_get_type() GType;
pub extern fn gtk_tool_button_new(icon_widget: [*c]GtkWidget, label: [*c]const gchar) [*c]GtkToolItem;
pub extern fn gtk_tool_button_new_from_stock(stock_id: [*c]const gchar) [*c]GtkToolItem;
pub extern fn gtk_tool_button_set_label(button: [*c]GtkToolButton, label: [*c]const gchar) void;
pub extern fn gtk_tool_button_get_label(button: [*c]GtkToolButton) [*c]const gchar;
pub extern fn gtk_tool_button_set_use_underline(button: [*c]GtkToolButton, use_underline: gboolean) void;
pub extern fn gtk_tool_button_get_use_underline(button: [*c]GtkToolButton) gboolean;
pub extern fn gtk_tool_button_set_stock_id(button: [*c]GtkToolButton, stock_id: [*c]const gchar) void;
pub extern fn gtk_tool_button_get_stock_id(button: [*c]GtkToolButton) [*c]const gchar;
pub extern fn gtk_tool_button_set_icon_name(button: [*c]GtkToolButton, icon_name: [*c]const gchar) void;
pub extern fn gtk_tool_button_get_icon_name(button: [*c]GtkToolButton) [*c]const gchar;
pub extern fn gtk_tool_button_set_icon_widget(button: [*c]GtkToolButton, icon_widget: [*c]GtkWidget) void;
pub extern fn gtk_tool_button_get_icon_widget(button: [*c]GtkToolButton) [*c]GtkWidget;
pub extern fn gtk_tool_button_set_label_widget(button: [*c]GtkToolButton, label_widget: [*c]GtkWidget) void;
pub extern fn gtk_tool_button_get_label_widget(button: [*c]GtkToolButton) [*c]GtkWidget;
pub extern fn _gtk_tool_button_get_button(button: [*c]GtkToolButton) [*c]GtkWidget;
pub const struct__GtkMenuToolButtonPrivate = @OpaqueType();
pub const GtkMenuToolButtonPrivate = struct__GtkMenuToolButtonPrivate;
pub const struct__GtkMenuToolButton = extern struct {
    parent: GtkToolButton,
    priv: ?*GtkMenuToolButtonPrivate,
};
pub const GtkMenuToolButton = struct__GtkMenuToolButton;
pub const struct__GtkMenuToolButtonClass = extern struct {
    parent_class: GtkToolButtonClass,
    show_menu: ?extern fn ([*c]GtkMenuToolButton) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkMenuToolButtonClass = struct__GtkMenuToolButtonClass;
pub extern fn gtk_menu_tool_button_get_type() GType;
pub extern fn gtk_menu_tool_button_new(icon_widget: [*c]GtkWidget, label: [*c]const gchar) [*c]GtkToolItem;
pub extern fn gtk_menu_tool_button_new_from_stock(stock_id: [*c]const gchar) [*c]GtkToolItem;
pub extern fn gtk_menu_tool_button_set_menu(button: [*c]GtkMenuToolButton, menu: [*c]GtkWidget) void;
pub extern fn gtk_menu_tool_button_get_menu(button: [*c]GtkMenuToolButton) [*c]GtkWidget;
pub extern fn gtk_menu_tool_button_set_arrow_tooltip_text(button: [*c]GtkMenuToolButton, text: [*c]const gchar) void;
pub extern fn gtk_menu_tool_button_set_arrow_tooltip_markup(button: [*c]GtkMenuToolButton, markup: [*c]const gchar) void;
pub const struct__GtkMessageDialogPrivate = @OpaqueType();
pub const GtkMessageDialogPrivate = struct__GtkMessageDialogPrivate;
pub const struct__GtkMessageDialog = extern struct {
    parent_instance: GtkDialog,
    priv: ?*GtkMessageDialogPrivate,
};
pub const GtkMessageDialog = struct__GtkMessageDialog;
pub const struct__GtkMessageDialogClass = extern struct {
    parent_class: GtkDialogClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkMessageDialogClass = struct__GtkMessageDialogClass;
pub const GTK_BUTTONS_NONE = 0;
pub const GTK_BUTTONS_OK = 1;
pub const GTK_BUTTONS_CLOSE = 2;
pub const GTK_BUTTONS_CANCEL = 3;
pub const GTK_BUTTONS_YES_NO = 4;
pub const GTK_BUTTONS_OK_CANCEL = 5;
pub const GtkButtonsType = extern enum {
    GTK_BUTTONS_NONE = 0,
    GTK_BUTTONS_OK = 1,
    GTK_BUTTONS_CLOSE = 2,
    GTK_BUTTONS_CANCEL = 3,
    GTK_BUTTONS_YES_NO = 4,
    GTK_BUTTONS_OK_CANCEL = 5,
};
pub extern fn gtk_message_dialog_get_type() GType;
pub extern fn gtk_message_dialog_new(parent: [*c]GtkWindow, flags: GtkDialogFlags, type_0: GtkMessageType, buttons: GtkButtonsType, message_format: [*c]const gchar, ...) [*c]GtkWidget;
pub extern fn gtk_message_dialog_new_with_markup(parent: [*c]GtkWindow, flags: GtkDialogFlags, type_0: GtkMessageType, buttons: GtkButtonsType, message_format: [*c]const gchar, ...) [*c]GtkWidget;
pub extern fn gtk_message_dialog_set_image(dialog: [*c]GtkMessageDialog, image: [*c]GtkWidget) void;
pub extern fn gtk_message_dialog_get_image(dialog: [*c]GtkMessageDialog) [*c]GtkWidget;
pub extern fn gtk_message_dialog_set_markup(message_dialog: [*c]GtkMessageDialog, str: [*c]const gchar) void;
pub extern fn gtk_message_dialog_format_secondary_text(message_dialog: [*c]GtkMessageDialog, message_format: [*c]const gchar, ...) void;
pub extern fn gtk_message_dialog_format_secondary_markup(message_dialog: [*c]GtkMessageDialog, message_format: [*c]const gchar, ...) void;
pub extern fn gtk_message_dialog_get_message_area(message_dialog: [*c]GtkMessageDialog) [*c]GtkWidget;
pub const struct__GtkModelButton = @OpaqueType();
pub const GtkModelButton = struct__GtkModelButton;
pub const GTK_BUTTON_ROLE_NORMAL = 0;
pub const GTK_BUTTON_ROLE_CHECK = 1;
pub const GTK_BUTTON_ROLE_RADIO = 2;
pub const GtkButtonRole = extern enum {
    GTK_BUTTON_ROLE_NORMAL = 0,
    GTK_BUTTON_ROLE_CHECK = 1,
    GTK_BUTTON_ROLE_RADIO = 2,
};
pub extern fn gtk_model_button_get_type() GType;
pub extern fn gtk_model_button_new() [*c]GtkWidget;
pub const GtkModuleInitFunc = ?extern fn ([*c]gint, [*c]([*c]([*c]gchar))) void;
pub const GtkModuleDisplayInitFunc = ?extern fn (?*GdkDisplay) void;
pub const struct__GtkMountOperationPrivate = @OpaqueType();
pub const GtkMountOperationPrivate = struct__GtkMountOperationPrivate;
pub const struct__GtkMountOperation = extern struct {
    parent_instance: GMountOperation,
    priv: ?*GtkMountOperationPrivate,
};
pub const GtkMountOperation = struct__GtkMountOperation;
pub const struct__GtkMountOperationClass = extern struct {
    parent_class: GMountOperationClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkMountOperationClass = struct__GtkMountOperationClass;
pub extern fn gtk_mount_operation_get_type() GType;
pub extern fn gtk_mount_operation_new(parent: [*c]GtkWindow) [*c]GMountOperation;
pub extern fn gtk_mount_operation_is_showing(op: [*c]GtkMountOperation) gboolean;
pub extern fn gtk_mount_operation_set_parent(op: [*c]GtkMountOperation, parent: [*c]GtkWindow) void;
pub extern fn gtk_mount_operation_get_parent(op: [*c]GtkMountOperation) [*c]GtkWindow;
pub extern fn gtk_mount_operation_set_screen(op: [*c]GtkMountOperation, screen: ?*GdkScreen) void;
pub extern fn gtk_mount_operation_get_screen(op: [*c]GtkMountOperation) ?*GdkScreen;
pub const GTK_NOTEBOOK_TAB_FIRST = 0;
pub const GTK_NOTEBOOK_TAB_LAST = 1;
pub const GtkNotebookTab = extern enum {
    GTK_NOTEBOOK_TAB_FIRST = 0,
    GTK_NOTEBOOK_TAB_LAST = 1,
};
pub const struct__GtkNotebookPrivate = @OpaqueType();
pub const GtkNotebookPrivate = struct__GtkNotebookPrivate;
pub const struct__GtkNotebook = extern struct {
    container: GtkContainer,
    priv: ?*GtkNotebookPrivate,
};
pub const GtkNotebook = struct__GtkNotebook;
pub const struct__GtkNotebookClass = extern struct {
    parent_class: GtkContainerClass,
    switch_page: ?extern fn ([*c]GtkNotebook, [*c]GtkWidget, guint) void,
    select_page: ?extern fn ([*c]GtkNotebook, gboolean) gboolean,
    focus_tab: ?extern fn ([*c]GtkNotebook, GtkNotebookTab) gboolean,
    change_current_page: ?extern fn ([*c]GtkNotebook, gint) gboolean,
    move_focus_out: ?extern fn ([*c]GtkNotebook, GtkDirectionType) void,
    reorder_tab: ?extern fn ([*c]GtkNotebook, GtkDirectionType, gboolean) gboolean,
    insert_page: ?extern fn ([*c]GtkNotebook, [*c]GtkWidget, [*c]GtkWidget, [*c]GtkWidget, gint) gint,
    create_window: ?extern fn ([*c]GtkNotebook, [*c]GtkWidget, gint, gint) [*c]GtkNotebook,
    page_reordered: ?extern fn ([*c]GtkNotebook, [*c]GtkWidget, guint) void,
    page_removed: ?extern fn ([*c]GtkNotebook, [*c]GtkWidget, guint) void,
    page_added: ?extern fn ([*c]GtkNotebook, [*c]GtkWidget, guint) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
    _gtk_reserved8: ?extern fn () void,
};
pub const GtkNotebookClass = struct__GtkNotebookClass;
pub extern fn gtk_notebook_get_type() GType;
pub extern fn gtk_notebook_new() [*c]GtkWidget;
pub extern fn gtk_notebook_append_page(notebook: [*c]GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget) gint;
pub extern fn gtk_notebook_append_page_menu(notebook: [*c]GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget, menu_label: [*c]GtkWidget) gint;
pub extern fn gtk_notebook_prepend_page(notebook: [*c]GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget) gint;
pub extern fn gtk_notebook_prepend_page_menu(notebook: [*c]GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget, menu_label: [*c]GtkWidget) gint;
pub extern fn gtk_notebook_insert_page(notebook: [*c]GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget, position: gint) gint;
pub extern fn gtk_notebook_insert_page_menu(notebook: [*c]GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget, menu_label: [*c]GtkWidget, position: gint) gint;
pub extern fn gtk_notebook_remove_page(notebook: [*c]GtkNotebook, page_num: gint) void;
pub extern fn gtk_notebook_set_group_name(notebook: [*c]GtkNotebook, group_name: [*c]const gchar) void;
pub extern fn gtk_notebook_get_group_name(notebook: [*c]GtkNotebook) [*c]const gchar;
pub extern fn gtk_notebook_get_current_page(notebook: [*c]GtkNotebook) gint;
pub extern fn gtk_notebook_get_nth_page(notebook: [*c]GtkNotebook, page_num: gint) [*c]GtkWidget;
pub extern fn gtk_notebook_get_n_pages(notebook: [*c]GtkNotebook) gint;
pub extern fn gtk_notebook_page_num(notebook: [*c]GtkNotebook, child: [*c]GtkWidget) gint;
pub extern fn gtk_notebook_set_current_page(notebook: [*c]GtkNotebook, page_num: gint) void;
pub extern fn gtk_notebook_next_page(notebook: [*c]GtkNotebook) void;
pub extern fn gtk_notebook_prev_page(notebook: [*c]GtkNotebook) void;
pub extern fn gtk_notebook_set_show_border(notebook: [*c]GtkNotebook, show_border: gboolean) void;
pub extern fn gtk_notebook_get_show_border(notebook: [*c]GtkNotebook) gboolean;
pub extern fn gtk_notebook_set_show_tabs(notebook: [*c]GtkNotebook, show_tabs: gboolean) void;
pub extern fn gtk_notebook_get_show_tabs(notebook: [*c]GtkNotebook) gboolean;
pub extern fn gtk_notebook_set_tab_pos(notebook: [*c]GtkNotebook, pos: GtkPositionType) void;
pub extern fn gtk_notebook_get_tab_pos(notebook: [*c]GtkNotebook) GtkPositionType;
pub extern fn gtk_notebook_set_scrollable(notebook: [*c]GtkNotebook, scrollable: gboolean) void;
pub extern fn gtk_notebook_get_scrollable(notebook: [*c]GtkNotebook) gboolean;
pub extern fn gtk_notebook_get_tab_hborder(notebook: [*c]GtkNotebook) guint16;
pub extern fn gtk_notebook_get_tab_vborder(notebook: [*c]GtkNotebook) guint16;
pub extern fn gtk_notebook_popup_enable(notebook: [*c]GtkNotebook) void;
pub extern fn gtk_notebook_popup_disable(notebook: [*c]GtkNotebook) void;
pub extern fn gtk_notebook_get_tab_label(notebook: [*c]GtkNotebook, child: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_notebook_set_tab_label(notebook: [*c]GtkNotebook, child: [*c]GtkWidget, tab_label: [*c]GtkWidget) void;
pub extern fn gtk_notebook_set_tab_label_text(notebook: [*c]GtkNotebook, child: [*c]GtkWidget, tab_text: [*c]const gchar) void;
pub extern fn gtk_notebook_get_tab_label_text(notebook: [*c]GtkNotebook, child: [*c]GtkWidget) [*c]const gchar;
pub extern fn gtk_notebook_get_menu_label(notebook: [*c]GtkNotebook, child: [*c]GtkWidget) [*c]GtkWidget;
pub extern fn gtk_notebook_set_menu_label(notebook: [*c]GtkNotebook, child: [*c]GtkWidget, menu_label: [*c]GtkWidget) void;
pub extern fn gtk_notebook_set_menu_label_text(notebook: [*c]GtkNotebook, child: [*c]GtkWidget, menu_text: [*c]const gchar) void;
pub extern fn gtk_notebook_get_menu_label_text(notebook: [*c]GtkNotebook, child: [*c]GtkWidget) [*c]const gchar;
pub extern fn gtk_notebook_reorder_child(notebook: [*c]GtkNotebook, child: [*c]GtkWidget, position: gint) void;
pub extern fn gtk_notebook_get_tab_reorderable(notebook: [*c]GtkNotebook, child: [*c]GtkWidget) gboolean;
pub extern fn gtk_notebook_set_tab_reorderable(notebook: [*c]GtkNotebook, child: [*c]GtkWidget, reorderable: gboolean) void;
pub extern fn gtk_notebook_get_tab_detachable(notebook: [*c]GtkNotebook, child: [*c]GtkWidget) gboolean;
pub extern fn gtk_notebook_set_tab_detachable(notebook: [*c]GtkNotebook, child: [*c]GtkWidget, detachable: gboolean) void;
pub extern fn gtk_notebook_detach_tab(notebook: [*c]GtkNotebook, child: [*c]GtkWidget) void;
pub extern fn gtk_notebook_get_action_widget(notebook: [*c]GtkNotebook, pack_type: GtkPackType) [*c]GtkWidget;
pub extern fn gtk_notebook_set_action_widget(notebook: [*c]GtkNotebook, widget: [*c]GtkWidget, pack_type: GtkPackType) void;
pub const struct__GtkOffscreenWindow = extern struct {
    parent_object: GtkWindow,
};
pub const GtkOffscreenWindow = struct__GtkOffscreenWindow;
pub const struct__GtkOffscreenWindowClass = extern struct {
    parent_class: GtkWindowClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkOffscreenWindowClass = struct__GtkOffscreenWindowClass;
pub extern fn gtk_offscreen_window_get_type() GType;
pub extern fn gtk_offscreen_window_new() [*c]GtkWidget;
pub extern fn gtk_offscreen_window_get_surface(offscreen: [*c]GtkOffscreenWindow) ?*cairo_surface_t;
pub extern fn gtk_offscreen_window_get_pixbuf(offscreen: [*c]GtkOffscreenWindow) ?*GdkPixbuf;
pub const struct__GtkOrientable = @OpaqueType();
pub const GtkOrientable = struct__GtkOrientable;
pub const struct__GtkOrientableIface = extern struct {
    base_iface: GTypeInterface,
};
pub const GtkOrientableIface = struct__GtkOrientableIface;
pub extern fn gtk_orientable_get_type() GType;
pub extern fn gtk_orientable_set_orientation(orientable: ?*GtkOrientable, orientation: GtkOrientation) void;
pub extern fn gtk_orientable_get_orientation(orientable: ?*GtkOrientable) GtkOrientation;
pub const struct__GtkOverlayPrivate = @OpaqueType();
pub const GtkOverlayPrivate = struct__GtkOverlayPrivate;
pub const struct__GtkOverlay = extern struct {
    parent: GtkBin,
    priv: ?*GtkOverlayPrivate,
};
pub const GtkOverlay = struct__GtkOverlay;
pub const struct__GtkOverlayClass = extern struct {
    parent_class: GtkBinClass,
    get_child_position: ?extern fn ([*c]GtkOverlay, [*c]GtkWidget, [*c]GtkAllocation) gboolean,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
    _gtk_reserved8: ?extern fn () void,
};
pub const GtkOverlayClass = struct__GtkOverlayClass;
pub extern fn gtk_overlay_get_type() GType;
pub extern fn gtk_overlay_new() [*c]GtkWidget;
pub extern fn gtk_overlay_add_overlay(overlay: [*c]GtkOverlay, widget: [*c]GtkWidget) void;
pub extern fn gtk_overlay_reorder_overlay(overlay: [*c]GtkOverlay, child: [*c]GtkWidget, index_: c_int) void;
pub extern fn gtk_overlay_get_overlay_pass_through(overlay: [*c]GtkOverlay, widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_overlay_set_overlay_pass_through(overlay: [*c]GtkOverlay, widget: [*c]GtkWidget, pass_through: gboolean) void;
pub const struct__GtkPadController = @OpaqueType();
pub const GtkPadController = struct__GtkPadController;
pub const struct__GtkPadControllerClass = @OpaqueType();
pub const GtkPadControllerClass = struct__GtkPadControllerClass;
pub const GTK_PAD_ACTION_BUTTON = 0;
pub const GTK_PAD_ACTION_RING = 1;
pub const GTK_PAD_ACTION_STRIP = 2;
pub const GtkPadActionType = extern enum {
    GTK_PAD_ACTION_BUTTON = 0,
    GTK_PAD_ACTION_RING = 1,
    GTK_PAD_ACTION_STRIP = 2,
};
pub const struct__GtkPadActionEntry = extern struct {
    type: GtkPadActionType,
    index: gint,
    mode: gint,
    label: [*c]gchar,
    action_name: [*c]gchar,
};
pub const GtkPadActionEntry = struct__GtkPadActionEntry;
pub extern fn gtk_pad_controller_get_type() GType;
pub extern fn gtk_pad_controller_new(window: [*c]GtkWindow, group: ?*GActionGroup, pad: ?*GdkDevice) ?*GtkPadController;
pub extern fn gtk_pad_controller_set_action_entries(controller: ?*GtkPadController, entries: [*c]const GtkPadActionEntry, n_entries: gint) void;
pub extern fn gtk_pad_controller_set_action(controller: ?*GtkPadController, type_0: GtkPadActionType, index: gint, mode: gint, label: [*c]const gchar, action_name: [*c]const gchar) void;
pub const struct__GtkPaperSize = @OpaqueType();
pub const GtkPaperSize = struct__GtkPaperSize;
pub extern fn gtk_paper_size_get_type() GType;
pub extern fn gtk_paper_size_new(name: [*c]const gchar) ?*GtkPaperSize;
pub extern fn gtk_paper_size_new_from_ppd(ppd_name: [*c]const gchar, ppd_display_name: [*c]const gchar, width: gdouble, height: gdouble) ?*GtkPaperSize;
pub extern fn gtk_paper_size_new_from_ipp(ipp_name: [*c]const gchar, width: gdouble, height: gdouble) ?*GtkPaperSize;
pub extern fn gtk_paper_size_new_custom(name: [*c]const gchar, display_name: [*c]const gchar, width: gdouble, height: gdouble, unit: GtkUnit) ?*GtkPaperSize;
pub extern fn gtk_paper_size_copy(other: ?*GtkPaperSize) ?*GtkPaperSize;
pub extern fn gtk_paper_size_free(size: ?*GtkPaperSize) void;
pub extern fn gtk_paper_size_is_equal(size1: ?*GtkPaperSize, size2: ?*GtkPaperSize) gboolean;
pub extern fn gtk_paper_size_get_paper_sizes(include_custom: gboolean) [*c]GList;
pub extern fn gtk_paper_size_get_name(size: ?*GtkPaperSize) [*c]const gchar;
pub extern fn gtk_paper_size_get_display_name(size: ?*GtkPaperSize) [*c]const gchar;
pub extern fn gtk_paper_size_get_ppd_name(size: ?*GtkPaperSize) [*c]const gchar;
pub extern fn gtk_paper_size_get_width(size: ?*GtkPaperSize, unit: GtkUnit) gdouble;
pub extern fn gtk_paper_size_get_height(size: ?*GtkPaperSize, unit: GtkUnit) gdouble;
pub extern fn gtk_paper_size_is_custom(size: ?*GtkPaperSize) gboolean;
pub extern fn gtk_paper_size_is_ipp(size: ?*GtkPaperSize) gboolean;
pub extern fn gtk_paper_size_set_size(size: ?*GtkPaperSize, width: gdouble, height: gdouble, unit: GtkUnit) void;
pub extern fn gtk_paper_size_get_default_top_margin(size: ?*GtkPaperSize, unit: GtkUnit) gdouble;
pub extern fn gtk_paper_size_get_default_bottom_margin(size: ?*GtkPaperSize, unit: GtkUnit) gdouble;
pub extern fn gtk_paper_size_get_default_left_margin(size: ?*GtkPaperSize, unit: GtkUnit) gdouble;
pub extern fn gtk_paper_size_get_default_right_margin(size: ?*GtkPaperSize, unit: GtkUnit) gdouble;
pub extern fn gtk_paper_size_get_default() [*c]const gchar;
pub extern fn gtk_paper_size_new_from_key_file(key_file: ?*GKeyFile, group_name: [*c]const gchar, @"error": [*c]([*c]GError)) ?*GtkPaperSize;
pub extern fn gtk_paper_size_to_key_file(size: ?*GtkPaperSize, key_file: ?*GKeyFile, group_name: [*c]const gchar) void;
pub extern fn gtk_paper_size_new_from_gvariant(variant: ?*GVariant) ?*GtkPaperSize;
pub extern fn gtk_paper_size_to_gvariant(paper_size: ?*GtkPaperSize) ?*GVariant;
pub const struct__GtkPageSetup = @OpaqueType();
pub const GtkPageSetup = struct__GtkPageSetup;
pub extern fn gtk_page_setup_get_type() GType;
pub extern fn gtk_page_setup_new() ?*GtkPageSetup;
pub extern fn gtk_page_setup_copy(other: ?*GtkPageSetup) ?*GtkPageSetup;
pub extern fn gtk_page_setup_get_orientation(setup: ?*GtkPageSetup) GtkPageOrientation;
pub extern fn gtk_page_setup_set_orientation(setup: ?*GtkPageSetup, orientation: GtkPageOrientation) void;
pub extern fn gtk_page_setup_get_paper_size(setup: ?*GtkPageSetup) ?*GtkPaperSize;
pub extern fn gtk_page_setup_set_paper_size(setup: ?*GtkPageSetup, size: ?*GtkPaperSize) void;
pub extern fn gtk_page_setup_get_top_margin(setup: ?*GtkPageSetup, unit: GtkUnit) gdouble;
pub extern fn gtk_page_setup_set_top_margin(setup: ?*GtkPageSetup, margin: gdouble, unit: GtkUnit) void;
pub extern fn gtk_page_setup_get_bottom_margin(setup: ?*GtkPageSetup, unit: GtkUnit) gdouble;
pub extern fn gtk_page_setup_set_bottom_margin(setup: ?*GtkPageSetup, margin: gdouble, unit: GtkUnit) void;
pub extern fn gtk_page_setup_get_left_margin(setup: ?*GtkPageSetup, unit: GtkUnit) gdouble;
pub extern fn gtk_page_setup_set_left_margin(setup: ?*GtkPageSetup, margin: gdouble, unit: GtkUnit) void;
pub extern fn gtk_page_setup_get_right_margin(setup: ?*GtkPageSetup, unit: GtkUnit) gdouble;
pub extern fn gtk_page_setup_set_right_margin(setup: ?*GtkPageSetup, margin: gdouble, unit: GtkUnit) void;
pub extern fn gtk_page_setup_set_paper_size_and_default_margins(setup: ?*GtkPageSetup, size: ?*GtkPaperSize) void;
pub extern fn gtk_page_setup_get_paper_width(setup: ?*GtkPageSetup, unit: GtkUnit) gdouble;
pub extern fn gtk_page_setup_get_paper_height(setup: ?*GtkPageSetup, unit: GtkUnit) gdouble;
pub extern fn gtk_page_setup_get_page_width(setup: ?*GtkPageSetup, unit: GtkUnit) gdouble;
pub extern fn gtk_page_setup_get_page_height(setup: ?*GtkPageSetup, unit: GtkUnit) gdouble;
pub extern fn gtk_page_setup_new_from_file(file_name: [*c]const gchar, @"error": [*c]([*c]GError)) ?*GtkPageSetup;
pub extern fn gtk_page_setup_load_file(setup: ?*GtkPageSetup, file_name: [*c]const u8, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_page_setup_to_file(setup: ?*GtkPageSetup, file_name: [*c]const u8, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_page_setup_new_from_key_file(key_file: ?*GKeyFile, group_name: [*c]const gchar, @"error": [*c]([*c]GError)) ?*GtkPageSetup;
pub extern fn gtk_page_setup_load_key_file(setup: ?*GtkPageSetup, key_file: ?*GKeyFile, group_name: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_page_setup_to_key_file(setup: ?*GtkPageSetup, key_file: ?*GKeyFile, group_name: [*c]const gchar) void;
pub extern fn gtk_page_setup_to_gvariant(setup: ?*GtkPageSetup) ?*GVariant;
pub extern fn gtk_page_setup_new_from_gvariant(variant: ?*GVariant) ?*GtkPageSetup;
pub const struct__GtkPanedPrivate = @OpaqueType();
pub const GtkPanedPrivate = struct__GtkPanedPrivate;
pub const struct__GtkPaned = extern struct {
    container: GtkContainer,
    priv: ?*GtkPanedPrivate,
};
pub const GtkPaned = struct__GtkPaned;
pub const struct__GtkPanedClass = extern struct {
    parent_class: GtkContainerClass,
    cycle_child_focus: ?extern fn ([*c]GtkPaned, gboolean) gboolean,
    toggle_handle_focus: ?extern fn ([*c]GtkPaned) gboolean,
    move_handle: ?extern fn ([*c]GtkPaned, GtkScrollType) gboolean,
    cycle_handle_focus: ?extern fn ([*c]GtkPaned, gboolean) gboolean,
    accept_position: ?extern fn ([*c]GtkPaned) gboolean,
    cancel_position: ?extern fn ([*c]GtkPaned) gboolean,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkPanedClass = struct__GtkPanedClass;
pub extern fn gtk_paned_get_type() GType;
pub extern fn gtk_paned_new(orientation: GtkOrientation) [*c]GtkWidget;
pub extern fn gtk_paned_add1(paned: [*c]GtkPaned, child: [*c]GtkWidget) void;
pub extern fn gtk_paned_add2(paned: [*c]GtkPaned, child: [*c]GtkWidget) void;
pub extern fn gtk_paned_pack1(paned: [*c]GtkPaned, child: [*c]GtkWidget, resize: gboolean, shrink: gboolean) void;
pub extern fn gtk_paned_pack2(paned: [*c]GtkPaned, child: [*c]GtkWidget, resize: gboolean, shrink: gboolean) void;
pub extern fn gtk_paned_get_position(paned: [*c]GtkPaned) gint;
pub extern fn gtk_paned_set_position(paned: [*c]GtkPaned, position: gint) void;
pub extern fn gtk_paned_get_child1(paned: [*c]GtkPaned) [*c]GtkWidget;
pub extern fn gtk_paned_get_child2(paned: [*c]GtkPaned) [*c]GtkWidget;
pub extern fn gtk_paned_get_handle_window(paned: [*c]GtkPaned) ?*GdkWindow;
pub extern fn gtk_paned_set_wide_handle(paned: [*c]GtkPaned, wide: gboolean) void;
pub extern fn gtk_paned_get_wide_handle(paned: [*c]GtkPaned) gboolean;
pub const struct__GtkPlacesSidebar = @OpaqueType();
pub const GtkPlacesSidebar = struct__GtkPlacesSidebar;
pub const struct__GtkPlacesSidebarClass = @OpaqueType();
pub const GtkPlacesSidebarClass = struct__GtkPlacesSidebarClass;
pub const GTK_PLACES_OPEN_NORMAL = 1;
pub const GTK_PLACES_OPEN_NEW_TAB = 2;
pub const GTK_PLACES_OPEN_NEW_WINDOW = 4;
pub const GtkPlacesOpenFlags = extern enum {
    GTK_PLACES_OPEN_NORMAL = 1,
    GTK_PLACES_OPEN_NEW_TAB = 2,
    GTK_PLACES_OPEN_NEW_WINDOW = 4,
};
pub extern fn gtk_places_sidebar_get_type() GType;
pub extern fn gtk_places_sidebar_new() [*c]GtkWidget;
pub extern fn gtk_places_sidebar_get_open_flags(sidebar: ?*GtkPlacesSidebar) GtkPlacesOpenFlags;
pub extern fn gtk_places_sidebar_set_open_flags(sidebar: ?*GtkPlacesSidebar, flags: GtkPlacesOpenFlags) void;
pub extern fn gtk_places_sidebar_get_location(sidebar: ?*GtkPlacesSidebar) ?*GFile;
pub extern fn gtk_places_sidebar_set_location(sidebar: ?*GtkPlacesSidebar, location: ?*GFile) void;
pub extern fn gtk_places_sidebar_get_show_recent(sidebar: ?*GtkPlacesSidebar) gboolean;
pub extern fn gtk_places_sidebar_set_show_recent(sidebar: ?*GtkPlacesSidebar, show_recent: gboolean) void;
pub extern fn gtk_places_sidebar_get_show_desktop(sidebar: ?*GtkPlacesSidebar) gboolean;
pub extern fn gtk_places_sidebar_set_show_desktop(sidebar: ?*GtkPlacesSidebar, show_desktop: gboolean) void;
pub extern fn gtk_places_sidebar_get_show_connect_to_server(sidebar: ?*GtkPlacesSidebar) gboolean;
pub extern fn gtk_places_sidebar_set_show_connect_to_server(sidebar: ?*GtkPlacesSidebar, show_connect_to_server: gboolean) void;
pub extern fn gtk_places_sidebar_get_show_enter_location(sidebar: ?*GtkPlacesSidebar) gboolean;
pub extern fn gtk_places_sidebar_set_show_enter_location(sidebar: ?*GtkPlacesSidebar, show_enter_location: gboolean) void;
pub extern fn gtk_places_sidebar_set_local_only(sidebar: ?*GtkPlacesSidebar, local_only: gboolean) void;
pub extern fn gtk_places_sidebar_get_local_only(sidebar: ?*GtkPlacesSidebar) gboolean;
pub extern fn gtk_places_sidebar_add_shortcut(sidebar: ?*GtkPlacesSidebar, location: ?*GFile) void;
pub extern fn gtk_places_sidebar_remove_shortcut(sidebar: ?*GtkPlacesSidebar, location: ?*GFile) void;
pub extern fn gtk_places_sidebar_list_shortcuts(sidebar: ?*GtkPlacesSidebar) [*c]GSList;
pub extern fn gtk_places_sidebar_get_nth_bookmark(sidebar: ?*GtkPlacesSidebar, n: gint) ?*GFile;
pub extern fn gtk_places_sidebar_set_drop_targets_visible(sidebar: ?*GtkPlacesSidebar, visible: gboolean, context: ?*GdkDragContext) void;
pub extern fn gtk_places_sidebar_get_show_trash(sidebar: ?*GtkPlacesSidebar) gboolean;
pub extern fn gtk_places_sidebar_set_show_trash(sidebar: ?*GtkPlacesSidebar, show_trash: gboolean) void;
pub extern fn gtk_places_sidebar_set_show_other_locations(sidebar: ?*GtkPlacesSidebar, show_other_locations: gboolean) void;
pub extern fn gtk_places_sidebar_get_show_other_locations(sidebar: ?*GtkPlacesSidebar) gboolean;
pub extern fn gtk_places_sidebar_set_show_starred_location(sidebar: ?*GtkPlacesSidebar, show_starred_location: gboolean) void;
pub extern fn gtk_places_sidebar_get_show_starred_location(sidebar: ?*GtkPlacesSidebar) gboolean;
pub const struct__GtkPopoverMenu = @OpaqueType();
pub const GtkPopoverMenu = struct__GtkPopoverMenu;
pub const struct__GtkPopoverMenuClass = extern struct {
    parent_class: GtkPopoverClass,
    reserved: [10]gpointer,
};
pub const GtkPopoverMenuClass = struct__GtkPopoverMenuClass;
pub extern fn gtk_popover_menu_get_type() GType;
pub extern fn gtk_popover_menu_new() [*c]GtkWidget;
pub extern fn gtk_popover_menu_open_submenu(popover: ?*GtkPopoverMenu, name: [*c]const gchar) void;
pub const struct__GtkPrintContext = @OpaqueType();
pub const GtkPrintContext = struct__GtkPrintContext;
pub extern fn gtk_print_context_get_type() GType;
pub extern fn gtk_print_context_get_cairo_context(context: ?*GtkPrintContext) ?*cairo_t;
pub extern fn gtk_print_context_get_page_setup(context: ?*GtkPrintContext) ?*GtkPageSetup;
pub extern fn gtk_print_context_get_width(context: ?*GtkPrintContext) gdouble;
pub extern fn gtk_print_context_get_height(context: ?*GtkPrintContext) gdouble;
pub extern fn gtk_print_context_get_dpi_x(context: ?*GtkPrintContext) gdouble;
pub extern fn gtk_print_context_get_dpi_y(context: ?*GtkPrintContext) gdouble;
pub extern fn gtk_print_context_get_hard_margins(context: ?*GtkPrintContext, top: [*c]gdouble, bottom: [*c]gdouble, left: [*c]gdouble, right: [*c]gdouble) gboolean;
pub extern fn gtk_print_context_get_pango_fontmap(context: ?*GtkPrintContext) ?*PangoFontMap;
pub extern fn gtk_print_context_create_pango_context(context: ?*GtkPrintContext) ?*PangoContext;
pub extern fn gtk_print_context_create_pango_layout(context: ?*GtkPrintContext) ?*PangoLayout;
pub extern fn gtk_print_context_set_cairo_context(context: ?*GtkPrintContext, cr: ?*cairo_t, dpi_x: f64, dpi_y: f64) void;
pub const struct__GtkPrintSettings = @OpaqueType();
pub const GtkPrintSettings = struct__GtkPrintSettings;
pub const GtkPrintSettingsFunc = ?extern fn ([*c]const gchar, [*c]const gchar, gpointer) void;
pub const struct__GtkPageRange = extern struct {
    start: gint,
    end: gint,
};
pub const GtkPageRange = struct__GtkPageRange;
pub extern fn gtk_print_settings_get_type() GType;
pub extern fn gtk_print_settings_new() ?*GtkPrintSettings;
pub extern fn gtk_print_settings_copy(other: ?*GtkPrintSettings) ?*GtkPrintSettings;
pub extern fn gtk_print_settings_new_from_file(file_name: [*c]const gchar, @"error": [*c]([*c]GError)) ?*GtkPrintSettings;
pub extern fn gtk_print_settings_load_file(settings: ?*GtkPrintSettings, file_name: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_print_settings_to_file(settings: ?*GtkPrintSettings, file_name: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_print_settings_new_from_key_file(key_file: ?*GKeyFile, group_name: [*c]const gchar, @"error": [*c]([*c]GError)) ?*GtkPrintSettings;
pub extern fn gtk_print_settings_load_key_file(settings: ?*GtkPrintSettings, key_file: ?*GKeyFile, group_name: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_print_settings_to_key_file(settings: ?*GtkPrintSettings, key_file: ?*GKeyFile, group_name: [*c]const gchar) void;
pub extern fn gtk_print_settings_has_key(settings: ?*GtkPrintSettings, key: [*c]const gchar) gboolean;
pub extern fn gtk_print_settings_get(settings: ?*GtkPrintSettings, key: [*c]const gchar) [*c]const gchar;
pub extern fn gtk_print_settings_set(settings: ?*GtkPrintSettings, key: [*c]const gchar, value: [*c]const gchar) void;
pub extern fn gtk_print_settings_unset(settings: ?*GtkPrintSettings, key: [*c]const gchar) void;
pub extern fn gtk_print_settings_foreach(settings: ?*GtkPrintSettings, func: GtkPrintSettingsFunc, user_data: gpointer) void;
pub extern fn gtk_print_settings_get_bool(settings: ?*GtkPrintSettings, key: [*c]const gchar) gboolean;
pub extern fn gtk_print_settings_set_bool(settings: ?*GtkPrintSettings, key: [*c]const gchar, value: gboolean) void;
pub extern fn gtk_print_settings_get_double(settings: ?*GtkPrintSettings, key: [*c]const gchar) gdouble;
pub extern fn gtk_print_settings_get_double_with_default(settings: ?*GtkPrintSettings, key: [*c]const gchar, def: gdouble) gdouble;
pub extern fn gtk_print_settings_set_double(settings: ?*GtkPrintSettings, key: [*c]const gchar, value: gdouble) void;
pub extern fn gtk_print_settings_get_length(settings: ?*GtkPrintSettings, key: [*c]const gchar, unit: GtkUnit) gdouble;
pub extern fn gtk_print_settings_set_length(settings: ?*GtkPrintSettings, key: [*c]const gchar, value: gdouble, unit: GtkUnit) void;
pub extern fn gtk_print_settings_get_int(settings: ?*GtkPrintSettings, key: [*c]const gchar) gint;
pub extern fn gtk_print_settings_get_int_with_default(settings: ?*GtkPrintSettings, key: [*c]const gchar, def: gint) gint;
pub extern fn gtk_print_settings_set_int(settings: ?*GtkPrintSettings, key: [*c]const gchar, value: gint) void;
pub extern fn gtk_print_settings_get_printer(settings: ?*GtkPrintSettings) [*c]const gchar;
pub extern fn gtk_print_settings_set_printer(settings: ?*GtkPrintSettings, printer: [*c]const gchar) void;
pub extern fn gtk_print_settings_get_orientation(settings: ?*GtkPrintSettings) GtkPageOrientation;
pub extern fn gtk_print_settings_set_orientation(settings: ?*GtkPrintSettings, orientation: GtkPageOrientation) void;
pub extern fn gtk_print_settings_get_paper_size(settings: ?*GtkPrintSettings) ?*GtkPaperSize;
pub extern fn gtk_print_settings_set_paper_size(settings: ?*GtkPrintSettings, paper_size: ?*GtkPaperSize) void;
pub extern fn gtk_print_settings_get_paper_width(settings: ?*GtkPrintSettings, unit: GtkUnit) gdouble;
pub extern fn gtk_print_settings_set_paper_width(settings: ?*GtkPrintSettings, width: gdouble, unit: GtkUnit) void;
pub extern fn gtk_print_settings_get_paper_height(settings: ?*GtkPrintSettings, unit: GtkUnit) gdouble;
pub extern fn gtk_print_settings_set_paper_height(settings: ?*GtkPrintSettings, height: gdouble, unit: GtkUnit) void;
pub extern fn gtk_print_settings_get_use_color(settings: ?*GtkPrintSettings) gboolean;
pub extern fn gtk_print_settings_set_use_color(settings: ?*GtkPrintSettings, use_color: gboolean) void;
pub extern fn gtk_print_settings_get_collate(settings: ?*GtkPrintSettings) gboolean;
pub extern fn gtk_print_settings_set_collate(settings: ?*GtkPrintSettings, collate: gboolean) void;
pub extern fn gtk_print_settings_get_reverse(settings: ?*GtkPrintSettings) gboolean;
pub extern fn gtk_print_settings_set_reverse(settings: ?*GtkPrintSettings, reverse: gboolean) void;
pub extern fn gtk_print_settings_get_duplex(settings: ?*GtkPrintSettings) GtkPrintDuplex;
pub extern fn gtk_print_settings_set_duplex(settings: ?*GtkPrintSettings, duplex: GtkPrintDuplex) void;
pub extern fn gtk_print_settings_get_quality(settings: ?*GtkPrintSettings) GtkPrintQuality;
pub extern fn gtk_print_settings_set_quality(settings: ?*GtkPrintSettings, quality: GtkPrintQuality) void;
pub extern fn gtk_print_settings_get_n_copies(settings: ?*GtkPrintSettings) gint;
pub extern fn gtk_print_settings_set_n_copies(settings: ?*GtkPrintSettings, num_copies: gint) void;
pub extern fn gtk_print_settings_get_number_up(settings: ?*GtkPrintSettings) gint;
pub extern fn gtk_print_settings_set_number_up(settings: ?*GtkPrintSettings, number_up: gint) void;
pub extern fn gtk_print_settings_get_number_up_layout(settings: ?*GtkPrintSettings) GtkNumberUpLayout;
pub extern fn gtk_print_settings_set_number_up_layout(settings: ?*GtkPrintSettings, number_up_layout: GtkNumberUpLayout) void;
pub extern fn gtk_print_settings_get_resolution(settings: ?*GtkPrintSettings) gint;
pub extern fn gtk_print_settings_set_resolution(settings: ?*GtkPrintSettings, resolution: gint) void;
pub extern fn gtk_print_settings_get_resolution_x(settings: ?*GtkPrintSettings) gint;
pub extern fn gtk_print_settings_get_resolution_y(settings: ?*GtkPrintSettings) gint;
pub extern fn gtk_print_settings_set_resolution_xy(settings: ?*GtkPrintSettings, resolution_x: gint, resolution_y: gint) void;
pub extern fn gtk_print_settings_get_printer_lpi(settings: ?*GtkPrintSettings) gdouble;
pub extern fn gtk_print_settings_set_printer_lpi(settings: ?*GtkPrintSettings, lpi: gdouble) void;
pub extern fn gtk_print_settings_get_scale(settings: ?*GtkPrintSettings) gdouble;
pub extern fn gtk_print_settings_set_scale(settings: ?*GtkPrintSettings, scale: gdouble) void;
pub extern fn gtk_print_settings_get_print_pages(settings: ?*GtkPrintSettings) GtkPrintPages;
pub extern fn gtk_print_settings_set_print_pages(settings: ?*GtkPrintSettings, pages: GtkPrintPages) void;
pub extern fn gtk_print_settings_get_page_ranges(settings: ?*GtkPrintSettings, num_ranges: [*c]gint) [*c]GtkPageRange;
pub extern fn gtk_print_settings_set_page_ranges(settings: ?*GtkPrintSettings, page_ranges: [*c]GtkPageRange, num_ranges: gint) void;
pub extern fn gtk_print_settings_get_page_set(settings: ?*GtkPrintSettings) GtkPageSet;
pub extern fn gtk_print_settings_set_page_set(settings: ?*GtkPrintSettings, page_set: GtkPageSet) void;
pub extern fn gtk_print_settings_get_default_source(settings: ?*GtkPrintSettings) [*c]const gchar;
pub extern fn gtk_print_settings_set_default_source(settings: ?*GtkPrintSettings, default_source: [*c]const gchar) void;
pub extern fn gtk_print_settings_get_media_type(settings: ?*GtkPrintSettings) [*c]const gchar;
pub extern fn gtk_print_settings_set_media_type(settings: ?*GtkPrintSettings, media_type: [*c]const gchar) void;
pub extern fn gtk_print_settings_get_dither(settings: ?*GtkPrintSettings) [*c]const gchar;
pub extern fn gtk_print_settings_set_dither(settings: ?*GtkPrintSettings, dither: [*c]const gchar) void;
pub extern fn gtk_print_settings_get_finishings(settings: ?*GtkPrintSettings) [*c]const gchar;
pub extern fn gtk_print_settings_set_finishings(settings: ?*GtkPrintSettings, finishings: [*c]const gchar) void;
pub extern fn gtk_print_settings_get_output_bin(settings: ?*GtkPrintSettings) [*c]const gchar;
pub extern fn gtk_print_settings_set_output_bin(settings: ?*GtkPrintSettings, output_bin: [*c]const gchar) void;
pub extern fn gtk_print_settings_to_gvariant(settings: ?*GtkPrintSettings) ?*GVariant;
pub extern fn gtk_print_settings_new_from_gvariant(variant: ?*GVariant) ?*GtkPrintSettings;
pub const struct__GtkPrintOperationPreview = @OpaqueType();
pub const GtkPrintOperationPreview = struct__GtkPrintOperationPreview;
pub const struct__GtkPrintOperationPreviewIface = extern struct {
    g_iface: GTypeInterface,
    ready: ?extern fn (?*GtkPrintOperationPreview, ?*GtkPrintContext) void,
    got_page_size: ?extern fn (?*GtkPrintOperationPreview, ?*GtkPrintContext, ?*GtkPageSetup) void,
    render_page: ?extern fn (?*GtkPrintOperationPreview, gint) void,
    is_selected: ?extern fn (?*GtkPrintOperationPreview, gint) gboolean,
    end_preview: ?extern fn (?*GtkPrintOperationPreview) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
    _gtk_reserved8: ?extern fn () void,
};
pub const GtkPrintOperationPreviewIface = struct__GtkPrintOperationPreviewIface;
pub extern fn gtk_print_operation_preview_get_type() GType;
pub extern fn gtk_print_operation_preview_render_page(preview: ?*GtkPrintOperationPreview, page_nr: gint) void;
pub extern fn gtk_print_operation_preview_end_preview(preview: ?*GtkPrintOperationPreview) void;
pub extern fn gtk_print_operation_preview_is_selected(preview: ?*GtkPrintOperationPreview, page_nr: gint) gboolean;
pub const struct__GtkPrintOperationPrivate = @OpaqueType();
pub const GtkPrintOperationPrivate = struct__GtkPrintOperationPrivate;
pub const struct__GtkPrintOperation = extern struct {
    parent_instance: GObject,
    priv: ?*GtkPrintOperationPrivate,
};
pub const GtkPrintOperation = struct__GtkPrintOperation;
pub const GTK_PRINT_OPERATION_RESULT_ERROR = 0;
pub const GTK_PRINT_OPERATION_RESULT_APPLY = 1;
pub const GTK_PRINT_OPERATION_RESULT_CANCEL = 2;
pub const GTK_PRINT_OPERATION_RESULT_IN_PROGRESS = 3;
pub const GtkPrintOperationResult = extern enum {
    GTK_PRINT_OPERATION_RESULT_ERROR = 0,
    GTK_PRINT_OPERATION_RESULT_APPLY = 1,
    GTK_PRINT_OPERATION_RESULT_CANCEL = 2,
    GTK_PRINT_OPERATION_RESULT_IN_PROGRESS = 3,
};
pub const struct__GtkPrintOperationClass = extern struct {
    parent_class: GObjectClass,
    done: ?extern fn ([*c]GtkPrintOperation, GtkPrintOperationResult) void,
    begin_print: ?extern fn ([*c]GtkPrintOperation, ?*GtkPrintContext) void,
    paginate: ?extern fn ([*c]GtkPrintOperation, ?*GtkPrintContext) gboolean,
    request_page_setup: ?extern fn ([*c]GtkPrintOperation, ?*GtkPrintContext, gint, ?*GtkPageSetup) void,
    draw_page: ?extern fn ([*c]GtkPrintOperation, ?*GtkPrintContext, gint) void,
    end_print: ?extern fn ([*c]GtkPrintOperation, ?*GtkPrintContext) void,
    status_changed: ?extern fn ([*c]GtkPrintOperation) void,
    create_custom_widget: ?extern fn ([*c]GtkPrintOperation) [*c]GtkWidget,
    custom_widget_apply: ?extern fn ([*c]GtkPrintOperation, [*c]GtkWidget) void,
    preview: ?extern fn ([*c]GtkPrintOperation, ?*GtkPrintOperationPreview, ?*GtkPrintContext, [*c]GtkWindow) gboolean,
    update_custom_widget: ?extern fn ([*c]GtkPrintOperation, [*c]GtkWidget, ?*GtkPageSetup, ?*GtkPrintSettings) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
    _gtk_reserved8: ?extern fn () void,
};
pub const GtkPrintOperationClass = struct__GtkPrintOperationClass;
pub const GTK_PRINT_STATUS_INITIAL = 0;
pub const GTK_PRINT_STATUS_PREPARING = 1;
pub const GTK_PRINT_STATUS_GENERATING_DATA = 2;
pub const GTK_PRINT_STATUS_SENDING_DATA = 3;
pub const GTK_PRINT_STATUS_PENDING = 4;
pub const GTK_PRINT_STATUS_PENDING_ISSUE = 5;
pub const GTK_PRINT_STATUS_PRINTING = 6;
pub const GTK_PRINT_STATUS_FINISHED = 7;
pub const GTK_PRINT_STATUS_FINISHED_ABORTED = 8;
pub const GtkPrintStatus = extern enum {
    GTK_PRINT_STATUS_INITIAL = 0,
    GTK_PRINT_STATUS_PREPARING = 1,
    GTK_PRINT_STATUS_GENERATING_DATA = 2,
    GTK_PRINT_STATUS_SENDING_DATA = 3,
    GTK_PRINT_STATUS_PENDING = 4,
    GTK_PRINT_STATUS_PENDING_ISSUE = 5,
    GTK_PRINT_STATUS_PRINTING = 6,
    GTK_PRINT_STATUS_FINISHED = 7,
    GTK_PRINT_STATUS_FINISHED_ABORTED = 8,
};
pub const GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG = 0;
pub const GTK_PRINT_OPERATION_ACTION_PRINT = 1;
pub const GTK_PRINT_OPERATION_ACTION_PREVIEW = 2;
pub const GTK_PRINT_OPERATION_ACTION_EXPORT = 3;
pub const GtkPrintOperationAction = extern enum {
    GTK_PRINT_OPERATION_ACTION_PRINT_DIALOG = 0,
    GTK_PRINT_OPERATION_ACTION_PRINT = 1,
    GTK_PRINT_OPERATION_ACTION_PREVIEW = 2,
    GTK_PRINT_OPERATION_ACTION_EXPORT = 3,
};
pub const GTK_PRINT_ERROR_GENERAL = 0;
pub const GTK_PRINT_ERROR_INTERNAL_ERROR = 1;
pub const GTK_PRINT_ERROR_NOMEM = 2;
pub const GTK_PRINT_ERROR_INVALID_FILE = 3;
pub const GtkPrintError = extern enum {
    GTK_PRINT_ERROR_GENERAL = 0,
    GTK_PRINT_ERROR_INTERNAL_ERROR = 1,
    GTK_PRINT_ERROR_NOMEM = 2,
    GTK_PRINT_ERROR_INVALID_FILE = 3,
};
pub extern fn gtk_print_error_quark() GQuark;
pub extern fn gtk_print_operation_get_type() GType;
pub extern fn gtk_print_operation_new() [*c]GtkPrintOperation;
pub extern fn gtk_print_operation_set_default_page_setup(op: [*c]GtkPrintOperation, default_page_setup: ?*GtkPageSetup) void;
pub extern fn gtk_print_operation_get_default_page_setup(op: [*c]GtkPrintOperation) ?*GtkPageSetup;
pub extern fn gtk_print_operation_set_print_settings(op: [*c]GtkPrintOperation, print_settings: ?*GtkPrintSettings) void;
pub extern fn gtk_print_operation_get_print_settings(op: [*c]GtkPrintOperation) ?*GtkPrintSettings;
pub extern fn gtk_print_operation_set_job_name(op: [*c]GtkPrintOperation, job_name: [*c]const gchar) void;
pub extern fn gtk_print_operation_set_n_pages(op: [*c]GtkPrintOperation, n_pages: gint) void;
pub extern fn gtk_print_operation_set_current_page(op: [*c]GtkPrintOperation, current_page: gint) void;
pub extern fn gtk_print_operation_set_use_full_page(op: [*c]GtkPrintOperation, full_page: gboolean) void;
pub extern fn gtk_print_operation_set_unit(op: [*c]GtkPrintOperation, unit: GtkUnit) void;
pub extern fn gtk_print_operation_set_export_filename(op: [*c]GtkPrintOperation, filename: [*c]const gchar) void;
pub extern fn gtk_print_operation_set_track_print_status(op: [*c]GtkPrintOperation, track_status: gboolean) void;
pub extern fn gtk_print_operation_set_show_progress(op: [*c]GtkPrintOperation, show_progress: gboolean) void;
pub extern fn gtk_print_operation_set_allow_async(op: [*c]GtkPrintOperation, allow_async: gboolean) void;
pub extern fn gtk_print_operation_set_custom_tab_label(op: [*c]GtkPrintOperation, label: [*c]const gchar) void;
pub extern fn gtk_print_operation_run(op: [*c]GtkPrintOperation, action: GtkPrintOperationAction, parent: [*c]GtkWindow, @"error": [*c]([*c]GError)) GtkPrintOperationResult;
pub extern fn gtk_print_operation_get_error(op: [*c]GtkPrintOperation, @"error": [*c]([*c]GError)) void;
pub extern fn gtk_print_operation_get_status(op: [*c]GtkPrintOperation) GtkPrintStatus;
pub extern fn gtk_print_operation_get_status_string(op: [*c]GtkPrintOperation) [*c]const gchar;
pub extern fn gtk_print_operation_is_finished(op: [*c]GtkPrintOperation) gboolean;
pub extern fn gtk_print_operation_cancel(op: [*c]GtkPrintOperation) void;
pub extern fn gtk_print_operation_draw_page_finish(op: [*c]GtkPrintOperation) void;
pub extern fn gtk_print_operation_set_defer_drawing(op: [*c]GtkPrintOperation) void;
pub extern fn gtk_print_operation_set_support_selection(op: [*c]GtkPrintOperation, support_selection: gboolean) void;
pub extern fn gtk_print_operation_get_support_selection(op: [*c]GtkPrintOperation) gboolean;
pub extern fn gtk_print_operation_set_has_selection(op: [*c]GtkPrintOperation, has_selection: gboolean) void;
pub extern fn gtk_print_operation_get_has_selection(op: [*c]GtkPrintOperation) gboolean;
pub extern fn gtk_print_operation_set_embed_page_setup(op: [*c]GtkPrintOperation, embed: gboolean) void;
pub extern fn gtk_print_operation_get_embed_page_setup(op: [*c]GtkPrintOperation) gboolean;
pub extern fn gtk_print_operation_get_n_pages_to_print(op: [*c]GtkPrintOperation) gint;
pub extern fn gtk_print_run_page_setup_dialog(parent: [*c]GtkWindow, page_setup: ?*GtkPageSetup, settings: ?*GtkPrintSettings) ?*GtkPageSetup;
pub const GtkPageSetupDoneFunc = ?extern fn (?*GtkPageSetup, gpointer) void;
pub extern fn gtk_print_run_page_setup_dialog_async(parent: [*c]GtkWindow, page_setup: ?*GtkPageSetup, settings: ?*GtkPrintSettings, done_cb: GtkPageSetupDoneFunc, data: gpointer) void;
pub const struct__GtkProgressBarPrivate = @OpaqueType();
pub const GtkProgressBarPrivate = struct__GtkProgressBarPrivate;
pub const struct__GtkProgressBar = extern struct {
    parent: GtkWidget,
    priv: ?*GtkProgressBarPrivate,
};
pub const GtkProgressBar = struct__GtkProgressBar;
pub const struct__GtkProgressBarClass = extern struct {
    parent_class: GtkWidgetClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkProgressBarClass = struct__GtkProgressBarClass;
pub extern fn gtk_progress_bar_get_type() GType;
pub extern fn gtk_progress_bar_new() [*c]GtkWidget;
pub extern fn gtk_progress_bar_pulse(pbar: [*c]GtkProgressBar) void;
pub extern fn gtk_progress_bar_set_text(pbar: [*c]GtkProgressBar, text: [*c]const gchar) void;
pub extern fn gtk_progress_bar_set_fraction(pbar: [*c]GtkProgressBar, fraction: gdouble) void;
pub extern fn gtk_progress_bar_set_pulse_step(pbar: [*c]GtkProgressBar, fraction: gdouble) void;
pub extern fn gtk_progress_bar_set_inverted(pbar: [*c]GtkProgressBar, inverted: gboolean) void;
pub extern fn gtk_progress_bar_get_text(pbar: [*c]GtkProgressBar) [*c]const gchar;
pub extern fn gtk_progress_bar_get_fraction(pbar: [*c]GtkProgressBar) gdouble;
pub extern fn gtk_progress_bar_get_pulse_step(pbar: [*c]GtkProgressBar) gdouble;
pub extern fn gtk_progress_bar_get_inverted(pbar: [*c]GtkProgressBar) gboolean;
pub extern fn gtk_progress_bar_set_ellipsize(pbar: [*c]GtkProgressBar, mode: PangoEllipsizeMode) void;
pub extern fn gtk_progress_bar_get_ellipsize(pbar: [*c]GtkProgressBar) PangoEllipsizeMode;
pub extern fn gtk_progress_bar_set_show_text(pbar: [*c]GtkProgressBar, show_text: gboolean) void;
pub extern fn gtk_progress_bar_get_show_text(pbar: [*c]GtkProgressBar) gboolean;
pub const struct__GtkRadioButtonPrivate = @OpaqueType();
pub const GtkRadioButtonPrivate = struct__GtkRadioButtonPrivate;
pub const struct__GtkRadioButton = extern struct {
    check_button: GtkCheckButton,
    priv: ?*GtkRadioButtonPrivate,
};
pub const GtkRadioButton = struct__GtkRadioButton;
pub const struct__GtkRadioButtonClass = extern struct {
    parent_class: GtkCheckButtonClass,
    group_changed: ?extern fn ([*c]GtkRadioButton) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkRadioButtonClass = struct__GtkRadioButtonClass;
pub extern fn gtk_radio_button_get_type() GType;
pub extern fn gtk_radio_button_new(group: [*c]GSList) [*c]GtkWidget;
pub extern fn gtk_radio_button_new_from_widget(radio_group_member: [*c]GtkRadioButton) [*c]GtkWidget;
pub extern fn gtk_radio_button_new_with_label(group: [*c]GSList, label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_radio_button_new_with_label_from_widget(radio_group_member: [*c]GtkRadioButton, label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_radio_button_new_with_mnemonic(group: [*c]GSList, label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_radio_button_new_with_mnemonic_from_widget(radio_group_member: [*c]GtkRadioButton, label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_radio_button_get_group(radio_button: [*c]GtkRadioButton) [*c]GSList;
pub extern fn gtk_radio_button_set_group(radio_button: [*c]GtkRadioButton, group: [*c]GSList) void;
pub extern fn gtk_radio_button_join_group(radio_button: [*c]GtkRadioButton, group_source: [*c]GtkRadioButton) void;
pub const struct__GtkRadioMenuItemPrivate = @OpaqueType();
pub const GtkRadioMenuItemPrivate = struct__GtkRadioMenuItemPrivate;
pub const struct__GtkRadioMenuItem = extern struct {
    check_menu_item: GtkCheckMenuItem,
    priv: ?*GtkRadioMenuItemPrivate,
};
pub const GtkRadioMenuItem = struct__GtkRadioMenuItem;
pub const struct__GtkRadioMenuItemClass = extern struct {
    parent_class: GtkCheckMenuItemClass,
    group_changed: ?extern fn ([*c]GtkRadioMenuItem) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkRadioMenuItemClass = struct__GtkRadioMenuItemClass;
pub extern fn gtk_radio_menu_item_get_type() GType;
pub extern fn gtk_radio_menu_item_new(group: [*c]GSList) [*c]GtkWidget;
pub extern fn gtk_radio_menu_item_new_with_label(group: [*c]GSList, label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_radio_menu_item_new_with_mnemonic(group: [*c]GSList, label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_radio_menu_item_new_from_widget(group: [*c]GtkRadioMenuItem) [*c]GtkWidget;
pub extern fn gtk_radio_menu_item_new_with_mnemonic_from_widget(group: [*c]GtkRadioMenuItem, label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_radio_menu_item_new_with_label_from_widget(group: [*c]GtkRadioMenuItem, label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_radio_menu_item_get_group(radio_menu_item: [*c]GtkRadioMenuItem) [*c]GSList;
pub extern fn gtk_radio_menu_item_set_group(radio_menu_item: [*c]GtkRadioMenuItem, group: [*c]GSList) void;
pub extern fn gtk_radio_menu_item_join_group(radio_menu_item: [*c]GtkRadioMenuItem, group_source: [*c]GtkRadioMenuItem) void;
pub const struct__GtkToggleToolButtonPrivate = @OpaqueType();
pub const GtkToggleToolButtonPrivate = struct__GtkToggleToolButtonPrivate;
pub const struct__GtkToggleToolButton = extern struct {
    parent: GtkToolButton,
    priv: ?*GtkToggleToolButtonPrivate,
};
pub const GtkToggleToolButton = struct__GtkToggleToolButton;
pub const struct__GtkToggleToolButtonClass = extern struct {
    parent_class: GtkToolButtonClass,
    toggled: ?extern fn ([*c]GtkToggleToolButton) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkToggleToolButtonClass = struct__GtkToggleToolButtonClass;
pub extern fn gtk_toggle_tool_button_get_type() GType;
pub extern fn gtk_toggle_tool_button_new() [*c]GtkToolItem;
pub extern fn gtk_toggle_tool_button_new_from_stock(stock_id: [*c]const gchar) [*c]GtkToolItem;
pub extern fn gtk_toggle_tool_button_set_active(button: [*c]GtkToggleToolButton, is_active: gboolean) void;
pub extern fn gtk_toggle_tool_button_get_active(button: [*c]GtkToggleToolButton) gboolean;
pub const struct__GtkRadioToolButton = extern struct {
    parent: GtkToggleToolButton,
};
pub const GtkRadioToolButton = struct__GtkRadioToolButton;
pub const struct__GtkRadioToolButtonClass = extern struct {
    parent_class: GtkToggleToolButtonClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkRadioToolButtonClass = struct__GtkRadioToolButtonClass;
pub extern fn gtk_radio_tool_button_get_type() GType;
pub extern fn gtk_radio_tool_button_new(group: [*c]GSList) [*c]GtkToolItem;
pub extern fn gtk_radio_tool_button_new_from_stock(group: [*c]GSList, stock_id: [*c]const gchar) [*c]GtkToolItem;
pub extern fn gtk_radio_tool_button_new_from_widget(group: [*c]GtkRadioToolButton) [*c]GtkToolItem;
pub extern fn gtk_radio_tool_button_new_with_stock_from_widget(group: [*c]GtkRadioToolButton, stock_id: [*c]const gchar) [*c]GtkToolItem;
pub extern fn gtk_radio_tool_button_get_group(button: [*c]GtkRadioToolButton) [*c]GSList;
pub extern fn gtk_radio_tool_button_set_group(button: [*c]GtkRadioToolButton, group: [*c]GSList) void;
pub const struct__GtkRangePrivate = @OpaqueType();
pub const GtkRangePrivate = struct__GtkRangePrivate;
pub const struct__GtkRange = extern struct {
    widget: GtkWidget,
    priv: ?*GtkRangePrivate,
};
pub const GtkRange = struct__GtkRange;
pub const struct__GtkRangeClass = extern struct {
    parent_class: GtkWidgetClass,
    slider_detail: [*c]gchar,
    stepper_detail: [*c]gchar,
    value_changed: ?extern fn ([*c]GtkRange) void,
    adjust_bounds: ?extern fn ([*c]GtkRange, gdouble) void,
    move_slider: ?extern fn ([*c]GtkRange, GtkScrollType) void,
    get_range_border: ?extern fn ([*c]GtkRange, [*c]GtkBorder) void,
    change_value: ?extern fn ([*c]GtkRange, GtkScrollType, gdouble) gboolean,
    get_range_size_request: ?extern fn ([*c]GtkRange, GtkOrientation, [*c]gint, [*c]gint) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
};
pub const GtkRangeClass = struct__GtkRangeClass;
pub extern fn gtk_range_get_type() GType;
pub extern fn gtk_range_set_adjustment(range: [*c]GtkRange, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_range_get_adjustment(range: [*c]GtkRange) [*c]GtkAdjustment;
pub extern fn gtk_range_set_inverted(range: [*c]GtkRange, setting: gboolean) void;
pub extern fn gtk_range_get_inverted(range: [*c]GtkRange) gboolean;
pub extern fn gtk_range_set_flippable(range: [*c]GtkRange, flippable: gboolean) void;
pub extern fn gtk_range_get_flippable(range: [*c]GtkRange) gboolean;
pub extern fn gtk_range_set_slider_size_fixed(range: [*c]GtkRange, size_fixed: gboolean) void;
pub extern fn gtk_range_get_slider_size_fixed(range: [*c]GtkRange) gboolean;
pub extern fn gtk_range_set_min_slider_size(range: [*c]GtkRange, min_size: gint) void;
pub extern fn gtk_range_get_min_slider_size(range: [*c]GtkRange) gint;
pub extern fn gtk_range_get_range_rect(range: [*c]GtkRange, range_rect: [*c]GdkRectangle) void;
pub extern fn gtk_range_get_slider_range(range: [*c]GtkRange, slider_start: [*c]gint, slider_end: [*c]gint) void;
pub extern fn gtk_range_set_lower_stepper_sensitivity(range: [*c]GtkRange, sensitivity: GtkSensitivityType) void;
pub extern fn gtk_range_get_lower_stepper_sensitivity(range: [*c]GtkRange) GtkSensitivityType;
pub extern fn gtk_range_set_upper_stepper_sensitivity(range: [*c]GtkRange, sensitivity: GtkSensitivityType) void;
pub extern fn gtk_range_get_upper_stepper_sensitivity(range: [*c]GtkRange) GtkSensitivityType;
pub extern fn gtk_range_set_increments(range: [*c]GtkRange, step: gdouble, page: gdouble) void;
pub extern fn gtk_range_set_range(range: [*c]GtkRange, min: gdouble, max: gdouble) void;
pub extern fn gtk_range_set_value(range: [*c]GtkRange, value: gdouble) void;
pub extern fn gtk_range_get_value(range: [*c]GtkRange) gdouble;
pub extern fn gtk_range_set_show_fill_level(range: [*c]GtkRange, show_fill_level: gboolean) void;
pub extern fn gtk_range_get_show_fill_level(range: [*c]GtkRange) gboolean;
pub extern fn gtk_range_set_restrict_to_fill_level(range: [*c]GtkRange, restrict_to_fill_level: gboolean) void;
pub extern fn gtk_range_get_restrict_to_fill_level(range: [*c]GtkRange) gboolean;
pub extern fn gtk_range_set_fill_level(range: [*c]GtkRange, fill_level: gdouble) void;
pub extern fn gtk_range_get_fill_level(range: [*c]GtkRange) gdouble;
pub extern fn gtk_range_set_round_digits(range: [*c]GtkRange, round_digits: gint) void;
pub extern fn gtk_range_get_round_digits(range: [*c]GtkRange) gint;
pub const struct__GtkRecentInfo = @OpaqueType();
pub const GtkRecentInfo = struct__GtkRecentInfo;
pub const struct__GtkRecentData = extern struct {
    display_name: [*c]gchar,
    description: [*c]gchar,
    mime_type: [*c]gchar,
    app_name: [*c]gchar,
    app_exec: [*c]gchar,
    groups: [*c]([*c]gchar),
    is_private: gboolean,
};
pub const GtkRecentData = struct__GtkRecentData;
pub const struct__GtkRecentManagerPrivate = @OpaqueType();
pub const GtkRecentManagerPrivate = struct__GtkRecentManagerPrivate;
pub const struct__GtkRecentManager = extern struct {
    parent_instance: GObject,
    priv: ?*GtkRecentManagerPrivate,
};
pub const GtkRecentManager = struct__GtkRecentManager;
pub const struct__GtkRecentManagerClass = extern struct {
    parent_class: GObjectClass,
    changed: ?extern fn ([*c]GtkRecentManager) void,
    _gtk_recent1: ?extern fn () void,
    _gtk_recent2: ?extern fn () void,
    _gtk_recent3: ?extern fn () void,
    _gtk_recent4: ?extern fn () void,
};
pub const GtkRecentManagerClass = struct__GtkRecentManagerClass;
pub const GTK_RECENT_MANAGER_ERROR_NOT_FOUND = 0;
pub const GTK_RECENT_MANAGER_ERROR_INVALID_URI = 1;
pub const GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING = 2;
pub const GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED = 3;
pub const GTK_RECENT_MANAGER_ERROR_READ = 4;
pub const GTK_RECENT_MANAGER_ERROR_WRITE = 5;
pub const GTK_RECENT_MANAGER_ERROR_UNKNOWN = 6;
pub const GtkRecentManagerError = extern enum {
    GTK_RECENT_MANAGER_ERROR_NOT_FOUND = 0,
    GTK_RECENT_MANAGER_ERROR_INVALID_URI = 1,
    GTK_RECENT_MANAGER_ERROR_INVALID_ENCODING = 2,
    GTK_RECENT_MANAGER_ERROR_NOT_REGISTERED = 3,
    GTK_RECENT_MANAGER_ERROR_READ = 4,
    GTK_RECENT_MANAGER_ERROR_WRITE = 5,
    GTK_RECENT_MANAGER_ERROR_UNKNOWN = 6,
};
pub extern fn gtk_recent_manager_error_quark() GQuark;
pub extern fn gtk_recent_manager_get_type() GType;
pub extern fn gtk_recent_manager_new() [*c]GtkRecentManager;
pub extern fn gtk_recent_manager_get_default() [*c]GtkRecentManager;
pub extern fn gtk_recent_manager_add_item(manager: [*c]GtkRecentManager, uri: [*c]const gchar) gboolean;
pub extern fn gtk_recent_manager_add_full(manager: [*c]GtkRecentManager, uri: [*c]const gchar, recent_data: [*c]const GtkRecentData) gboolean;
pub extern fn gtk_recent_manager_remove_item(manager: [*c]GtkRecentManager, uri: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_recent_manager_lookup_item(manager: [*c]GtkRecentManager, uri: [*c]const gchar, @"error": [*c]([*c]GError)) ?*GtkRecentInfo;
pub extern fn gtk_recent_manager_has_item(manager: [*c]GtkRecentManager, uri: [*c]const gchar) gboolean;
pub extern fn gtk_recent_manager_move_item(manager: [*c]GtkRecentManager, uri: [*c]const gchar, new_uri: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_recent_manager_get_items(manager: [*c]GtkRecentManager) [*c]GList;
pub extern fn gtk_recent_manager_purge_items(manager: [*c]GtkRecentManager, @"error": [*c]([*c]GError)) gint;
pub extern fn gtk_recent_info_get_type() GType;
pub extern fn gtk_recent_info_ref(info: ?*GtkRecentInfo) ?*GtkRecentInfo;
pub extern fn gtk_recent_info_unref(info: ?*GtkRecentInfo) void;
pub extern fn gtk_recent_info_get_uri(info: ?*GtkRecentInfo) [*c]const gchar;
pub extern fn gtk_recent_info_get_display_name(info: ?*GtkRecentInfo) [*c]const gchar;
pub extern fn gtk_recent_info_get_description(info: ?*GtkRecentInfo) [*c]const gchar;
pub extern fn gtk_recent_info_get_mime_type(info: ?*GtkRecentInfo) [*c]const gchar;
pub extern fn gtk_recent_info_get_added(info: ?*GtkRecentInfo) time_t;
pub extern fn gtk_recent_info_get_modified(info: ?*GtkRecentInfo) time_t;
pub extern fn gtk_recent_info_get_visited(info: ?*GtkRecentInfo) time_t;
pub extern fn gtk_recent_info_get_private_hint(info: ?*GtkRecentInfo) gboolean;
pub extern fn gtk_recent_info_get_application_info(info: ?*GtkRecentInfo, app_name: [*c]const gchar, app_exec: [*c]([*c]const gchar), count: [*c]guint, time_: [*c]time_t) gboolean;
pub extern fn gtk_recent_info_create_app_info(info: ?*GtkRecentInfo, app_name: [*c]const gchar, @"error": [*c]([*c]GError)) ?*GAppInfo;
pub extern fn gtk_recent_info_get_applications(info: ?*GtkRecentInfo, length: [*c]gsize) [*c]([*c]gchar);
pub extern fn gtk_recent_info_last_application(info: ?*GtkRecentInfo) [*c]gchar;
pub extern fn gtk_recent_info_has_application(info: ?*GtkRecentInfo, app_name: [*c]const gchar) gboolean;
pub extern fn gtk_recent_info_get_groups(info: ?*GtkRecentInfo, length: [*c]gsize) [*c]([*c]gchar);
pub extern fn gtk_recent_info_has_group(info: ?*GtkRecentInfo, group_name: [*c]const gchar) gboolean;
pub extern fn gtk_recent_info_get_icon(info: ?*GtkRecentInfo, size: gint) ?*GdkPixbuf;
pub extern fn gtk_recent_info_get_gicon(info: ?*GtkRecentInfo) ?*GIcon;
pub extern fn gtk_recent_info_get_short_name(info: ?*GtkRecentInfo) [*c]gchar;
pub extern fn gtk_recent_info_get_uri_display(info: ?*GtkRecentInfo) [*c]gchar;
pub extern fn gtk_recent_info_get_age(info: ?*GtkRecentInfo) gint;
pub extern fn gtk_recent_info_is_local(info: ?*GtkRecentInfo) gboolean;
pub extern fn gtk_recent_info_exists(info: ?*GtkRecentInfo) gboolean;
pub extern fn gtk_recent_info_match(info_a: ?*GtkRecentInfo, info_b: ?*GtkRecentInfo) gboolean;
pub extern fn _gtk_recent_manager_sync() void;
pub const struct__GtkRecentFilter = @OpaqueType();
pub const GtkRecentFilter = struct__GtkRecentFilter;
pub const GTK_RECENT_FILTER_URI = 1;
pub const GTK_RECENT_FILTER_DISPLAY_NAME = 2;
pub const GTK_RECENT_FILTER_MIME_TYPE = 4;
pub const GTK_RECENT_FILTER_APPLICATION = 8;
pub const GTK_RECENT_FILTER_GROUP = 16;
pub const GTK_RECENT_FILTER_AGE = 32;
pub const GtkRecentFilterFlags = extern enum {
    GTK_RECENT_FILTER_URI = 1,
    GTK_RECENT_FILTER_DISPLAY_NAME = 2,
    GTK_RECENT_FILTER_MIME_TYPE = 4,
    GTK_RECENT_FILTER_APPLICATION = 8,
    GTK_RECENT_FILTER_GROUP = 16,
    GTK_RECENT_FILTER_AGE = 32,
};
pub const struct__GtkRecentFilterInfo = extern struct {
    contains: GtkRecentFilterFlags,
    uri: [*c]const gchar,
    display_name: [*c]const gchar,
    mime_type: [*c]const gchar,
    applications: [*c]([*c]const gchar),
    groups: [*c]([*c]const gchar),
    age: gint,
};
pub const GtkRecentFilterInfo = struct__GtkRecentFilterInfo;
pub const GtkRecentFilterFunc = ?extern fn ([*c]const GtkRecentFilterInfo, gpointer) gboolean;
pub extern fn gtk_recent_filter_get_type() GType;
pub extern fn gtk_recent_filter_new() ?*GtkRecentFilter;
pub extern fn gtk_recent_filter_set_name(filter: ?*GtkRecentFilter, name: [*c]const gchar) void;
pub extern fn gtk_recent_filter_get_name(filter: ?*GtkRecentFilter) [*c]const gchar;
pub extern fn gtk_recent_filter_add_mime_type(filter: ?*GtkRecentFilter, mime_type: [*c]const gchar) void;
pub extern fn gtk_recent_filter_add_pattern(filter: ?*GtkRecentFilter, pattern: [*c]const gchar) void;
pub extern fn gtk_recent_filter_add_pixbuf_formats(filter: ?*GtkRecentFilter) void;
pub extern fn gtk_recent_filter_add_application(filter: ?*GtkRecentFilter, application: [*c]const gchar) void;
pub extern fn gtk_recent_filter_add_group(filter: ?*GtkRecentFilter, group: [*c]const gchar) void;
pub extern fn gtk_recent_filter_add_age(filter: ?*GtkRecentFilter, days: gint) void;
pub extern fn gtk_recent_filter_add_custom(filter: ?*GtkRecentFilter, needed: GtkRecentFilterFlags, func: GtkRecentFilterFunc, data: gpointer, data_destroy: GDestroyNotify) void;
pub extern fn gtk_recent_filter_get_needed(filter: ?*GtkRecentFilter) GtkRecentFilterFlags;
pub extern fn gtk_recent_filter_filter(filter: ?*GtkRecentFilter, filter_info: [*c]const GtkRecentFilterInfo) gboolean;
pub const GTK_RECENT_SORT_NONE = 0;
pub const GTK_RECENT_SORT_MRU = 1;
pub const GTK_RECENT_SORT_LRU = 2;
pub const GTK_RECENT_SORT_CUSTOM = 3;
pub const GtkRecentSortType = extern enum {
    GTK_RECENT_SORT_NONE = 0,
    GTK_RECENT_SORT_MRU = 1,
    GTK_RECENT_SORT_LRU = 2,
    GTK_RECENT_SORT_CUSTOM = 3,
};
pub const GtkRecentSortFunc = ?extern fn (?*GtkRecentInfo, ?*GtkRecentInfo, gpointer) gint;
pub const struct__GtkRecentChooser = @OpaqueType();
pub const GtkRecentChooser = struct__GtkRecentChooser;
pub const struct__GtkRecentChooserIface = extern struct {
    base_iface: GTypeInterface,
    set_current_uri: ?extern fn (?*GtkRecentChooser, [*c]const gchar, [*c]([*c]GError)) gboolean,
    get_current_uri: ?extern fn (?*GtkRecentChooser) [*c]gchar,
    select_uri: ?extern fn (?*GtkRecentChooser, [*c]const gchar, [*c]([*c]GError)) gboolean,
    unselect_uri: ?extern fn (?*GtkRecentChooser, [*c]const gchar) void,
    select_all: ?extern fn (?*GtkRecentChooser) void,
    unselect_all: ?extern fn (?*GtkRecentChooser) void,
    get_items: ?extern fn (?*GtkRecentChooser) [*c]GList,
    get_recent_manager: ?extern fn (?*GtkRecentChooser) [*c]GtkRecentManager,
    add_filter: ?extern fn (?*GtkRecentChooser, ?*GtkRecentFilter) void,
    remove_filter: ?extern fn (?*GtkRecentChooser, ?*GtkRecentFilter) void,
    list_filters: ?extern fn (?*GtkRecentChooser) [*c]GSList,
    set_sort_func: ?extern fn (?*GtkRecentChooser, GtkRecentSortFunc, gpointer, GDestroyNotify) void,
    item_activated: ?extern fn (?*GtkRecentChooser) void,
    selection_changed: ?extern fn (?*GtkRecentChooser) void,
};
pub const GtkRecentChooserIface = struct__GtkRecentChooserIface;
pub const GTK_RECENT_CHOOSER_ERROR_NOT_FOUND = 0;
pub const GTK_RECENT_CHOOSER_ERROR_INVALID_URI = 1;
pub const GtkRecentChooserError = extern enum {
    GTK_RECENT_CHOOSER_ERROR_NOT_FOUND = 0,
    GTK_RECENT_CHOOSER_ERROR_INVALID_URI = 1,
};
pub extern fn gtk_recent_chooser_error_quark() GQuark;
pub extern fn gtk_recent_chooser_get_type() GType;
pub extern fn gtk_recent_chooser_set_show_private(chooser: ?*GtkRecentChooser, show_private: gboolean) void;
pub extern fn gtk_recent_chooser_get_show_private(chooser: ?*GtkRecentChooser) gboolean;
pub extern fn gtk_recent_chooser_set_show_not_found(chooser: ?*GtkRecentChooser, show_not_found: gboolean) void;
pub extern fn gtk_recent_chooser_get_show_not_found(chooser: ?*GtkRecentChooser) gboolean;
pub extern fn gtk_recent_chooser_set_select_multiple(chooser: ?*GtkRecentChooser, select_multiple: gboolean) void;
pub extern fn gtk_recent_chooser_get_select_multiple(chooser: ?*GtkRecentChooser) gboolean;
pub extern fn gtk_recent_chooser_set_limit(chooser: ?*GtkRecentChooser, limit: gint) void;
pub extern fn gtk_recent_chooser_get_limit(chooser: ?*GtkRecentChooser) gint;
pub extern fn gtk_recent_chooser_set_local_only(chooser: ?*GtkRecentChooser, local_only: gboolean) void;
pub extern fn gtk_recent_chooser_get_local_only(chooser: ?*GtkRecentChooser) gboolean;
pub extern fn gtk_recent_chooser_set_show_tips(chooser: ?*GtkRecentChooser, show_tips: gboolean) void;
pub extern fn gtk_recent_chooser_get_show_tips(chooser: ?*GtkRecentChooser) gboolean;
pub extern fn gtk_recent_chooser_set_show_icons(chooser: ?*GtkRecentChooser, show_icons: gboolean) void;
pub extern fn gtk_recent_chooser_get_show_icons(chooser: ?*GtkRecentChooser) gboolean;
pub extern fn gtk_recent_chooser_set_sort_type(chooser: ?*GtkRecentChooser, sort_type: GtkRecentSortType) void;
pub extern fn gtk_recent_chooser_get_sort_type(chooser: ?*GtkRecentChooser) GtkRecentSortType;
pub extern fn gtk_recent_chooser_set_sort_func(chooser: ?*GtkRecentChooser, sort_func: GtkRecentSortFunc, sort_data: gpointer, data_destroy: GDestroyNotify) void;
pub extern fn gtk_recent_chooser_set_current_uri(chooser: ?*GtkRecentChooser, uri: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_recent_chooser_get_current_uri(chooser: ?*GtkRecentChooser) [*c]gchar;
pub extern fn gtk_recent_chooser_get_current_item(chooser: ?*GtkRecentChooser) ?*GtkRecentInfo;
pub extern fn gtk_recent_chooser_select_uri(chooser: ?*GtkRecentChooser, uri: [*c]const gchar, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_recent_chooser_unselect_uri(chooser: ?*GtkRecentChooser, uri: [*c]const gchar) void;
pub extern fn gtk_recent_chooser_select_all(chooser: ?*GtkRecentChooser) void;
pub extern fn gtk_recent_chooser_unselect_all(chooser: ?*GtkRecentChooser) void;
pub extern fn gtk_recent_chooser_get_items(chooser: ?*GtkRecentChooser) [*c]GList;
pub extern fn gtk_recent_chooser_get_uris(chooser: ?*GtkRecentChooser, length: [*c]gsize) [*c]([*c]gchar);
pub extern fn gtk_recent_chooser_add_filter(chooser: ?*GtkRecentChooser, filter: ?*GtkRecentFilter) void;
pub extern fn gtk_recent_chooser_remove_filter(chooser: ?*GtkRecentChooser, filter: ?*GtkRecentFilter) void;
pub extern fn gtk_recent_chooser_list_filters(chooser: ?*GtkRecentChooser) [*c]GSList;
pub extern fn gtk_recent_chooser_set_filter(chooser: ?*GtkRecentChooser, filter: ?*GtkRecentFilter) void;
pub extern fn gtk_recent_chooser_get_filter(chooser: ?*GtkRecentChooser) ?*GtkRecentFilter;
pub const struct__GtkRecentChooserDialogPrivate = @OpaqueType();
pub const GtkRecentChooserDialogPrivate = struct__GtkRecentChooserDialogPrivate;
pub const struct__GtkRecentChooserDialog = extern struct {
    parent_instance: GtkDialog,
    priv: ?*GtkRecentChooserDialogPrivate,
};
pub const GtkRecentChooserDialog = struct__GtkRecentChooserDialog;
pub const struct__GtkRecentChooserDialogClass = extern struct {
    parent_class: GtkDialogClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkRecentChooserDialogClass = struct__GtkRecentChooserDialogClass;
pub extern fn gtk_recent_chooser_dialog_get_type() GType;
pub extern fn gtk_recent_chooser_dialog_new(title: [*c]const gchar, parent: [*c]GtkWindow, first_button_text: [*c]const gchar, ...) [*c]GtkWidget;
pub extern fn gtk_recent_chooser_dialog_new_for_manager(title: [*c]const gchar, parent: [*c]GtkWindow, manager: [*c]GtkRecentManager, first_button_text: [*c]const gchar, ...) [*c]GtkWidget;
pub const struct__GtkRecentChooserMenuPrivate = @OpaqueType();
pub const GtkRecentChooserMenuPrivate = struct__GtkRecentChooserMenuPrivate;
pub const struct__GtkRecentChooserMenu = extern struct {
    parent_instance: GtkMenu,
    priv: ?*GtkRecentChooserMenuPrivate,
};
pub const GtkRecentChooserMenu = struct__GtkRecentChooserMenu;
pub const struct__GtkRecentChooserMenuClass = extern struct {
    parent_class: GtkMenuClass,
    gtk_recent1: ?extern fn () void,
    gtk_recent2: ?extern fn () void,
    gtk_recent3: ?extern fn () void,
    gtk_recent4: ?extern fn () void,
};
pub const GtkRecentChooserMenuClass = struct__GtkRecentChooserMenuClass;
pub extern fn gtk_recent_chooser_menu_get_type() GType;
pub extern fn gtk_recent_chooser_menu_new() [*c]GtkWidget;
pub extern fn gtk_recent_chooser_menu_new_for_manager(manager: [*c]GtkRecentManager) [*c]GtkWidget;
pub extern fn gtk_recent_chooser_menu_get_show_numbers(menu: [*c]GtkRecentChooserMenu) gboolean;
pub extern fn gtk_recent_chooser_menu_set_show_numbers(menu: [*c]GtkRecentChooserMenu, show_numbers: gboolean) void;
pub const struct__GtkRecentChooserWidgetPrivate = @OpaqueType();
pub const GtkRecentChooserWidgetPrivate = struct__GtkRecentChooserWidgetPrivate;
pub const struct__GtkRecentChooserWidget = extern struct {
    parent_instance: GtkBox,
    priv: ?*GtkRecentChooserWidgetPrivate,
};
pub const GtkRecentChooserWidget = struct__GtkRecentChooserWidget;
pub const struct__GtkRecentChooserWidgetClass = extern struct {
    parent_class: GtkBoxClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkRecentChooserWidgetClass = struct__GtkRecentChooserWidgetClass;
pub extern fn gtk_recent_chooser_widget_get_type() GType;
pub extern fn gtk_recent_chooser_widget_new() [*c]GtkWidget;
pub extern fn gtk_recent_chooser_widget_new_for_manager(manager: [*c]GtkRecentManager) [*c]GtkWidget;
pub extern fn gtk_render_check(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: gdouble, y: gdouble, width: gdouble, height: gdouble) void;
pub extern fn gtk_render_option(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: gdouble, y: gdouble, width: gdouble, height: gdouble) void;
pub extern fn gtk_render_arrow(context: [*c]GtkStyleContext, cr: ?*cairo_t, angle: gdouble, x: gdouble, y: gdouble, size: gdouble) void;
pub extern fn gtk_render_background(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: gdouble, y: gdouble, width: gdouble, height: gdouble) void;
pub extern fn gtk_render_background_get_clip(context: [*c]GtkStyleContext, x: gdouble, y: gdouble, width: gdouble, height: gdouble, out_clip: [*c]GdkRectangle) void;
pub extern fn gtk_render_frame(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: gdouble, y: gdouble, width: gdouble, height: gdouble) void;
pub extern fn gtk_render_expander(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: gdouble, y: gdouble, width: gdouble, height: gdouble) void;
pub extern fn gtk_render_focus(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: gdouble, y: gdouble, width: gdouble, height: gdouble) void;
pub extern fn gtk_render_layout(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: gdouble, y: gdouble, layout: ?*PangoLayout) void;
pub extern fn gtk_render_line(context: [*c]GtkStyleContext, cr: ?*cairo_t, x0: gdouble, y0: gdouble, x1: gdouble, y1: gdouble) void;
pub extern fn gtk_render_slider(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: gdouble, y: gdouble, width: gdouble, height: gdouble, orientation: GtkOrientation) void;
pub extern fn gtk_render_frame_gap(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: gdouble, y: gdouble, width: gdouble, height: gdouble, gap_side: GtkPositionType, xy0_gap: gdouble, xy1_gap: gdouble) void;
pub extern fn gtk_render_extension(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: gdouble, y: gdouble, width: gdouble, height: gdouble, gap_side: GtkPositionType) void;
pub extern fn gtk_render_handle(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: gdouble, y: gdouble, width: gdouble, height: gdouble) void;
pub extern fn gtk_render_activity(context: [*c]GtkStyleContext, cr: ?*cairo_t, x: gdouble, y: gdouble, width: gdouble, height: gdouble) void;
pub extern fn gtk_render_icon_pixbuf(context: [*c]GtkStyleContext, source: ?*const GtkIconSource, size: GtkIconSize) ?*GdkPixbuf;
pub extern fn gtk_render_icon(context: [*c]GtkStyleContext, cr: ?*cairo_t, pixbuf: ?*GdkPixbuf, x: gdouble, y: gdouble) void;
pub extern fn gtk_render_icon_surface(context: [*c]GtkStyleContext, cr: ?*cairo_t, surface: ?*cairo_surface_t, x: gdouble, y: gdouble) void;
pub const struct__GtkRevealer = extern struct {
    parent_instance: GtkBin,
};
pub const GtkRevealer = struct__GtkRevealer;
pub const struct__GtkRevealerClass = extern struct {
    parent_class: GtkBinClass,
};
pub const GtkRevealerClass = struct__GtkRevealerClass;
pub const GTK_REVEALER_TRANSITION_TYPE_NONE = 0;
pub const GTK_REVEALER_TRANSITION_TYPE_CROSSFADE = 1;
pub const GTK_REVEALER_TRANSITION_TYPE_SLIDE_RIGHT = 2;
pub const GTK_REVEALER_TRANSITION_TYPE_SLIDE_LEFT = 3;
pub const GTK_REVEALER_TRANSITION_TYPE_SLIDE_UP = 4;
pub const GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN = 5;
pub const GtkRevealerTransitionType = extern enum {
    GTK_REVEALER_TRANSITION_TYPE_NONE = 0,
    GTK_REVEALER_TRANSITION_TYPE_CROSSFADE = 1,
    GTK_REVEALER_TRANSITION_TYPE_SLIDE_RIGHT = 2,
    GTK_REVEALER_TRANSITION_TYPE_SLIDE_LEFT = 3,
    GTK_REVEALER_TRANSITION_TYPE_SLIDE_UP = 4,
    GTK_REVEALER_TRANSITION_TYPE_SLIDE_DOWN = 5,
};
pub extern fn gtk_revealer_get_type() GType;
pub extern fn gtk_revealer_new() [*c]GtkWidget;
pub extern fn gtk_revealer_get_reveal_child(revealer: [*c]GtkRevealer) gboolean;
pub extern fn gtk_revealer_set_reveal_child(revealer: [*c]GtkRevealer, reveal_child: gboolean) void;
pub extern fn gtk_revealer_get_child_revealed(revealer: [*c]GtkRevealer) gboolean;
pub extern fn gtk_revealer_get_transition_duration(revealer: [*c]GtkRevealer) guint;
pub extern fn gtk_revealer_set_transition_duration(revealer: [*c]GtkRevealer, duration: guint) void;
pub extern fn gtk_revealer_set_transition_type(revealer: [*c]GtkRevealer, transition: GtkRevealerTransitionType) void;
pub extern fn gtk_revealer_get_transition_type(revealer: [*c]GtkRevealer) GtkRevealerTransitionType;
pub const struct__GtkScalePrivate = @OpaqueType();
pub const GtkScalePrivate = struct__GtkScalePrivate;
pub const struct__GtkScale = extern struct {
    range: GtkRange,
    priv: ?*GtkScalePrivate,
};
pub const GtkScale = struct__GtkScale;
pub const struct__GtkScaleClass = extern struct {
    parent_class: GtkRangeClass,
    format_value: ?extern fn ([*c]GtkScale, gdouble) [*c]gchar,
    draw_value: ?extern fn ([*c]GtkScale) void,
    get_layout_offsets: ?extern fn ([*c]GtkScale, [*c]gint, [*c]gint) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkScaleClass = struct__GtkScaleClass;
pub extern fn gtk_scale_get_type() GType;
pub extern fn gtk_scale_new(orientation: GtkOrientation, adjustment: [*c]GtkAdjustment) [*c]GtkWidget;
pub extern fn gtk_scale_new_with_range(orientation: GtkOrientation, min: gdouble, max: gdouble, step: gdouble) [*c]GtkWidget;
pub extern fn gtk_scale_set_digits(scale: [*c]GtkScale, digits: gint) void;
pub extern fn gtk_scale_get_digits(scale: [*c]GtkScale) gint;
pub extern fn gtk_scale_set_draw_value(scale: [*c]GtkScale, draw_value: gboolean) void;
pub extern fn gtk_scale_get_draw_value(scale: [*c]GtkScale) gboolean;
pub extern fn gtk_scale_set_has_origin(scale: [*c]GtkScale, has_origin: gboolean) void;
pub extern fn gtk_scale_get_has_origin(scale: [*c]GtkScale) gboolean;
pub extern fn gtk_scale_set_value_pos(scale: [*c]GtkScale, pos: GtkPositionType) void;
pub extern fn gtk_scale_get_value_pos(scale: [*c]GtkScale) GtkPositionType;
pub extern fn gtk_scale_get_layout(scale: [*c]GtkScale) ?*PangoLayout;
pub extern fn gtk_scale_get_layout_offsets(scale: [*c]GtkScale, x: [*c]gint, y: [*c]gint) void;
pub extern fn gtk_scale_add_mark(scale: [*c]GtkScale, value: gdouble, position: GtkPositionType, markup: [*c]const gchar) void;
pub extern fn gtk_scale_clear_marks(scale: [*c]GtkScale) void;
pub const struct__GtkScaleButtonPrivate = @OpaqueType();
pub const GtkScaleButtonPrivate = struct__GtkScaleButtonPrivate;
pub const struct__GtkScaleButton = extern struct {
    parent: GtkButton,
    priv: ?*GtkScaleButtonPrivate,
};
pub const GtkScaleButton = struct__GtkScaleButton;
pub const struct__GtkScaleButtonClass = extern struct {
    parent_class: GtkButtonClass,
    value_changed: ?extern fn ([*c]GtkScaleButton, gdouble) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkScaleButtonClass = struct__GtkScaleButtonClass;
pub extern fn gtk_scale_button_get_type() GType;
pub extern fn gtk_scale_button_new(size: GtkIconSize, min: gdouble, max: gdouble, step: gdouble, icons: [*c]([*c]const gchar)) [*c]GtkWidget;
pub extern fn gtk_scale_button_set_icons(button: [*c]GtkScaleButton, icons: [*c]([*c]const gchar)) void;
pub extern fn gtk_scale_button_get_value(button: [*c]GtkScaleButton) gdouble;
pub extern fn gtk_scale_button_set_value(button: [*c]GtkScaleButton, value: gdouble) void;
pub extern fn gtk_scale_button_get_adjustment(button: [*c]GtkScaleButton) [*c]GtkAdjustment;
pub extern fn gtk_scale_button_set_adjustment(button: [*c]GtkScaleButton, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_scale_button_get_plus_button(button: [*c]GtkScaleButton) [*c]GtkWidget;
pub extern fn gtk_scale_button_get_minus_button(button: [*c]GtkScaleButton) [*c]GtkWidget;
pub extern fn gtk_scale_button_get_popup(button: [*c]GtkScaleButton) [*c]GtkWidget;
pub const struct__GtkScrollable = @OpaqueType();
pub const GtkScrollable = struct__GtkScrollable;
pub const struct__GtkScrollableInterface = extern struct {
    base_iface: GTypeInterface,
    get_border: ?extern fn (?*GtkScrollable, [*c]GtkBorder) gboolean,
};
pub const GtkScrollableInterface = struct__GtkScrollableInterface;
pub extern fn gtk_scrollable_get_type() GType;
pub extern fn gtk_scrollable_get_hadjustment(scrollable: ?*GtkScrollable) [*c]GtkAdjustment;
pub extern fn gtk_scrollable_set_hadjustment(scrollable: ?*GtkScrollable, hadjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_scrollable_get_vadjustment(scrollable: ?*GtkScrollable) [*c]GtkAdjustment;
pub extern fn gtk_scrollable_set_vadjustment(scrollable: ?*GtkScrollable, vadjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_scrollable_get_hscroll_policy(scrollable: ?*GtkScrollable) GtkScrollablePolicy;
pub extern fn gtk_scrollable_set_hscroll_policy(scrollable: ?*GtkScrollable, policy: GtkScrollablePolicy) void;
pub extern fn gtk_scrollable_get_vscroll_policy(scrollable: ?*GtkScrollable) GtkScrollablePolicy;
pub extern fn gtk_scrollable_set_vscroll_policy(scrollable: ?*GtkScrollable, policy: GtkScrollablePolicy) void;
pub extern fn gtk_scrollable_get_border(scrollable: ?*GtkScrollable, border: [*c]GtkBorder) gboolean;
pub const struct__GtkScrollbar = extern struct {
    range: GtkRange,
};
pub const GtkScrollbar = struct__GtkScrollbar;
pub const struct__GtkScrollbarClass = extern struct {
    parent_class: GtkRangeClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkScrollbarClass = struct__GtkScrollbarClass;
pub extern fn gtk_scrollbar_get_type() GType;
pub extern fn gtk_scrollbar_new(orientation: GtkOrientation, adjustment: [*c]GtkAdjustment) [*c]GtkWidget;
pub const struct__GtkScrolledWindowPrivate = @OpaqueType();
pub const GtkScrolledWindowPrivate = struct__GtkScrolledWindowPrivate;
pub const struct__GtkScrolledWindow = extern struct {
    container: GtkBin,
    priv: ?*GtkScrolledWindowPrivate,
};
pub const GtkScrolledWindow = struct__GtkScrolledWindow;
pub const struct__GtkScrolledWindowClass = extern struct {
    parent_class: GtkBinClass,
    scrollbar_spacing: gint,
    scroll_child: ?extern fn ([*c]GtkScrolledWindow, GtkScrollType, gboolean) gboolean,
    move_focus_out: ?extern fn ([*c]GtkScrolledWindow, GtkDirectionType) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkScrolledWindowClass = struct__GtkScrolledWindowClass;
pub const GTK_CORNER_TOP_LEFT = 0;
pub const GTK_CORNER_BOTTOM_LEFT = 1;
pub const GTK_CORNER_TOP_RIGHT = 2;
pub const GTK_CORNER_BOTTOM_RIGHT = 3;
pub const GtkCornerType = extern enum {
    GTK_CORNER_TOP_LEFT = 0,
    GTK_CORNER_BOTTOM_LEFT = 1,
    GTK_CORNER_TOP_RIGHT = 2,
    GTK_CORNER_BOTTOM_RIGHT = 3,
};
pub const GTK_POLICY_ALWAYS = 0;
pub const GTK_POLICY_AUTOMATIC = 1;
pub const GTK_POLICY_NEVER = 2;
pub const GTK_POLICY_EXTERNAL = 3;
pub const GtkPolicyType = extern enum {
    GTK_POLICY_ALWAYS = 0,
    GTK_POLICY_AUTOMATIC = 1,
    GTK_POLICY_NEVER = 2,
    GTK_POLICY_EXTERNAL = 3,
};
pub extern fn gtk_scrolled_window_get_type() GType;
pub extern fn gtk_scrolled_window_new(hadjustment: [*c]GtkAdjustment, vadjustment: [*c]GtkAdjustment) [*c]GtkWidget;
pub extern fn gtk_scrolled_window_set_hadjustment(scrolled_window: [*c]GtkScrolledWindow, hadjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_scrolled_window_set_vadjustment(scrolled_window: [*c]GtkScrolledWindow, vadjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_scrolled_window_get_hadjustment(scrolled_window: [*c]GtkScrolledWindow) [*c]GtkAdjustment;
pub extern fn gtk_scrolled_window_get_vadjustment(scrolled_window: [*c]GtkScrolledWindow) [*c]GtkAdjustment;
pub extern fn gtk_scrolled_window_get_hscrollbar(scrolled_window: [*c]GtkScrolledWindow) [*c]GtkWidget;
pub extern fn gtk_scrolled_window_get_vscrollbar(scrolled_window: [*c]GtkScrolledWindow) [*c]GtkWidget;
pub extern fn gtk_scrolled_window_set_policy(scrolled_window: [*c]GtkScrolledWindow, hscrollbar_policy: GtkPolicyType, vscrollbar_policy: GtkPolicyType) void;
pub extern fn gtk_scrolled_window_get_policy(scrolled_window: [*c]GtkScrolledWindow, hscrollbar_policy: [*c]GtkPolicyType, vscrollbar_policy: [*c]GtkPolicyType) void;
pub extern fn gtk_scrolled_window_set_placement(scrolled_window: [*c]GtkScrolledWindow, window_placement: GtkCornerType) void;
pub extern fn gtk_scrolled_window_unset_placement(scrolled_window: [*c]GtkScrolledWindow) void;
pub extern fn gtk_scrolled_window_get_placement(scrolled_window: [*c]GtkScrolledWindow) GtkCornerType;
pub extern fn gtk_scrolled_window_set_shadow_type(scrolled_window: [*c]GtkScrolledWindow, type_0: GtkShadowType) void;
pub extern fn gtk_scrolled_window_get_shadow_type(scrolled_window: [*c]GtkScrolledWindow) GtkShadowType;
pub extern fn gtk_scrolled_window_add_with_viewport(scrolled_window: [*c]GtkScrolledWindow, child: [*c]GtkWidget) void;
pub extern fn gtk_scrolled_window_get_min_content_width(scrolled_window: [*c]GtkScrolledWindow) gint;
pub extern fn gtk_scrolled_window_set_min_content_width(scrolled_window: [*c]GtkScrolledWindow, width: gint) void;
pub extern fn gtk_scrolled_window_get_min_content_height(scrolled_window: [*c]GtkScrolledWindow) gint;
pub extern fn gtk_scrolled_window_set_min_content_height(scrolled_window: [*c]GtkScrolledWindow, height: gint) void;
pub extern fn gtk_scrolled_window_set_kinetic_scrolling(scrolled_window: [*c]GtkScrolledWindow, kinetic_scrolling: gboolean) void;
pub extern fn gtk_scrolled_window_get_kinetic_scrolling(scrolled_window: [*c]GtkScrolledWindow) gboolean;
pub extern fn gtk_scrolled_window_set_capture_button_press(scrolled_window: [*c]GtkScrolledWindow, capture_button_press: gboolean) void;
pub extern fn gtk_scrolled_window_get_capture_button_press(scrolled_window: [*c]GtkScrolledWindow) gboolean;
pub extern fn gtk_scrolled_window_set_overlay_scrolling(scrolled_window: [*c]GtkScrolledWindow, overlay_scrolling: gboolean) void;
pub extern fn gtk_scrolled_window_get_overlay_scrolling(scrolled_window: [*c]GtkScrolledWindow) gboolean;
pub extern fn gtk_scrolled_window_set_max_content_width(scrolled_window: [*c]GtkScrolledWindow, width: gint) void;
pub extern fn gtk_scrolled_window_get_max_content_width(scrolled_window: [*c]GtkScrolledWindow) gint;
pub extern fn gtk_scrolled_window_set_max_content_height(scrolled_window: [*c]GtkScrolledWindow, height: gint) void;
pub extern fn gtk_scrolled_window_get_max_content_height(scrolled_window: [*c]GtkScrolledWindow) gint;
pub extern fn gtk_scrolled_window_set_propagate_natural_width(scrolled_window: [*c]GtkScrolledWindow, propagate: gboolean) void;
pub extern fn gtk_scrolled_window_get_propagate_natural_width(scrolled_window: [*c]GtkScrolledWindow) gboolean;
pub extern fn gtk_scrolled_window_set_propagate_natural_height(scrolled_window: [*c]GtkScrolledWindow, propagate: gboolean) void;
pub extern fn gtk_scrolled_window_get_propagate_natural_height(scrolled_window: [*c]GtkScrolledWindow) gboolean;
pub const struct__GtkSearchBar = extern struct {
    parent: GtkBin,
};
pub const GtkSearchBar = struct__GtkSearchBar;
pub const struct__GtkSearchBarClass = extern struct {
    parent_class: GtkBinClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkSearchBarClass = struct__GtkSearchBarClass;
pub extern fn gtk_search_bar_get_type() GType;
pub extern fn gtk_search_bar_new() [*c]GtkWidget;
pub extern fn gtk_search_bar_connect_entry(bar: [*c]GtkSearchBar, entry: [*c]GtkEntry) void;
pub extern fn gtk_search_bar_get_search_mode(bar: [*c]GtkSearchBar) gboolean;
pub extern fn gtk_search_bar_set_search_mode(bar: [*c]GtkSearchBar, search_mode: gboolean) void;
pub extern fn gtk_search_bar_get_show_close_button(bar: [*c]GtkSearchBar) gboolean;
pub extern fn gtk_search_bar_set_show_close_button(bar: [*c]GtkSearchBar, visible: gboolean) void;
pub extern fn gtk_search_bar_handle_event(bar: [*c]GtkSearchBar, event: [*c]GdkEvent) gboolean;
pub const struct__GtkSearchEntry = extern struct {
    parent: GtkEntry,
};
pub const GtkSearchEntry = struct__GtkSearchEntry;
pub const struct__GtkSearchEntryClass = extern struct {
    parent_class: GtkEntryClass,
    search_changed: ?extern fn ([*c]GtkSearchEntry) void,
    next_match: ?extern fn ([*c]GtkSearchEntry) void,
    previous_match: ?extern fn ([*c]GtkSearchEntry) void,
    stop_search: ?extern fn ([*c]GtkSearchEntry) void,
};
pub const GtkSearchEntryClass = struct__GtkSearchEntryClass;
pub extern fn gtk_search_entry_get_type() GType;
pub extern fn gtk_search_entry_new() [*c]GtkWidget;
pub extern fn gtk_search_entry_handle_event(entry: [*c]GtkSearchEntry, event: [*c]GdkEvent) gboolean;
pub const struct__GtkSeparatorPrivate = @OpaqueType();
pub const GtkSeparatorPrivate = struct__GtkSeparatorPrivate;
pub const struct__GtkSeparator = extern struct {
    widget: GtkWidget,
    priv: ?*GtkSeparatorPrivate,
};
pub const GtkSeparator = struct__GtkSeparator;
pub const struct__GtkSeparatorClass = extern struct {
    parent_class: GtkWidgetClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkSeparatorClass = struct__GtkSeparatorClass;
pub extern fn gtk_separator_get_type() GType;
pub extern fn gtk_separator_new(orientation: GtkOrientation) [*c]GtkWidget;
pub const struct__GtkSeparatorMenuItem = extern struct {
    menu_item: GtkMenuItem,
};
pub const GtkSeparatorMenuItem = struct__GtkSeparatorMenuItem;
pub const struct__GtkSeparatorMenuItemClass = extern struct {
    parent_class: GtkMenuItemClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkSeparatorMenuItemClass = struct__GtkSeparatorMenuItemClass;
pub extern fn gtk_separator_menu_item_get_type() GType;
pub extern fn gtk_separator_menu_item_new() [*c]GtkWidget;
pub const struct__GtkSeparatorToolItemPrivate = @OpaqueType();
pub const GtkSeparatorToolItemPrivate = struct__GtkSeparatorToolItemPrivate;
pub const struct__GtkSeparatorToolItem = extern struct {
    parent: GtkToolItem,
    priv: ?*GtkSeparatorToolItemPrivate,
};
pub const GtkSeparatorToolItem = struct__GtkSeparatorToolItem;
pub const struct__GtkSeparatorToolItemClass = extern struct {
    parent_class: GtkToolItemClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkSeparatorToolItemClass = struct__GtkSeparatorToolItemClass;
pub extern fn gtk_separator_tool_item_get_type() GType;
pub extern fn gtk_separator_tool_item_new() [*c]GtkToolItem;
pub extern fn gtk_separator_tool_item_get_draw(item: [*c]GtkSeparatorToolItem) gboolean;
pub extern fn gtk_separator_tool_item_set_draw(item: [*c]GtkSeparatorToolItem, draw: gboolean) void;
pub const struct__GtkSettingsClass = extern struct {
    parent_class: GObjectClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkSettingsClass = struct__GtkSettingsClass;
pub const struct__GtkSettingsValue = extern struct {
    origin: [*c]gchar,
    value: GValue,
};
pub const GtkSettingsValue = struct__GtkSettingsValue;
pub extern fn gtk_settings_get_type() GType;
pub extern fn gtk_settings_get_default() [*c]GtkSettings;
pub extern fn gtk_settings_get_for_screen(screen: ?*GdkScreen) [*c]GtkSettings;
pub extern fn gtk_settings_install_property(pspec: [*c]GParamSpec) void;
pub extern fn gtk_settings_install_property_parser(pspec: [*c]GParamSpec, parser: GtkRcPropertyParser) void;
pub extern fn gtk_rc_property_parse_color(pspec: [*c]const GParamSpec, gstring: [*c]const GString, property_value: [*c]GValue) gboolean;
pub extern fn gtk_rc_property_parse_enum(pspec: [*c]const GParamSpec, gstring: [*c]const GString, property_value: [*c]GValue) gboolean;
pub extern fn gtk_rc_property_parse_flags(pspec: [*c]const GParamSpec, gstring: [*c]const GString, property_value: [*c]GValue) gboolean;
pub extern fn gtk_rc_property_parse_requisition(pspec: [*c]const GParamSpec, gstring: [*c]const GString, property_value: [*c]GValue) gboolean;
pub extern fn gtk_rc_property_parse_border(pspec: [*c]const GParamSpec, gstring: [*c]const GString, property_value: [*c]GValue) gboolean;
pub extern fn gtk_settings_set_property_value(settings: [*c]GtkSettings, name: [*c]const gchar, svalue: [*c]const GtkSettingsValue) void;
pub extern fn gtk_settings_set_string_property(settings: [*c]GtkSettings, name: [*c]const gchar, v_string: [*c]const gchar, origin: [*c]const gchar) void;
pub extern fn gtk_settings_set_long_property(settings: [*c]GtkSettings, name: [*c]const gchar, v_long: glong, origin: [*c]const gchar) void;
pub extern fn gtk_settings_set_double_property(settings: [*c]GtkSettings, name: [*c]const gchar, v_double: gdouble, origin: [*c]const gchar) void;
pub extern fn gtk_settings_reset_property(settings: [*c]GtkSettings, name: [*c]const gchar) void;
pub const struct__GtkShortcutLabel = @OpaqueType();
pub const GtkShortcutLabel = struct__GtkShortcutLabel;
pub const struct__GtkShortcutLabelClass = @OpaqueType();
pub const GtkShortcutLabelClass = struct__GtkShortcutLabelClass;
pub extern fn gtk_shortcut_label_get_type() GType;
pub extern fn gtk_shortcut_label_new(accelerator: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_shortcut_label_get_accelerator(self: ?*GtkShortcutLabel) [*c]const gchar;
pub extern fn gtk_shortcut_label_set_accelerator(self: ?*GtkShortcutLabel, accelerator: [*c]const gchar) void;
pub extern fn gtk_shortcut_label_get_disabled_text(self: ?*GtkShortcutLabel) [*c]const gchar;
pub extern fn gtk_shortcut_label_set_disabled_text(self: ?*GtkShortcutLabel, disabled_text: [*c]const gchar) void;
pub const struct__GtkShortcutsGroup = @OpaqueType();
pub const GtkShortcutsGroup = struct__GtkShortcutsGroup;
pub const struct__GtkShortcutsGroupClass = @OpaqueType();
pub const GtkShortcutsGroupClass = struct__GtkShortcutsGroupClass;
pub extern fn gtk_shortcuts_group_get_type() GType;
pub const struct__GtkShortcutsSection = @OpaqueType();
pub const GtkShortcutsSection = struct__GtkShortcutsSection;
pub const struct__GtkShortcutsSectionClass = @OpaqueType();
pub const GtkShortcutsSectionClass = struct__GtkShortcutsSectionClass;
pub extern fn gtk_shortcuts_section_get_type() GType;
pub const struct__GtkShortcutsShortcut = @OpaqueType();
pub const GtkShortcutsShortcut = struct__GtkShortcutsShortcut;
pub const struct__GtkShortcutsShortcutClass = @OpaqueType();
pub const GtkShortcutsShortcutClass = struct__GtkShortcutsShortcutClass;
pub const GTK_SHORTCUT_ACCELERATOR = 0;
pub const GTK_SHORTCUT_GESTURE_PINCH = 1;
pub const GTK_SHORTCUT_GESTURE_STRETCH = 2;
pub const GTK_SHORTCUT_GESTURE_ROTATE_CLOCKWISE = 3;
pub const GTK_SHORTCUT_GESTURE_ROTATE_COUNTERCLOCKWISE = 4;
pub const GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_LEFT = 5;
pub const GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_RIGHT = 6;
pub const GTK_SHORTCUT_GESTURE = 7;
pub const GtkShortcutType = extern enum {
    GTK_SHORTCUT_ACCELERATOR = 0,
    GTK_SHORTCUT_GESTURE_PINCH = 1,
    GTK_SHORTCUT_GESTURE_STRETCH = 2,
    GTK_SHORTCUT_GESTURE_ROTATE_CLOCKWISE = 3,
    GTK_SHORTCUT_GESTURE_ROTATE_COUNTERCLOCKWISE = 4,
    GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_LEFT = 5,
    GTK_SHORTCUT_GESTURE_TWO_FINGER_SWIPE_RIGHT = 6,
    GTK_SHORTCUT_GESTURE = 7,
};
pub extern fn gtk_shortcuts_shortcut_get_type() GType;
pub extern fn gtk_show_uri(screen: ?*GdkScreen, uri: [*c]const gchar, timestamp: guint32, @"error": [*c]([*c]GError)) gboolean;
pub extern fn gtk_show_uri_on_window(parent: [*c]GtkWindow, uri: [*c]const u8, timestamp: guint32, @"error": [*c]([*c]GError)) gboolean;
pub const struct__GtkStack = extern struct {
    parent_instance: GtkContainer,
};
pub const GtkStack = struct__GtkStack;
pub const struct__GtkStackClass = extern struct {
    parent_class: GtkContainerClass,
};
pub const GtkStackClass = struct__GtkStackClass;
pub const GTK_STACK_TRANSITION_TYPE_NONE = 0;
pub const GTK_STACK_TRANSITION_TYPE_CROSSFADE = 1;
pub const GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT = 2;
pub const GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT = 3;
pub const GTK_STACK_TRANSITION_TYPE_SLIDE_UP = 4;
pub const GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN = 5;
pub const GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT = 6;
pub const GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN = 7;
pub const GTK_STACK_TRANSITION_TYPE_OVER_UP = 8;
pub const GTK_STACK_TRANSITION_TYPE_OVER_DOWN = 9;
pub const GTK_STACK_TRANSITION_TYPE_OVER_LEFT = 10;
pub const GTK_STACK_TRANSITION_TYPE_OVER_RIGHT = 11;
pub const GTK_STACK_TRANSITION_TYPE_UNDER_UP = 12;
pub const GTK_STACK_TRANSITION_TYPE_UNDER_DOWN = 13;
pub const GTK_STACK_TRANSITION_TYPE_UNDER_LEFT = 14;
pub const GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT = 15;
pub const GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN = 16;
pub const GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP = 17;
pub const GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT = 18;
pub const GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT = 19;
pub const GtkStackTransitionType = extern enum {
    GTK_STACK_TRANSITION_TYPE_NONE = 0,
    GTK_STACK_TRANSITION_TYPE_CROSSFADE = 1,
    GTK_STACK_TRANSITION_TYPE_SLIDE_RIGHT = 2,
    GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT = 3,
    GTK_STACK_TRANSITION_TYPE_SLIDE_UP = 4,
    GTK_STACK_TRANSITION_TYPE_SLIDE_DOWN = 5,
    GTK_STACK_TRANSITION_TYPE_SLIDE_LEFT_RIGHT = 6,
    GTK_STACK_TRANSITION_TYPE_SLIDE_UP_DOWN = 7,
    GTK_STACK_TRANSITION_TYPE_OVER_UP = 8,
    GTK_STACK_TRANSITION_TYPE_OVER_DOWN = 9,
    GTK_STACK_TRANSITION_TYPE_OVER_LEFT = 10,
    GTK_STACK_TRANSITION_TYPE_OVER_RIGHT = 11,
    GTK_STACK_TRANSITION_TYPE_UNDER_UP = 12,
    GTK_STACK_TRANSITION_TYPE_UNDER_DOWN = 13,
    GTK_STACK_TRANSITION_TYPE_UNDER_LEFT = 14,
    GTK_STACK_TRANSITION_TYPE_UNDER_RIGHT = 15,
    GTK_STACK_TRANSITION_TYPE_OVER_UP_DOWN = 16,
    GTK_STACK_TRANSITION_TYPE_OVER_DOWN_UP = 17,
    GTK_STACK_TRANSITION_TYPE_OVER_LEFT_RIGHT = 18,
    GTK_STACK_TRANSITION_TYPE_OVER_RIGHT_LEFT = 19,
};
pub extern fn gtk_stack_get_type() GType;
pub extern fn gtk_stack_new() [*c]GtkWidget;
pub extern fn gtk_stack_add_named(stack: [*c]GtkStack, child: [*c]GtkWidget, name: [*c]const gchar) void;
pub extern fn gtk_stack_add_titled(stack: [*c]GtkStack, child: [*c]GtkWidget, name: [*c]const gchar, title: [*c]const gchar) void;
pub extern fn gtk_stack_get_child_by_name(stack: [*c]GtkStack, name: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_stack_set_visible_child(stack: [*c]GtkStack, child: [*c]GtkWidget) void;
pub extern fn gtk_stack_get_visible_child(stack: [*c]GtkStack) [*c]GtkWidget;
pub extern fn gtk_stack_set_visible_child_name(stack: [*c]GtkStack, name: [*c]const gchar) void;
pub extern fn gtk_stack_get_visible_child_name(stack: [*c]GtkStack) [*c]const gchar;
pub extern fn gtk_stack_set_visible_child_full(stack: [*c]GtkStack, name: [*c]const gchar, transition: GtkStackTransitionType) void;
pub extern fn gtk_stack_set_homogeneous(stack: [*c]GtkStack, homogeneous: gboolean) void;
pub extern fn gtk_stack_get_homogeneous(stack: [*c]GtkStack) gboolean;
pub extern fn gtk_stack_set_hhomogeneous(stack: [*c]GtkStack, hhomogeneous: gboolean) void;
pub extern fn gtk_stack_get_hhomogeneous(stack: [*c]GtkStack) gboolean;
pub extern fn gtk_stack_set_vhomogeneous(stack: [*c]GtkStack, vhomogeneous: gboolean) void;
pub extern fn gtk_stack_get_vhomogeneous(stack: [*c]GtkStack) gboolean;
pub extern fn gtk_stack_set_transition_duration(stack: [*c]GtkStack, duration: guint) void;
pub extern fn gtk_stack_get_transition_duration(stack: [*c]GtkStack) guint;
pub extern fn gtk_stack_set_transition_type(stack: [*c]GtkStack, transition: GtkStackTransitionType) void;
pub extern fn gtk_stack_get_transition_type(stack: [*c]GtkStack) GtkStackTransitionType;
pub extern fn gtk_stack_get_transition_running(stack: [*c]GtkStack) gboolean;
pub extern fn gtk_stack_set_interpolate_size(stack: [*c]GtkStack, interpolate_size: gboolean) void;
pub extern fn gtk_stack_get_interpolate_size(stack: [*c]GtkStack) gboolean;
pub const struct__GtkStackSidebar = extern struct {
    parent: GtkBin,
};
pub const GtkStackSidebar = struct__GtkStackSidebar;
pub const struct__GtkStackSidebarPrivate = @OpaqueType();
pub const GtkStackSidebarPrivate = struct__GtkStackSidebarPrivate;
pub const struct__GtkStackSidebarClass = extern struct {
    parent_class: GtkBinClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkStackSidebarClass = struct__GtkStackSidebarClass;
pub extern fn gtk_stack_sidebar_get_type() GType;
pub extern fn gtk_stack_sidebar_new() [*c]GtkWidget;
pub extern fn gtk_stack_sidebar_set_stack(sidebar: [*c]GtkStackSidebar, stack: [*c]GtkStack) void;
pub extern fn gtk_stack_sidebar_get_stack(sidebar: [*c]GtkStackSidebar) [*c]GtkStack;
pub const struct__GtkRequestedSize = extern struct {
    data: gpointer,
    minimum_size: gint,
    natural_size: gint,
};
pub const GtkRequestedSize = struct__GtkRequestedSize;
pub extern fn gtk_distribute_natural_allocation(extra_space: gint, n_requested_sizes: guint, sizes: [*c]GtkRequestedSize) gint;
pub const GTK_UPDATE_ALWAYS = 0;
pub const GTK_UPDATE_IF_VALID = 1;
pub const GtkSpinButtonUpdatePolicy = extern enum {
    GTK_UPDATE_ALWAYS = 0,
    GTK_UPDATE_IF_VALID = 1,
};
pub const GTK_SPIN_STEP_FORWARD = 0;
pub const GTK_SPIN_STEP_BACKWARD = 1;
pub const GTK_SPIN_PAGE_FORWARD = 2;
pub const GTK_SPIN_PAGE_BACKWARD = 3;
pub const GTK_SPIN_HOME = 4;
pub const GTK_SPIN_END = 5;
pub const GTK_SPIN_USER_DEFINED = 6;
pub const GtkSpinType = extern enum {
    GTK_SPIN_STEP_FORWARD = 0,
    GTK_SPIN_STEP_BACKWARD = 1,
    GTK_SPIN_PAGE_FORWARD = 2,
    GTK_SPIN_PAGE_BACKWARD = 3,
    GTK_SPIN_HOME = 4,
    GTK_SPIN_END = 5,
    GTK_SPIN_USER_DEFINED = 6,
};
pub const struct__GtkSpinButtonPrivate = @OpaqueType();
pub const GtkSpinButtonPrivate = struct__GtkSpinButtonPrivate;
pub const struct__GtkSpinButton = extern struct {
    entry: GtkEntry,
    priv: ?*GtkSpinButtonPrivate,
};
pub const GtkSpinButton = struct__GtkSpinButton;
pub const struct__GtkSpinButtonClass = extern struct {
    parent_class: GtkEntryClass,
    input: ?extern fn ([*c]GtkSpinButton, [*c]gdouble) gint,
    output: ?extern fn ([*c]GtkSpinButton) gint,
    value_changed: ?extern fn ([*c]GtkSpinButton) void,
    change_value: ?extern fn ([*c]GtkSpinButton, GtkScrollType) void,
    wrapped: ?extern fn ([*c]GtkSpinButton) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkSpinButtonClass = struct__GtkSpinButtonClass;
pub extern fn gtk_spin_button_get_type() GType;
pub extern fn gtk_spin_button_configure(spin_button: [*c]GtkSpinButton, adjustment: [*c]GtkAdjustment, climb_rate: gdouble, digits: guint) void;
pub extern fn gtk_spin_button_new(adjustment: [*c]GtkAdjustment, climb_rate: gdouble, digits: guint) [*c]GtkWidget;
pub extern fn gtk_spin_button_new_with_range(min: gdouble, max: gdouble, step: gdouble) [*c]GtkWidget;
pub extern fn gtk_spin_button_set_adjustment(spin_button: [*c]GtkSpinButton, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_spin_button_get_adjustment(spin_button: [*c]GtkSpinButton) [*c]GtkAdjustment;
pub extern fn gtk_spin_button_set_digits(spin_button: [*c]GtkSpinButton, digits: guint) void;
pub extern fn gtk_spin_button_get_digits(spin_button: [*c]GtkSpinButton) guint;
pub extern fn gtk_spin_button_set_increments(spin_button: [*c]GtkSpinButton, step: gdouble, page: gdouble) void;
pub extern fn gtk_spin_button_get_increments(spin_button: [*c]GtkSpinButton, step: [*c]gdouble, page: [*c]gdouble) void;
pub extern fn gtk_spin_button_set_range(spin_button: [*c]GtkSpinButton, min: gdouble, max: gdouble) void;
pub extern fn gtk_spin_button_get_range(spin_button: [*c]GtkSpinButton, min: [*c]gdouble, max: [*c]gdouble) void;
pub extern fn gtk_spin_button_get_value(spin_button: [*c]GtkSpinButton) gdouble;
pub extern fn gtk_spin_button_get_value_as_int(spin_button: [*c]GtkSpinButton) gint;
pub extern fn gtk_spin_button_set_value(spin_button: [*c]GtkSpinButton, value: gdouble) void;
pub extern fn gtk_spin_button_set_update_policy(spin_button: [*c]GtkSpinButton, policy: GtkSpinButtonUpdatePolicy) void;
pub extern fn gtk_spin_button_get_update_policy(spin_button: [*c]GtkSpinButton) GtkSpinButtonUpdatePolicy;
pub extern fn gtk_spin_button_set_numeric(spin_button: [*c]GtkSpinButton, numeric: gboolean) void;
pub extern fn gtk_spin_button_get_numeric(spin_button: [*c]GtkSpinButton) gboolean;
pub extern fn gtk_spin_button_spin(spin_button: [*c]GtkSpinButton, direction: GtkSpinType, increment: gdouble) void;
pub extern fn gtk_spin_button_set_wrap(spin_button: [*c]GtkSpinButton, wrap: gboolean) void;
pub extern fn gtk_spin_button_get_wrap(spin_button: [*c]GtkSpinButton) gboolean;
pub extern fn gtk_spin_button_set_snap_to_ticks(spin_button: [*c]GtkSpinButton, snap_to_ticks: gboolean) void;
pub extern fn gtk_spin_button_get_snap_to_ticks(spin_button: [*c]GtkSpinButton) gboolean;
pub extern fn gtk_spin_button_update(spin_button: [*c]GtkSpinButton) void;
pub extern fn _gtk_spin_button_get_panels(spin_button: [*c]GtkSpinButton, down_panel: [*c](?*GdkWindow), up_panel: [*c](?*GdkWindow)) void;
pub const struct__GtkSpinnerPrivate = @OpaqueType();
pub const GtkSpinnerPrivate = struct__GtkSpinnerPrivate;
pub const struct__GtkSpinner = extern struct {
    parent: GtkWidget,
    priv: ?*GtkSpinnerPrivate,
};
pub const GtkSpinner = struct__GtkSpinner;
pub const struct__GtkSpinnerClass = extern struct {
    parent_class: GtkWidgetClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkSpinnerClass = struct__GtkSpinnerClass;
pub extern fn gtk_spinner_get_type() GType;
pub extern fn gtk_spinner_new() [*c]GtkWidget;
pub extern fn gtk_spinner_start(spinner: [*c]GtkSpinner) void;
pub extern fn gtk_spinner_stop(spinner: [*c]GtkSpinner) void;
pub const struct__GtkStackSwitcher = extern struct {
    widget: GtkBox,
};
pub const GtkStackSwitcher = struct__GtkStackSwitcher;
pub const struct__GtkStackSwitcherClass = extern struct {
    parent_class: GtkBoxClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkStackSwitcherClass = struct__GtkStackSwitcherClass;
pub extern fn gtk_stack_switcher_get_type() GType;
pub extern fn gtk_stack_switcher_new() [*c]GtkWidget;
pub extern fn gtk_stack_switcher_set_stack(switcher: [*c]GtkStackSwitcher, stack: [*c]GtkStack) void;
pub extern fn gtk_stack_switcher_get_stack(switcher: [*c]GtkStackSwitcher) [*c]GtkStack;
pub const struct__GtkStatusbarPrivate = @OpaqueType();
pub const GtkStatusbarPrivate = struct__GtkStatusbarPrivate;
pub const struct__GtkStatusbar = extern struct {
    parent_widget: GtkBox,
    priv: ?*GtkStatusbarPrivate,
};
pub const GtkStatusbar = struct__GtkStatusbar;
pub const struct__GtkStatusbarClass = extern struct {
    parent_class: GtkBoxClass,
    reserved: gpointer,
    text_pushed: ?extern fn ([*c]GtkStatusbar, guint, [*c]const gchar) void,
    text_popped: ?extern fn ([*c]GtkStatusbar, guint, [*c]const gchar) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkStatusbarClass = struct__GtkStatusbarClass;
pub extern fn gtk_statusbar_get_type() GType;
pub extern fn gtk_statusbar_new() [*c]GtkWidget;
pub extern fn gtk_statusbar_get_context_id(statusbar: [*c]GtkStatusbar, context_description: [*c]const gchar) guint;
pub extern fn gtk_statusbar_push(statusbar: [*c]GtkStatusbar, context_id: guint, text: [*c]const gchar) guint;
pub extern fn gtk_statusbar_pop(statusbar: [*c]GtkStatusbar, context_id: guint) void;
pub extern fn gtk_statusbar_remove(statusbar: [*c]GtkStatusbar, context_id: guint, message_id: guint) void;
pub extern fn gtk_statusbar_remove_all(statusbar: [*c]GtkStatusbar, context_id: guint) void;
pub extern fn gtk_statusbar_get_message_area(statusbar: [*c]GtkStatusbar) [*c]GtkWidget;
pub const struct__GtkSwitchPrivate = @OpaqueType();
pub const GtkSwitchPrivate = struct__GtkSwitchPrivate;
pub const struct__GtkSwitch = extern struct {
    parent_instance: GtkWidget,
    priv: ?*GtkSwitchPrivate,
};
pub const GtkSwitch = struct__GtkSwitch;
pub const struct__GtkSwitchClass = extern struct {
    parent_class: GtkWidgetClass,
    activate: ?extern fn ([*c]GtkSwitch) void,
    state_set: ?extern fn ([*c]GtkSwitch, gboolean) gboolean,
    _switch_padding_1: ?extern fn () void,
    _switch_padding_2: ?extern fn () void,
    _switch_padding_3: ?extern fn () void,
    _switch_padding_4: ?extern fn () void,
    _switch_padding_5: ?extern fn () void,
};
pub const GtkSwitchClass = struct__GtkSwitchClass;
pub extern fn gtk_switch_get_type() GType;
pub extern fn gtk_switch_new() [*c]GtkWidget;
pub extern fn gtk_switch_set_active(sw: [*c]GtkSwitch, is_active: gboolean) void;
pub extern fn gtk_switch_get_active(sw: [*c]GtkSwitch) gboolean;
pub extern fn gtk_switch_set_state(sw: [*c]GtkSwitch, state: gboolean) void;
pub extern fn gtk_switch_get_state(sw: [*c]GtkSwitch) gboolean;
pub const GtkTextTagTableForeach = ?extern fn ([*c]GtkTextTag, gpointer) void;
pub const struct__GtkTextTagTableClass = extern struct {
    parent_class: GObjectClass,
    tag_changed: ?extern fn ([*c]GtkTextTagTable, [*c]GtkTextTag, gboolean) void,
    tag_added: ?extern fn ([*c]GtkTextTagTable, [*c]GtkTextTag) void,
    tag_removed: ?extern fn ([*c]GtkTextTagTable, [*c]GtkTextTag) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkTextTagTableClass = struct__GtkTextTagTableClass;
pub extern fn gtk_text_tag_table_get_type() GType;
pub extern fn gtk_text_tag_table_new() [*c]GtkTextTagTable;
pub extern fn gtk_text_tag_table_add(table: [*c]GtkTextTagTable, tag: [*c]GtkTextTag) gboolean;
pub extern fn gtk_text_tag_table_remove(table: [*c]GtkTextTagTable, tag: [*c]GtkTextTag) void;
pub extern fn gtk_text_tag_table_lookup(table: [*c]GtkTextTagTable, name: [*c]const gchar) [*c]GtkTextTag;
pub extern fn gtk_text_tag_table_foreach(table: [*c]GtkTextTagTable, func: GtkTextTagTableForeach, data: gpointer) void;
pub extern fn gtk_text_tag_table_get_size(table: [*c]GtkTextTagTable) gint;
pub extern fn _gtk_text_tag_table_add_buffer(table: [*c]GtkTextTagTable, buffer: gpointer) void;
pub extern fn _gtk_text_tag_table_remove_buffer(table: [*c]GtkTextTagTable, buffer: gpointer) void;
pub const struct__GtkTextMark = extern struct {
    parent_instance: GObject,
    segment: gpointer,
};
pub const GtkTextMark = struct__GtkTextMark;
pub const struct__GtkTextMarkClass = extern struct {
    parent_class: GObjectClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkTextMarkClass = struct__GtkTextMarkClass;
pub extern fn gtk_text_mark_get_type() GType;
pub extern fn gtk_text_mark_new(name: [*c]const gchar, left_gravity: gboolean) [*c]GtkTextMark;
pub extern fn gtk_text_mark_set_visible(mark: [*c]GtkTextMark, setting: gboolean) void;
pub extern fn gtk_text_mark_get_visible(mark: [*c]GtkTextMark) gboolean;
pub extern fn gtk_text_mark_get_name(mark: [*c]GtkTextMark) [*c]const gchar;
pub extern fn gtk_text_mark_get_deleted(mark: [*c]GtkTextMark) gboolean;
pub extern fn gtk_text_mark_get_buffer(mark: [*c]GtkTextMark) [*c]GtkTextBuffer;
pub extern fn gtk_text_mark_get_left_gravity(mark: [*c]GtkTextMark) gboolean;
pub const GTK_TEXT_BUFFER_TARGET_INFO_BUFFER_CONTENTS = -1;
pub const GTK_TEXT_BUFFER_TARGET_INFO_RICH_TEXT = -2;
pub const GTK_TEXT_BUFFER_TARGET_INFO_TEXT = -3;
pub const GtkTextBufferTargetInfo = extern enum {
    GTK_TEXT_BUFFER_TARGET_INFO_BUFFER_CONTENTS = -1,
    GTK_TEXT_BUFFER_TARGET_INFO_RICH_TEXT = -2,
    GTK_TEXT_BUFFER_TARGET_INFO_TEXT = -3,
};
pub const struct__GtkTextBTree = @OpaqueType();
pub const GtkTextBTree = struct__GtkTextBTree;
pub const struct__GtkTextBufferClass = extern struct {
    parent_class: GObjectClass,
    insert_text: ?extern fn ([*c]GtkTextBuffer, [*c]GtkTextIter, [*c]const gchar, gint) void,
    insert_pixbuf: ?extern fn ([*c]GtkTextBuffer, [*c]GtkTextIter, ?*GdkPixbuf) void,
    insert_child_anchor: ?extern fn ([*c]GtkTextBuffer, [*c]GtkTextIter, [*c]GtkTextChildAnchor) void,
    delete_range: ?extern fn ([*c]GtkTextBuffer, [*c]GtkTextIter, [*c]GtkTextIter) void,
    changed: ?extern fn ([*c]GtkTextBuffer) void,
    modified_changed: ?extern fn ([*c]GtkTextBuffer) void,
    mark_set: ?extern fn ([*c]GtkTextBuffer, [*c]const GtkTextIter, [*c]GtkTextMark) void,
    mark_deleted: ?extern fn ([*c]GtkTextBuffer, [*c]GtkTextMark) void,
    apply_tag: ?extern fn ([*c]GtkTextBuffer, [*c]GtkTextTag, [*c]const GtkTextIter, [*c]const GtkTextIter) void,
    remove_tag: ?extern fn ([*c]GtkTextBuffer, [*c]GtkTextTag, [*c]const GtkTextIter, [*c]const GtkTextIter) void,
    begin_user_action: ?extern fn ([*c]GtkTextBuffer) void,
    end_user_action: ?extern fn ([*c]GtkTextBuffer) void,
    paste_done: ?extern fn ([*c]GtkTextBuffer, ?*GtkClipboard) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkTextBufferClass = struct__GtkTextBufferClass;
pub extern fn gtk_text_buffer_get_type() GType;
pub extern fn gtk_text_buffer_new(table: [*c]GtkTextTagTable) [*c]GtkTextBuffer;
pub extern fn gtk_text_buffer_get_line_count(buffer: [*c]GtkTextBuffer) gint;
pub extern fn gtk_text_buffer_get_char_count(buffer: [*c]GtkTextBuffer) gint;
pub extern fn gtk_text_buffer_get_tag_table(buffer: [*c]GtkTextBuffer) [*c]GtkTextTagTable;
pub extern fn gtk_text_buffer_set_text(buffer: [*c]GtkTextBuffer, text: [*c]const gchar, len: gint) void;
pub extern fn gtk_text_buffer_insert(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, text: [*c]const gchar, len: gint) void;
pub extern fn gtk_text_buffer_insert_at_cursor(buffer: [*c]GtkTextBuffer, text: [*c]const gchar, len: gint) void;
pub extern fn gtk_text_buffer_insert_interactive(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, text: [*c]const gchar, len: gint, default_editable: gboolean) gboolean;
pub extern fn gtk_text_buffer_insert_interactive_at_cursor(buffer: [*c]GtkTextBuffer, text: [*c]const gchar, len: gint, default_editable: gboolean) gboolean;
pub extern fn gtk_text_buffer_insert_range(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_insert_range_interactive(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter, default_editable: gboolean) gboolean;
pub extern fn gtk_text_buffer_insert_with_tags(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, text: [*c]const gchar, len: gint, first_tag: [*c]GtkTextTag, ...) void;
pub extern fn gtk_text_buffer_insert_with_tags_by_name(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, text: [*c]const gchar, len: gint, first_tag_name: [*c]const gchar, ...) void;
pub extern fn gtk_text_buffer_insert_markup(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, markup: [*c]const gchar, len: gint) void;
pub extern fn gtk_text_buffer_delete(buffer: [*c]GtkTextBuffer, start: [*c]GtkTextIter, end: [*c]GtkTextIter) void;
pub extern fn gtk_text_buffer_delete_interactive(buffer: [*c]GtkTextBuffer, start_iter: [*c]GtkTextIter, end_iter: [*c]GtkTextIter, default_editable: gboolean) gboolean;
pub extern fn gtk_text_buffer_backspace(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, interactive: gboolean, default_editable: gboolean) gboolean;
pub extern fn gtk_text_buffer_get_text(buffer: [*c]GtkTextBuffer, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter, include_hidden_chars: gboolean) [*c]gchar;
pub extern fn gtk_text_buffer_get_slice(buffer: [*c]GtkTextBuffer, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter, include_hidden_chars: gboolean) [*c]gchar;
pub extern fn gtk_text_buffer_insert_pixbuf(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, pixbuf: ?*GdkPixbuf) void;
pub extern fn gtk_text_buffer_insert_child_anchor(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, anchor: [*c]GtkTextChildAnchor) void;
pub extern fn gtk_text_buffer_create_child_anchor(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter) [*c]GtkTextChildAnchor;
pub extern fn gtk_text_buffer_add_mark(buffer: [*c]GtkTextBuffer, mark: [*c]GtkTextMark, where: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_create_mark(buffer: [*c]GtkTextBuffer, mark_name: [*c]const gchar, where: [*c]const GtkTextIter, left_gravity: gboolean) [*c]GtkTextMark;
pub extern fn gtk_text_buffer_move_mark(buffer: [*c]GtkTextBuffer, mark: [*c]GtkTextMark, where: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_delete_mark(buffer: [*c]GtkTextBuffer, mark: [*c]GtkTextMark) void;
pub extern fn gtk_text_buffer_get_mark(buffer: [*c]GtkTextBuffer, name: [*c]const gchar) [*c]GtkTextMark;
pub extern fn gtk_text_buffer_move_mark_by_name(buffer: [*c]GtkTextBuffer, name: [*c]const gchar, where: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_delete_mark_by_name(buffer: [*c]GtkTextBuffer, name: [*c]const gchar) void;
pub extern fn gtk_text_buffer_get_insert(buffer: [*c]GtkTextBuffer) [*c]GtkTextMark;
pub extern fn gtk_text_buffer_get_selection_bound(buffer: [*c]GtkTextBuffer) [*c]GtkTextMark;
pub extern fn gtk_text_buffer_place_cursor(buffer: [*c]GtkTextBuffer, where: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_select_range(buffer: [*c]GtkTextBuffer, ins: [*c]const GtkTextIter, bound: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_apply_tag(buffer: [*c]GtkTextBuffer, tag: [*c]GtkTextTag, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_remove_tag(buffer: [*c]GtkTextBuffer, tag: [*c]GtkTextTag, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_apply_tag_by_name(buffer: [*c]GtkTextBuffer, name: [*c]const gchar, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_remove_tag_by_name(buffer: [*c]GtkTextBuffer, name: [*c]const gchar, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_remove_all_tags(buffer: [*c]GtkTextBuffer, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter) void;
pub extern fn gtk_text_buffer_create_tag(buffer: [*c]GtkTextBuffer, tag_name: [*c]const gchar, first_property_name: [*c]const gchar, ...) [*c]GtkTextTag;
pub extern fn gtk_text_buffer_get_iter_at_line_offset(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, line_number: gint, char_offset: gint) void;
pub extern fn gtk_text_buffer_get_iter_at_line_index(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, line_number: gint, byte_index: gint) void;
pub extern fn gtk_text_buffer_get_iter_at_offset(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, char_offset: gint) void;
pub extern fn gtk_text_buffer_get_iter_at_line(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, line_number: gint) void;
pub extern fn gtk_text_buffer_get_start_iter(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter) void;
pub extern fn gtk_text_buffer_get_end_iter(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter) void;
pub extern fn gtk_text_buffer_get_bounds(buffer: [*c]GtkTextBuffer, start: [*c]GtkTextIter, end: [*c]GtkTextIter) void;
pub extern fn gtk_text_buffer_get_iter_at_mark(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, mark: [*c]GtkTextMark) void;
pub extern fn gtk_text_buffer_get_iter_at_child_anchor(buffer: [*c]GtkTextBuffer, iter: [*c]GtkTextIter, anchor: [*c]GtkTextChildAnchor) void;
pub extern fn gtk_text_buffer_get_modified(buffer: [*c]GtkTextBuffer) gboolean;
pub extern fn gtk_text_buffer_set_modified(buffer: [*c]GtkTextBuffer, setting: gboolean) void;
pub extern fn gtk_text_buffer_get_has_selection(buffer: [*c]GtkTextBuffer) gboolean;
pub extern fn gtk_text_buffer_add_selection_clipboard(buffer: [*c]GtkTextBuffer, clipboard: ?*GtkClipboard) void;
pub extern fn gtk_text_buffer_remove_selection_clipboard(buffer: [*c]GtkTextBuffer, clipboard: ?*GtkClipboard) void;
pub extern fn gtk_text_buffer_cut_clipboard(buffer: [*c]GtkTextBuffer, clipboard: ?*GtkClipboard, default_editable: gboolean) void;
pub extern fn gtk_text_buffer_copy_clipboard(buffer: [*c]GtkTextBuffer, clipboard: ?*GtkClipboard) void;
pub extern fn gtk_text_buffer_paste_clipboard(buffer: [*c]GtkTextBuffer, clipboard: ?*GtkClipboard, override_location: [*c]GtkTextIter, default_editable: gboolean) void;
pub extern fn gtk_text_buffer_get_selection_bounds(buffer: [*c]GtkTextBuffer, start: [*c]GtkTextIter, end: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_buffer_delete_selection(buffer: [*c]GtkTextBuffer, interactive: gboolean, default_editable: gboolean) gboolean;
pub extern fn gtk_text_buffer_begin_user_action(buffer: [*c]GtkTextBuffer) void;
pub extern fn gtk_text_buffer_end_user_action(buffer: [*c]GtkTextBuffer) void;
pub extern fn gtk_text_buffer_get_copy_target_list(buffer: [*c]GtkTextBuffer) ?*GtkTargetList;
pub extern fn gtk_text_buffer_get_paste_target_list(buffer: [*c]GtkTextBuffer) ?*GtkTargetList;
pub const GtkTextBufferSerializeFunc = ?extern fn ([*c]GtkTextBuffer, [*c]GtkTextBuffer, [*c]const GtkTextIter, [*c]const GtkTextIter, [*c]gsize, gpointer) [*c]guint8;
pub const GtkTextBufferDeserializeFunc = ?extern fn ([*c]GtkTextBuffer, [*c]GtkTextBuffer, [*c]GtkTextIter, [*c]const guint8, gsize, gboolean, gpointer, [*c]([*c]GError)) gboolean;
pub extern fn gtk_text_buffer_register_serialize_format(buffer: [*c]GtkTextBuffer, mime_type: [*c]const gchar, function: GtkTextBufferSerializeFunc, user_data: gpointer, user_data_destroy: GDestroyNotify) GdkAtom;
pub extern fn gtk_text_buffer_register_serialize_tagset(buffer: [*c]GtkTextBuffer, tagset_name: [*c]const gchar) GdkAtom;
pub extern fn gtk_text_buffer_register_deserialize_format(buffer: [*c]GtkTextBuffer, mime_type: [*c]const gchar, function: GtkTextBufferDeserializeFunc, user_data: gpointer, user_data_destroy: GDestroyNotify) GdkAtom;
pub extern fn gtk_text_buffer_register_deserialize_tagset(buffer: [*c]GtkTextBuffer, tagset_name: [*c]const gchar) GdkAtom;
pub extern fn gtk_text_buffer_unregister_serialize_format(buffer: [*c]GtkTextBuffer, format: GdkAtom) void;
pub extern fn gtk_text_buffer_unregister_deserialize_format(buffer: [*c]GtkTextBuffer, format: GdkAtom) void;
pub extern fn gtk_text_buffer_deserialize_set_can_create_tags(buffer: [*c]GtkTextBuffer, format: GdkAtom, can_create_tags: gboolean) void;
pub extern fn gtk_text_buffer_deserialize_get_can_create_tags(buffer: [*c]GtkTextBuffer, format: GdkAtom) gboolean;
pub extern fn gtk_text_buffer_get_serialize_formats(buffer: [*c]GtkTextBuffer, n_formats: [*c]gint) [*c]GdkAtom;
pub extern fn gtk_text_buffer_get_deserialize_formats(buffer: [*c]GtkTextBuffer, n_formats: [*c]gint) [*c]GdkAtom;
pub extern fn gtk_text_buffer_serialize(register_buffer: [*c]GtkTextBuffer, content_buffer: [*c]GtkTextBuffer, format: GdkAtom, start: [*c]const GtkTextIter, end: [*c]const GtkTextIter, length: [*c]gsize) [*c]guint8;
pub extern fn gtk_text_buffer_deserialize(register_buffer: [*c]GtkTextBuffer, content_buffer: [*c]GtkTextBuffer, format: GdkAtom, iter: [*c]GtkTextIter, data: [*c]const guint8, length: gsize, @"error": [*c]([*c]GError)) gboolean;
pub const GTK_TEXT_WINDOW_PRIVATE = 0;
pub const GTK_TEXT_WINDOW_WIDGET = 1;
pub const GTK_TEXT_WINDOW_TEXT = 2;
pub const GTK_TEXT_WINDOW_LEFT = 3;
pub const GTK_TEXT_WINDOW_RIGHT = 4;
pub const GTK_TEXT_WINDOW_TOP = 5;
pub const GTK_TEXT_WINDOW_BOTTOM = 6;
pub const GtkTextWindowType = extern enum {
    GTK_TEXT_WINDOW_PRIVATE = 0,
    GTK_TEXT_WINDOW_WIDGET = 1,
    GTK_TEXT_WINDOW_TEXT = 2,
    GTK_TEXT_WINDOW_LEFT = 3,
    GTK_TEXT_WINDOW_RIGHT = 4,
    GTK_TEXT_WINDOW_TOP = 5,
    GTK_TEXT_WINDOW_BOTTOM = 6,
};
pub const GTK_TEXT_VIEW_LAYER_BELOW = 0;
pub const GTK_TEXT_VIEW_LAYER_ABOVE = 1;
pub const GTK_TEXT_VIEW_LAYER_BELOW_TEXT = 2;
pub const GTK_TEXT_VIEW_LAYER_ABOVE_TEXT = 3;
pub const GtkTextViewLayer = extern enum {
    GTK_TEXT_VIEW_LAYER_BELOW = 0,
    GTK_TEXT_VIEW_LAYER_ABOVE = 1,
    GTK_TEXT_VIEW_LAYER_BELOW_TEXT = 2,
    GTK_TEXT_VIEW_LAYER_ABOVE_TEXT = 3,
};
pub const GTK_TEXT_EXTEND_SELECTION_WORD = 0;
pub const GTK_TEXT_EXTEND_SELECTION_LINE = 1;
pub const GtkTextExtendSelection = extern enum {
    GTK_TEXT_EXTEND_SELECTION_WORD = 0,
    GTK_TEXT_EXTEND_SELECTION_LINE = 1,
};
pub const struct__GtkTextViewPrivate = @OpaqueType();
pub const GtkTextViewPrivate = struct__GtkTextViewPrivate;
pub const struct__GtkTextView = extern struct {
    parent_instance: GtkContainer,
    priv: ?*GtkTextViewPrivate,
};
pub const GtkTextView = struct__GtkTextView;
pub const struct__GtkTextViewClass = extern struct {
    parent_class: GtkContainerClass,
    populate_popup: ?extern fn ([*c]GtkTextView, [*c]GtkWidget) void,
    move_cursor: ?extern fn ([*c]GtkTextView, GtkMovementStep, gint, gboolean) void,
    set_anchor: ?extern fn ([*c]GtkTextView) void,
    insert_at_cursor: ?extern fn ([*c]GtkTextView, [*c]const gchar) void,
    delete_from_cursor: ?extern fn ([*c]GtkTextView, GtkDeleteType, gint) void,
    backspace: ?extern fn ([*c]GtkTextView) void,
    cut_clipboard: ?extern fn ([*c]GtkTextView) void,
    copy_clipboard: ?extern fn ([*c]GtkTextView) void,
    paste_clipboard: ?extern fn ([*c]GtkTextView) void,
    toggle_overwrite: ?extern fn ([*c]GtkTextView) void,
    create_buffer: ?extern fn ([*c]GtkTextView) [*c]GtkTextBuffer,
    draw_layer: ?extern fn ([*c]GtkTextView, GtkTextViewLayer, ?*cairo_t) void,
    extend_selection: ?extern fn ([*c]GtkTextView, GtkTextExtendSelection, [*c]const GtkTextIter, [*c]GtkTextIter, [*c]GtkTextIter) gboolean,
    insert_emoji: ?extern fn ([*c]GtkTextView) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkTextViewClass = struct__GtkTextViewClass;
pub extern fn gtk_text_view_get_type() GType;
pub extern fn gtk_text_view_new() [*c]GtkWidget;
pub extern fn gtk_text_view_new_with_buffer(buffer: [*c]GtkTextBuffer) [*c]GtkWidget;
pub extern fn gtk_text_view_set_buffer(text_view: [*c]GtkTextView, buffer: [*c]GtkTextBuffer) void;
pub extern fn gtk_text_view_get_buffer(text_view: [*c]GtkTextView) [*c]GtkTextBuffer;
pub extern fn gtk_text_view_scroll_to_iter(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter, within_margin: gdouble, use_align: gboolean, xalign: gdouble, yalign: gdouble) gboolean;
pub extern fn gtk_text_view_scroll_to_mark(text_view: [*c]GtkTextView, mark: [*c]GtkTextMark, within_margin: gdouble, use_align: gboolean, xalign: gdouble, yalign: gdouble) void;
pub extern fn gtk_text_view_scroll_mark_onscreen(text_view: [*c]GtkTextView, mark: [*c]GtkTextMark) void;
pub extern fn gtk_text_view_move_mark_onscreen(text_view: [*c]GtkTextView, mark: [*c]GtkTextMark) gboolean;
pub extern fn gtk_text_view_place_cursor_onscreen(text_view: [*c]GtkTextView) gboolean;
pub extern fn gtk_text_view_get_visible_rect(text_view: [*c]GtkTextView, visible_rect: [*c]GdkRectangle) void;
pub extern fn gtk_text_view_set_cursor_visible(text_view: [*c]GtkTextView, setting: gboolean) void;
pub extern fn gtk_text_view_get_cursor_visible(text_view: [*c]GtkTextView) gboolean;
pub extern fn gtk_text_view_reset_cursor_blink(text_view: [*c]GtkTextView) void;
pub extern fn gtk_text_view_get_cursor_locations(text_view: [*c]GtkTextView, iter: [*c]const GtkTextIter, strong: [*c]GdkRectangle, weak: [*c]GdkRectangle) void;
pub extern fn gtk_text_view_get_iter_location(text_view: [*c]GtkTextView, iter: [*c]const GtkTextIter, location: [*c]GdkRectangle) void;
pub extern fn gtk_text_view_get_iter_at_location(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter, x: gint, y: gint) gboolean;
pub extern fn gtk_text_view_get_iter_at_position(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter, trailing: [*c]gint, x: gint, y: gint) gboolean;
pub extern fn gtk_text_view_get_line_yrange(text_view: [*c]GtkTextView, iter: [*c]const GtkTextIter, y: [*c]gint, height: [*c]gint) void;
pub extern fn gtk_text_view_get_line_at_y(text_view: [*c]GtkTextView, target_iter: [*c]GtkTextIter, y: gint, line_top: [*c]gint) void;
pub extern fn gtk_text_view_buffer_to_window_coords(text_view: [*c]GtkTextView, win: GtkTextWindowType, buffer_x: gint, buffer_y: gint, window_x: [*c]gint, window_y: [*c]gint) void;
pub extern fn gtk_text_view_window_to_buffer_coords(text_view: [*c]GtkTextView, win: GtkTextWindowType, window_x: gint, window_y: gint, buffer_x: [*c]gint, buffer_y: [*c]gint) void;
pub extern fn gtk_text_view_get_hadjustment(text_view: [*c]GtkTextView) [*c]GtkAdjustment;
pub extern fn gtk_text_view_get_vadjustment(text_view: [*c]GtkTextView) [*c]GtkAdjustment;
pub extern fn gtk_text_view_get_window(text_view: [*c]GtkTextView, win: GtkTextWindowType) ?*GdkWindow;
pub extern fn gtk_text_view_get_window_type(text_view: [*c]GtkTextView, window: ?*GdkWindow) GtkTextWindowType;
pub extern fn gtk_text_view_set_border_window_size(text_view: [*c]GtkTextView, type_0: GtkTextWindowType, size: gint) void;
pub extern fn gtk_text_view_get_border_window_size(text_view: [*c]GtkTextView, type_0: GtkTextWindowType) gint;
pub extern fn gtk_text_view_forward_display_line(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_view_backward_display_line(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_view_forward_display_line_end(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_view_backward_display_line_start(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter) gboolean;
pub extern fn gtk_text_view_starts_display_line(text_view: [*c]GtkTextView, iter: [*c]const GtkTextIter) gboolean;
pub extern fn gtk_text_view_move_visually(text_view: [*c]GtkTextView, iter: [*c]GtkTextIter, count: gint) gboolean;
pub extern fn gtk_text_view_im_context_filter_keypress(text_view: [*c]GtkTextView, event: ?*GdkEventKey) gboolean;
pub extern fn gtk_text_view_reset_im_context(text_view: [*c]GtkTextView) void;
pub extern fn gtk_text_view_add_child_at_anchor(text_view: [*c]GtkTextView, child: [*c]GtkWidget, anchor: [*c]GtkTextChildAnchor) void;
pub extern fn gtk_text_view_add_child_in_window(text_view: [*c]GtkTextView, child: [*c]GtkWidget, which_window: GtkTextWindowType, xpos: gint, ypos: gint) void;
pub extern fn gtk_text_view_move_child(text_view: [*c]GtkTextView, child: [*c]GtkWidget, xpos: gint, ypos: gint) void;
pub extern fn gtk_text_view_set_wrap_mode(text_view: [*c]GtkTextView, wrap_mode: GtkWrapMode) void;
pub extern fn gtk_text_view_get_wrap_mode(text_view: [*c]GtkTextView) GtkWrapMode;
pub extern fn gtk_text_view_set_editable(text_view: [*c]GtkTextView, setting: gboolean) void;
pub extern fn gtk_text_view_get_editable(text_view: [*c]GtkTextView) gboolean;
pub extern fn gtk_text_view_set_overwrite(text_view: [*c]GtkTextView, overwrite: gboolean) void;
pub extern fn gtk_text_view_get_overwrite(text_view: [*c]GtkTextView) gboolean;
pub extern fn gtk_text_view_set_accepts_tab(text_view: [*c]GtkTextView, accepts_tab: gboolean) void;
pub extern fn gtk_text_view_get_accepts_tab(text_view: [*c]GtkTextView) gboolean;
pub extern fn gtk_text_view_set_pixels_above_lines(text_view: [*c]GtkTextView, pixels_above_lines: gint) void;
pub extern fn gtk_text_view_get_pixels_above_lines(text_view: [*c]GtkTextView) gint;
pub extern fn gtk_text_view_set_pixels_below_lines(text_view: [*c]GtkTextView, pixels_below_lines: gint) void;
pub extern fn gtk_text_view_get_pixels_below_lines(text_view: [*c]GtkTextView) gint;
pub extern fn gtk_text_view_set_pixels_inside_wrap(text_view: [*c]GtkTextView, pixels_inside_wrap: gint) void;
pub extern fn gtk_text_view_get_pixels_inside_wrap(text_view: [*c]GtkTextView) gint;
pub extern fn gtk_text_view_set_justification(text_view: [*c]GtkTextView, justification: GtkJustification) void;
pub extern fn gtk_text_view_get_justification(text_view: [*c]GtkTextView) GtkJustification;
pub extern fn gtk_text_view_set_left_margin(text_view: [*c]GtkTextView, left_margin: gint) void;
pub extern fn gtk_text_view_get_left_margin(text_view: [*c]GtkTextView) gint;
pub extern fn gtk_text_view_set_right_margin(text_view: [*c]GtkTextView, right_margin: gint) void;
pub extern fn gtk_text_view_get_right_margin(text_view: [*c]GtkTextView) gint;
pub extern fn gtk_text_view_set_top_margin(text_view: [*c]GtkTextView, top_margin: gint) void;
pub extern fn gtk_text_view_get_top_margin(text_view: [*c]GtkTextView) gint;
pub extern fn gtk_text_view_set_bottom_margin(text_view: [*c]GtkTextView, bottom_margin: gint) void;
pub extern fn gtk_text_view_get_bottom_margin(text_view: [*c]GtkTextView) gint;
pub extern fn gtk_text_view_set_indent(text_view: [*c]GtkTextView, indent: gint) void;
pub extern fn gtk_text_view_get_indent(text_view: [*c]GtkTextView) gint;
pub extern fn gtk_text_view_set_tabs(text_view: [*c]GtkTextView, tabs: ?*PangoTabArray) void;
pub extern fn gtk_text_view_get_tabs(text_view: [*c]GtkTextView) ?*PangoTabArray;
pub extern fn gtk_text_view_get_default_attributes(text_view: [*c]GtkTextView) ?*GtkTextAttributes;
pub extern fn gtk_text_view_set_input_purpose(text_view: [*c]GtkTextView, purpose: GtkInputPurpose) void;
pub extern fn gtk_text_view_get_input_purpose(text_view: [*c]GtkTextView) GtkInputPurpose;
pub extern fn gtk_text_view_set_input_hints(text_view: [*c]GtkTextView, hints: GtkInputHints) void;
pub extern fn gtk_text_view_get_input_hints(text_view: [*c]GtkTextView) GtkInputHints;
pub extern fn gtk_text_view_set_monospace(text_view: [*c]GtkTextView, monospace: gboolean) void;
pub extern fn gtk_text_view_get_monospace(text_view: [*c]GtkTextView) gboolean;
pub const GTK_TOOLBAR_SPACE_EMPTY = 0;
pub const GTK_TOOLBAR_SPACE_LINE = 1;
pub const GtkToolbarSpaceStyle = extern enum {
    GTK_TOOLBAR_SPACE_EMPTY = 0,
    GTK_TOOLBAR_SPACE_LINE = 1,
};
pub const struct__GtkToolbarPrivate = @OpaqueType();
pub const GtkToolbarPrivate = struct__GtkToolbarPrivate;
pub const struct__GtkToolbar = extern struct {
    container: GtkContainer,
    priv: ?*GtkToolbarPrivate,
};
pub const GtkToolbar = struct__GtkToolbar;
pub const struct__GtkToolbarClass = extern struct {
    parent_class: GtkContainerClass,
    orientation_changed: ?extern fn ([*c]GtkToolbar, GtkOrientation) void,
    style_changed: ?extern fn ([*c]GtkToolbar, GtkToolbarStyle) void,
    popup_context_menu: ?extern fn ([*c]GtkToolbar, gint, gint, gint) gboolean,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkToolbarClass = struct__GtkToolbarClass;
pub extern fn gtk_toolbar_get_type() GType;
pub extern fn gtk_toolbar_new() [*c]GtkWidget;
pub extern fn gtk_toolbar_insert(toolbar: [*c]GtkToolbar, item: [*c]GtkToolItem, pos: gint) void;
pub extern fn gtk_toolbar_get_item_index(toolbar: [*c]GtkToolbar, item: [*c]GtkToolItem) gint;
pub extern fn gtk_toolbar_get_n_items(toolbar: [*c]GtkToolbar) gint;
pub extern fn gtk_toolbar_get_nth_item(toolbar: [*c]GtkToolbar, n: gint) [*c]GtkToolItem;
pub extern fn gtk_toolbar_get_show_arrow(toolbar: [*c]GtkToolbar) gboolean;
pub extern fn gtk_toolbar_set_show_arrow(toolbar: [*c]GtkToolbar, show_arrow: gboolean) void;
pub extern fn gtk_toolbar_get_style(toolbar: [*c]GtkToolbar) GtkToolbarStyle;
pub extern fn gtk_toolbar_set_style(toolbar: [*c]GtkToolbar, style: GtkToolbarStyle) void;
pub extern fn gtk_toolbar_unset_style(toolbar: [*c]GtkToolbar) void;
pub extern fn gtk_toolbar_get_icon_size(toolbar: [*c]GtkToolbar) GtkIconSize;
pub extern fn gtk_toolbar_set_icon_size(toolbar: [*c]GtkToolbar, icon_size: GtkIconSize) void;
pub extern fn gtk_toolbar_unset_icon_size(toolbar: [*c]GtkToolbar) void;
pub extern fn gtk_toolbar_get_relief_style(toolbar: [*c]GtkToolbar) GtkReliefStyle;
pub extern fn gtk_toolbar_get_drop_index(toolbar: [*c]GtkToolbar, x: gint, y: gint) gint;
pub extern fn gtk_toolbar_set_drop_highlight_item(toolbar: [*c]GtkToolbar, tool_item: [*c]GtkToolItem, index_: gint) void;
pub const struct__GtkToolItemGroupPrivate = @OpaqueType();
pub const GtkToolItemGroupPrivate = struct__GtkToolItemGroupPrivate;
pub const struct__GtkToolItemGroup = extern struct {
    parent_instance: GtkContainer,
    priv: ?*GtkToolItemGroupPrivate,
};
pub const GtkToolItemGroup = struct__GtkToolItemGroup;
pub const struct__GtkToolItemGroupClass = extern struct {
    parent_class: GtkContainerClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkToolItemGroupClass = struct__GtkToolItemGroupClass;
pub extern fn gtk_tool_item_group_get_type() GType;
pub extern fn gtk_tool_item_group_new(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_tool_item_group_set_label(group: [*c]GtkToolItemGroup, label: [*c]const gchar) void;
pub extern fn gtk_tool_item_group_set_label_widget(group: [*c]GtkToolItemGroup, label_widget: [*c]GtkWidget) void;
pub extern fn gtk_tool_item_group_set_collapsed(group: [*c]GtkToolItemGroup, collapsed: gboolean) void;
pub extern fn gtk_tool_item_group_set_ellipsize(group: [*c]GtkToolItemGroup, ellipsize: PangoEllipsizeMode) void;
pub extern fn gtk_tool_item_group_set_header_relief(group: [*c]GtkToolItemGroup, style: GtkReliefStyle) void;
pub extern fn gtk_tool_item_group_get_label(group: [*c]GtkToolItemGroup) [*c]const gchar;
pub extern fn gtk_tool_item_group_get_label_widget(group: [*c]GtkToolItemGroup) [*c]GtkWidget;
pub extern fn gtk_tool_item_group_get_collapsed(group: [*c]GtkToolItemGroup) gboolean;
pub extern fn gtk_tool_item_group_get_ellipsize(group: [*c]GtkToolItemGroup) PangoEllipsizeMode;
pub extern fn gtk_tool_item_group_get_header_relief(group: [*c]GtkToolItemGroup) GtkReliefStyle;
pub extern fn gtk_tool_item_group_insert(group: [*c]GtkToolItemGroup, item: [*c]GtkToolItem, position: gint) void;
pub extern fn gtk_tool_item_group_set_item_position(group: [*c]GtkToolItemGroup, item: [*c]GtkToolItem, position: gint) void;
pub extern fn gtk_tool_item_group_get_item_position(group: [*c]GtkToolItemGroup, item: [*c]GtkToolItem) gint;
pub extern fn gtk_tool_item_group_get_n_items(group: [*c]GtkToolItemGroup) guint;
pub extern fn gtk_tool_item_group_get_nth_item(group: [*c]GtkToolItemGroup, index: guint) [*c]GtkToolItem;
pub extern fn gtk_tool_item_group_get_drop_item(group: [*c]GtkToolItemGroup, x: gint, y: gint) [*c]GtkToolItem;
pub const struct__GtkToolPalettePrivate = @OpaqueType();
pub const GtkToolPalettePrivate = struct__GtkToolPalettePrivate;
pub const struct__GtkToolPalette = extern struct {
    parent_instance: GtkContainer,
    priv: ?*GtkToolPalettePrivate,
};
pub const GtkToolPalette = struct__GtkToolPalette;
pub const struct__GtkToolPaletteClass = extern struct {
    parent_class: GtkContainerClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkToolPaletteClass = struct__GtkToolPaletteClass;
pub const GTK_TOOL_PALETTE_DRAG_ITEMS = 1;
pub const GTK_TOOL_PALETTE_DRAG_GROUPS = 2;
pub const GtkToolPaletteDragTargets = extern enum {
    GTK_TOOL_PALETTE_DRAG_ITEMS = 1,
    GTK_TOOL_PALETTE_DRAG_GROUPS = 2,
};
pub extern fn gtk_tool_palette_get_type() GType;
pub extern fn gtk_tool_palette_new() [*c]GtkWidget;
pub extern fn gtk_tool_palette_set_group_position(palette: [*c]GtkToolPalette, group: [*c]GtkToolItemGroup, position: gint) void;
pub extern fn gtk_tool_palette_set_exclusive(palette: [*c]GtkToolPalette, group: [*c]GtkToolItemGroup, exclusive: gboolean) void;
pub extern fn gtk_tool_palette_set_expand(palette: [*c]GtkToolPalette, group: [*c]GtkToolItemGroup, expand: gboolean) void;
pub extern fn gtk_tool_palette_get_group_position(palette: [*c]GtkToolPalette, group: [*c]GtkToolItemGroup) gint;
pub extern fn gtk_tool_palette_get_exclusive(palette: [*c]GtkToolPalette, group: [*c]GtkToolItemGroup) gboolean;
pub extern fn gtk_tool_palette_get_expand(palette: [*c]GtkToolPalette, group: [*c]GtkToolItemGroup) gboolean;
pub extern fn gtk_tool_palette_set_icon_size(palette: [*c]GtkToolPalette, icon_size: GtkIconSize) void;
pub extern fn gtk_tool_palette_unset_icon_size(palette: [*c]GtkToolPalette) void;
pub extern fn gtk_tool_palette_set_style(palette: [*c]GtkToolPalette, style: GtkToolbarStyle) void;
pub extern fn gtk_tool_palette_unset_style(palette: [*c]GtkToolPalette) void;
pub extern fn gtk_tool_palette_get_icon_size(palette: [*c]GtkToolPalette) GtkIconSize;
pub extern fn gtk_tool_palette_get_style(palette: [*c]GtkToolPalette) GtkToolbarStyle;
pub extern fn gtk_tool_palette_get_drop_item(palette: [*c]GtkToolPalette, x: gint, y: gint) [*c]GtkToolItem;
pub extern fn gtk_tool_palette_get_drop_group(palette: [*c]GtkToolPalette, x: gint, y: gint) [*c]GtkToolItemGroup;
pub extern fn gtk_tool_palette_get_drag_item(palette: [*c]GtkToolPalette, selection: ?*const GtkSelectionData) [*c]GtkWidget;
pub extern fn gtk_tool_palette_set_drag_source(palette: [*c]GtkToolPalette, targets: GtkToolPaletteDragTargets) void;
pub extern fn gtk_tool_palette_add_drag_dest(palette: [*c]GtkToolPalette, widget: [*c]GtkWidget, flags: GtkDestDefaults, targets: GtkToolPaletteDragTargets, actions: GdkDragAction) void;
pub extern fn gtk_tool_palette_get_hadjustment(palette: [*c]GtkToolPalette) [*c]GtkAdjustment;
pub extern fn gtk_tool_palette_get_vadjustment(palette: [*c]GtkToolPalette) [*c]GtkAdjustment;
pub extern fn gtk_tool_palette_get_drag_target_item() [*c]const GtkTargetEntry;
pub extern fn gtk_tool_palette_get_drag_target_group() [*c]const GtkTargetEntry;
pub const struct__GtkToolShell = @OpaqueType();
pub const GtkToolShell = struct__GtkToolShell;
pub const struct__GtkToolShellIface = extern struct {
    g_iface: GTypeInterface,
    get_icon_size: ?extern fn (?*GtkToolShell) GtkIconSize,
    get_orientation: ?extern fn (?*GtkToolShell) GtkOrientation,
    get_style: ?extern fn (?*GtkToolShell) GtkToolbarStyle,
    get_relief_style: ?extern fn (?*GtkToolShell) GtkReliefStyle,
    rebuild_menu: ?extern fn (?*GtkToolShell) void,
    get_text_orientation: ?extern fn (?*GtkToolShell) GtkOrientation,
    get_text_alignment: ?extern fn (?*GtkToolShell) gfloat,
    get_ellipsize_mode: ?extern fn (?*GtkToolShell) PangoEllipsizeMode,
    get_text_size_group: ?extern fn (?*GtkToolShell) [*c]GtkSizeGroup,
};
pub const GtkToolShellIface = struct__GtkToolShellIface;
pub extern fn gtk_tool_shell_get_type() GType;
pub extern fn gtk_tool_shell_get_icon_size(shell: ?*GtkToolShell) GtkIconSize;
pub extern fn gtk_tool_shell_get_orientation(shell: ?*GtkToolShell) GtkOrientation;
pub extern fn gtk_tool_shell_get_style(shell: ?*GtkToolShell) GtkToolbarStyle;
pub extern fn gtk_tool_shell_get_relief_style(shell: ?*GtkToolShell) GtkReliefStyle;
pub extern fn gtk_tool_shell_rebuild_menu(shell: ?*GtkToolShell) void;
pub extern fn gtk_tool_shell_get_text_orientation(shell: ?*GtkToolShell) GtkOrientation;
pub extern fn gtk_tool_shell_get_text_alignment(shell: ?*GtkToolShell) gfloat;
pub extern fn gtk_tool_shell_get_ellipsize_mode(shell: ?*GtkToolShell) PangoEllipsizeMode;
pub extern fn gtk_tool_shell_get_text_size_group(shell: ?*GtkToolShell) [*c]GtkSizeGroup;
pub extern fn gtk_test_init(argcp: [*c]c_int, argvp: [*c]([*c]([*c]u8)), ...) void;
pub extern fn gtk_test_register_all_types() void;
pub extern fn gtk_test_list_all_types(n_types: [*c]guint) [*c]const GType;
pub extern fn gtk_test_find_widget(widget: [*c]GtkWidget, label_pattern: [*c]const gchar, widget_type: GType) [*c]GtkWidget;
pub extern fn gtk_test_create_widget(widget_type: GType, first_property_name: [*c]const gchar, ...) [*c]GtkWidget;
pub extern fn gtk_test_create_simple_window(window_title: [*c]const gchar, dialog_text: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_test_display_button_window(window_title: [*c]const gchar, dialog_text: [*c]const gchar, ...) [*c]GtkWidget;
pub extern fn gtk_test_slider_set_perc(widget: [*c]GtkWidget, percentage: f64) void;
pub extern fn gtk_test_slider_get_value(widget: [*c]GtkWidget) f64;
pub extern fn gtk_test_spin_button_click(spinner: [*c]GtkSpinButton, button: guint, upwards: gboolean) gboolean;
pub extern fn gtk_test_widget_wait_for_draw(widget: [*c]GtkWidget) void;
pub extern fn gtk_test_widget_click(widget: [*c]GtkWidget, button: guint, modifiers: GdkModifierType) gboolean;
pub extern fn gtk_test_widget_send_key(widget: [*c]GtkWidget, keyval: guint, modifiers: GdkModifierType) gboolean;
pub extern fn gtk_test_text_set(widget: [*c]GtkWidget, string: [*c]const gchar) void;
pub extern fn gtk_test_text_get(widget: [*c]GtkWidget) [*c]gchar;
pub extern fn gtk_test_find_sibling(base_widget: [*c]GtkWidget, widget_type: GType) [*c]GtkWidget;
pub extern fn gtk_test_find_label(widget: [*c]GtkWidget, label_pattern: [*c]const gchar) [*c]GtkWidget;
pub const struct__GtkTreeDragSource = @OpaqueType();
pub const GtkTreeDragSource = struct__GtkTreeDragSource;
pub const struct__GtkTreeDragSourceIface = extern struct {
    g_iface: GTypeInterface,
    row_draggable: ?extern fn (?*GtkTreeDragSource, ?*GtkTreePath) gboolean,
    drag_data_get: ?extern fn (?*GtkTreeDragSource, ?*GtkTreePath, ?*GtkSelectionData) gboolean,
    drag_data_delete: ?extern fn (?*GtkTreeDragSource, ?*GtkTreePath) gboolean,
};
pub const GtkTreeDragSourceIface = struct__GtkTreeDragSourceIface;
pub extern fn gtk_tree_drag_source_get_type() GType;
pub extern fn gtk_tree_drag_source_row_draggable(drag_source: ?*GtkTreeDragSource, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_drag_source_drag_data_delete(drag_source: ?*GtkTreeDragSource, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_drag_source_drag_data_get(drag_source: ?*GtkTreeDragSource, path: ?*GtkTreePath, selection_data: ?*GtkSelectionData) gboolean;
pub const struct__GtkTreeDragDest = @OpaqueType();
pub const GtkTreeDragDest = struct__GtkTreeDragDest;
pub const struct__GtkTreeDragDestIface = extern struct {
    g_iface: GTypeInterface,
    drag_data_received: ?extern fn (?*GtkTreeDragDest, ?*GtkTreePath, ?*GtkSelectionData) gboolean,
    row_drop_possible: ?extern fn (?*GtkTreeDragDest, ?*GtkTreePath, ?*GtkSelectionData) gboolean,
};
pub const GtkTreeDragDestIface = struct__GtkTreeDragDestIface;
pub extern fn gtk_tree_drag_dest_get_type() GType;
pub extern fn gtk_tree_drag_dest_drag_data_received(drag_dest: ?*GtkTreeDragDest, dest: ?*GtkTreePath, selection_data: ?*GtkSelectionData) gboolean;
pub extern fn gtk_tree_drag_dest_row_drop_possible(drag_dest: ?*GtkTreeDragDest, dest_path: ?*GtkTreePath, selection_data: ?*GtkSelectionData) gboolean;
pub extern fn gtk_tree_set_row_drag_data(selection_data: ?*GtkSelectionData, tree_model: ?*GtkTreeModel, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_get_row_drag_data(selection_data: ?*GtkSelectionData, tree_model: [*c](?*GtkTreeModel), path: [*c](?*GtkTreePath)) gboolean;
pub const struct__GtkTreeModelSortPrivate = @OpaqueType();
pub const GtkTreeModelSortPrivate = struct__GtkTreeModelSortPrivate;
pub const struct__GtkTreeModelSort = extern struct {
    parent: GObject,
    priv: ?*GtkTreeModelSortPrivate,
};
pub const GtkTreeModelSort = struct__GtkTreeModelSort;
pub const struct__GtkTreeModelSortClass = extern struct {
    parent_class: GObjectClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkTreeModelSortClass = struct__GtkTreeModelSortClass;
pub extern fn gtk_tree_model_sort_get_type() GType;
pub extern fn gtk_tree_model_sort_new_with_model(child_model: ?*GtkTreeModel) ?*GtkTreeModel;
pub extern fn gtk_tree_model_sort_get_model(tree_model: [*c]GtkTreeModelSort) ?*GtkTreeModel;
pub extern fn gtk_tree_model_sort_convert_child_path_to_path(tree_model_sort: [*c]GtkTreeModelSort, child_path: ?*GtkTreePath) ?*GtkTreePath;
pub extern fn gtk_tree_model_sort_convert_child_iter_to_iter(tree_model_sort: [*c]GtkTreeModelSort, sort_iter: [*c]GtkTreeIter, child_iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_model_sort_convert_path_to_child_path(tree_model_sort: [*c]GtkTreeModelSort, sorted_path: ?*GtkTreePath) ?*GtkTreePath;
pub extern fn gtk_tree_model_sort_convert_iter_to_child_iter(tree_model_sort: [*c]GtkTreeModelSort, child_iter: [*c]GtkTreeIter, sorted_iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_model_sort_reset_default_sort_func(tree_model_sort: [*c]GtkTreeModelSort) void;
pub extern fn gtk_tree_model_sort_clear_cache(tree_model_sort: [*c]GtkTreeModelSort) void;
pub extern fn gtk_tree_model_sort_iter_is_valid(tree_model_sort: [*c]GtkTreeModelSort, iter: [*c]GtkTreeIter) gboolean;
pub const GtkTreeSelectionFunc = ?extern fn ([*c]GtkTreeSelection, ?*GtkTreeModel, ?*GtkTreePath, gboolean, gpointer) gboolean;
pub const GtkTreeSelectionForeachFunc = ?extern fn (?*GtkTreeModel, ?*GtkTreePath, [*c]GtkTreeIter, gpointer) void;
pub extern fn gtk_tree_selection_get_type() GType;
pub extern fn gtk_tree_selection_set_mode(selection: [*c]GtkTreeSelection, type_0: GtkSelectionMode) void;
pub extern fn gtk_tree_selection_get_mode(selection: [*c]GtkTreeSelection) GtkSelectionMode;
pub extern fn gtk_tree_selection_set_select_function(selection: [*c]GtkTreeSelection, func: GtkTreeSelectionFunc, data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_tree_selection_get_user_data(selection: [*c]GtkTreeSelection) gpointer;
pub extern fn gtk_tree_selection_get_tree_view(selection: [*c]GtkTreeSelection) [*c]GtkTreeView;
pub extern fn gtk_tree_selection_get_select_function(selection: [*c]GtkTreeSelection) GtkTreeSelectionFunc;
pub extern fn gtk_tree_selection_get_selected(selection: [*c]GtkTreeSelection, model: [*c](?*GtkTreeModel), iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_selection_get_selected_rows(selection: [*c]GtkTreeSelection, model: [*c](?*GtkTreeModel)) [*c]GList;
pub extern fn gtk_tree_selection_count_selected_rows(selection: [*c]GtkTreeSelection) gint;
pub extern fn gtk_tree_selection_selected_foreach(selection: [*c]GtkTreeSelection, func: GtkTreeSelectionForeachFunc, data: gpointer) void;
pub extern fn gtk_tree_selection_select_path(selection: [*c]GtkTreeSelection, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_selection_unselect_path(selection: [*c]GtkTreeSelection, path: ?*GtkTreePath) void;
pub extern fn gtk_tree_selection_select_iter(selection: [*c]GtkTreeSelection, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_selection_unselect_iter(selection: [*c]GtkTreeSelection, iter: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_selection_path_is_selected(selection: [*c]GtkTreeSelection, path: ?*GtkTreePath) gboolean;
pub extern fn gtk_tree_selection_iter_is_selected(selection: [*c]GtkTreeSelection, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_selection_select_all(selection: [*c]GtkTreeSelection) void;
pub extern fn gtk_tree_selection_unselect_all(selection: [*c]GtkTreeSelection) void;
pub extern fn gtk_tree_selection_select_range(selection: [*c]GtkTreeSelection, start_path: ?*GtkTreePath, end_path: ?*GtkTreePath) void;
pub extern fn gtk_tree_selection_unselect_range(selection: [*c]GtkTreeSelection, start_path: ?*GtkTreePath, end_path: ?*GtkTreePath) void;
pub const struct__GtkTreeStorePrivate = @OpaqueType();
pub const GtkTreeStorePrivate = struct__GtkTreeStorePrivate;
pub const struct__GtkTreeStore = extern struct {
    parent: GObject,
    priv: ?*GtkTreeStorePrivate,
};
pub const GtkTreeStore = struct__GtkTreeStore;
pub const struct__GtkTreeStoreClass = extern struct {
    parent_class: GObjectClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkTreeStoreClass = struct__GtkTreeStoreClass;
pub extern fn gtk_tree_store_get_type() GType;
pub extern fn gtk_tree_store_new(n_columns: gint, ...) [*c]GtkTreeStore;
pub extern fn gtk_tree_store_newv(n_columns: gint, types: [*c]GType) [*c]GtkTreeStore;
pub extern fn gtk_tree_store_set_column_types(tree_store: [*c]GtkTreeStore, n_columns: gint, types: [*c]GType) void;
pub extern fn gtk_tree_store_set_value(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, column: gint, value: [*c]GValue) void;
pub extern fn gtk_tree_store_set(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, ...) void;
pub extern fn gtk_tree_store_set_valuesv(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, columns: [*c]gint, values: [*c]GValue, n_values: gint) void;
pub extern fn gtk_tree_store_set_valist(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, var_args: va_list) void;
pub extern fn gtk_tree_store_remove(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_store_insert(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter, position: gint) void;
pub extern fn gtk_tree_store_insert_before(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter, sibling: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_store_insert_after(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter, sibling: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_store_insert_with_values(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter, position: gint, ...) void;
pub extern fn gtk_tree_store_insert_with_valuesv(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter, position: gint, columns: [*c]gint, values: [*c]GValue, n_values: gint) void;
pub extern fn gtk_tree_store_prepend(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_store_append(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, parent: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_store_is_ancestor(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, descendant: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_store_iter_depth(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter) gint;
pub extern fn gtk_tree_store_clear(tree_store: [*c]GtkTreeStore) void;
pub extern fn gtk_tree_store_iter_is_valid(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter) gboolean;
pub extern fn gtk_tree_store_reorder(tree_store: [*c]GtkTreeStore, parent: [*c]GtkTreeIter, new_order: [*c]gint) void;
pub extern fn gtk_tree_store_swap(tree_store: [*c]GtkTreeStore, a: [*c]GtkTreeIter, b: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_store_move_before(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, position: [*c]GtkTreeIter) void;
pub extern fn gtk_tree_store_move_after(tree_store: [*c]GtkTreeStore, iter: [*c]GtkTreeIter, position: [*c]GtkTreeIter) void;
pub extern fn gtk_rc_flags_get_type() GType;
pub extern fn gtk_rc_token_type_get_type() GType;
pub extern fn gtk_path_priority_type_get_type() GType;
pub extern fn gtk_path_type_get_type() GType;
pub extern fn gtk_expander_style_get_type() GType;
pub extern fn gtk_attach_options_get_type() GType;
pub extern fn gtk_ui_manager_item_type_get_type() GType;
pub extern fn gtk_license_get_type() GType;
pub extern fn gtk_accel_flags_get_type() GType;
pub extern fn gtk_application_inhibit_flags_get_type() GType;
pub extern fn gtk_assistant_page_type_get_type() GType;
pub extern fn gtk_button_box_style_get_type() GType;
pub extern fn gtk_builder_error_get_type() GType;
pub extern fn gtk_calendar_display_options_get_type() GType;
pub extern fn gtk_cell_renderer_state_get_type() GType;
pub extern fn gtk_cell_renderer_mode_get_type() GType;
pub extern fn gtk_cell_renderer_accel_mode_get_type() GType;
pub extern fn gtk_resize_mode_get_type() GType;
pub extern fn gtk_css_provider_error_get_type() GType;
pub extern fn gtk_css_section_type_get_type() GType;
pub extern fn gtk_debug_flag_get_type() GType;
pub extern fn gtk_dialog_flags_get_type() GType;
pub extern fn gtk_response_type_get_type() GType;
pub extern fn gtk_dest_defaults_get_type() GType;
pub extern fn gtk_entry_icon_position_get_type() GType;
pub extern fn gtk_align_get_type() GType;
pub extern fn gtk_arrow_type_get_type() GType;
pub extern fn gtk_baseline_position_get_type() GType;
pub extern fn gtk_delete_type_get_type() GType;
pub extern fn gtk_direction_type_get_type() GType;
pub extern fn gtk_icon_size_get_type() GType;
pub extern fn gtk_sensitivity_type_get_type() GType;
pub extern fn gtk_text_direction_get_type() GType;
pub extern fn gtk_justification_get_type() GType;
pub extern fn gtk_menu_direction_type_get_type() GType;
pub extern fn gtk_message_type_get_type() GType;
pub extern fn gtk_movement_step_get_type() GType;
pub extern fn gtk_scroll_step_get_type() GType;
pub extern fn gtk_orientation_get_type() GType;
pub extern fn gtk_pack_type_get_type() GType;
pub extern fn gtk_position_type_get_type() GType;
pub extern fn gtk_relief_style_get_type() GType;
pub extern fn gtk_scroll_type_get_type() GType;
pub extern fn gtk_selection_mode_get_type() GType;
pub extern fn gtk_shadow_type_get_type() GType;
pub extern fn gtk_state_type_get_type() GType;
pub extern fn gtk_toolbar_style_get_type() GType;
pub extern fn gtk_wrap_mode_get_type() GType;
pub extern fn gtk_sort_type_get_type() GType;
pub extern fn gtk_im_preedit_style_get_type() GType;
pub extern fn gtk_im_status_style_get_type() GType;
pub extern fn gtk_pack_direction_get_type() GType;
pub extern fn gtk_print_pages_get_type() GType;
pub extern fn gtk_page_set_get_type() GType;
pub extern fn gtk_number_up_layout_get_type() GType;
pub extern fn gtk_page_orientation_get_type() GType;
pub extern fn gtk_print_quality_get_type() GType;
pub extern fn gtk_print_duplex_get_type() GType;
pub extern fn gtk_unit_get_type() GType;
pub extern fn gtk_tree_view_grid_lines_get_type() GType;
pub extern fn gtk_drag_result_get_type() GType;
pub extern fn gtk_size_group_mode_get_type() GType;
pub extern fn gtk_size_request_mode_get_type() GType;
pub extern fn gtk_scrollable_policy_get_type() GType;
pub extern fn gtk_state_flags_get_type() GType;
pub extern fn gtk_region_flags_get_type() GType;
pub extern fn gtk_junction_sides_get_type() GType;
pub extern fn gtk_border_style_get_type() GType;
pub extern fn gtk_level_bar_mode_get_type() GType;
pub extern fn gtk_input_purpose_get_type() GType;
pub extern fn gtk_input_hints_get_type() GType;
pub extern fn gtk_propagation_phase_get_type() GType;
pub extern fn gtk_event_sequence_state_get_type() GType;
pub extern fn gtk_pan_direction_get_type() GType;
pub extern fn gtk_popover_constraint_get_type() GType;
pub extern fn gtk_event_controller_scroll_flags_get_type() GType;
pub extern fn gtk_file_chooser_action_get_type() GType;
pub extern fn gtk_file_chooser_confirmation_get_type() GType;
pub extern fn gtk_file_chooser_error_get_type() GType;
pub extern fn gtk_file_filter_flags_get_type() GType;
pub extern fn gtk_font_chooser_level_get_type() GType;
pub extern fn gtk_icon_lookup_flags_get_type() GType;
pub extern fn gtk_icon_theme_error_get_type() GType;
pub extern fn gtk_icon_view_drop_position_get_type() GType;
pub extern fn gtk_image_type_get_type() GType;
pub extern fn gtk_arrow_placement_get_type() GType;
pub extern fn gtk_buttons_type_get_type() GType;
pub extern fn gtk_button_role_get_type() GType;
pub extern fn gtk_notebook_tab_get_type() GType;
pub extern fn gtk_pad_action_type_get_type() GType;
pub extern fn gtk_places_open_flags_get_type() GType;
pub extern fn gtk_print_status_get_type() GType;
pub extern fn gtk_print_operation_result_get_type() GType;
pub extern fn gtk_print_operation_action_get_type() GType;
pub extern fn gtk_print_error_get_type() GType;
pub extern fn gtk_recent_sort_type_get_type() GType;
pub extern fn gtk_recent_chooser_error_get_type() GType;
pub extern fn gtk_recent_filter_flags_get_type() GType;
pub extern fn gtk_recent_manager_error_get_type() GType;
pub extern fn gtk_revealer_transition_type_get_type() GType;
pub extern fn gtk_corner_type_get_type() GType;
pub extern fn gtk_policy_type_get_type() GType;
pub extern fn gtk_target_flags_get_type() GType;
pub extern fn gtk_shortcut_type_get_type() GType;
pub extern fn gtk_spin_button_update_policy_get_type() GType;
pub extern fn gtk_spin_type_get_type() GType;
pub extern fn gtk_stack_transition_type_get_type() GType;
pub extern fn gtk_style_context_print_flags_get_type() GType;
pub extern fn gtk_text_buffer_target_info_get_type() GType;
pub extern fn gtk_text_search_flags_get_type() GType;
pub extern fn gtk_text_window_type_get_type() GType;
pub extern fn gtk_text_view_layer_get_type() GType;
pub extern fn gtk_text_extend_selection_get_type() GType;
pub extern fn gtk_toolbar_space_style_get_type() GType;
pub extern fn gtk_tool_palette_drag_targets_get_type() GType;
pub extern fn gtk_tree_model_flags_get_type() GType;
pub extern fn gtk_tree_view_drop_position_get_type() GType;
pub extern fn gtk_tree_view_column_sizing_get_type() GType;
pub extern fn gtk_widget_help_type_get_type() GType;
pub extern fn gtk_window_type_get_type() GType;
pub extern fn gtk_window_position_get_type() GType;
pub const struct__GtkViewportPrivate = @OpaqueType();
pub const GtkViewportPrivate = struct__GtkViewportPrivate;
pub const struct__GtkViewport = extern struct {
    bin: GtkBin,
    priv: ?*GtkViewportPrivate,
};
pub const GtkViewport = struct__GtkViewport;
pub const struct__GtkViewportClass = extern struct {
    parent_class: GtkBinClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkViewportClass = struct__GtkViewportClass;
pub extern fn gtk_viewport_get_type() GType;
pub extern fn gtk_viewport_new(hadjustment: [*c]GtkAdjustment, vadjustment: [*c]GtkAdjustment) [*c]GtkWidget;
pub extern fn gtk_viewport_get_hadjustment(viewport: [*c]GtkViewport) [*c]GtkAdjustment;
pub extern fn gtk_viewport_get_vadjustment(viewport: [*c]GtkViewport) [*c]GtkAdjustment;
pub extern fn gtk_viewport_set_hadjustment(viewport: [*c]GtkViewport, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_viewport_set_vadjustment(viewport: [*c]GtkViewport, adjustment: [*c]GtkAdjustment) void;
pub extern fn gtk_viewport_set_shadow_type(viewport: [*c]GtkViewport, type_0: GtkShadowType) void;
pub extern fn gtk_viewport_get_shadow_type(viewport: [*c]GtkViewport) GtkShadowType;
pub extern fn gtk_viewport_get_bin_window(viewport: [*c]GtkViewport) ?*GdkWindow;
pub extern fn gtk_viewport_get_view_window(viewport: [*c]GtkViewport) ?*GdkWindow;
pub const struct__GtkVolumeButton = extern struct {
    parent: GtkScaleButton,
};
pub const GtkVolumeButton = struct__GtkVolumeButton;
pub const struct__GtkVolumeButtonClass = extern struct {
    parent_class: GtkScaleButtonClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkVolumeButtonClass = struct__GtkVolumeButtonClass;
pub extern fn gtk_volume_button_get_type() GType;
pub extern fn gtk_volume_button_new() [*c]GtkWidget;
pub extern fn gtk_widget_path_get_type() GType;
pub extern fn gtk_widget_path_new() ?*GtkWidgetPath;
pub extern fn gtk_widget_path_copy(path: ?*const GtkWidgetPath) ?*GtkWidgetPath;
pub extern fn gtk_widget_path_ref(path: ?*GtkWidgetPath) ?*GtkWidgetPath;
pub extern fn gtk_widget_path_unref(path: ?*GtkWidgetPath) void;
pub extern fn gtk_widget_path_free(path: ?*GtkWidgetPath) void;
pub extern fn gtk_widget_path_to_string(path: ?*const GtkWidgetPath) [*c]u8;
pub extern fn gtk_widget_path_length(path: ?*const GtkWidgetPath) gint;
pub extern fn gtk_widget_path_append_type(path: ?*GtkWidgetPath, type_0: GType) gint;
pub extern fn gtk_widget_path_prepend_type(path: ?*GtkWidgetPath, type_0: GType) void;
pub extern fn gtk_widget_path_append_with_siblings(path: ?*GtkWidgetPath, siblings: ?*GtkWidgetPath, sibling_index: guint) gint;
pub extern fn gtk_widget_path_append_for_widget(path: ?*GtkWidgetPath, widget: [*c]GtkWidget) gint;
pub extern fn gtk_widget_path_iter_get_object_type(path: ?*const GtkWidgetPath, pos: gint) GType;
pub extern fn gtk_widget_path_iter_set_object_type(path: ?*GtkWidgetPath, pos: gint, type_0: GType) void;
pub extern fn gtk_widget_path_iter_get_object_name(path: ?*const GtkWidgetPath, pos: gint) [*c]const u8;
pub extern fn gtk_widget_path_iter_set_object_name(path: ?*GtkWidgetPath, pos: gint, name: [*c]const u8) void;
pub extern fn gtk_widget_path_iter_get_siblings(path: ?*const GtkWidgetPath, pos: gint) ?*const GtkWidgetPath;
pub extern fn gtk_widget_path_iter_get_sibling_index(path: ?*const GtkWidgetPath, pos: gint) guint;
pub extern fn gtk_widget_path_iter_get_name(path: ?*const GtkWidgetPath, pos: gint) [*c]const gchar;
pub extern fn gtk_widget_path_iter_set_name(path: ?*GtkWidgetPath, pos: gint, name: [*c]const gchar) void;
pub extern fn gtk_widget_path_iter_has_name(path: ?*const GtkWidgetPath, pos: gint, name: [*c]const gchar) gboolean;
pub extern fn gtk_widget_path_iter_has_qname(path: ?*const GtkWidgetPath, pos: gint, qname: GQuark) gboolean;
pub extern fn gtk_widget_path_iter_get_state(path: ?*const GtkWidgetPath, pos: gint) GtkStateFlags;
pub extern fn gtk_widget_path_iter_set_state(path: ?*GtkWidgetPath, pos: gint, state: GtkStateFlags) void;
pub extern fn gtk_widget_path_iter_add_class(path: ?*GtkWidgetPath, pos: gint, name: [*c]const gchar) void;
pub extern fn gtk_widget_path_iter_remove_class(path: ?*GtkWidgetPath, pos: gint, name: [*c]const gchar) void;
pub extern fn gtk_widget_path_iter_clear_classes(path: ?*GtkWidgetPath, pos: gint) void;
pub extern fn gtk_widget_path_iter_list_classes(path: ?*const GtkWidgetPath, pos: gint) [*c]GSList;
pub extern fn gtk_widget_path_iter_has_class(path: ?*const GtkWidgetPath, pos: gint, name: [*c]const gchar) gboolean;
pub extern fn gtk_widget_path_iter_has_qclass(path: ?*const GtkWidgetPath, pos: gint, qname: GQuark) gboolean;
pub extern fn gtk_widget_path_iter_add_region(path: ?*GtkWidgetPath, pos: gint, name: [*c]const gchar, flags: GtkRegionFlags) void;
pub extern fn gtk_widget_path_iter_remove_region(path: ?*GtkWidgetPath, pos: gint, name: [*c]const gchar) void;
pub extern fn gtk_widget_path_iter_clear_regions(path: ?*GtkWidgetPath, pos: gint) void;
pub extern fn gtk_widget_path_iter_list_regions(path: ?*const GtkWidgetPath, pos: gint) [*c]GSList;
pub extern fn gtk_widget_path_iter_has_region(path: ?*const GtkWidgetPath, pos: gint, name: [*c]const gchar, flags: [*c]GtkRegionFlags) gboolean;
pub extern fn gtk_widget_path_iter_has_qregion(path: ?*const GtkWidgetPath, pos: gint, qname: GQuark, flags: [*c]GtkRegionFlags) gboolean;
pub extern fn gtk_widget_path_get_object_type(path: ?*const GtkWidgetPath) GType;
pub extern fn gtk_widget_path_is_type(path: ?*const GtkWidgetPath, type_0: GType) gboolean;
pub extern fn gtk_widget_path_has_parent(path: ?*const GtkWidgetPath, type_0: GType) gboolean;
pub extern fn gtk_window_group_get_type() GType;
pub extern fn gtk_window_group_new() [*c]GtkWindowGroup;
pub extern fn gtk_window_group_add_window(window_group: [*c]GtkWindowGroup, window: [*c]GtkWindow) void;
pub extern fn gtk_window_group_remove_window(window_group: [*c]GtkWindowGroup, window: [*c]GtkWindow) void;
pub extern fn gtk_window_group_list_windows(window_group: [*c]GtkWindowGroup) [*c]GList;
pub extern fn gtk_window_group_get_current_grab(window_group: [*c]GtkWindowGroup) [*c]GtkWidget;
pub extern fn gtk_window_group_get_current_device_grab(window_group: [*c]GtkWindowGroup, device: ?*GdkDevice) [*c]GtkWidget;
pub const struct__GtkArrowPrivate = @OpaqueType();
pub const GtkArrowPrivate = struct__GtkArrowPrivate;
pub const struct__GtkArrow = extern struct {
    misc: GtkMisc,
    priv: ?*GtkArrowPrivate,
};
pub const GtkArrow = struct__GtkArrow;
pub const struct__GtkArrowClass = extern struct {
    parent_class: GtkMiscClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkArrowClass = struct__GtkArrowClass;
pub extern fn gtk_arrow_get_type() GType;
pub extern fn gtk_arrow_new(arrow_type: GtkArrowType, shadow_type: GtkShadowType) [*c]GtkWidget;
pub extern fn gtk_arrow_set(arrow: [*c]GtkArrow, arrow_type: GtkArrowType, shadow_type: GtkShadowType) void;
pub const struct__GtkActionPrivate = @OpaqueType();
pub const GtkActionPrivate = struct__GtkActionPrivate;
pub const struct__GtkAction = extern struct {
    object: GObject,
    private_data: ?*GtkActionPrivate,
};
pub const GtkAction = struct__GtkAction;
pub const struct__GtkActionClass = extern struct {
    parent_class: GObjectClass,
    activate: ?extern fn ([*c]GtkAction) void,
    menu_item_type: GType,
    toolbar_item_type: GType,
    create_menu_item: ?extern fn ([*c]GtkAction) [*c]GtkWidget,
    create_tool_item: ?extern fn ([*c]GtkAction) [*c]GtkWidget,
    connect_proxy: ?extern fn ([*c]GtkAction, [*c]GtkWidget) void,
    disconnect_proxy: ?extern fn ([*c]GtkAction, [*c]GtkWidget) void,
    create_menu: ?extern fn ([*c]GtkAction) [*c]GtkWidget,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkActionClass = struct__GtkActionClass;
pub extern fn gtk_action_get_type() GType;
pub extern fn gtk_action_new(name: [*c]const gchar, label: [*c]const gchar, tooltip: [*c]const gchar, stock_id: [*c]const gchar) [*c]GtkAction;
pub extern fn gtk_action_get_name(action: [*c]GtkAction) [*c]const gchar;
pub extern fn gtk_action_is_sensitive(action: [*c]GtkAction) gboolean;
pub extern fn gtk_action_get_sensitive(action: [*c]GtkAction) gboolean;
pub extern fn gtk_action_set_sensitive(action: [*c]GtkAction, sensitive: gboolean) void;
pub extern fn gtk_action_is_visible(action: [*c]GtkAction) gboolean;
pub extern fn gtk_action_get_visible(action: [*c]GtkAction) gboolean;
pub extern fn gtk_action_set_visible(action: [*c]GtkAction, visible: gboolean) void;
pub extern fn gtk_action_activate(action: [*c]GtkAction) void;
pub extern fn gtk_action_create_icon(action: [*c]GtkAction, icon_size: GtkIconSize) [*c]GtkWidget;
pub extern fn gtk_action_create_menu_item(action: [*c]GtkAction) [*c]GtkWidget;
pub extern fn gtk_action_create_tool_item(action: [*c]GtkAction) [*c]GtkWidget;
pub extern fn gtk_action_create_menu(action: [*c]GtkAction) [*c]GtkWidget;
pub extern fn gtk_action_get_proxies(action: [*c]GtkAction) [*c]GSList;
pub extern fn gtk_action_connect_accelerator(action: [*c]GtkAction) void;
pub extern fn gtk_action_disconnect_accelerator(action: [*c]GtkAction) void;
pub extern fn gtk_action_get_accel_path(action: [*c]GtkAction) [*c]const gchar;
pub extern fn gtk_action_get_accel_closure(action: [*c]GtkAction) ?*GClosure;
pub extern fn gtk_action_block_activate(action: [*c]GtkAction) void;
pub extern fn gtk_action_unblock_activate(action: [*c]GtkAction) void;
pub extern fn _gtk_action_add_to_proxy_list(action: [*c]GtkAction, proxy: [*c]GtkWidget) void;
pub extern fn _gtk_action_remove_from_proxy_list(action: [*c]GtkAction, proxy: [*c]GtkWidget) void;
pub extern fn _gtk_action_emit_activate(action: [*c]GtkAction) void;
pub extern fn gtk_action_set_accel_path(action: [*c]GtkAction, accel_path: [*c]const gchar) void;
pub extern fn gtk_action_set_accel_group(action: [*c]GtkAction, accel_group: [*c]GtkAccelGroup) void;
pub extern fn _gtk_action_sync_menu_visible(action: [*c]GtkAction, proxy: [*c]GtkWidget, empty: gboolean) void;
pub extern fn gtk_action_set_label(action: [*c]GtkAction, label: [*c]const gchar) void;
pub extern fn gtk_action_get_label(action: [*c]GtkAction) [*c]const gchar;
pub extern fn gtk_action_set_short_label(action: [*c]GtkAction, short_label: [*c]const gchar) void;
pub extern fn gtk_action_get_short_label(action: [*c]GtkAction) [*c]const gchar;
pub extern fn gtk_action_set_tooltip(action: [*c]GtkAction, tooltip: [*c]const gchar) void;
pub extern fn gtk_action_get_tooltip(action: [*c]GtkAction) [*c]const gchar;
pub extern fn gtk_action_set_stock_id(action: [*c]GtkAction, stock_id: [*c]const gchar) void;
pub extern fn gtk_action_get_stock_id(action: [*c]GtkAction) [*c]const gchar;
pub extern fn gtk_action_set_gicon(action: [*c]GtkAction, icon: ?*GIcon) void;
pub extern fn gtk_action_get_gicon(action: [*c]GtkAction) ?*GIcon;
pub extern fn gtk_action_set_icon_name(action: [*c]GtkAction, icon_name: [*c]const gchar) void;
pub extern fn gtk_action_get_icon_name(action: [*c]GtkAction) [*c]const gchar;
pub extern fn gtk_action_set_visible_horizontal(action: [*c]GtkAction, visible_horizontal: gboolean) void;
pub extern fn gtk_action_get_visible_horizontal(action: [*c]GtkAction) gboolean;
pub extern fn gtk_action_set_visible_vertical(action: [*c]GtkAction, visible_vertical: gboolean) void;
pub extern fn gtk_action_get_visible_vertical(action: [*c]GtkAction) gboolean;
pub extern fn gtk_action_set_is_important(action: [*c]GtkAction, is_important: gboolean) void;
pub extern fn gtk_action_get_is_important(action: [*c]GtkAction) gboolean;
pub extern fn gtk_action_set_always_show_image(action: [*c]GtkAction, always_show: gboolean) void;
pub extern fn gtk_action_get_always_show_image(action: [*c]GtkAction) gboolean;
pub const struct__GtkActivatable = @OpaqueType();
pub const GtkActivatable = struct__GtkActivatable;
pub const struct__GtkActivatableIface = extern struct {
    g_iface: GTypeInterface,
    update: ?extern fn (?*GtkActivatable, [*c]GtkAction, [*c]const gchar) void,
    sync_action_properties: ?extern fn (?*GtkActivatable, [*c]GtkAction) void,
};
pub const GtkActivatableIface = struct__GtkActivatableIface;
pub extern fn gtk_activatable_get_type() GType;
pub extern fn gtk_activatable_sync_action_properties(activatable: ?*GtkActivatable, action: [*c]GtkAction) void;
pub extern fn gtk_activatable_set_related_action(activatable: ?*GtkActivatable, action: [*c]GtkAction) void;
pub extern fn gtk_activatable_get_related_action(activatable: ?*GtkActivatable) [*c]GtkAction;
pub extern fn gtk_activatable_set_use_action_appearance(activatable: ?*GtkActivatable, use_appearance: gboolean) void;
pub extern fn gtk_activatable_get_use_action_appearance(activatable: ?*GtkActivatable) gboolean;
pub extern fn gtk_activatable_do_set_related_action(activatable: ?*GtkActivatable, action: [*c]GtkAction) void;
pub const GtkTranslateFunc = ?extern fn ([*c]const gchar, gpointer) [*c]gchar;
pub const struct__GtkStockItem = extern struct {
    stock_id: [*c]gchar,
    label: [*c]gchar,
    modifier: GdkModifierType,
    keyval: guint,
    translation_domain: [*c]gchar,
};
pub const GtkStockItem = struct__GtkStockItem;
pub extern fn gtk_stock_add(items: [*c]const GtkStockItem, n_items: guint) void;
pub extern fn gtk_stock_add_static(items: [*c]const GtkStockItem, n_items: guint) void;
pub extern fn gtk_stock_lookup(stock_id: [*c]const gchar, item: [*c]GtkStockItem) gboolean;
pub extern fn gtk_stock_list_ids() [*c]GSList;
pub extern fn gtk_stock_item_copy(item: [*c]const GtkStockItem) [*c]GtkStockItem;
pub extern fn gtk_stock_item_free(item: [*c]GtkStockItem) void;
pub extern fn gtk_stock_set_translate_func(domain: [*c]const gchar, func: GtkTranslateFunc, data: gpointer, notify: GDestroyNotify) void;
pub const GtkStock = [*c]u8;
pub const struct__GtkActionGroupPrivate = @OpaqueType();
pub const GtkActionGroupPrivate = struct__GtkActionGroupPrivate;
pub const struct__GtkActionGroup = extern struct {
    parent: GObject,
    priv: ?*GtkActionGroupPrivate,
};
pub const GtkActionGroup = struct__GtkActionGroup;
pub const struct__GtkActionGroupClass = extern struct {
    parent_class: GObjectClass,
    get_action: ?extern fn ([*c]GtkActionGroup, [*c]const gchar) [*c]GtkAction,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkActionGroupClass = struct__GtkActionGroupClass;
pub const struct__GtkActionEntry = extern struct {
    name: [*c]const gchar,
    stock_id: [*c]const gchar,
    label: [*c]const gchar,
    accelerator: [*c]const gchar,
    tooltip: [*c]const gchar,
    callback: GCallback,
};
pub const GtkActionEntry = struct__GtkActionEntry;
pub const struct__GtkToggleActionEntry = extern struct {
    name: [*c]const gchar,
    stock_id: [*c]const gchar,
    label: [*c]const gchar,
    accelerator: [*c]const gchar,
    tooltip: [*c]const gchar,
    callback: GCallback,
    is_active: gboolean,
};
pub const GtkToggleActionEntry = struct__GtkToggleActionEntry;
pub const struct__GtkRadioActionEntry = extern struct {
    name: [*c]const gchar,
    stock_id: [*c]const gchar,
    label: [*c]const gchar,
    accelerator: [*c]const gchar,
    tooltip: [*c]const gchar,
    value: gint,
};
pub const GtkRadioActionEntry = struct__GtkRadioActionEntry;
pub extern fn gtk_action_group_get_type() GType;
pub extern fn gtk_action_group_new(name: [*c]const gchar) [*c]GtkActionGroup;
pub extern fn gtk_action_group_get_name(action_group: [*c]GtkActionGroup) [*c]const gchar;
pub extern fn gtk_action_group_get_sensitive(action_group: [*c]GtkActionGroup) gboolean;
pub extern fn gtk_action_group_set_sensitive(action_group: [*c]GtkActionGroup, sensitive: gboolean) void;
pub extern fn gtk_action_group_get_visible(action_group: [*c]GtkActionGroup) gboolean;
pub extern fn gtk_action_group_set_visible(action_group: [*c]GtkActionGroup, visible: gboolean) void;
pub extern fn gtk_action_group_get_accel_group(action_group: [*c]GtkActionGroup) [*c]GtkAccelGroup;
pub extern fn gtk_action_group_set_accel_group(action_group: [*c]GtkActionGroup, accel_group: [*c]GtkAccelGroup) void;
pub extern fn gtk_action_group_get_action(action_group: [*c]GtkActionGroup, action_name: [*c]const gchar) [*c]GtkAction;
pub extern fn gtk_action_group_list_actions(action_group: [*c]GtkActionGroup) [*c]GList;
pub extern fn gtk_action_group_add_action(action_group: [*c]GtkActionGroup, action: [*c]GtkAction) void;
pub extern fn gtk_action_group_add_action_with_accel(action_group: [*c]GtkActionGroup, action: [*c]GtkAction, accelerator: [*c]const gchar) void;
pub extern fn gtk_action_group_remove_action(action_group: [*c]GtkActionGroup, action: [*c]GtkAction) void;
pub extern fn gtk_action_group_add_actions(action_group: [*c]GtkActionGroup, entries: [*c]const GtkActionEntry, n_entries: guint, user_data: gpointer) void;
pub extern fn gtk_action_group_add_toggle_actions(action_group: [*c]GtkActionGroup, entries: [*c]const GtkToggleActionEntry, n_entries: guint, user_data: gpointer) void;
pub extern fn gtk_action_group_add_radio_actions(action_group: [*c]GtkActionGroup, entries: [*c]const GtkRadioActionEntry, n_entries: guint, value: gint, on_change: GCallback, user_data: gpointer) void;
pub extern fn gtk_action_group_add_actions_full(action_group: [*c]GtkActionGroup, entries: [*c]const GtkActionEntry, n_entries: guint, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_action_group_add_toggle_actions_full(action_group: [*c]GtkActionGroup, entries: [*c]const GtkToggleActionEntry, n_entries: guint, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_action_group_add_radio_actions_full(action_group: [*c]GtkActionGroup, entries: [*c]const GtkRadioActionEntry, n_entries: guint, value: gint, on_change: GCallback, user_data: gpointer, destroy: GDestroyNotify) void;
pub extern fn gtk_action_group_set_translate_func(action_group: [*c]GtkActionGroup, func: GtkTranslateFunc, data: gpointer, notify: GDestroyNotify) void;
pub extern fn gtk_action_group_set_translation_domain(action_group: [*c]GtkActionGroup, domain: [*c]const gchar) void;
pub extern fn gtk_action_group_translate_string(action_group: [*c]GtkActionGroup, string: [*c]const gchar) [*c]const gchar;
pub extern fn _gtk_action_group_emit_connect_proxy(action_group: [*c]GtkActionGroup, action: [*c]GtkAction, proxy: [*c]GtkWidget) void;
pub extern fn _gtk_action_group_emit_disconnect_proxy(action_group: [*c]GtkActionGroup, action: [*c]GtkAction, proxy: [*c]GtkWidget) void;
pub extern fn _gtk_action_group_emit_pre_activate(action_group: [*c]GtkActionGroup, action: [*c]GtkAction) void;
pub extern fn _gtk_action_group_emit_post_activate(action_group: [*c]GtkActionGroup, action: [*c]GtkAction) void;
pub const struct__GtkAlignmentPrivate = @OpaqueType();
pub const GtkAlignmentPrivate = struct__GtkAlignmentPrivate;
pub const struct__GtkAlignment = extern struct {
    bin: GtkBin,
    priv: ?*GtkAlignmentPrivate,
};
pub const GtkAlignment = struct__GtkAlignment;
pub const struct__GtkAlignmentClass = extern struct {
    parent_class: GtkBinClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkAlignmentClass = struct__GtkAlignmentClass;
pub extern fn gtk_alignment_get_type() GType;
pub extern fn gtk_alignment_new(xalign: gfloat, yalign: gfloat, xscale: gfloat, yscale: gfloat) [*c]GtkWidget;
pub extern fn gtk_alignment_set(alignment: [*c]GtkAlignment, xalign: gfloat, yalign: gfloat, xscale: gfloat, yscale: gfloat) void;
pub extern fn gtk_alignment_set_padding(alignment: [*c]GtkAlignment, padding_top: guint, padding_bottom: guint, padding_left: guint, padding_right: guint) void;
pub extern fn gtk_alignment_get_padding(alignment: [*c]GtkAlignment, padding_top: [*c]guint, padding_bottom: [*c]guint, padding_left: [*c]guint, padding_right: [*c]guint) void;
pub const struct__GtkColorSelectionPrivate = @OpaqueType();
pub const GtkColorSelectionPrivate = struct__GtkColorSelectionPrivate;
pub const struct__GtkColorSelection = extern struct {
    parent_instance: GtkBox,
    private_data: ?*GtkColorSelectionPrivate,
};
pub const GtkColorSelection = struct__GtkColorSelection;
pub const struct__GtkColorSelectionClass = extern struct {
    parent_class: GtkBoxClass,
    color_changed: ?extern fn ([*c]GtkColorSelection) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkColorSelectionClass = struct__GtkColorSelectionClass;
pub const GtkColorSelectionChangePaletteFunc = ?extern fn ([*c]const GdkColor, gint) void;
pub const GtkColorSelectionChangePaletteWithScreenFunc = ?extern fn (?*GdkScreen, [*c]const GdkColor, gint) void;
pub extern fn gtk_color_selection_get_type() GType;
pub extern fn gtk_color_selection_new() [*c]GtkWidget;
pub extern fn gtk_color_selection_get_has_opacity_control(colorsel: [*c]GtkColorSelection) gboolean;
pub extern fn gtk_color_selection_set_has_opacity_control(colorsel: [*c]GtkColorSelection, has_opacity: gboolean) void;
pub extern fn gtk_color_selection_get_has_palette(colorsel: [*c]GtkColorSelection) gboolean;
pub extern fn gtk_color_selection_set_has_palette(colorsel: [*c]GtkColorSelection, has_palette: gboolean) void;
pub extern fn gtk_color_selection_set_current_alpha(colorsel: [*c]GtkColorSelection, alpha: guint16) void;
pub extern fn gtk_color_selection_get_current_alpha(colorsel: [*c]GtkColorSelection) guint16;
pub extern fn gtk_color_selection_set_previous_alpha(colorsel: [*c]GtkColorSelection, alpha: guint16) void;
pub extern fn gtk_color_selection_get_previous_alpha(colorsel: [*c]GtkColorSelection) guint16;
pub extern fn gtk_color_selection_set_current_rgba(colorsel: [*c]GtkColorSelection, rgba: [*c]const GdkRGBA) void;
pub extern fn gtk_color_selection_get_current_rgba(colorsel: [*c]GtkColorSelection, rgba: [*c]GdkRGBA) void;
pub extern fn gtk_color_selection_set_previous_rgba(colorsel: [*c]GtkColorSelection, rgba: [*c]const GdkRGBA) void;
pub extern fn gtk_color_selection_get_previous_rgba(colorsel: [*c]GtkColorSelection, rgba: [*c]GdkRGBA) void;
pub extern fn gtk_color_selection_is_adjusting(colorsel: [*c]GtkColorSelection) gboolean;
pub extern fn gtk_color_selection_palette_from_string(str: [*c]const gchar, colors: [*c]([*c]GdkColor), n_colors: [*c]gint) gboolean;
pub extern fn gtk_color_selection_palette_to_string(colors: [*c]const GdkColor, n_colors: gint) [*c]gchar;
pub extern fn gtk_color_selection_set_change_palette_with_screen_hook(func: GtkColorSelectionChangePaletteWithScreenFunc) GtkColorSelectionChangePaletteWithScreenFunc;
pub extern fn gtk_color_selection_set_current_color(colorsel: [*c]GtkColorSelection, color: [*c]const GdkColor) void;
pub extern fn gtk_color_selection_get_current_color(colorsel: [*c]GtkColorSelection, color: [*c]GdkColor) void;
pub extern fn gtk_color_selection_set_previous_color(colorsel: [*c]GtkColorSelection, color: [*c]const GdkColor) void;
pub extern fn gtk_color_selection_get_previous_color(colorsel: [*c]GtkColorSelection, color: [*c]GdkColor) void;
pub const struct__GtkColorSelectionDialogPrivate = @OpaqueType();
pub const GtkColorSelectionDialogPrivate = struct__GtkColorSelectionDialogPrivate;
pub const struct__GtkColorSelectionDialog = extern struct {
    parent_instance: GtkDialog,
    priv: ?*GtkColorSelectionDialogPrivate,
};
pub const GtkColorSelectionDialog = struct__GtkColorSelectionDialog;
pub const struct__GtkColorSelectionDialogClass = extern struct {
    parent_class: GtkDialogClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkColorSelectionDialogClass = struct__GtkColorSelectionDialogClass;
pub extern fn gtk_color_selection_dialog_get_type() GType;
pub extern fn gtk_color_selection_dialog_new(title: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_color_selection_dialog_get_color_selection(colorsel: [*c]GtkColorSelectionDialog) [*c]GtkWidget;
pub const struct__GtkFontSelectionPrivate = @OpaqueType();
pub const GtkFontSelectionPrivate = struct__GtkFontSelectionPrivate;
pub const struct__GtkFontSelection = extern struct {
    parent_instance: GtkBox,
    priv: ?*GtkFontSelectionPrivate,
};
pub const GtkFontSelection = struct__GtkFontSelection;
pub const struct__GtkFontSelectionClass = extern struct {
    parent_class: GtkBoxClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkFontSelectionClass = struct__GtkFontSelectionClass;
pub const struct__GtkFontSelectionDialogPrivate = @OpaqueType();
pub const GtkFontSelectionDialogPrivate = struct__GtkFontSelectionDialogPrivate;
pub const struct__GtkFontSelectionDialog = extern struct {
    parent_instance: GtkDialog,
    priv: ?*GtkFontSelectionDialogPrivate,
};
pub const GtkFontSelectionDialog = struct__GtkFontSelectionDialog;
pub const struct__GtkFontSelectionDialogClass = extern struct {
    parent_class: GtkDialogClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkFontSelectionDialogClass = struct__GtkFontSelectionDialogClass;
pub extern fn gtk_font_selection_get_type() GType;
pub extern fn gtk_font_selection_new() [*c]GtkWidget;
pub extern fn gtk_font_selection_get_family_list(fontsel: [*c]GtkFontSelection) [*c]GtkWidget;
pub extern fn gtk_font_selection_get_face_list(fontsel: [*c]GtkFontSelection) [*c]GtkWidget;
pub extern fn gtk_font_selection_get_size_entry(fontsel: [*c]GtkFontSelection) [*c]GtkWidget;
pub extern fn gtk_font_selection_get_size_list(fontsel: [*c]GtkFontSelection) [*c]GtkWidget;
pub extern fn gtk_font_selection_get_preview_entry(fontsel: [*c]GtkFontSelection) [*c]GtkWidget;
pub extern fn gtk_font_selection_get_family(fontsel: [*c]GtkFontSelection) ?*PangoFontFamily;
pub extern fn gtk_font_selection_get_face(fontsel: [*c]GtkFontSelection) ?*PangoFontFace;
pub extern fn gtk_font_selection_get_size(fontsel: [*c]GtkFontSelection) gint;
pub extern fn gtk_font_selection_get_font_name(fontsel: [*c]GtkFontSelection) [*c]gchar;
pub extern fn gtk_font_selection_set_font_name(fontsel: [*c]GtkFontSelection, fontname: [*c]const gchar) gboolean;
pub extern fn gtk_font_selection_get_preview_text(fontsel: [*c]GtkFontSelection) [*c]const gchar;
pub extern fn gtk_font_selection_set_preview_text(fontsel: [*c]GtkFontSelection, text: [*c]const gchar) void;
pub extern fn gtk_font_selection_dialog_get_type() GType;
pub extern fn gtk_font_selection_dialog_new(title: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_font_selection_dialog_get_ok_button(fsd: [*c]GtkFontSelectionDialog) [*c]GtkWidget;
pub extern fn gtk_font_selection_dialog_get_cancel_button(fsd: [*c]GtkFontSelectionDialog) [*c]GtkWidget;
pub extern fn gtk_font_selection_dialog_get_font_selection(fsd: [*c]GtkFontSelectionDialog) [*c]GtkWidget;
pub extern fn gtk_font_selection_dialog_get_font_name(fsd: [*c]GtkFontSelectionDialog) [*c]gchar;
pub extern fn gtk_font_selection_dialog_set_font_name(fsd: [*c]GtkFontSelectionDialog, fontname: [*c]const gchar) gboolean;
pub extern fn gtk_font_selection_dialog_get_preview_text(fsd: [*c]GtkFontSelectionDialog) [*c]const gchar;
pub extern fn gtk_font_selection_dialog_set_preview_text(fsd: [*c]GtkFontSelectionDialog, text: [*c]const gchar) void;
pub extern fn gtk_symbolic_color_get_type() GType;
pub extern fn gtk_symbolic_color_new_literal(color: [*c]const GdkRGBA) ?*GtkSymbolicColor;
pub extern fn gtk_symbolic_color_new_name(name: [*c]const gchar) ?*GtkSymbolicColor;
pub extern fn gtk_symbolic_color_new_shade(color: ?*GtkSymbolicColor, factor: gdouble) ?*GtkSymbolicColor;
pub extern fn gtk_symbolic_color_new_alpha(color: ?*GtkSymbolicColor, factor: gdouble) ?*GtkSymbolicColor;
pub extern fn gtk_symbolic_color_new_mix(color1: ?*GtkSymbolicColor, color2: ?*GtkSymbolicColor, factor: gdouble) ?*GtkSymbolicColor;
pub extern fn gtk_symbolic_color_new_win32(theme_class: [*c]const gchar, id: gint) ?*GtkSymbolicColor;
pub extern fn gtk_symbolic_color_ref(color: ?*GtkSymbolicColor) ?*GtkSymbolicColor;
pub extern fn gtk_symbolic_color_unref(color: ?*GtkSymbolicColor) void;
pub extern fn gtk_symbolic_color_to_string(color: ?*GtkSymbolicColor) [*c]u8;
pub extern fn gtk_symbolic_color_resolve(color: ?*GtkSymbolicColor, props: [*c]GtkStyleProperties, resolved_color: [*c]GdkRGBA) gboolean;
pub extern fn gtk_gradient_get_type() GType;
pub extern fn gtk_gradient_new_linear(x0: gdouble, y0: gdouble, x1: gdouble, y1: gdouble) ?*GtkGradient;
pub extern fn gtk_gradient_new_radial(x0: gdouble, y0: gdouble, radius0: gdouble, x1: gdouble, y1: gdouble, radius1: gdouble) ?*GtkGradient;
pub extern fn gtk_gradient_add_color_stop(gradient: ?*GtkGradient, offset: gdouble, color: ?*GtkSymbolicColor) void;
pub extern fn gtk_gradient_ref(gradient: ?*GtkGradient) ?*GtkGradient;
pub extern fn gtk_gradient_unref(gradient: ?*GtkGradient) void;
pub extern fn gtk_gradient_resolve(gradient: ?*GtkGradient, props: [*c]GtkStyleProperties, resolved_gradient: [*c](?*cairo_pattern_t)) gboolean;
pub extern fn gtk_gradient_resolve_for_context(gradient: ?*GtkGradient, context: [*c]GtkStyleContext) ?*cairo_pattern_t;
pub extern fn gtk_gradient_to_string(gradient: ?*GtkGradient) [*c]u8;
pub const struct__GtkHandleBoxPrivate = @OpaqueType();
pub const GtkHandleBoxPrivate = struct__GtkHandleBoxPrivate;
pub const struct__GtkHandleBox = extern struct {
    bin: GtkBin,
    priv: ?*GtkHandleBoxPrivate,
};
pub const GtkHandleBox = struct__GtkHandleBox;
pub const struct__GtkHandleBoxClass = extern struct {
    parent_class: GtkBinClass,
    child_attached: ?extern fn ([*c]GtkHandleBox, [*c]GtkWidget) void,
    child_detached: ?extern fn ([*c]GtkHandleBox, [*c]GtkWidget) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkHandleBoxClass = struct__GtkHandleBoxClass;
pub extern fn gtk_handle_box_get_type() GType;
pub extern fn gtk_handle_box_new() [*c]GtkWidget;
pub extern fn gtk_handle_box_set_shadow_type(handle_box: [*c]GtkHandleBox, type_0: GtkShadowType) void;
pub extern fn gtk_handle_box_get_shadow_type(handle_box: [*c]GtkHandleBox) GtkShadowType;
pub extern fn gtk_handle_box_set_handle_position(handle_box: [*c]GtkHandleBox, position: GtkPositionType) void;
pub extern fn gtk_handle_box_get_handle_position(handle_box: [*c]GtkHandleBox) GtkPositionType;
pub extern fn gtk_handle_box_set_snap_edge(handle_box: [*c]GtkHandleBox, edge: GtkPositionType) void;
pub extern fn gtk_handle_box_get_snap_edge(handle_box: [*c]GtkHandleBox) GtkPositionType;
pub extern fn gtk_handle_box_get_child_detached(handle_box: [*c]GtkHandleBox) gboolean;
pub const struct__GtkHButtonBox = extern struct {
    button_box: GtkButtonBox,
};
pub const GtkHButtonBox = struct__GtkHButtonBox;
pub const struct__GtkHButtonBoxClass = extern struct {
    parent_class: GtkButtonBoxClass,
};
pub const GtkHButtonBoxClass = struct__GtkHButtonBoxClass;
pub extern fn gtk_hbutton_box_get_type() GType;
pub extern fn gtk_hbutton_box_new() [*c]GtkWidget;
pub const struct__GtkHBox = extern struct {
    box: GtkBox,
};
pub const GtkHBox = struct__GtkHBox;
pub const struct__GtkHBoxClass = extern struct {
    parent_class: GtkBoxClass,
};
pub const GtkHBoxClass = struct__GtkHBoxClass;
pub extern fn gtk_hbox_get_type() GType;
pub extern fn gtk_hbox_new(homogeneous: gboolean, spacing: gint) [*c]GtkWidget;
pub const struct__GtkHPaned = extern struct {
    paned: GtkPaned,
};
pub const GtkHPaned = struct__GtkHPaned;
pub const struct__GtkHPanedClass = extern struct {
    parent_class: GtkPanedClass,
};
pub const GtkHPanedClass = struct__GtkHPanedClass;
pub extern fn gtk_hpaned_get_type() GType;
pub extern fn gtk_hpaned_new() [*c]GtkWidget;
pub const struct__GtkHSVPrivate = @OpaqueType();
pub const GtkHSVPrivate = struct__GtkHSVPrivate;
pub const struct__GtkHSV = extern struct {
    parent_instance: GtkWidget,
    priv: ?*GtkHSVPrivate,
};
pub const GtkHSV = struct__GtkHSV;
pub const struct__GtkHSVClass = extern struct {
    parent_class: GtkWidgetClass,
    changed: ?extern fn ([*c]GtkHSV) void,
    move: ?extern fn ([*c]GtkHSV, GtkDirectionType) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkHSVClass = struct__GtkHSVClass;
pub extern fn gtk_hsv_get_type() GType;
pub extern fn gtk_hsv_new() [*c]GtkWidget;
pub extern fn gtk_hsv_set_color(hsv: [*c]GtkHSV, h: f64, s: f64, v: f64) void;
pub extern fn gtk_hsv_get_color(hsv: [*c]GtkHSV, h: [*c]gdouble, s: [*c]gdouble, v: [*c]gdouble) void;
pub extern fn gtk_hsv_set_metrics(hsv: [*c]GtkHSV, size: gint, ring_width: gint) void;
pub extern fn gtk_hsv_get_metrics(hsv: [*c]GtkHSV, size: [*c]gint, ring_width: [*c]gint) void;
pub extern fn gtk_hsv_is_adjusting(hsv: [*c]GtkHSV) gboolean;
pub const struct__GtkHScale = extern struct {
    scale: GtkScale,
};
pub const GtkHScale = struct__GtkHScale;
pub const struct__GtkHScaleClass = extern struct {
    parent_class: GtkScaleClass,
};
pub const GtkHScaleClass = struct__GtkHScaleClass;
pub extern fn gtk_hscale_get_type() GType;
pub extern fn gtk_hscale_new(adjustment: [*c]GtkAdjustment) [*c]GtkWidget;
pub extern fn gtk_hscale_new_with_range(min: gdouble, max: gdouble, step: gdouble) [*c]GtkWidget;
pub const struct__GtkHScrollbar = extern struct {
    scrollbar: GtkScrollbar,
};
pub const GtkHScrollbar = struct__GtkHScrollbar;
pub const struct__GtkHScrollbarClass = extern struct {
    parent_class: GtkScrollbarClass,
};
pub const GtkHScrollbarClass = struct__GtkHScrollbarClass;
pub extern fn gtk_hscrollbar_get_type() GType;
pub extern fn gtk_hscrollbar_new(adjustment: [*c]GtkAdjustment) [*c]GtkWidget;
pub const struct__GtkHSeparator = extern struct {
    separator: GtkSeparator,
};
pub const GtkHSeparator = struct__GtkHSeparator;
pub const struct__GtkHSeparatorClass = extern struct {
    parent_class: GtkSeparatorClass,
};
pub const GtkHSeparatorClass = struct__GtkHSeparatorClass;
pub extern fn gtk_hseparator_get_type() GType;
pub extern fn gtk_hseparator_new() [*c]GtkWidget;
pub const struct__GtkImageMenuItemPrivate = @OpaqueType();
pub const GtkImageMenuItemPrivate = struct__GtkImageMenuItemPrivate;
pub const struct__GtkImageMenuItem = extern struct {
    menu_item: GtkMenuItem,
    priv: ?*GtkImageMenuItemPrivate,
};
pub const GtkImageMenuItem = struct__GtkImageMenuItem;
pub const struct__GtkImageMenuItemClass = extern struct {
    parent_class: GtkMenuItemClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkImageMenuItemClass = struct__GtkImageMenuItemClass;
pub extern fn gtk_image_menu_item_get_type() GType;
pub extern fn gtk_image_menu_item_new() [*c]GtkWidget;
pub extern fn gtk_image_menu_item_new_with_label(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_image_menu_item_new_with_mnemonic(label: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_image_menu_item_new_from_stock(stock_id: [*c]const gchar, accel_group: [*c]GtkAccelGroup) [*c]GtkWidget;
pub extern fn gtk_image_menu_item_set_always_show_image(image_menu_item: [*c]GtkImageMenuItem, always_show: gboolean) void;
pub extern fn gtk_image_menu_item_get_always_show_image(image_menu_item: [*c]GtkImageMenuItem) gboolean;
pub extern fn gtk_image_menu_item_set_image(image_menu_item: [*c]GtkImageMenuItem, image: [*c]GtkWidget) void;
pub extern fn gtk_image_menu_item_get_image(image_menu_item: [*c]GtkImageMenuItem) [*c]GtkWidget;
pub extern fn gtk_image_menu_item_set_use_stock(image_menu_item: [*c]GtkImageMenuItem, use_stock: gboolean) void;
pub extern fn gtk_image_menu_item_get_use_stock(image_menu_item: [*c]GtkImageMenuItem) gboolean;
pub extern fn gtk_image_menu_item_set_accel_group(image_menu_item: [*c]GtkImageMenuItem, accel_group: [*c]GtkAccelGroup) void;
pub const struct__GtkNumerableIconPrivate = @OpaqueType();
pub const GtkNumerableIconPrivate = struct__GtkNumerableIconPrivate;
pub const struct__GtkNumerableIcon = extern struct {
    parent: GEmblemedIcon,
    priv: ?*GtkNumerableIconPrivate,
};
pub const GtkNumerableIcon = struct__GtkNumerableIcon;
pub const struct__GtkNumerableIconClass = extern struct {
    parent_class: GEmblemedIconClass,
    padding: [16]gpointer,
};
pub const GtkNumerableIconClass = struct__GtkNumerableIconClass;
pub extern fn gtk_numerable_icon_get_type() GType;
pub extern fn gtk_numerable_icon_new(base_icon: ?*GIcon) ?*GIcon;
pub extern fn gtk_numerable_icon_new_with_style_context(base_icon: ?*GIcon, context: [*c]GtkStyleContext) ?*GIcon;
pub extern fn gtk_numerable_icon_get_style_context(self: [*c]GtkNumerableIcon) [*c]GtkStyleContext;
pub extern fn gtk_numerable_icon_set_style_context(self: [*c]GtkNumerableIcon, style: [*c]GtkStyleContext) void;
pub extern fn gtk_numerable_icon_get_count(self: [*c]GtkNumerableIcon) gint;
pub extern fn gtk_numerable_icon_set_count(self: [*c]GtkNumerableIcon, count: gint) void;
pub extern fn gtk_numerable_icon_get_label(self: [*c]GtkNumerableIcon) [*c]const gchar;
pub extern fn gtk_numerable_icon_set_label(self: [*c]GtkNumerableIcon, label: [*c]const gchar) void;
pub extern fn gtk_numerable_icon_set_background_gicon(self: [*c]GtkNumerableIcon, icon: ?*GIcon) void;
pub extern fn gtk_numerable_icon_get_background_gicon(self: [*c]GtkNumerableIcon) ?*GIcon;
pub extern fn gtk_numerable_icon_set_background_icon_name(self: [*c]GtkNumerableIcon, icon_name: [*c]const gchar) void;
pub extern fn gtk_numerable_icon_get_background_icon_name(self: [*c]GtkNumerableIcon) [*c]const gchar;
pub const struct__GtkToggleActionPrivate = @OpaqueType();
pub const GtkToggleActionPrivate = struct__GtkToggleActionPrivate;
pub const struct__GtkToggleAction = extern struct {
    parent: GtkAction,
    private_data: ?*GtkToggleActionPrivate,
};
pub const GtkToggleAction = struct__GtkToggleAction;
pub const struct__GtkToggleActionClass = extern struct {
    parent_class: GtkActionClass,
    toggled: ?extern fn ([*c]GtkToggleAction) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkToggleActionClass = struct__GtkToggleActionClass;
pub extern fn gtk_toggle_action_get_type() GType;
pub extern fn gtk_toggle_action_new(name: [*c]const gchar, label: [*c]const gchar, tooltip: [*c]const gchar, stock_id: [*c]const gchar) [*c]GtkToggleAction;
pub extern fn gtk_toggle_action_toggled(action: [*c]GtkToggleAction) void;
pub extern fn gtk_toggle_action_set_active(action: [*c]GtkToggleAction, is_active: gboolean) void;
pub extern fn gtk_toggle_action_get_active(action: [*c]GtkToggleAction) gboolean;
pub extern fn gtk_toggle_action_set_draw_as_radio(action: [*c]GtkToggleAction, draw_as_radio: gboolean) void;
pub extern fn gtk_toggle_action_get_draw_as_radio(action: [*c]GtkToggleAction) gboolean;
pub extern fn _gtk_toggle_action_set_active(toggle_action: [*c]GtkToggleAction, is_active: gboolean) void;
pub const struct__GtkRadioActionPrivate = @OpaqueType();
pub const GtkRadioActionPrivate = struct__GtkRadioActionPrivate;
pub const struct__GtkRadioAction = extern struct {
    parent: GtkToggleAction,
    private_data: ?*GtkRadioActionPrivate,
};
pub const GtkRadioAction = struct__GtkRadioAction;
pub const struct__GtkRadioActionClass = extern struct {
    parent_class: GtkToggleActionClass,
    changed: ?extern fn ([*c]GtkRadioAction, [*c]GtkRadioAction) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkRadioActionClass = struct__GtkRadioActionClass;
pub extern fn gtk_radio_action_get_type() GType;
pub extern fn gtk_radio_action_new(name: [*c]const gchar, label: [*c]const gchar, tooltip: [*c]const gchar, stock_id: [*c]const gchar, value: gint) [*c]GtkRadioAction;
pub extern fn gtk_radio_action_get_group(action: [*c]GtkRadioAction) [*c]GSList;
pub extern fn gtk_radio_action_set_group(action: [*c]GtkRadioAction, group: [*c]GSList) void;
pub extern fn gtk_radio_action_join_group(action: [*c]GtkRadioAction, group_source: [*c]GtkRadioAction) void;
pub extern fn gtk_radio_action_get_current_value(action: [*c]GtkRadioAction) gint;
pub extern fn gtk_radio_action_set_current_value(action: [*c]GtkRadioAction, current_value: gint) void;
pub const struct__GtkRcContext = @OpaqueType();
pub const GtkRcContext = struct__GtkRcContext;
pub const struct__GtkRcStyleClass = extern struct {
    parent_class: GObjectClass,
    create_rc_style: ?extern fn (?*GtkRcStyle) ?*GtkRcStyle,
    parse: ?extern fn (?*GtkRcStyle, [*c]GtkSettings, [*c]GScanner) guint,
    merge: ?extern fn (?*GtkRcStyle, ?*GtkRcStyle) void,
    create_style: ?extern fn (?*GtkRcStyle) [*c]GtkStyle,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkRcStyleClass = struct__GtkRcStyleClass;
pub const GTK_RC_FG = 1;
pub const GTK_RC_BG = 2;
pub const GTK_RC_TEXT = 4;
pub const GTK_RC_BASE = 8;
pub const GtkRcFlags = extern enum {
    GTK_RC_FG = 1,
    GTK_RC_BG = 2,
    GTK_RC_TEXT = 4,
    GTK_RC_BASE = 8,
};
pub extern fn _gtk_rc_parse_widget_class_path(pattern: [*c]const gchar) [*c]GSList;
pub extern fn _gtk_rc_free_widget_class_path(list: [*c]GSList) void;
pub extern fn _gtk_rc_match_widget_class(list: [*c]GSList, length: gint, path: [*c]gchar, path_reversed: [*c]gchar) gboolean;
pub extern fn gtk_rc_add_default_file(filename: [*c]const gchar) void;
pub extern fn gtk_rc_set_default_files(filenames: [*c]([*c]gchar)) void;
pub extern fn gtk_rc_get_default_files() [*c]([*c]gchar);
pub extern fn gtk_rc_get_style(widget: [*c]GtkWidget) [*c]GtkStyle;
pub extern fn gtk_rc_get_style_by_paths(settings: [*c]GtkSettings, widget_path: [*c]const u8, class_path: [*c]const u8, type_0: GType) [*c]GtkStyle;
pub extern fn gtk_rc_reparse_all_for_settings(settings: [*c]GtkSettings, force_load: gboolean) gboolean;
pub extern fn gtk_rc_reset_styles(settings: [*c]GtkSettings) void;
pub extern fn gtk_rc_find_pixmap_in_path(settings: [*c]GtkSettings, scanner: [*c]GScanner, pixmap_file: [*c]const gchar) [*c]gchar;
pub extern fn gtk_rc_parse(filename: [*c]const gchar) void;
pub extern fn gtk_rc_parse_string(rc_string: [*c]const gchar) void;
pub extern fn gtk_rc_reparse_all() gboolean;
pub extern fn gtk_rc_style_get_type() GType;
pub extern fn gtk_rc_style_new() ?*GtkRcStyle;
pub extern fn gtk_rc_style_copy(orig: ?*GtkRcStyle) ?*GtkRcStyle;
pub extern fn gtk_rc_find_module_in_path(module_file: [*c]const gchar) [*c]gchar;
pub extern fn gtk_rc_get_theme_dir() [*c]gchar;
pub extern fn gtk_rc_get_module_dir() [*c]gchar;
pub extern fn gtk_rc_get_im_module_path() [*c]gchar;
pub extern fn gtk_rc_get_im_module_file() [*c]gchar;
pub const GTK_RC_TOKEN_INVALID = 270;
pub const GTK_RC_TOKEN_INCLUDE = 271;
pub const GTK_RC_TOKEN_NORMAL = 272;
pub const GTK_RC_TOKEN_ACTIVE = 273;
pub const GTK_RC_TOKEN_PRELIGHT = 274;
pub const GTK_RC_TOKEN_SELECTED = 275;
pub const GTK_RC_TOKEN_INSENSITIVE = 276;
pub const GTK_RC_TOKEN_FG = 277;
pub const GTK_RC_TOKEN_BG = 278;
pub const GTK_RC_TOKEN_TEXT = 279;
pub const GTK_RC_TOKEN_BASE = 280;
pub const GTK_RC_TOKEN_XTHICKNESS = 281;
pub const GTK_RC_TOKEN_YTHICKNESS = 282;
pub const GTK_RC_TOKEN_FONT = 283;
pub const GTK_RC_TOKEN_FONTSET = 284;
pub const GTK_RC_TOKEN_FONT_NAME = 285;
pub const GTK_RC_TOKEN_BG_PIXMAP = 286;
pub const GTK_RC_TOKEN_PIXMAP_PATH = 287;
pub const GTK_RC_TOKEN_STYLE = 288;
pub const GTK_RC_TOKEN_BINDING = 289;
pub const GTK_RC_TOKEN_BIND = 290;
pub const GTK_RC_TOKEN_WIDGET = 291;
pub const GTK_RC_TOKEN_WIDGET_CLASS = 292;
pub const GTK_RC_TOKEN_CLASS = 293;
pub const GTK_RC_TOKEN_LOWEST = 294;
pub const GTK_RC_TOKEN_GTK = 295;
pub const GTK_RC_TOKEN_APPLICATION = 296;
pub const GTK_RC_TOKEN_THEME = 297;
pub const GTK_RC_TOKEN_RC = 298;
pub const GTK_RC_TOKEN_HIGHEST = 299;
pub const GTK_RC_TOKEN_ENGINE = 300;
pub const GTK_RC_TOKEN_MODULE_PATH = 301;
pub const GTK_RC_TOKEN_IM_MODULE_PATH = 302;
pub const GTK_RC_TOKEN_IM_MODULE_FILE = 303;
pub const GTK_RC_TOKEN_STOCK = 304;
pub const GTK_RC_TOKEN_LTR = 305;
pub const GTK_RC_TOKEN_RTL = 306;
pub const GTK_RC_TOKEN_COLOR = 307;
pub const GTK_RC_TOKEN_UNBIND = 308;
pub const GTK_RC_TOKEN_LAST = 309;
pub const GtkRcTokenType = extern enum {
    GTK_RC_TOKEN_INVALID = 270,
    GTK_RC_TOKEN_INCLUDE = 271,
    GTK_RC_TOKEN_NORMAL = 272,
    GTK_RC_TOKEN_ACTIVE = 273,
    GTK_RC_TOKEN_PRELIGHT = 274,
    GTK_RC_TOKEN_SELECTED = 275,
    GTK_RC_TOKEN_INSENSITIVE = 276,
    GTK_RC_TOKEN_FG = 277,
    GTK_RC_TOKEN_BG = 278,
    GTK_RC_TOKEN_TEXT = 279,
    GTK_RC_TOKEN_BASE = 280,
    GTK_RC_TOKEN_XTHICKNESS = 281,
    GTK_RC_TOKEN_YTHICKNESS = 282,
    GTK_RC_TOKEN_FONT = 283,
    GTK_RC_TOKEN_FONTSET = 284,
    GTK_RC_TOKEN_FONT_NAME = 285,
    GTK_RC_TOKEN_BG_PIXMAP = 286,
    GTK_RC_TOKEN_PIXMAP_PATH = 287,
    GTK_RC_TOKEN_STYLE = 288,
    GTK_RC_TOKEN_BINDING = 289,
    GTK_RC_TOKEN_BIND = 290,
    GTK_RC_TOKEN_WIDGET = 291,
    GTK_RC_TOKEN_WIDGET_CLASS = 292,
    GTK_RC_TOKEN_CLASS = 293,
    GTK_RC_TOKEN_LOWEST = 294,
    GTK_RC_TOKEN_GTK = 295,
    GTK_RC_TOKEN_APPLICATION = 296,
    GTK_RC_TOKEN_THEME = 297,
    GTK_RC_TOKEN_RC = 298,
    GTK_RC_TOKEN_HIGHEST = 299,
    GTK_RC_TOKEN_ENGINE = 300,
    GTK_RC_TOKEN_MODULE_PATH = 301,
    GTK_RC_TOKEN_IM_MODULE_PATH = 302,
    GTK_RC_TOKEN_IM_MODULE_FILE = 303,
    GTK_RC_TOKEN_STOCK = 304,
    GTK_RC_TOKEN_LTR = 305,
    GTK_RC_TOKEN_RTL = 306,
    GTK_RC_TOKEN_COLOR = 307,
    GTK_RC_TOKEN_UNBIND = 308,
    GTK_RC_TOKEN_LAST = 309,
};
pub const GTK_PATH_PRIO_LOWEST = 0;
pub const GTK_PATH_PRIO_GTK = 4;
pub const GTK_PATH_PRIO_APPLICATION = 8;
pub const GTK_PATH_PRIO_THEME = 10;
pub const GTK_PATH_PRIO_RC = 12;
pub const GTK_PATH_PRIO_HIGHEST = 15;
pub const GtkPathPriorityType = extern enum {
    GTK_PATH_PRIO_LOWEST = 0,
    GTK_PATH_PRIO_GTK = 4,
    GTK_PATH_PRIO_APPLICATION = 8,
    GTK_PATH_PRIO_THEME = 10,
    GTK_PATH_PRIO_RC = 12,
    GTK_PATH_PRIO_HIGHEST = 15,
};
pub const GTK_PATH_WIDGET = 0;
pub const GTK_PATH_WIDGET_CLASS = 1;
pub const GTK_PATH_CLASS = 2;
pub const GtkPathType = extern enum {
    GTK_PATH_WIDGET = 0,
    GTK_PATH_WIDGET_CLASS = 1,
    GTK_PATH_CLASS = 2,
};
pub extern fn gtk_rc_scanner_new() [*c]GScanner;
pub extern fn gtk_rc_parse_color(scanner: [*c]GScanner, color: [*c]GdkColor) guint;
pub extern fn gtk_rc_parse_color_full(scanner: [*c]GScanner, style: ?*GtkRcStyle, color: [*c]GdkColor) guint;
pub extern fn gtk_rc_parse_state(scanner: [*c]GScanner, state: [*c]GtkStateType) guint;
pub extern fn gtk_rc_parse_priority(scanner: [*c]GScanner, priority: [*c]GtkPathPriorityType) guint;
pub const struct__GtkRcProperty = extern struct {
    type_name: GQuark,
    property_name: GQuark,
    origin: [*c]gchar,
    value: GValue,
};
pub extern fn gtk_binding_set_add_path(binding_set: ?*GtkBindingSet, path_type: GtkPathType, path_pattern: [*c]const gchar, priority: GtkPathPriorityType) void;
pub const struct__GtkRecentActionPrivate = @OpaqueType();
pub const GtkRecentActionPrivate = struct__GtkRecentActionPrivate;
pub const struct__GtkRecentAction = extern struct {
    parent_instance: GtkAction,
    priv: ?*GtkRecentActionPrivate,
};
pub const GtkRecentAction = struct__GtkRecentAction;
pub const struct__GtkRecentActionClass = extern struct {
    parent_class: GtkActionClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkRecentActionClass = struct__GtkRecentActionClass;
pub extern fn gtk_recent_action_get_type() GType;
pub extern fn gtk_recent_action_new(name: [*c]const gchar, label: [*c]const gchar, tooltip: [*c]const gchar, stock_id: [*c]const gchar) [*c]GtkAction;
pub extern fn gtk_recent_action_new_for_manager(name: [*c]const gchar, label: [*c]const gchar, tooltip: [*c]const gchar, stock_id: [*c]const gchar, manager: [*c]GtkRecentManager) [*c]GtkAction;
pub extern fn gtk_recent_action_get_show_numbers(action: [*c]GtkRecentAction) gboolean;
pub extern fn gtk_recent_action_set_show_numbers(action: [*c]GtkRecentAction, show_numbers: gboolean) void;
pub const struct__GtkStatusIconPrivate = @OpaqueType();
pub const GtkStatusIconPrivate = struct__GtkStatusIconPrivate;
pub const struct__GtkStatusIcon = extern struct {
    parent_instance: GObject,
    priv: ?*GtkStatusIconPrivate,
};
pub const GtkStatusIcon = struct__GtkStatusIcon;
pub const struct__GtkStatusIconClass = extern struct {
    parent_class: GObjectClass,
    activate: ?extern fn ([*c]GtkStatusIcon) void,
    popup_menu: ?extern fn ([*c]GtkStatusIcon, guint, guint32) void,
    size_changed: ?extern fn ([*c]GtkStatusIcon, gint) gboolean,
    button_press_event: ?extern fn ([*c]GtkStatusIcon, [*c]GdkEventButton) gboolean,
    button_release_event: ?extern fn ([*c]GtkStatusIcon, [*c]GdkEventButton) gboolean,
    scroll_event: ?extern fn ([*c]GtkStatusIcon, ?*GdkEventScroll) gboolean,
    query_tooltip: ?extern fn ([*c]GtkStatusIcon, gint, gint, gboolean, ?*GtkTooltip) gboolean,
    __gtk_reserved1: ?extern fn () void,
    __gtk_reserved2: ?extern fn () void,
    __gtk_reserved3: ?extern fn () void,
    __gtk_reserved4: ?extern fn () void,
};
pub const GtkStatusIconClass = struct__GtkStatusIconClass;
pub extern fn gtk_status_icon_get_type() GType;
pub extern fn gtk_status_icon_new() [*c]GtkStatusIcon;
pub extern fn gtk_status_icon_new_from_pixbuf(pixbuf: ?*GdkPixbuf) [*c]GtkStatusIcon;
pub extern fn gtk_status_icon_new_from_file(filename: [*c]const gchar) [*c]GtkStatusIcon;
pub extern fn gtk_status_icon_new_from_stock(stock_id: [*c]const gchar) [*c]GtkStatusIcon;
pub extern fn gtk_status_icon_new_from_icon_name(icon_name: [*c]const gchar) [*c]GtkStatusIcon;
pub extern fn gtk_status_icon_new_from_gicon(icon: ?*GIcon) [*c]GtkStatusIcon;
pub extern fn gtk_status_icon_set_from_pixbuf(status_icon: [*c]GtkStatusIcon, pixbuf: ?*GdkPixbuf) void;
pub extern fn gtk_status_icon_set_from_file(status_icon: [*c]GtkStatusIcon, filename: [*c]const gchar) void;
pub extern fn gtk_status_icon_set_from_stock(status_icon: [*c]GtkStatusIcon, stock_id: [*c]const gchar) void;
pub extern fn gtk_status_icon_set_from_icon_name(status_icon: [*c]GtkStatusIcon, icon_name: [*c]const gchar) void;
pub extern fn gtk_status_icon_set_from_gicon(status_icon: [*c]GtkStatusIcon, icon: ?*GIcon) void;
pub extern fn gtk_status_icon_get_storage_type(status_icon: [*c]GtkStatusIcon) GtkImageType;
pub extern fn gtk_status_icon_get_pixbuf(status_icon: [*c]GtkStatusIcon) ?*GdkPixbuf;
pub extern fn gtk_status_icon_get_stock(status_icon: [*c]GtkStatusIcon) [*c]const gchar;
pub extern fn gtk_status_icon_get_icon_name(status_icon: [*c]GtkStatusIcon) [*c]const gchar;
pub extern fn gtk_status_icon_get_gicon(status_icon: [*c]GtkStatusIcon) ?*GIcon;
pub extern fn gtk_status_icon_get_size(status_icon: [*c]GtkStatusIcon) gint;
pub extern fn gtk_status_icon_set_screen(status_icon: [*c]GtkStatusIcon, screen: ?*GdkScreen) void;
pub extern fn gtk_status_icon_get_screen(status_icon: [*c]GtkStatusIcon) ?*GdkScreen;
pub extern fn gtk_status_icon_set_has_tooltip(status_icon: [*c]GtkStatusIcon, has_tooltip: gboolean) void;
pub extern fn gtk_status_icon_set_tooltip_text(status_icon: [*c]GtkStatusIcon, text: [*c]const gchar) void;
pub extern fn gtk_status_icon_set_tooltip_markup(status_icon: [*c]GtkStatusIcon, markup: [*c]const gchar) void;
pub extern fn gtk_status_icon_set_title(status_icon: [*c]GtkStatusIcon, title: [*c]const gchar) void;
pub extern fn gtk_status_icon_get_title(status_icon: [*c]GtkStatusIcon) [*c]const gchar;
pub extern fn gtk_status_icon_set_name(status_icon: [*c]GtkStatusIcon, name: [*c]const gchar) void;
pub extern fn gtk_status_icon_set_visible(status_icon: [*c]GtkStatusIcon, visible: gboolean) void;
pub extern fn gtk_status_icon_get_visible(status_icon: [*c]GtkStatusIcon) gboolean;
pub extern fn gtk_status_icon_is_embedded(status_icon: [*c]GtkStatusIcon) gboolean;
pub extern fn gtk_status_icon_position_menu(menu: [*c]GtkMenu, x: [*c]gint, y: [*c]gint, push_in: [*c]gboolean, user_data: gpointer) void;
pub extern fn gtk_status_icon_get_geometry(status_icon: [*c]GtkStatusIcon, screen: [*c](?*GdkScreen), area: [*c]GdkRectangle, orientation: [*c]GtkOrientation) gboolean;
pub extern fn gtk_status_icon_get_has_tooltip(status_icon: [*c]GtkStatusIcon) gboolean;
pub extern fn gtk_status_icon_get_tooltip_text(status_icon: [*c]GtkStatusIcon) [*c]gchar;
pub extern fn gtk_status_icon_get_tooltip_markup(status_icon: [*c]GtkStatusIcon) [*c]gchar;
pub extern fn gtk_status_icon_get_x11_window_id(status_icon: [*c]GtkStatusIcon) guint32;
pub const GTK_EXPANDER_COLLAPSED = 0;
pub const GTK_EXPANDER_SEMI_COLLAPSED = 1;
pub const GTK_EXPANDER_SEMI_EXPANDED = 2;
pub const GTK_EXPANDER_EXPANDED = 3;
pub const GtkExpanderStyle = extern enum {
    GTK_EXPANDER_COLLAPSED = 0,
    GTK_EXPANDER_SEMI_COLLAPSED = 1,
    GTK_EXPANDER_SEMI_EXPANDED = 2,
    GTK_EXPANDER_EXPANDED = 3,
};
pub const struct__GtkStyleClass = extern struct {
    parent_class: GObjectClass,
    realize: ?extern fn ([*c]GtkStyle) void,
    unrealize: ?extern fn ([*c]GtkStyle) void,
    copy: ?extern fn ([*c]GtkStyle, [*c]GtkStyle) void,
    clone: ?extern fn ([*c]GtkStyle) [*c]GtkStyle,
    init_from_rc: ?extern fn ([*c]GtkStyle, ?*GtkRcStyle) void,
    set_background: ?extern fn ([*c]GtkStyle, ?*GdkWindow, GtkStateType) void,
    render_icon: ?extern fn ([*c]GtkStyle, ?*const GtkIconSource, GtkTextDirection, GtkStateType, GtkIconSize, [*c]GtkWidget, [*c]const gchar) ?*GdkPixbuf,
    draw_hline: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint) void,
    draw_vline: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint) void,
    draw_shadow: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, GtkShadowType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint, gint) void,
    draw_arrow: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, GtkShadowType, [*c]GtkWidget, [*c]const gchar, GtkArrowType, gboolean, gint, gint, gint, gint) void,
    draw_diamond: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, GtkShadowType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint, gint) void,
    draw_box: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, GtkShadowType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint, gint) void,
    draw_flat_box: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, GtkShadowType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint, gint) void,
    draw_check: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, GtkShadowType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint, gint) void,
    draw_option: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, GtkShadowType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint, gint) void,
    draw_tab: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, GtkShadowType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint, gint) void,
    draw_shadow_gap: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, GtkShadowType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint, gint, GtkPositionType, gint, gint) void,
    draw_box_gap: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, GtkShadowType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint, gint, GtkPositionType, gint, gint) void,
    draw_extension: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, GtkShadowType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint, gint, GtkPositionType) void,
    draw_focus: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint, gint) void,
    draw_slider: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, GtkShadowType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint, gint, GtkOrientation) void,
    draw_handle: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, GtkShadowType, [*c]GtkWidget, [*c]const gchar, gint, gint, gint, gint, GtkOrientation) void,
    draw_expander: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, [*c]GtkWidget, [*c]const gchar, gint, gint, GtkExpanderStyle) void,
    draw_layout: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, gboolean, [*c]GtkWidget, [*c]const gchar, gint, gint, ?*PangoLayout) void,
    draw_resize_grip: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, [*c]GtkWidget, [*c]const gchar, GdkWindowEdge, gint, gint, gint, gint) void,
    draw_spinner: ?extern fn ([*c]GtkStyle, ?*cairo_t, GtkStateType, [*c]GtkWidget, [*c]const gchar, guint, gint, gint, gint, gint) void,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
    _gtk_reserved5: ?extern fn () void,
    _gtk_reserved6: ?extern fn () void,
    _gtk_reserved7: ?extern fn () void,
    _gtk_reserved8: ?extern fn () void,
    _gtk_reserved9: ?extern fn () void,
    _gtk_reserved10: ?extern fn () void,
    _gtk_reserved11: ?extern fn () void,
};
pub const GtkStyleClass = struct__GtkStyleClass;
pub const struct__GtkThemeEngine = @OpaqueType();
pub const GtkThemeEngine = struct__GtkThemeEngine;
pub const GtkRcProperty = struct__GtkRcProperty;
pub extern fn gtk_style_get_type() GType;
pub extern fn gtk_style_new() [*c]GtkStyle;
pub extern fn gtk_style_copy(style: [*c]GtkStyle) [*c]GtkStyle;
pub extern fn gtk_style_attach(style: [*c]GtkStyle, window: ?*GdkWindow) [*c]GtkStyle;
pub extern fn gtk_style_detach(style: [*c]GtkStyle) void;
pub extern fn gtk_style_set_background(style: [*c]GtkStyle, window: ?*GdkWindow, state_type: GtkStateType) void;
pub extern fn gtk_style_apply_default_background(style: [*c]GtkStyle, cr: ?*cairo_t, window: ?*GdkWindow, state_type: GtkStateType, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gtk_style_lookup_icon_set(style: [*c]GtkStyle, stock_id: [*c]const gchar) ?*GtkIconSet;
pub extern fn gtk_style_lookup_color(style: [*c]GtkStyle, color_name: [*c]const gchar, color: [*c]GdkColor) gboolean;
pub extern fn gtk_style_render_icon(style: [*c]GtkStyle, source: ?*const GtkIconSource, direction: GtkTextDirection, state: GtkStateType, size: GtkIconSize, widget: [*c]GtkWidget, detail: [*c]const gchar) ?*GdkPixbuf;
pub extern fn gtk_paint_hline(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, widget: [*c]GtkWidget, detail: [*c]const gchar, x1: gint, x2: gint, y: gint) void;
pub extern fn gtk_paint_vline(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, widget: [*c]GtkWidget, detail: [*c]const gchar, y1_: gint, y2_: gint, x: gint) void;
pub extern fn gtk_paint_shadow(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, shadow_type: GtkShadowType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gtk_paint_arrow(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, shadow_type: GtkShadowType, widget: [*c]GtkWidget, detail: [*c]const gchar, arrow_type: GtkArrowType, fill: gboolean, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gtk_paint_diamond(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, shadow_type: GtkShadowType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gtk_paint_box(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, shadow_type: GtkShadowType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gtk_paint_flat_box(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, shadow_type: GtkShadowType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gtk_paint_check(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, shadow_type: GtkShadowType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gtk_paint_option(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, shadow_type: GtkShadowType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gtk_paint_tab(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, shadow_type: GtkShadowType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gtk_paint_shadow_gap(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, shadow_type: GtkShadowType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, width: gint, height: gint, gap_side: GtkPositionType, gap_x: gint, gap_width: gint) void;
pub extern fn gtk_paint_box_gap(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, shadow_type: GtkShadowType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, width: gint, height: gint, gap_side: GtkPositionType, gap_x: gint, gap_width: gint) void;
pub extern fn gtk_paint_extension(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, shadow_type: GtkShadowType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, width: gint, height: gint, gap_side: GtkPositionType) void;
pub extern fn gtk_paint_focus(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gtk_paint_slider(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, shadow_type: GtkShadowType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, width: gint, height: gint, orientation: GtkOrientation) void;
pub extern fn gtk_paint_handle(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, shadow_type: GtkShadowType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, width: gint, height: gint, orientation: GtkOrientation) void;
pub extern fn gtk_paint_expander(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, expander_style: GtkExpanderStyle) void;
pub extern fn gtk_paint_layout(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, use_text: gboolean, widget: [*c]GtkWidget, detail: [*c]const gchar, x: gint, y: gint, layout: ?*PangoLayout) void;
pub extern fn gtk_paint_resize_grip(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, widget: [*c]GtkWidget, detail: [*c]const gchar, edge: GdkWindowEdge, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gtk_paint_spinner(style: [*c]GtkStyle, cr: ?*cairo_t, state_type: GtkStateType, widget: [*c]GtkWidget, detail: [*c]const gchar, step: guint, x: gint, y: gint, width: gint, height: gint) void;
pub extern fn gtk_style_get_style_property(style: [*c]GtkStyle, widget_type: GType, property_name: [*c]const gchar, value: [*c]GValue) void;
pub extern fn gtk_style_get_valist(style: [*c]GtkStyle, widget_type: GType, first_property_name: [*c]const gchar, var_args: va_list) void;
pub extern fn gtk_style_get(style: [*c]GtkStyle, widget_type: GType, first_property_name: [*c]const gchar, ...) void;
pub extern fn _gtk_style_new_for_path(screen: ?*GdkScreen, path: ?*GtkWidgetPath) [*c]GtkStyle;
pub extern fn _gtk_style_shade(a: [*c]const GdkColor, b: [*c]GdkColor, k: gdouble) void;
pub extern fn gtk_style_has_context(style: [*c]GtkStyle) gboolean;
pub extern fn gtk_widget_style_attach(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_has_rc_style(widget: [*c]GtkWidget) gboolean;
pub extern fn gtk_widget_set_style(widget: [*c]GtkWidget, style: [*c]GtkStyle) void;
pub extern fn gtk_widget_ensure_style(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_get_style(widget: [*c]GtkWidget) [*c]GtkStyle;
pub extern fn gtk_widget_modify_style(widget: [*c]GtkWidget, style: ?*GtkRcStyle) void;
pub extern fn gtk_widget_get_modifier_style(widget: [*c]GtkWidget) ?*GtkRcStyle;
pub extern fn gtk_widget_modify_fg(widget: [*c]GtkWidget, state: GtkStateType, color: [*c]const GdkColor) void;
pub extern fn gtk_widget_modify_bg(widget: [*c]GtkWidget, state: GtkStateType, color: [*c]const GdkColor) void;
pub extern fn gtk_widget_modify_text(widget: [*c]GtkWidget, state: GtkStateType, color: [*c]const GdkColor) void;
pub extern fn gtk_widget_modify_base(widget: [*c]GtkWidget, state: GtkStateType, color: [*c]const GdkColor) void;
pub extern fn gtk_widget_modify_cursor(widget: [*c]GtkWidget, primary: [*c]const GdkColor, secondary: [*c]const GdkColor) void;
pub extern fn gtk_widget_modify_font(widget: [*c]GtkWidget, font_desc: ?*PangoFontDescription) void;
pub extern fn gtk_widget_reset_rc_styles(widget: [*c]GtkWidget) void;
pub extern fn gtk_widget_get_default_style() [*c]GtkStyle;
pub extern fn gtk_widget_path(widget: [*c]GtkWidget, path_length: [*c]guint, path: [*c]([*c]gchar), path_reversed: [*c]([*c]gchar)) void;
pub extern fn gtk_widget_class_path(widget: [*c]GtkWidget, path_length: [*c]guint, path: [*c]([*c]gchar), path_reversed: [*c]([*c]gchar)) void;
pub extern fn gtk_widget_render_icon(widget: [*c]GtkWidget, stock_id: [*c]const gchar, size: GtkIconSize, detail: [*c]const gchar) ?*GdkPixbuf;
pub const struct__GtkTablePrivate = @OpaqueType();
pub const GtkTablePrivate = struct__GtkTablePrivate;
pub const struct__GtkTable = extern struct {
    container: GtkContainer,
    priv: ?*GtkTablePrivate,
};
pub const GtkTable = struct__GtkTable;
pub const struct__GtkTableClass = extern struct {
    parent_class: GtkContainerClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkTableClass = struct__GtkTableClass;
pub const struct__GtkTableChild = @OpaqueType();
pub const GtkTableChild = struct__GtkTableChild;
pub const struct__GtkTableRowCol = @OpaqueType();
pub const GtkTableRowCol = struct__GtkTableRowCol;
pub const GTK_EXPAND = 1;
pub const GTK_SHRINK = 2;
pub const GTK_FILL = 4;
pub const GtkAttachOptions = extern enum {
    GTK_EXPAND = 1,
    GTK_SHRINK = 2,
    GTK_FILL = 4,
};
pub extern fn gtk_table_get_type() GType;
pub extern fn gtk_table_new(rows: guint, columns: guint, homogeneous: gboolean) [*c]GtkWidget;
pub extern fn gtk_table_resize(table: [*c]GtkTable, rows: guint, columns: guint) void;
pub extern fn gtk_table_attach(table: [*c]GtkTable, child: [*c]GtkWidget, left_attach: guint, right_attach: guint, top_attach: guint, bottom_attach: guint, xoptions: GtkAttachOptions, yoptions: GtkAttachOptions, xpadding: guint, ypadding: guint) void;
pub extern fn gtk_table_attach_defaults(table: [*c]GtkTable, widget: [*c]GtkWidget, left_attach: guint, right_attach: guint, top_attach: guint, bottom_attach: guint) void;
pub extern fn gtk_table_set_row_spacing(table: [*c]GtkTable, row: guint, spacing: guint) void;
pub extern fn gtk_table_get_row_spacing(table: [*c]GtkTable, row: guint) guint;
pub extern fn gtk_table_set_col_spacing(table: [*c]GtkTable, column: guint, spacing: guint) void;
pub extern fn gtk_table_get_col_spacing(table: [*c]GtkTable, column: guint) guint;
pub extern fn gtk_table_set_row_spacings(table: [*c]GtkTable, spacing: guint) void;
pub extern fn gtk_table_get_default_row_spacing(table: [*c]GtkTable) guint;
pub extern fn gtk_table_set_col_spacings(table: [*c]GtkTable, spacing: guint) void;
pub extern fn gtk_table_get_default_col_spacing(table: [*c]GtkTable) guint;
pub extern fn gtk_table_set_homogeneous(table: [*c]GtkTable, homogeneous: gboolean) void;
pub extern fn gtk_table_get_homogeneous(table: [*c]GtkTable) gboolean;
pub extern fn gtk_table_get_size(table: [*c]GtkTable, rows: [*c]guint, columns: [*c]guint) void;
pub const struct__GtkTearoffMenuItemPrivate = @OpaqueType();
pub const GtkTearoffMenuItemPrivate = struct__GtkTearoffMenuItemPrivate;
pub const struct__GtkTearoffMenuItem = extern struct {
    menu_item: GtkMenuItem,
    priv: ?*GtkTearoffMenuItemPrivate,
};
pub const GtkTearoffMenuItem = struct__GtkTearoffMenuItem;
pub const struct__GtkTearoffMenuItemClass = extern struct {
    parent_class: GtkMenuItemClass,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkTearoffMenuItemClass = struct__GtkTearoffMenuItemClass;
pub extern fn gtk_tearoff_menu_item_get_type() GType;
pub extern fn gtk_tearoff_menu_item_new() [*c]GtkWidget;
pub const struct_GtkThemingEnginePrivate = @OpaqueType();
pub const GtkThemingEnginePrivate = struct_GtkThemingEnginePrivate;
pub const struct__GtkThemingEngine = extern struct {
    parent_object: GObject,
    priv: ?*GtkThemingEnginePrivate,
};
pub const GtkThemingEngine = struct__GtkThemingEngine;
pub const struct__GtkThemingEngineClass = extern struct {
    parent_class: GObjectClass,
    render_line: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, gdouble, gdouble) void,
    render_background: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, gdouble, gdouble) void,
    render_frame: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, gdouble, gdouble) void,
    render_frame_gap: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, gdouble, gdouble, GtkPositionType, gdouble, gdouble) void,
    render_extension: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, gdouble, gdouble, GtkPositionType) void,
    render_check: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, gdouble, gdouble) void,
    render_option: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, gdouble, gdouble) void,
    render_arrow: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, gdouble, gdouble) void,
    render_expander: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, gdouble, gdouble) void,
    render_focus: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, gdouble, gdouble) void,
    render_layout: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, ?*PangoLayout) void,
    render_slider: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, gdouble, gdouble, GtkOrientation) void,
    render_handle: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, gdouble, gdouble) void,
    render_activity: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, gdouble, gdouble, gdouble, gdouble) void,
    render_icon_pixbuf: ?extern fn ([*c]GtkThemingEngine, ?*const GtkIconSource, GtkIconSize) ?*GdkPixbuf,
    render_icon: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, ?*GdkPixbuf, gdouble, gdouble) void,
    render_icon_surface: ?extern fn ([*c]GtkThemingEngine, ?*cairo_t, ?*cairo_surface_t, gdouble, gdouble) void,
    padding: [14]gpointer,
};
pub const GtkThemingEngineClass = struct__GtkThemingEngineClass;
pub extern fn gtk_theming_engine_get_type() GType;
pub extern fn gtk_theming_engine_register_property(name_space: [*c]const gchar, parse_func: GtkStylePropertyParser, pspec: [*c]GParamSpec) void;
pub extern fn gtk_theming_engine_get_property(engine: [*c]GtkThemingEngine, property: [*c]const gchar, state: GtkStateFlags, value: [*c]GValue) void;
pub extern fn gtk_theming_engine_get_valist(engine: [*c]GtkThemingEngine, state: GtkStateFlags, args: va_list) void;
pub extern fn gtk_theming_engine_get(engine: [*c]GtkThemingEngine, state: GtkStateFlags, ...) void;
pub extern fn gtk_theming_engine_get_style_property(engine: [*c]GtkThemingEngine, property_name: [*c]const gchar, value: [*c]GValue) void;
pub extern fn gtk_theming_engine_get_style_valist(engine: [*c]GtkThemingEngine, args: va_list) void;
pub extern fn gtk_theming_engine_get_style(engine: [*c]GtkThemingEngine, ...) void;
pub extern fn gtk_theming_engine_lookup_color(engine: [*c]GtkThemingEngine, color_name: [*c]const gchar, color: [*c]GdkRGBA) gboolean;
pub extern fn gtk_theming_engine_get_path(engine: [*c]GtkThemingEngine) ?*const GtkWidgetPath;
pub extern fn gtk_theming_engine_has_class(engine: [*c]GtkThemingEngine, style_class: [*c]const gchar) gboolean;
pub extern fn gtk_theming_engine_has_region(engine: [*c]GtkThemingEngine, style_region: [*c]const gchar, flags: [*c]GtkRegionFlags) gboolean;
pub extern fn gtk_theming_engine_get_state(engine: [*c]GtkThemingEngine) GtkStateFlags;
pub extern fn gtk_theming_engine_state_is_running(engine: [*c]GtkThemingEngine, state: GtkStateType, progress: [*c]gdouble) gboolean;
pub extern fn gtk_theming_engine_get_direction(engine: [*c]GtkThemingEngine) GtkTextDirection;
pub extern fn gtk_theming_engine_get_junction_sides(engine: [*c]GtkThemingEngine) GtkJunctionSides;
pub extern fn gtk_theming_engine_get_color(engine: [*c]GtkThemingEngine, state: GtkStateFlags, color: [*c]GdkRGBA) void;
pub extern fn gtk_theming_engine_get_background_color(engine: [*c]GtkThemingEngine, state: GtkStateFlags, color: [*c]GdkRGBA) void;
pub extern fn gtk_theming_engine_get_border_color(engine: [*c]GtkThemingEngine, state: GtkStateFlags, color: [*c]GdkRGBA) void;
pub extern fn gtk_theming_engine_get_border(engine: [*c]GtkThemingEngine, state: GtkStateFlags, border: [*c]GtkBorder) void;
pub extern fn gtk_theming_engine_get_padding(engine: [*c]GtkThemingEngine, state: GtkStateFlags, padding: [*c]GtkBorder) void;
pub extern fn gtk_theming_engine_get_margin(engine: [*c]GtkThemingEngine, state: GtkStateFlags, margin: [*c]GtkBorder) void;
pub extern fn gtk_theming_engine_get_font(engine: [*c]GtkThemingEngine, state: GtkStateFlags) ?*const PangoFontDescription;
pub extern fn gtk_theming_engine_load(name: [*c]const gchar) [*c]GtkThemingEngine;
pub extern fn gtk_theming_engine_get_screen(engine: [*c]GtkThemingEngine) ?*GdkScreen;
pub const struct__GtkUIManagerPrivate = @OpaqueType();
pub const GtkUIManagerPrivate = struct__GtkUIManagerPrivate;
pub const struct__GtkUIManager = extern struct {
    parent: GObject,
    private_data: ?*GtkUIManagerPrivate,
};
pub const GtkUIManager = struct__GtkUIManager;
pub const struct__GtkUIManagerClass = extern struct {
    parent_class: GObjectClass,
    add_widget: ?extern fn ([*c]GtkUIManager, [*c]GtkWidget) void,
    actions_changed: ?extern fn ([*c]GtkUIManager) void,
    connect_proxy: ?extern fn ([*c]GtkUIManager, [*c]GtkAction, [*c]GtkWidget) void,
    disconnect_proxy: ?extern fn ([*c]GtkUIManager, [*c]GtkAction, [*c]GtkWidget) void,
    pre_activate: ?extern fn ([*c]GtkUIManager, [*c]GtkAction) void,
    post_activate: ?extern fn ([*c]GtkUIManager, [*c]GtkAction) void,
    get_widget: ?extern fn ([*c]GtkUIManager, [*c]const gchar) [*c]GtkWidget,
    get_action: ?extern fn ([*c]GtkUIManager, [*c]const gchar) [*c]GtkAction,
    _gtk_reserved1: ?extern fn () void,
    _gtk_reserved2: ?extern fn () void,
    _gtk_reserved3: ?extern fn () void,
    _gtk_reserved4: ?extern fn () void,
};
pub const GtkUIManagerClass = struct__GtkUIManagerClass;
pub const GTK_UI_MANAGER_AUTO = 0;
pub const GTK_UI_MANAGER_MENUBAR = 1;
pub const GTK_UI_MANAGER_MENU = 2;
pub const GTK_UI_MANAGER_TOOLBAR = 4;
pub const GTK_UI_MANAGER_PLACEHOLDER = 8;
pub const GTK_UI_MANAGER_POPUP = 16;
pub const GTK_UI_MANAGER_MENUITEM = 32;
pub const GTK_UI_MANAGER_TOOLITEM = 64;
pub const GTK_UI_MANAGER_SEPARATOR = 128;
pub const GTK_UI_MANAGER_ACCELERATOR = 256;
pub const GTK_UI_MANAGER_POPUP_WITH_ACCELS = 512;
pub const GtkUIManagerItemType = extern enum {
    GTK_UI_MANAGER_AUTO = 0,
    GTK_UI_MANAGER_MENUBAR = 1,
    GTK_UI_MANAGER_MENU = 2,
    GTK_UI_MANAGER_TOOLBAR = 4,
    GTK_UI_MANAGER_PLACEHOLDER = 8,
    GTK_UI_MANAGER_POPUP = 16,
    GTK_UI_MANAGER_MENUITEM = 32,
    GTK_UI_MANAGER_TOOLITEM = 64,
    GTK_UI_MANAGER_SEPARATOR = 128,
    GTK_UI_MANAGER_ACCELERATOR = 256,
    GTK_UI_MANAGER_POPUP_WITH_ACCELS = 512,
};
pub extern fn gtk_ui_manager_get_type() GType;
pub extern fn gtk_ui_manager_new() [*c]GtkUIManager;
pub extern fn gtk_ui_manager_set_add_tearoffs(manager: [*c]GtkUIManager, add_tearoffs: gboolean) void;
pub extern fn gtk_ui_manager_get_add_tearoffs(manager: [*c]GtkUIManager) gboolean;
pub extern fn gtk_ui_manager_insert_action_group(manager: [*c]GtkUIManager, action_group: [*c]GtkActionGroup, pos: gint) void;
pub extern fn gtk_ui_manager_remove_action_group(manager: [*c]GtkUIManager, action_group: [*c]GtkActionGroup) void;
pub extern fn gtk_ui_manager_get_action_groups(manager: [*c]GtkUIManager) [*c]GList;
pub extern fn gtk_ui_manager_get_accel_group(manager: [*c]GtkUIManager) [*c]GtkAccelGroup;
pub extern fn gtk_ui_manager_get_widget(manager: [*c]GtkUIManager, path: [*c]const gchar) [*c]GtkWidget;
pub extern fn gtk_ui_manager_get_toplevels(manager: [*c]GtkUIManager, types: GtkUIManagerItemType) [*c]GSList;
pub extern fn gtk_ui_manager_get_action(manager: [*c]GtkUIManager, path: [*c]const gchar) [*c]GtkAction;
pub extern fn gtk_ui_manager_add_ui_from_string(manager: [*c]GtkUIManager, buffer: [*c]const gchar, length: gssize, @"error": [*c]([*c]GError)) guint;
pub extern fn gtk_ui_manager_add_ui_from_file(manager: [*c]GtkUIManager, filename: [*c]const gchar, @"error": [*c]([*c]GError)) guint;
pub extern fn gtk_ui_manager_add_ui_from_resource(manager: [*c]GtkUIManager, resource_path: [*c]const gchar, @"error": [*c]([*c]GError)) guint;
pub extern fn gtk_ui_manager_add_ui(manager: [*c]GtkUIManager, merge_id: guint, path: [*c]const gchar, name: [*c]const gchar, action: [*c]const gchar, type_0: GtkUIManagerItemType, top: gboolean) void;
pub extern fn gtk_ui_manager_remove_ui(manager: [*c]GtkUIManager, merge_id: guint) void;
pub extern fn gtk_ui_manager_get_ui(manager: [*c]GtkUIManager) [*c]gchar;
pub extern fn gtk_ui_manager_ensure_update(manager: [*c]GtkUIManager) void;
pub extern fn gtk_ui_manager_new_merge_id(manager: [*c]GtkUIManager) guint;
pub const struct__GtkVButtonBox = extern struct {
    button_box: GtkButtonBox,
};
pub const GtkVButtonBox = struct__GtkVButtonBox;
pub const struct__GtkVButtonBoxClass = extern struct {
    parent_class: GtkButtonBoxClass,
};
pub const GtkVButtonBoxClass = struct__GtkVButtonBoxClass;
pub extern fn gtk_vbutton_box_get_type() GType;
pub extern fn gtk_vbutton_box_new() [*c]GtkWidget;
pub const struct__GtkVBox = extern struct {
    box: GtkBox,
};
pub const GtkVBox = struct__GtkVBox;
pub const struct__GtkVBoxClass = extern struct {
    parent_class: GtkBoxClass,
};
pub const GtkVBoxClass = struct__GtkVBoxClass;
pub extern fn gtk_vbox_get_type() GType;
pub extern fn gtk_vbox_new(homogeneous: gboolean, spacing: gint) [*c]GtkWidget;
pub const struct__GtkVPaned = extern struct {
    paned: GtkPaned,
};
pub const GtkVPaned = struct__GtkVPaned;
pub const struct__GtkVPanedClass = extern struct {
    parent_class: GtkPanedClass,
};
pub const GtkVPanedClass = struct__GtkVPanedClass;
pub extern fn gtk_vpaned_get_type() GType;
pub extern fn gtk_vpaned_new() [*c]GtkWidget;
pub const struct__GtkVScale = extern struct {
    scale: GtkScale,
};
pub const GtkVScale = struct__GtkVScale;
pub const struct__GtkVScaleClass = extern struct {
    parent_class: GtkScaleClass,
};
pub const GtkVScaleClass = struct__GtkVScaleClass;
pub extern fn gtk_vscale_get_type() GType;
pub extern fn gtk_vscale_new(adjustment: [*c]GtkAdjustment) [*c]GtkWidget;
pub extern fn gtk_vscale_new_with_range(min: gdouble, max: gdouble, step: gdouble) [*c]GtkWidget;
pub const struct__GtkVScrollbar = extern struct {
    scrollbar: GtkScrollbar,
};
pub const GtkVScrollbar = struct__GtkVScrollbar;
pub const struct__GtkVScrollbarClass = extern struct {
    parent_class: GtkScrollbarClass,
};
pub const GtkVScrollbarClass = struct__GtkVScrollbarClass;
pub extern fn gtk_vscrollbar_get_type() GType;
pub extern fn gtk_vscrollbar_new(adjustment: [*c]GtkAdjustment) [*c]GtkWidget;
pub const struct__GtkVSeparator = extern struct {
    separator: GtkSeparator,
};
pub const GtkVSeparator = struct__GtkVSeparator;
pub const struct__GtkVSeparatorClass = extern struct {
    parent_class: GtkSeparatorClass,
};
pub const GtkVSeparatorClass = struct__GtkVSeparatorClass;
pub extern fn gtk_vseparator_get_type() GType;
pub extern fn gtk_vseparator_new() [*c]GtkWidget;
pub const GtkAccessible_autoptr = [*c]GtkAccessible;
pub const GtkAccessible_listautoptr = [*c]GList;
pub const GtkAccessible_slistautoptr = [*c]GSList;
pub const GtkAccessible_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAccessible(_ptr: [*c]GtkAccessible) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkAccessible(_ptr: [*c]([*c]GtkAccessible)) void {
    glib_autoptr_clear_GtkAccessible(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkAccessible(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkAccessible(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkAccessible(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkActionBar_autoptr = [*c]GtkActionBar;
pub const GtkActionBar_listautoptr = [*c]GList;
pub const GtkActionBar_slistautoptr = [*c]GSList;
pub const GtkActionBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkActionBar(_ptr: [*c]GtkActionBar) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkActionBar(_ptr: [*c]([*c]GtkActionBar)) void {
    glib_autoptr_clear_GtkActionBar(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkActionBar(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkActionBar(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkActionBar(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkActionable_autoptr = ?*GtkActionable;
pub const GtkActionable_listautoptr = [*c]GList;
pub const GtkActionable_slistautoptr = [*c]GSList;
pub const GtkActionable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkActionable(_ptr: ?*GtkActionable) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkActionable(_ptr: [*c](?*GtkActionable)) void {
    glib_autoptr_clear_GtkActionable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkActionable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkActionable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkActionable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkAdjustment_autoptr = [*c]GtkAdjustment;
pub const GtkAdjustment_listautoptr = [*c]GList;
pub const GtkAdjustment_slistautoptr = [*c]GSList;
pub const GtkAdjustment_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAdjustment(_ptr: [*c]GtkAdjustment) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkAdjustment(_ptr: [*c]([*c]GtkAdjustment)) void {
    glib_autoptr_clear_GtkAdjustment(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkAdjustment(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkAdjustment(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkAdjustment(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkAppChooser_autoptr = ?*GtkAppChooser;
pub const GtkAppChooser_listautoptr = [*c]GList;
pub const GtkAppChooser_slistautoptr = [*c]GSList;
pub const GtkAppChooser_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAppChooser(_ptr: ?*GtkAppChooser) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkAppChooser(_ptr: [*c](?*GtkAppChooser)) void {
    glib_autoptr_clear_GtkAppChooser(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkAppChooser(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkAppChooser(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkAppChooser(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkAppChooserButton_autoptr = [*c]GtkAppChooserButton;
pub const GtkAppChooserButton_listautoptr = [*c]GList;
pub const GtkAppChooserButton_slistautoptr = [*c]GSList;
pub const GtkAppChooserButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAppChooserButton(_ptr: [*c]GtkAppChooserButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkAppChooserButton(_ptr: [*c]([*c]GtkAppChooserButton)) void {
    glib_autoptr_clear_GtkAppChooserButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkAppChooserButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkAppChooserButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkAppChooserButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkAppChooserDialog_autoptr = [*c]GtkAppChooserDialog;
pub const GtkAppChooserDialog_listautoptr = [*c]GList;
pub const GtkAppChooserDialog_slistautoptr = [*c]GSList;
pub const GtkAppChooserDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAppChooserDialog(_ptr: [*c]GtkAppChooserDialog) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkAppChooserDialog(_ptr: [*c]([*c]GtkAppChooserDialog)) void {
    glib_autoptr_clear_GtkAppChooserDialog(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkAppChooserDialog(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkAppChooserDialog(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkAppChooserDialog(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkAppChooserWidget_autoptr = [*c]GtkAppChooserWidget;
pub const GtkAppChooserWidget_listautoptr = [*c]GList;
pub const GtkAppChooserWidget_slistautoptr = [*c]GSList;
pub const GtkAppChooserWidget_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAppChooserWidget(_ptr: [*c]GtkAppChooserWidget) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkAppChooserWidget(_ptr: [*c]([*c]GtkAppChooserWidget)) void {
    glib_autoptr_clear_GtkAppChooserWidget(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkAppChooserWidget(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkAppChooserWidget(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkAppChooserWidget(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkApplicationWindow_autoptr = [*c]GtkApplicationWindow;
pub const GtkApplicationWindow_listautoptr = [*c]GList;
pub const GtkApplicationWindow_slistautoptr = [*c]GSList;
pub const GtkApplicationWindow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkApplicationWindow(_ptr: [*c]GtkApplicationWindow) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkApplicationWindow(_ptr: [*c]([*c]GtkApplicationWindow)) void {
    glib_autoptr_clear_GtkApplicationWindow(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkApplicationWindow(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkApplicationWindow(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkApplicationWindow(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkAspectFrame_autoptr = [*c]GtkAspectFrame;
pub const GtkAspectFrame_listautoptr = [*c]GList;
pub const GtkAspectFrame_slistautoptr = [*c]GSList;
pub const GtkAspectFrame_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAspectFrame(_ptr: [*c]GtkAspectFrame) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkAspectFrame(_ptr: [*c]([*c]GtkAspectFrame)) void {
    glib_autoptr_clear_GtkAspectFrame(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkAspectFrame(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkAspectFrame(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkAspectFrame(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkAssistant_autoptr = [*c]GtkAssistant;
pub const GtkAssistant_listautoptr = [*c]GList;
pub const GtkAssistant_slistautoptr = [*c]GSList;
pub const GtkAssistant_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkAssistant(_ptr: [*c]GtkAssistant) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkAssistant(_ptr: [*c]([*c]GtkAssistant)) void {
    glib_autoptr_clear_GtkAssistant(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkAssistant(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkAssistant(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkAssistant(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkBox_autoptr = [*c]GtkBox;
pub const GtkBox_listautoptr = [*c]GList;
pub const GtkBox_slistautoptr = [*c]GSList;
pub const GtkBox_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBox(_ptr: [*c]GtkBox) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkBox(_ptr: [*c]([*c]GtkBox)) void {
    glib_autoptr_clear_GtkBox(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkBox(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkBox(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkBox(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkBuildable_autoptr = ?*GtkBuildable;
pub const GtkBuildable_listautoptr = [*c]GList;
pub const GtkBuildable_slistautoptr = [*c]GSList;
pub const GtkBuildable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBuildable(_ptr: ?*GtkBuildable) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkBuildable(_ptr: [*c](?*GtkBuildable)) void {
    glib_autoptr_clear_GtkBuildable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkBuildable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkBuildable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkBuildable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkBuilder_autoptr = [*c]GtkBuilder;
pub const GtkBuilder_listautoptr = [*c]GList;
pub const GtkBuilder_slistautoptr = [*c]GSList;
pub const GtkBuilder_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkBuilder(_ptr: [*c]GtkBuilder) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkBuilder(_ptr: [*c]([*c]GtkBuilder)) void {
    glib_autoptr_clear_GtkBuilder(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkBuilder(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkBuilder(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkBuilder(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkButton_autoptr = [*c]GtkButton;
pub const GtkButton_listautoptr = [*c]GList;
pub const GtkButton_slistautoptr = [*c]GSList;
pub const GtkButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkButton(_ptr: [*c]GtkButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkButton(_ptr: [*c]([*c]GtkButton)) void {
    glib_autoptr_clear_GtkButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkButtonBox_autoptr = [*c]GtkButtonBox;
pub const GtkButtonBox_listautoptr = [*c]GList;
pub const GtkButtonBox_slistautoptr = [*c]GSList;
pub const GtkButtonBox_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkButtonBox(_ptr: [*c]GtkButtonBox) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkButtonBox(_ptr: [*c]([*c]GtkButtonBox)) void {
    glib_autoptr_clear_GtkButtonBox(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkButtonBox(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkButtonBox(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkButtonBox(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCalendar_autoptr = [*c]GtkCalendar;
pub const GtkCalendar_listautoptr = [*c]GList;
pub const GtkCalendar_slistautoptr = [*c]GSList;
pub const GtkCalendar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCalendar(_ptr: [*c]GtkCalendar) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCalendar(_ptr: [*c]([*c]GtkCalendar)) void {
    glib_autoptr_clear_GtkCalendar(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCalendar(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCalendar(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCalendar(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellArea_autoptr = [*c]GtkCellArea;
pub const GtkCellArea_listautoptr = [*c]GList;
pub const GtkCellArea_slistautoptr = [*c]GSList;
pub const GtkCellArea_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellArea(_ptr: [*c]GtkCellArea) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellArea(_ptr: [*c]([*c]GtkCellArea)) void {
    glib_autoptr_clear_GtkCellArea(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellArea(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellArea(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellArea(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellAreaBox_autoptr = [*c]GtkCellAreaBox;
pub const GtkCellAreaBox_listautoptr = [*c]GList;
pub const GtkCellAreaBox_slistautoptr = [*c]GSList;
pub const GtkCellAreaBox_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellAreaBox(_ptr: [*c]GtkCellAreaBox) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellAreaBox(_ptr: [*c]([*c]GtkCellAreaBox)) void {
    glib_autoptr_clear_GtkCellAreaBox(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellAreaBox(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellAreaBox(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellAreaBox(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellAreaContext_autoptr = [*c]GtkCellAreaContext;
pub const GtkCellAreaContext_listautoptr = [*c]GList;
pub const GtkCellAreaContext_slistautoptr = [*c]GSList;
pub const GtkCellAreaContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellAreaContext(_ptr: [*c]GtkCellAreaContext) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellAreaContext(_ptr: [*c]([*c]GtkCellAreaContext)) void {
    glib_autoptr_clear_GtkCellAreaContext(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellAreaContext(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellAreaContext(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellAreaContext(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellEditable_autoptr = ?*GtkCellEditable;
pub const GtkCellEditable_listautoptr = [*c]GList;
pub const GtkCellEditable_slistautoptr = [*c]GSList;
pub const GtkCellEditable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellEditable(_ptr: ?*GtkCellEditable) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellEditable(_ptr: [*c](?*GtkCellEditable)) void {
    glib_autoptr_clear_GtkCellEditable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellEditable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellEditable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellEditable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellLayout_autoptr = ?*GtkCellLayout;
pub const GtkCellLayout_listautoptr = [*c]GList;
pub const GtkCellLayout_slistautoptr = [*c]GSList;
pub const GtkCellLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellLayout(_ptr: ?*GtkCellLayout) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellLayout(_ptr: [*c](?*GtkCellLayout)) void {
    glib_autoptr_clear_GtkCellLayout(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellLayout(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellLayout(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellLayout(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellRenderer_autoptr = [*c]GtkCellRenderer;
pub const GtkCellRenderer_listautoptr = [*c]GList;
pub const GtkCellRenderer_slistautoptr = [*c]GSList;
pub const GtkCellRenderer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRenderer(_ptr: [*c]GtkCellRenderer) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellRenderer(_ptr: [*c]([*c]GtkCellRenderer)) void {
    glib_autoptr_clear_GtkCellRenderer(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRenderer(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRenderer(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRenderer(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellRendererAccel_autoptr = [*c]GtkCellRendererAccel;
pub const GtkCellRendererAccel_listautoptr = [*c]GList;
pub const GtkCellRendererAccel_slistautoptr = [*c]GSList;
pub const GtkCellRendererAccel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererAccel(_ptr: [*c]GtkCellRendererAccel) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellRendererAccel(_ptr: [*c]([*c]GtkCellRendererAccel)) void {
    glib_autoptr_clear_GtkCellRendererAccel(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererAccel(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererAccel(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererAccel(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellRendererCombo_autoptr = [*c]GtkCellRendererCombo;
pub const GtkCellRendererCombo_listautoptr = [*c]GList;
pub const GtkCellRendererCombo_slistautoptr = [*c]GSList;
pub const GtkCellRendererCombo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererCombo(_ptr: [*c]GtkCellRendererCombo) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellRendererCombo(_ptr: [*c]([*c]GtkCellRendererCombo)) void {
    glib_autoptr_clear_GtkCellRendererCombo(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererCombo(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererCombo(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererCombo(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellRendererPixbuf_autoptr = [*c]GtkCellRendererPixbuf;
pub const GtkCellRendererPixbuf_listautoptr = [*c]GList;
pub const GtkCellRendererPixbuf_slistautoptr = [*c]GSList;
pub const GtkCellRendererPixbuf_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererPixbuf(_ptr: [*c]GtkCellRendererPixbuf) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellRendererPixbuf(_ptr: [*c]([*c]GtkCellRendererPixbuf)) void {
    glib_autoptr_clear_GtkCellRendererPixbuf(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererPixbuf(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererPixbuf(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererPixbuf(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellRendererProgress_autoptr = [*c]GtkCellRendererProgress;
pub const GtkCellRendererProgress_listautoptr = [*c]GList;
pub const GtkCellRendererProgress_slistautoptr = [*c]GSList;
pub const GtkCellRendererProgress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererProgress(_ptr: [*c]GtkCellRendererProgress) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellRendererProgress(_ptr: [*c]([*c]GtkCellRendererProgress)) void {
    glib_autoptr_clear_GtkCellRendererProgress(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererProgress(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererProgress(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererProgress(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellRendererSpin_autoptr = [*c]GtkCellRendererSpin;
pub const GtkCellRendererSpin_listautoptr = [*c]GList;
pub const GtkCellRendererSpin_slistautoptr = [*c]GSList;
pub const GtkCellRendererSpin_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererSpin(_ptr: [*c]GtkCellRendererSpin) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellRendererSpin(_ptr: [*c]([*c]GtkCellRendererSpin)) void {
    glib_autoptr_clear_GtkCellRendererSpin(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererSpin(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererSpin(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererSpin(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellRendererSpinner_autoptr = [*c]GtkCellRendererSpinner;
pub const GtkCellRendererSpinner_listautoptr = [*c]GList;
pub const GtkCellRendererSpinner_slistautoptr = [*c]GSList;
pub const GtkCellRendererSpinner_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererSpinner(_ptr: [*c]GtkCellRendererSpinner) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellRendererSpinner(_ptr: [*c]([*c]GtkCellRendererSpinner)) void {
    glib_autoptr_clear_GtkCellRendererSpinner(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererSpinner(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererSpinner(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererSpinner(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellRendererText_autoptr = [*c]GtkCellRendererText;
pub const GtkCellRendererText_listautoptr = [*c]GList;
pub const GtkCellRendererText_slistautoptr = [*c]GSList;
pub const GtkCellRendererText_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererText(_ptr: [*c]GtkCellRendererText) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellRendererText(_ptr: [*c]([*c]GtkCellRendererText)) void {
    glib_autoptr_clear_GtkCellRendererText(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererText(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererText(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererText(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellRendererToggle_autoptr = [*c]GtkCellRendererToggle;
pub const GtkCellRendererToggle_listautoptr = [*c]GList;
pub const GtkCellRendererToggle_slistautoptr = [*c]GSList;
pub const GtkCellRendererToggle_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellRendererToggle(_ptr: [*c]GtkCellRendererToggle) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellRendererToggle(_ptr: [*c]([*c]GtkCellRendererToggle)) void {
    glib_autoptr_clear_GtkCellRendererToggle(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellRendererToggle(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellRendererToggle(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellRendererToggle(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCellView_autoptr = [*c]GtkCellView;
pub const GtkCellView_listautoptr = [*c]GList;
pub const GtkCellView_slistautoptr = [*c]GSList;
pub const GtkCellView_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCellView(_ptr: [*c]GtkCellView) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCellView(_ptr: [*c]([*c]GtkCellView)) void {
    glib_autoptr_clear_GtkCellView(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCellView(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCellView(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCellView(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCheckButton_autoptr = [*c]GtkCheckButton;
pub const GtkCheckButton_listautoptr = [*c]GList;
pub const GtkCheckButton_slistautoptr = [*c]GSList;
pub const GtkCheckButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCheckButton(_ptr: [*c]GtkCheckButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCheckButton(_ptr: [*c]([*c]GtkCheckButton)) void {
    glib_autoptr_clear_GtkCheckButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCheckButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCheckButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCheckButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCheckMenuItem_autoptr = [*c]GtkCheckMenuItem;
pub const GtkCheckMenuItem_listautoptr = [*c]GList;
pub const GtkCheckMenuItem_slistautoptr = [*c]GSList;
pub const GtkCheckMenuItem_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCheckMenuItem(_ptr: [*c]GtkCheckMenuItem) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCheckMenuItem(_ptr: [*c]([*c]GtkCheckMenuItem)) void {
    glib_autoptr_clear_GtkCheckMenuItem(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCheckMenuItem(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCheckMenuItem(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCheckMenuItem(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkClipboard_autoptr = ?*GtkClipboard;
pub const GtkClipboard_listautoptr = [*c]GList;
pub const GtkClipboard_slistautoptr = [*c]GSList;
pub const GtkClipboard_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkClipboard(_ptr: ?*GtkClipboard) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkClipboard(_ptr: [*c](?*GtkClipboard)) void {
    glib_autoptr_clear_GtkClipboard(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkClipboard(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkClipboard(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkClipboard(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkColorButton_autoptr = [*c]GtkColorButton;
pub const GtkColorButton_listautoptr = [*c]GList;
pub const GtkColorButton_slistautoptr = [*c]GSList;
pub const GtkColorButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColorButton(_ptr: [*c]GtkColorButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkColorButton(_ptr: [*c]([*c]GtkColorButton)) void {
    glib_autoptr_clear_GtkColorButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkColorButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkColorButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkColorButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkColorChooser_autoptr = ?*GtkColorChooser;
pub const GtkColorChooser_listautoptr = [*c]GList;
pub const GtkColorChooser_slistautoptr = [*c]GSList;
pub const GtkColorChooser_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColorChooser(_ptr: ?*GtkColorChooser) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkColorChooser(_ptr: [*c](?*GtkColorChooser)) void {
    glib_autoptr_clear_GtkColorChooser(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkColorChooser(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkColorChooser(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkColorChooser(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkColorChooserDialog_autoptr = [*c]GtkColorChooserDialog;
pub const GtkColorChooserDialog_listautoptr = [*c]GList;
pub const GtkColorChooserDialog_slistautoptr = [*c]GSList;
pub const GtkColorChooserDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColorChooserDialog(_ptr: [*c]GtkColorChooserDialog) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkColorChooserDialog(_ptr: [*c]([*c]GtkColorChooserDialog)) void {
    glib_autoptr_clear_GtkColorChooserDialog(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkColorChooserDialog(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkColorChooserDialog(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkColorChooserDialog(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkColorChooserWidget_autoptr = [*c]GtkColorChooserWidget;
pub const GtkColorChooserWidget_listautoptr = [*c]GList;
pub const GtkColorChooserWidget_slistautoptr = [*c]GSList;
pub const GtkColorChooserWidget_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkColorChooserWidget(_ptr: [*c]GtkColorChooserWidget) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkColorChooserWidget(_ptr: [*c]([*c]GtkColorChooserWidget)) void {
    glib_autoptr_clear_GtkColorChooserWidget(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkColorChooserWidget(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkColorChooserWidget(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkColorChooserWidget(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkComboBox_autoptr = [*c]GtkComboBox;
pub const GtkComboBox_listautoptr = [*c]GList;
pub const GtkComboBox_slistautoptr = [*c]GSList;
pub const GtkComboBox_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkComboBox(_ptr: [*c]GtkComboBox) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkComboBox(_ptr: [*c]([*c]GtkComboBox)) void {
    glib_autoptr_clear_GtkComboBox(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkComboBox(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkComboBox(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkComboBox(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkComboBoxText_autoptr = [*c]GtkComboBoxText;
pub const GtkComboBoxText_listautoptr = [*c]GList;
pub const GtkComboBoxText_slistautoptr = [*c]GSList;
pub const GtkComboBoxText_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkComboBoxText(_ptr: [*c]GtkComboBoxText) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkComboBoxText(_ptr: [*c]([*c]GtkComboBoxText)) void {
    glib_autoptr_clear_GtkComboBoxText(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkComboBoxText(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkComboBoxText(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkComboBoxText(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkCssProvider_autoptr = [*c]GtkCssProvider;
pub const GtkCssProvider_listautoptr = [*c]GList;
pub const GtkCssProvider_slistautoptr = [*c]GSList;
pub const GtkCssProvider_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkCssProvider(_ptr: [*c]GtkCssProvider) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkCssProvider(_ptr: [*c]([*c]GtkCssProvider)) void {
    glib_autoptr_clear_GtkCssProvider(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkCssProvider(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkCssProvider(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkCssProvider(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkDrawingArea_autoptr = [*c]GtkDrawingArea;
pub const GtkDrawingArea_listautoptr = [*c]GList;
pub const GtkDrawingArea_slistautoptr = [*c]GSList;
pub const GtkDrawingArea_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkDrawingArea(_ptr: [*c]GtkDrawingArea) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkDrawingArea(_ptr: [*c]([*c]GtkDrawingArea)) void {
    glib_autoptr_clear_GtkDrawingArea(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkDrawingArea(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkDrawingArea(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkDrawingArea(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkEditable_autoptr = ?*GtkEditable;
pub const GtkEditable_listautoptr = [*c]GList;
pub const GtkEditable_slistautoptr = [*c]GSList;
pub const GtkEditable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEditable(_ptr: ?*GtkEditable) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkEditable(_ptr: [*c](?*GtkEditable)) void {
    glib_autoptr_clear_GtkEditable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkEditable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkEditable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkEditable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkEntry_autoptr = [*c]GtkEntry;
pub const GtkEntry_listautoptr = [*c]GList;
pub const GtkEntry_slistautoptr = [*c]GSList;
pub const GtkEntry_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEntry(_ptr: [*c]GtkEntry) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkEntry(_ptr: [*c]([*c]GtkEntry)) void {
    glib_autoptr_clear_GtkEntry(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkEntry(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkEntry(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkEntry(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkEntryBuffer_autoptr = [*c]GtkEntryBuffer;
pub const GtkEntryBuffer_listautoptr = [*c]GList;
pub const GtkEntryBuffer_slistautoptr = [*c]GSList;
pub const GtkEntryBuffer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEntryBuffer(_ptr: [*c]GtkEntryBuffer) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkEntryBuffer(_ptr: [*c]([*c]GtkEntryBuffer)) void {
    glib_autoptr_clear_GtkEntryBuffer(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkEntryBuffer(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkEntryBuffer(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkEntryBuffer(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkEntryCompletion_autoptr = [*c]GtkEntryCompletion;
pub const GtkEntryCompletion_listautoptr = [*c]GList;
pub const GtkEntryCompletion_slistautoptr = [*c]GSList;
pub const GtkEntryCompletion_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEntryCompletion(_ptr: [*c]GtkEntryCompletion) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkEntryCompletion(_ptr: [*c]([*c]GtkEntryCompletion)) void {
    glib_autoptr_clear_GtkEntryCompletion(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkEntryCompletion(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkEntryCompletion(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkEntryCompletion(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkEventBox_autoptr = [*c]GtkEventBox;
pub const GtkEventBox_listautoptr = [*c]GList;
pub const GtkEventBox_slistautoptr = [*c]GSList;
pub const GtkEventBox_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEventBox(_ptr: [*c]GtkEventBox) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkEventBox(_ptr: [*c]([*c]GtkEventBox)) void {
    glib_autoptr_clear_GtkEventBox(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkEventBox(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkEventBox(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkEventBox(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkEventController_autoptr = ?*GtkEventController;
pub const GtkEventController_listautoptr = [*c]GList;
pub const GtkEventController_slistautoptr = [*c]GSList;
pub const GtkEventController_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkEventController(_ptr: ?*GtkEventController) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkEventController(_ptr: [*c](?*GtkEventController)) void {
    glib_autoptr_clear_GtkEventController(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkEventController(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkEventController(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkEventController(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkExpander_autoptr = [*c]GtkExpander;
pub const GtkExpander_listautoptr = [*c]GList;
pub const GtkExpander_slistautoptr = [*c]GSList;
pub const GtkExpander_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkExpander(_ptr: [*c]GtkExpander) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkExpander(_ptr: [*c]([*c]GtkExpander)) void {
    glib_autoptr_clear_GtkExpander(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkExpander(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkExpander(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkExpander(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkFileChooserButton_autoptr = [*c]GtkFileChooserButton;
pub const GtkFileChooserButton_listautoptr = [*c]GList;
pub const GtkFileChooserButton_slistautoptr = [*c]GSList;
pub const GtkFileChooserButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileChooserButton(_ptr: [*c]GtkFileChooserButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkFileChooserButton(_ptr: [*c]([*c]GtkFileChooserButton)) void {
    glib_autoptr_clear_GtkFileChooserButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkFileChooserButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkFileChooserButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkFileChooserButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkFileChooserDialog_autoptr = [*c]GtkFileChooserDialog;
pub const GtkFileChooserDialog_listautoptr = [*c]GList;
pub const GtkFileChooserDialog_slistautoptr = [*c]GSList;
pub const GtkFileChooserDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileChooserDialog(_ptr: [*c]GtkFileChooserDialog) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkFileChooserDialog(_ptr: [*c]([*c]GtkFileChooserDialog)) void {
    glib_autoptr_clear_GtkFileChooserDialog(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkFileChooserDialog(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkFileChooserDialog(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkFileChooserDialog(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkFileChooserWidget_autoptr = [*c]GtkFileChooserWidget;
pub const GtkFileChooserWidget_listautoptr = [*c]GList;
pub const GtkFileChooserWidget_slistautoptr = [*c]GSList;
pub const GtkFileChooserWidget_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileChooserWidget(_ptr: [*c]GtkFileChooserWidget) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkFileChooserWidget(_ptr: [*c]([*c]GtkFileChooserWidget)) void {
    glib_autoptr_clear_GtkFileChooserWidget(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkFileChooserWidget(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkFileChooserWidget(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkFileChooserWidget(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkFileFilter_autoptr = ?*GtkFileFilter;
pub const GtkFileFilter_listautoptr = [*c]GList;
pub const GtkFileFilter_slistautoptr = [*c]GSList;
pub const GtkFileFilter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFileFilter(_ptr: ?*GtkFileFilter) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkFileFilter(_ptr: [*c](?*GtkFileFilter)) void {
    glib_autoptr_clear_GtkFileFilter(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkFileFilter(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkFileFilter(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkFileFilter(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkFixed_autoptr = [*c]GtkFixed;
pub const GtkFixed_listautoptr = [*c]GList;
pub const GtkFixed_slistautoptr = [*c]GSList;
pub const GtkFixed_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFixed(_ptr: [*c]GtkFixed) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkFixed(_ptr: [*c]([*c]GtkFixed)) void {
    glib_autoptr_clear_GtkFixed(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkFixed(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkFixed(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkFixed(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkFlowBox_autoptr = [*c]GtkFlowBox;
pub const GtkFlowBox_listautoptr = [*c]GList;
pub const GtkFlowBox_slistautoptr = [*c]GSList;
pub const GtkFlowBox_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFlowBox(_ptr: [*c]GtkFlowBox) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkFlowBox(_ptr: [*c]([*c]GtkFlowBox)) void {
    glib_autoptr_clear_GtkFlowBox(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkFlowBox(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkFlowBox(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkFlowBox(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkFlowBoxChild_autoptr = [*c]GtkFlowBoxChild;
pub const GtkFlowBoxChild_listautoptr = [*c]GList;
pub const GtkFlowBoxChild_slistautoptr = [*c]GSList;
pub const GtkFlowBoxChild_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFlowBoxChild(_ptr: [*c]GtkFlowBoxChild) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkFlowBoxChild(_ptr: [*c]([*c]GtkFlowBoxChild)) void {
    glib_autoptr_clear_GtkFlowBoxChild(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkFlowBoxChild(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkFlowBoxChild(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkFlowBoxChild(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkFontButton_autoptr = [*c]GtkFontButton;
pub const GtkFontButton_listautoptr = [*c]GList;
pub const GtkFontButton_slistautoptr = [*c]GSList;
pub const GtkFontButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFontButton(_ptr: [*c]GtkFontButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkFontButton(_ptr: [*c]([*c]GtkFontButton)) void {
    glib_autoptr_clear_GtkFontButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkFontButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkFontButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkFontButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkFontChooser_autoptr = ?*GtkFontChooser;
pub const GtkFontChooser_listautoptr = [*c]GList;
pub const GtkFontChooser_slistautoptr = [*c]GSList;
pub const GtkFontChooser_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFontChooser(_ptr: ?*GtkFontChooser) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkFontChooser(_ptr: [*c](?*GtkFontChooser)) void {
    glib_autoptr_clear_GtkFontChooser(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkFontChooser(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkFontChooser(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkFontChooser(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkFontChooserDialog_autoptr = [*c]GtkFontChooserDialog;
pub const GtkFontChooserDialog_listautoptr = [*c]GList;
pub const GtkFontChooserDialog_slistautoptr = [*c]GSList;
pub const GtkFontChooserDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFontChooserDialog(_ptr: [*c]GtkFontChooserDialog) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkFontChooserDialog(_ptr: [*c]([*c]GtkFontChooserDialog)) void {
    glib_autoptr_clear_GtkFontChooserDialog(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkFontChooserDialog(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkFontChooserDialog(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkFontChooserDialog(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkFontChooserWidget_autoptr = [*c]GtkFontChooserWidget;
pub const GtkFontChooserWidget_listautoptr = [*c]GList;
pub const GtkFontChooserWidget_slistautoptr = [*c]GSList;
pub const GtkFontChooserWidget_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFontChooserWidget(_ptr: [*c]GtkFontChooserWidget) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkFontChooserWidget(_ptr: [*c]([*c]GtkFontChooserWidget)) void {
    glib_autoptr_clear_GtkFontChooserWidget(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkFontChooserWidget(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkFontChooserWidget(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkFontChooserWidget(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkFrame_autoptr = [*c]GtkFrame;
pub const GtkFrame_listautoptr = [*c]GList;
pub const GtkFrame_slistautoptr = [*c]GSList;
pub const GtkFrame_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkFrame(_ptr: [*c]GtkFrame) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkFrame(_ptr: [*c]([*c]GtkFrame)) void {
    glib_autoptr_clear_GtkFrame(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkFrame(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkFrame(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkFrame(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkGLArea_autoptr = [*c]GtkGLArea;
pub const GtkGLArea_listautoptr = [*c]GList;
pub const GtkGLArea_slistautoptr = [*c]GSList;
pub const GtkGLArea_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGLArea(_ptr: [*c]GtkGLArea) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkGLArea(_ptr: [*c]([*c]GtkGLArea)) void {
    glib_autoptr_clear_GtkGLArea(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkGLArea(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkGLArea(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkGLArea(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkGesture_autoptr = ?*GtkGesture;
pub const GtkGesture_listautoptr = [*c]GList;
pub const GtkGesture_slistautoptr = [*c]GSList;
pub const GtkGesture_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGesture(_ptr: ?*GtkGesture) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkGesture(_ptr: [*c](?*GtkGesture)) void {
    glib_autoptr_clear_GtkGesture(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkGesture(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkGesture(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkGesture(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkGestureDrag_autoptr = ?*GtkGestureDrag;
pub const GtkGestureDrag_listautoptr = [*c]GList;
pub const GtkGestureDrag_slistautoptr = [*c]GSList;
pub const GtkGestureDrag_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureDrag(_ptr: ?*GtkGestureDrag) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkGestureDrag(_ptr: [*c](?*GtkGestureDrag)) void {
    glib_autoptr_clear_GtkGestureDrag(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureDrag(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureDrag(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureDrag(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkGestureLongPress_autoptr = ?*GtkGestureLongPress;
pub const GtkGestureLongPress_listautoptr = [*c]GList;
pub const GtkGestureLongPress_slistautoptr = [*c]GSList;
pub const GtkGestureLongPress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureLongPress(_ptr: ?*GtkGestureLongPress) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkGestureLongPress(_ptr: [*c](?*GtkGestureLongPress)) void {
    glib_autoptr_clear_GtkGestureLongPress(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureLongPress(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureLongPress(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureLongPress(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkGestureMultiPress_autoptr = ?*GtkGestureMultiPress;
pub const GtkGestureMultiPress_listautoptr = [*c]GList;
pub const GtkGestureMultiPress_slistautoptr = [*c]GSList;
pub const GtkGestureMultiPress_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureMultiPress(_ptr: ?*GtkGestureMultiPress) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkGestureMultiPress(_ptr: [*c](?*GtkGestureMultiPress)) void {
    glib_autoptr_clear_GtkGestureMultiPress(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureMultiPress(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureMultiPress(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureMultiPress(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkGesturePan_autoptr = ?*GtkGesturePan;
pub const GtkGesturePan_listautoptr = [*c]GList;
pub const GtkGesturePan_slistautoptr = [*c]GSList;
pub const GtkGesturePan_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGesturePan(_ptr: ?*GtkGesturePan) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkGesturePan(_ptr: [*c](?*GtkGesturePan)) void {
    glib_autoptr_clear_GtkGesturePan(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkGesturePan(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkGesturePan(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkGesturePan(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkGestureRotate_autoptr = ?*GtkGestureRotate;
pub const GtkGestureRotate_listautoptr = [*c]GList;
pub const GtkGestureRotate_slistautoptr = [*c]GSList;
pub const GtkGestureRotate_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureRotate(_ptr: ?*GtkGestureRotate) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkGestureRotate(_ptr: [*c](?*GtkGestureRotate)) void {
    glib_autoptr_clear_GtkGestureRotate(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureRotate(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureRotate(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureRotate(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkGestureSingle_autoptr = ?*GtkGestureSingle;
pub const GtkGestureSingle_listautoptr = [*c]GList;
pub const GtkGestureSingle_slistautoptr = [*c]GSList;
pub const GtkGestureSingle_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureSingle(_ptr: ?*GtkGestureSingle) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkGestureSingle(_ptr: [*c](?*GtkGestureSingle)) void {
    glib_autoptr_clear_GtkGestureSingle(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureSingle(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureSingle(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureSingle(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkGestureSwipe_autoptr = ?*GtkGestureSwipe;
pub const GtkGestureSwipe_listautoptr = [*c]GList;
pub const GtkGestureSwipe_slistautoptr = [*c]GSList;
pub const GtkGestureSwipe_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureSwipe(_ptr: ?*GtkGestureSwipe) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkGestureSwipe(_ptr: [*c](?*GtkGestureSwipe)) void {
    glib_autoptr_clear_GtkGestureSwipe(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureSwipe(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureSwipe(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureSwipe(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkGestureZoom_autoptr = ?*GtkGestureZoom;
pub const GtkGestureZoom_listautoptr = [*c]GList;
pub const GtkGestureZoom_slistautoptr = [*c]GSList;
pub const GtkGestureZoom_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGestureZoom(_ptr: ?*GtkGestureZoom) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkGestureZoom(_ptr: [*c](?*GtkGestureZoom)) void {
    glib_autoptr_clear_GtkGestureZoom(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkGestureZoom(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkGestureZoom(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkGestureZoom(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkGrid_autoptr = [*c]GtkGrid;
pub const GtkGrid_listautoptr = [*c]GList;
pub const GtkGrid_slistautoptr = [*c]GSList;
pub const GtkGrid_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkGrid(_ptr: [*c]GtkGrid) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkGrid(_ptr: [*c]([*c]GtkGrid)) void {
    glib_autoptr_clear_GtkGrid(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkGrid(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkGrid(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkGrid(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkHeaderBar_autoptr = [*c]GtkHeaderBar;
pub const GtkHeaderBar_listautoptr = [*c]GList;
pub const GtkHeaderBar_slistautoptr = [*c]GSList;
pub const GtkHeaderBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkHeaderBar(_ptr: [*c]GtkHeaderBar) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkHeaderBar(_ptr: [*c]([*c]GtkHeaderBar)) void {
    glib_autoptr_clear_GtkHeaderBar(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkHeaderBar(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkHeaderBar(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkHeaderBar(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkIMContext_autoptr = [*c]GtkIMContext;
pub const GtkIMContext_listautoptr = [*c]GList;
pub const GtkIMContext_slistautoptr = [*c]GSList;
pub const GtkIMContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkIMContext(_ptr: [*c]GtkIMContext) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkIMContext(_ptr: [*c]([*c]GtkIMContext)) void {
    glib_autoptr_clear_GtkIMContext(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkIMContext(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkIMContext(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkIMContext(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkIMContextSimple_autoptr = [*c]GtkIMContextSimple;
pub const GtkIMContextSimple_listautoptr = [*c]GList;
pub const GtkIMContextSimple_slistautoptr = [*c]GSList;
pub const GtkIMContextSimple_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkIMContextSimple(_ptr: [*c]GtkIMContextSimple) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkIMContextSimple(_ptr: [*c]([*c]GtkIMContextSimple)) void {
    glib_autoptr_clear_GtkIMContextSimple(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkIMContextSimple(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkIMContextSimple(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkIMContextSimple(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkIMMulticontext_autoptr = [*c]GtkIMMulticontext;
pub const GtkIMMulticontext_listautoptr = [*c]GList;
pub const GtkIMMulticontext_slistautoptr = [*c]GSList;
pub const GtkIMMulticontext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkIMMulticontext(_ptr: [*c]GtkIMMulticontext) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkIMMulticontext(_ptr: [*c]([*c]GtkIMMulticontext)) void {
    glib_autoptr_clear_GtkIMMulticontext(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkIMMulticontext(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkIMMulticontext(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkIMMulticontext(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkIconInfo_autoptr = ?*GtkIconInfo;
pub const GtkIconInfo_listautoptr = [*c]GList;
pub const GtkIconInfo_slistautoptr = [*c]GSList;
pub const GtkIconInfo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkIconInfo(_ptr: ?*GtkIconInfo) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkIconInfo(_ptr: [*c](?*GtkIconInfo)) void {
    glib_autoptr_clear_GtkIconInfo(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkIconInfo(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkIconInfo(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkIconInfo(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkIconTheme_autoptr = [*c]GtkIconTheme;
pub const GtkIconTheme_listautoptr = [*c]GList;
pub const GtkIconTheme_slistautoptr = [*c]GSList;
pub const GtkIconTheme_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkIconTheme(_ptr: [*c]GtkIconTheme) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkIconTheme(_ptr: [*c]([*c]GtkIconTheme)) void {
    glib_autoptr_clear_GtkIconTheme(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkIconTheme(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkIconTheme(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkIconTheme(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkIconView_autoptr = [*c]GtkIconView;
pub const GtkIconView_listautoptr = [*c]GList;
pub const GtkIconView_slistautoptr = [*c]GSList;
pub const GtkIconView_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkIconView(_ptr: [*c]GtkIconView) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkIconView(_ptr: [*c]([*c]GtkIconView)) void {
    glib_autoptr_clear_GtkIconView(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkIconView(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkIconView(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkIconView(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkImage_autoptr = [*c]GtkImage;
pub const GtkImage_listautoptr = [*c]GList;
pub const GtkImage_slistautoptr = [*c]GSList;
pub const GtkImage_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkImage(_ptr: [*c]GtkImage) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkImage(_ptr: [*c]([*c]GtkImage)) void {
    glib_autoptr_clear_GtkImage(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkImage(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkImage(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkImage(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkInfoBar_autoptr = [*c]GtkInfoBar;
pub const GtkInfoBar_listautoptr = [*c]GList;
pub const GtkInfoBar_slistautoptr = [*c]GSList;
pub const GtkInfoBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkInfoBar(_ptr: [*c]GtkInfoBar) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkInfoBar(_ptr: [*c]([*c]GtkInfoBar)) void {
    glib_autoptr_clear_GtkInfoBar(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkInfoBar(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkInfoBar(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkInfoBar(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkInvisible_autoptr = [*c]GtkInvisible;
pub const GtkInvisible_listautoptr = [*c]GList;
pub const GtkInvisible_slistautoptr = [*c]GSList;
pub const GtkInvisible_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkInvisible(_ptr: [*c]GtkInvisible) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkInvisible(_ptr: [*c]([*c]GtkInvisible)) void {
    glib_autoptr_clear_GtkInvisible(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkInvisible(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkInvisible(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkInvisible(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkLayout_autoptr = [*c]GtkLayout;
pub const GtkLayout_listautoptr = [*c]GList;
pub const GtkLayout_slistautoptr = [*c]GSList;
pub const GtkLayout_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkLayout(_ptr: [*c]GtkLayout) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkLayout(_ptr: [*c]([*c]GtkLayout)) void {
    glib_autoptr_clear_GtkLayout(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkLayout(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkLayout(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkLayout(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkLevelBar_autoptr = [*c]GtkLevelBar;
pub const GtkLevelBar_listautoptr = [*c]GList;
pub const GtkLevelBar_slistautoptr = [*c]GSList;
pub const GtkLevelBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkLevelBar(_ptr: [*c]GtkLevelBar) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkLevelBar(_ptr: [*c]([*c]GtkLevelBar)) void {
    glib_autoptr_clear_GtkLevelBar(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkLevelBar(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkLevelBar(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkLevelBar(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkLinkButton_autoptr = [*c]GtkLinkButton;
pub const GtkLinkButton_listautoptr = [*c]GList;
pub const GtkLinkButton_slistautoptr = [*c]GSList;
pub const GtkLinkButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkLinkButton(_ptr: [*c]GtkLinkButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkLinkButton(_ptr: [*c]([*c]GtkLinkButton)) void {
    glib_autoptr_clear_GtkLinkButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkLinkButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkLinkButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkLinkButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkListStore_autoptr = [*c]GtkListStore;
pub const GtkListStore_listautoptr = [*c]GList;
pub const GtkListStore_slistautoptr = [*c]GSList;
pub const GtkListStore_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkListStore(_ptr: [*c]GtkListStore) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkListStore(_ptr: [*c]([*c]GtkListStore)) void {
    glib_autoptr_clear_GtkListStore(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkListStore(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkListStore(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkListStore(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkLockButton_autoptr = [*c]GtkLockButton;
pub const GtkLockButton_listautoptr = [*c]GList;
pub const GtkLockButton_slistautoptr = [*c]GSList;
pub const GtkLockButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkLockButton(_ptr: [*c]GtkLockButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkLockButton(_ptr: [*c]([*c]GtkLockButton)) void {
    glib_autoptr_clear_GtkLockButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkLockButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkLockButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkLockButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkMenuBar_autoptr = [*c]GtkMenuBar;
pub const GtkMenuBar_listautoptr = [*c]GList;
pub const GtkMenuBar_slistautoptr = [*c]GSList;
pub const GtkMenuBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMenuBar(_ptr: [*c]GtkMenuBar) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkMenuBar(_ptr: [*c]([*c]GtkMenuBar)) void {
    glib_autoptr_clear_GtkMenuBar(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkMenuBar(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkMenuBar(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkMenuBar(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkMenuButton_autoptr = [*c]GtkMenuButton;
pub const GtkMenuButton_listautoptr = [*c]GList;
pub const GtkMenuButton_slistautoptr = [*c]GSList;
pub const GtkMenuButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMenuButton(_ptr: [*c]GtkMenuButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkMenuButton(_ptr: [*c]([*c]GtkMenuButton)) void {
    glib_autoptr_clear_GtkMenuButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkMenuButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkMenuButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkMenuButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkMenuItem_autoptr = [*c]GtkMenuItem;
pub const GtkMenuItem_listautoptr = [*c]GList;
pub const GtkMenuItem_slistautoptr = [*c]GSList;
pub const GtkMenuItem_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMenuItem(_ptr: [*c]GtkMenuItem) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkMenuItem(_ptr: [*c]([*c]GtkMenuItem)) void {
    glib_autoptr_clear_GtkMenuItem(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkMenuItem(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkMenuItem(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkMenuItem(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkMenuToolButton_autoptr = [*c]GtkMenuToolButton;
pub const GtkMenuToolButton_listautoptr = [*c]GList;
pub const GtkMenuToolButton_slistautoptr = [*c]GSList;
pub const GtkMenuToolButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMenuToolButton(_ptr: [*c]GtkMenuToolButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkMenuToolButton(_ptr: [*c]([*c]GtkMenuToolButton)) void {
    glib_autoptr_clear_GtkMenuToolButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkMenuToolButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkMenuToolButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkMenuToolButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkMessageDialog_autoptr = [*c]GtkMessageDialog;
pub const GtkMessageDialog_listautoptr = [*c]GList;
pub const GtkMessageDialog_slistautoptr = [*c]GSList;
pub const GtkMessageDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMessageDialog(_ptr: [*c]GtkMessageDialog) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkMessageDialog(_ptr: [*c]([*c]GtkMessageDialog)) void {
    glib_autoptr_clear_GtkMessageDialog(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkMessageDialog(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkMessageDialog(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkMessageDialog(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkMountOperation_autoptr = [*c]GtkMountOperation;
pub const GtkMountOperation_listautoptr = [*c]GList;
pub const GtkMountOperation_slistautoptr = [*c]GSList;
pub const GtkMountOperation_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkMountOperation(_ptr: [*c]GtkMountOperation) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkMountOperation(_ptr: [*c]([*c]GtkMountOperation)) void {
    glib_autoptr_clear_GtkMountOperation(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkMountOperation(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkMountOperation(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkMountOperation(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkNotebook_autoptr = [*c]GtkNotebook;
pub const GtkNotebook_listautoptr = [*c]GList;
pub const GtkNotebook_slistautoptr = [*c]GSList;
pub const GtkNotebook_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkNotebook(_ptr: [*c]GtkNotebook) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkNotebook(_ptr: [*c]([*c]GtkNotebook)) void {
    glib_autoptr_clear_GtkNotebook(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkNotebook(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkNotebook(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkNotebook(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkOffscreenWindow_autoptr = [*c]GtkOffscreenWindow;
pub const GtkOffscreenWindow_listautoptr = [*c]GList;
pub const GtkOffscreenWindow_slistautoptr = [*c]GSList;
pub const GtkOffscreenWindow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkOffscreenWindow(_ptr: [*c]GtkOffscreenWindow) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkOffscreenWindow(_ptr: [*c]([*c]GtkOffscreenWindow)) void {
    glib_autoptr_clear_GtkOffscreenWindow(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkOffscreenWindow(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkOffscreenWindow(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkOffscreenWindow(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkOrientable_autoptr = ?*GtkOrientable;
pub const GtkOrientable_listautoptr = [*c]GList;
pub const GtkOrientable_slistautoptr = [*c]GSList;
pub const GtkOrientable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkOrientable(_ptr: ?*GtkOrientable) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkOrientable(_ptr: [*c](?*GtkOrientable)) void {
    glib_autoptr_clear_GtkOrientable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkOrientable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkOrientable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkOrientable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkOverlay_autoptr = [*c]GtkOverlay;
pub const GtkOverlay_listautoptr = [*c]GList;
pub const GtkOverlay_slistautoptr = [*c]GSList;
pub const GtkOverlay_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkOverlay(_ptr: [*c]GtkOverlay) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkOverlay(_ptr: [*c]([*c]GtkOverlay)) void {
    glib_autoptr_clear_GtkOverlay(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkOverlay(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkOverlay(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkOverlay(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkPageSetup_autoptr = ?*GtkPageSetup;
pub const GtkPageSetup_listautoptr = [*c]GList;
pub const GtkPageSetup_slistautoptr = [*c]GSList;
pub const GtkPageSetup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPageSetup(_ptr: ?*GtkPageSetup) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkPageSetup(_ptr: [*c](?*GtkPageSetup)) void {
    glib_autoptr_clear_GtkPageSetup(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkPageSetup(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkPageSetup(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkPageSetup(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkPaned_autoptr = [*c]GtkPaned;
pub const GtkPaned_listautoptr = [*c]GList;
pub const GtkPaned_slistautoptr = [*c]GSList;
pub const GtkPaned_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPaned(_ptr: [*c]GtkPaned) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkPaned(_ptr: [*c]([*c]GtkPaned)) void {
    glib_autoptr_clear_GtkPaned(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkPaned(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkPaned(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkPaned(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkPlacesSidebar_autoptr = ?*GtkPlacesSidebar;
pub const GtkPlacesSidebar_listautoptr = [*c]GList;
pub const GtkPlacesSidebar_slistautoptr = [*c]GSList;
pub const GtkPlacesSidebar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPlacesSidebar(_ptr: ?*GtkPlacesSidebar) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkPlacesSidebar(_ptr: [*c](?*GtkPlacesSidebar)) void {
    glib_autoptr_clear_GtkPlacesSidebar(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkPlacesSidebar(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkPlacesSidebar(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkPlacesSidebar(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkPopover_autoptr = [*c]GtkPopover;
pub const GtkPopover_listautoptr = [*c]GList;
pub const GtkPopover_slistautoptr = [*c]GSList;
pub const GtkPopover_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPopover(_ptr: [*c]GtkPopover) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkPopover(_ptr: [*c]([*c]GtkPopover)) void {
    glib_autoptr_clear_GtkPopover(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkPopover(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkPopover(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkPopover(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkPopoverMenu_autoptr = ?*GtkPopoverMenu;
pub const GtkPopoverMenu_listautoptr = [*c]GList;
pub const GtkPopoverMenu_slistautoptr = [*c]GSList;
pub const GtkPopoverMenu_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPopoverMenu(_ptr: ?*GtkPopoverMenu) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkPopoverMenu(_ptr: [*c](?*GtkPopoverMenu)) void {
    glib_autoptr_clear_GtkPopoverMenu(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkPopoverMenu(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkPopoverMenu(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkPopoverMenu(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkPrintContext_autoptr = ?*GtkPrintContext;
pub const GtkPrintContext_listautoptr = [*c]GList;
pub const GtkPrintContext_slistautoptr = [*c]GSList;
pub const GtkPrintContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPrintContext(_ptr: ?*GtkPrintContext) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkPrintContext(_ptr: [*c](?*GtkPrintContext)) void {
    glib_autoptr_clear_GtkPrintContext(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkPrintContext(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkPrintContext(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkPrintContext(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkPrintOperation_autoptr = [*c]GtkPrintOperation;
pub const GtkPrintOperation_listautoptr = [*c]GList;
pub const GtkPrintOperation_slistautoptr = [*c]GSList;
pub const GtkPrintOperation_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPrintOperation(_ptr: [*c]GtkPrintOperation) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkPrintOperation(_ptr: [*c]([*c]GtkPrintOperation)) void {
    glib_autoptr_clear_GtkPrintOperation(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkPrintOperation(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkPrintOperation(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkPrintOperation(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkPrintOperationPreview_autoptr = ?*GtkPrintOperationPreview;
pub const GtkPrintOperationPreview_listautoptr = [*c]GList;
pub const GtkPrintOperationPreview_slistautoptr = [*c]GSList;
pub const GtkPrintOperationPreview_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPrintOperationPreview(_ptr: ?*GtkPrintOperationPreview) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkPrintOperationPreview(_ptr: [*c](?*GtkPrintOperationPreview)) void {
    glib_autoptr_clear_GtkPrintOperationPreview(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkPrintOperationPreview(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkPrintOperationPreview(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkPrintOperationPreview(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkPrintSettings_autoptr = ?*GtkPrintSettings;
pub const GtkPrintSettings_listautoptr = [*c]GList;
pub const GtkPrintSettings_slistautoptr = [*c]GSList;
pub const GtkPrintSettings_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPrintSettings(_ptr: ?*GtkPrintSettings) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkPrintSettings(_ptr: [*c](?*GtkPrintSettings)) void {
    glib_autoptr_clear_GtkPrintSettings(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkPrintSettings(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkPrintSettings(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkPrintSettings(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkProgressBar_autoptr = [*c]GtkProgressBar;
pub const GtkProgressBar_listautoptr = [*c]GList;
pub const GtkProgressBar_slistautoptr = [*c]GSList;
pub const GtkProgressBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkProgressBar(_ptr: [*c]GtkProgressBar) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkProgressBar(_ptr: [*c]([*c]GtkProgressBar)) void {
    glib_autoptr_clear_GtkProgressBar(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkProgressBar(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkProgressBar(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkProgressBar(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkRadioButton_autoptr = [*c]GtkRadioButton;
pub const GtkRadioButton_listautoptr = [*c]GList;
pub const GtkRadioButton_slistautoptr = [*c]GSList;
pub const GtkRadioButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRadioButton(_ptr: [*c]GtkRadioButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkRadioButton(_ptr: [*c]([*c]GtkRadioButton)) void {
    glib_autoptr_clear_GtkRadioButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRadioButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkRadioButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkRadioButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkRadioMenuItem_autoptr = [*c]GtkRadioMenuItem;
pub const GtkRadioMenuItem_listautoptr = [*c]GList;
pub const GtkRadioMenuItem_slistautoptr = [*c]GSList;
pub const GtkRadioMenuItem_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRadioMenuItem(_ptr: [*c]GtkRadioMenuItem) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkRadioMenuItem(_ptr: [*c]([*c]GtkRadioMenuItem)) void {
    glib_autoptr_clear_GtkRadioMenuItem(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRadioMenuItem(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkRadioMenuItem(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkRadioMenuItem(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkRadioToolButton_autoptr = [*c]GtkRadioToolButton;
pub const GtkRadioToolButton_listautoptr = [*c]GList;
pub const GtkRadioToolButton_slistautoptr = [*c]GSList;
pub const GtkRadioToolButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRadioToolButton(_ptr: [*c]GtkRadioToolButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkRadioToolButton(_ptr: [*c]([*c]GtkRadioToolButton)) void {
    glib_autoptr_clear_GtkRadioToolButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRadioToolButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkRadioToolButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkRadioToolButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkRange_autoptr = [*c]GtkRange;
pub const GtkRange_listautoptr = [*c]GList;
pub const GtkRange_slistautoptr = [*c]GSList;
pub const GtkRange_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRange(_ptr: [*c]GtkRange) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkRange(_ptr: [*c]([*c]GtkRange)) void {
    glib_autoptr_clear_GtkRange(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRange(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkRange(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkRange(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkRcStyle_autoptr = ?*GtkRcStyle;
pub const GtkRcStyle_listautoptr = [*c]GList;
pub const GtkRcStyle_slistautoptr = [*c]GSList;
pub const GtkRcStyle_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRcStyle(_ptr: ?*GtkRcStyle) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkRcStyle(_ptr: [*c](?*GtkRcStyle)) void {
    glib_autoptr_clear_GtkRcStyle(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRcStyle(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkRcStyle(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkRcStyle(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkRecentChooser_autoptr = ?*GtkRecentChooser;
pub const GtkRecentChooser_listautoptr = [*c]GList;
pub const GtkRecentChooser_slistautoptr = [*c]GSList;
pub const GtkRecentChooser_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRecentChooser(_ptr: ?*GtkRecentChooser) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkRecentChooser(_ptr: [*c](?*GtkRecentChooser)) void {
    glib_autoptr_clear_GtkRecentChooser(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRecentChooser(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkRecentChooser(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkRecentChooser(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkRecentChooserDialog_autoptr = [*c]GtkRecentChooserDialog;
pub const GtkRecentChooserDialog_listautoptr = [*c]GList;
pub const GtkRecentChooserDialog_slistautoptr = [*c]GSList;
pub const GtkRecentChooserDialog_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRecentChooserDialog(_ptr: [*c]GtkRecentChooserDialog) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkRecentChooserDialog(_ptr: [*c]([*c]GtkRecentChooserDialog)) void {
    glib_autoptr_clear_GtkRecentChooserDialog(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRecentChooserDialog(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkRecentChooserDialog(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkRecentChooserDialog(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkRecentChooserMenu_autoptr = [*c]GtkRecentChooserMenu;
pub const GtkRecentChooserMenu_listautoptr = [*c]GList;
pub const GtkRecentChooserMenu_slistautoptr = [*c]GSList;
pub const GtkRecentChooserMenu_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRecentChooserMenu(_ptr: [*c]GtkRecentChooserMenu) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkRecentChooserMenu(_ptr: [*c]([*c]GtkRecentChooserMenu)) void {
    glib_autoptr_clear_GtkRecentChooserMenu(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRecentChooserMenu(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkRecentChooserMenu(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkRecentChooserMenu(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkRecentChooserWidget_autoptr = [*c]GtkRecentChooserWidget;
pub const GtkRecentChooserWidget_listautoptr = [*c]GList;
pub const GtkRecentChooserWidget_slistautoptr = [*c]GSList;
pub const GtkRecentChooserWidget_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRecentChooserWidget(_ptr: [*c]GtkRecentChooserWidget) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkRecentChooserWidget(_ptr: [*c]([*c]GtkRecentChooserWidget)) void {
    glib_autoptr_clear_GtkRecentChooserWidget(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRecentChooserWidget(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkRecentChooserWidget(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkRecentChooserWidget(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkRecentFilter_autoptr = ?*GtkRecentFilter;
pub const GtkRecentFilter_listautoptr = [*c]GList;
pub const GtkRecentFilter_slistautoptr = [*c]GSList;
pub const GtkRecentFilter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRecentFilter(_ptr: ?*GtkRecentFilter) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkRecentFilter(_ptr: [*c](?*GtkRecentFilter)) void {
    glib_autoptr_clear_GtkRecentFilter(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRecentFilter(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkRecentFilter(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkRecentFilter(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkRecentManager_autoptr = [*c]GtkRecentManager;
pub const GtkRecentManager_listautoptr = [*c]GList;
pub const GtkRecentManager_slistautoptr = [*c]GSList;
pub const GtkRecentManager_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRecentManager(_ptr: [*c]GtkRecentManager) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkRecentManager(_ptr: [*c]([*c]GtkRecentManager)) void {
    glib_autoptr_clear_GtkRecentManager(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRecentManager(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkRecentManager(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkRecentManager(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkRevealer_autoptr = [*c]GtkRevealer;
pub const GtkRevealer_listautoptr = [*c]GList;
pub const GtkRevealer_slistautoptr = [*c]GSList;
pub const GtkRevealer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRevealer(_ptr: [*c]GtkRevealer) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkRevealer(_ptr: [*c]([*c]GtkRevealer)) void {
    glib_autoptr_clear_GtkRevealer(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRevealer(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkRevealer(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkRevealer(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkScale_autoptr = [*c]GtkScale;
pub const GtkScale_listautoptr = [*c]GList;
pub const GtkScale_slistautoptr = [*c]GSList;
pub const GtkScale_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkScale(_ptr: [*c]GtkScale) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkScale(_ptr: [*c]([*c]GtkScale)) void {
    glib_autoptr_clear_GtkScale(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkScale(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkScale(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkScale(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkScaleButton_autoptr = [*c]GtkScaleButton;
pub const GtkScaleButton_listautoptr = [*c]GList;
pub const GtkScaleButton_slistautoptr = [*c]GSList;
pub const GtkScaleButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkScaleButton(_ptr: [*c]GtkScaleButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkScaleButton(_ptr: [*c]([*c]GtkScaleButton)) void {
    glib_autoptr_clear_GtkScaleButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkScaleButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkScaleButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkScaleButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkScrollable_autoptr = ?*GtkScrollable;
pub const GtkScrollable_listautoptr = [*c]GList;
pub const GtkScrollable_slistautoptr = [*c]GSList;
pub const GtkScrollable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkScrollable(_ptr: ?*GtkScrollable) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkScrollable(_ptr: [*c](?*GtkScrollable)) void {
    glib_autoptr_clear_GtkScrollable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkScrollable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkScrollable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkScrollable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkScrollbar_autoptr = [*c]GtkScrollbar;
pub const GtkScrollbar_listautoptr = [*c]GList;
pub const GtkScrollbar_slistautoptr = [*c]GSList;
pub const GtkScrollbar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkScrollbar(_ptr: [*c]GtkScrollbar) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkScrollbar(_ptr: [*c]([*c]GtkScrollbar)) void {
    glib_autoptr_clear_GtkScrollbar(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkScrollbar(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkScrollbar(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkScrollbar(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkScrolledWindow_autoptr = [*c]GtkScrolledWindow;
pub const GtkScrolledWindow_listautoptr = [*c]GList;
pub const GtkScrolledWindow_slistautoptr = [*c]GSList;
pub const GtkScrolledWindow_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkScrolledWindow(_ptr: [*c]GtkScrolledWindow) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkScrolledWindow(_ptr: [*c]([*c]GtkScrolledWindow)) void {
    glib_autoptr_clear_GtkScrolledWindow(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkScrolledWindow(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkScrolledWindow(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkScrolledWindow(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkSearchBar_autoptr = [*c]GtkSearchBar;
pub const GtkSearchBar_listautoptr = [*c]GList;
pub const GtkSearchBar_slistautoptr = [*c]GSList;
pub const GtkSearchBar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSearchBar(_ptr: [*c]GtkSearchBar) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkSearchBar(_ptr: [*c]([*c]GtkSearchBar)) void {
    glib_autoptr_clear_GtkSearchBar(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkSearchBar(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkSearchBar(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkSearchBar(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkSearchEntry_autoptr = [*c]GtkSearchEntry;
pub const GtkSearchEntry_listautoptr = [*c]GList;
pub const GtkSearchEntry_slistautoptr = [*c]GSList;
pub const GtkSearchEntry_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSearchEntry(_ptr: [*c]GtkSearchEntry) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkSearchEntry(_ptr: [*c]([*c]GtkSearchEntry)) void {
    glib_autoptr_clear_GtkSearchEntry(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkSearchEntry(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkSearchEntry(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkSearchEntry(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkSeparator_autoptr = [*c]GtkSeparator;
pub const GtkSeparator_listautoptr = [*c]GList;
pub const GtkSeparator_slistautoptr = [*c]GSList;
pub const GtkSeparator_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSeparator(_ptr: [*c]GtkSeparator) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkSeparator(_ptr: [*c]([*c]GtkSeparator)) void {
    glib_autoptr_clear_GtkSeparator(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkSeparator(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkSeparator(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkSeparator(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkSeparatorMenuItem_autoptr = [*c]GtkSeparatorMenuItem;
pub const GtkSeparatorMenuItem_listautoptr = [*c]GList;
pub const GtkSeparatorMenuItem_slistautoptr = [*c]GSList;
pub const GtkSeparatorMenuItem_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSeparatorMenuItem(_ptr: [*c]GtkSeparatorMenuItem) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkSeparatorMenuItem(_ptr: [*c]([*c]GtkSeparatorMenuItem)) void {
    glib_autoptr_clear_GtkSeparatorMenuItem(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkSeparatorMenuItem(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkSeparatorMenuItem(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkSeparatorMenuItem(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkSeparatorToolItem_autoptr = [*c]GtkSeparatorToolItem;
pub const GtkSeparatorToolItem_listautoptr = [*c]GList;
pub const GtkSeparatorToolItem_slistautoptr = [*c]GSList;
pub const GtkSeparatorToolItem_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSeparatorToolItem(_ptr: [*c]GtkSeparatorToolItem) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkSeparatorToolItem(_ptr: [*c]([*c]GtkSeparatorToolItem)) void {
    glib_autoptr_clear_GtkSeparatorToolItem(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkSeparatorToolItem(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkSeparatorToolItem(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkSeparatorToolItem(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkSettings_autoptr = [*c]GtkSettings;
pub const GtkSettings_listautoptr = [*c]GList;
pub const GtkSettings_slistautoptr = [*c]GSList;
pub const GtkSettings_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSettings(_ptr: [*c]GtkSettings) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkSettings(_ptr: [*c]([*c]GtkSettings)) void {
    glib_autoptr_clear_GtkSettings(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkSettings(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkSettings(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkSettings(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkStackSidebar_autoptr = [*c]GtkStackSidebar;
pub const GtkStackSidebar_listautoptr = [*c]GList;
pub const GtkStackSidebar_slistautoptr = [*c]GSList;
pub const GtkStackSidebar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStackSidebar(_ptr: [*c]GtkStackSidebar) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkStackSidebar(_ptr: [*c]([*c]GtkStackSidebar)) void {
    glib_autoptr_clear_GtkStackSidebar(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkStackSidebar(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkStackSidebar(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkStackSidebar(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkSizeGroup_autoptr = [*c]GtkSizeGroup;
pub const GtkSizeGroup_listautoptr = [*c]GList;
pub const GtkSizeGroup_slistautoptr = [*c]GSList;
pub const GtkSizeGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSizeGroup(_ptr: [*c]GtkSizeGroup) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkSizeGroup(_ptr: [*c]([*c]GtkSizeGroup)) void {
    glib_autoptr_clear_GtkSizeGroup(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkSizeGroup(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkSizeGroup(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkSizeGroup(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkSpinButton_autoptr = [*c]GtkSpinButton;
pub const GtkSpinButton_listautoptr = [*c]GList;
pub const GtkSpinButton_slistautoptr = [*c]GSList;
pub const GtkSpinButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSpinButton(_ptr: [*c]GtkSpinButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkSpinButton(_ptr: [*c]([*c]GtkSpinButton)) void {
    glib_autoptr_clear_GtkSpinButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkSpinButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkSpinButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkSpinButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkSpinner_autoptr = [*c]GtkSpinner;
pub const GtkSpinner_listautoptr = [*c]GList;
pub const GtkSpinner_slistautoptr = [*c]GSList;
pub const GtkSpinner_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSpinner(_ptr: [*c]GtkSpinner) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkSpinner(_ptr: [*c]([*c]GtkSpinner)) void {
    glib_autoptr_clear_GtkSpinner(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkSpinner(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkSpinner(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkSpinner(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkStack_autoptr = [*c]GtkStack;
pub const GtkStack_listautoptr = [*c]GList;
pub const GtkStack_slistautoptr = [*c]GSList;
pub const GtkStack_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStack(_ptr: [*c]GtkStack) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkStack(_ptr: [*c]([*c]GtkStack)) void {
    glib_autoptr_clear_GtkStack(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkStack(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkStack(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkStack(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkStackSwitcher_autoptr = [*c]GtkStackSwitcher;
pub const GtkStackSwitcher_listautoptr = [*c]GList;
pub const GtkStackSwitcher_slistautoptr = [*c]GSList;
pub const GtkStackSwitcher_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStackSwitcher(_ptr: [*c]GtkStackSwitcher) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkStackSwitcher(_ptr: [*c]([*c]GtkStackSwitcher)) void {
    glib_autoptr_clear_GtkStackSwitcher(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkStackSwitcher(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkStackSwitcher(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkStackSwitcher(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkStatusbar_autoptr = [*c]GtkStatusbar;
pub const GtkStatusbar_listautoptr = [*c]GList;
pub const GtkStatusbar_slistautoptr = [*c]GSList;
pub const GtkStatusbar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStatusbar(_ptr: [*c]GtkStatusbar) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkStatusbar(_ptr: [*c]([*c]GtkStatusbar)) void {
    glib_autoptr_clear_GtkStatusbar(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkStatusbar(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkStatusbar(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkStatusbar(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkStyle_autoptr = [*c]GtkStyle;
pub const GtkStyle_listautoptr = [*c]GList;
pub const GtkStyle_slistautoptr = [*c]GSList;
pub const GtkStyle_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStyle(_ptr: [*c]GtkStyle) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkStyle(_ptr: [*c]([*c]GtkStyle)) void {
    glib_autoptr_clear_GtkStyle(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkStyle(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkStyle(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkStyle(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkStyleContext_autoptr = [*c]GtkStyleContext;
pub const GtkStyleContext_listautoptr = [*c]GList;
pub const GtkStyleContext_slistautoptr = [*c]GSList;
pub const GtkStyleContext_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStyleContext(_ptr: [*c]GtkStyleContext) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkStyleContext(_ptr: [*c]([*c]GtkStyleContext)) void {
    glib_autoptr_clear_GtkStyleContext(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkStyleContext(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkStyleContext(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkStyleContext(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkStyleProperties_autoptr = [*c]GtkStyleProperties;
pub const GtkStyleProperties_listautoptr = [*c]GList;
pub const GtkStyleProperties_slistautoptr = [*c]GSList;
pub const GtkStyleProperties_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStyleProperties(_ptr: [*c]GtkStyleProperties) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkStyleProperties(_ptr: [*c]([*c]GtkStyleProperties)) void {
    glib_autoptr_clear_GtkStyleProperties(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkStyleProperties(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkStyleProperties(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkStyleProperties(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkStyleProvider_autoptr = ?*GtkStyleProvider;
pub const GtkStyleProvider_listautoptr = [*c]GList;
pub const GtkStyleProvider_slistautoptr = [*c]GSList;
pub const GtkStyleProvider_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkStyleProvider(_ptr: ?*GtkStyleProvider) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkStyleProvider(_ptr: [*c](?*GtkStyleProvider)) void {
    glib_autoptr_clear_GtkStyleProvider(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkStyleProvider(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkStyleProvider(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkStyleProvider(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkSwitch_autoptr = [*c]GtkSwitch;
pub const GtkSwitch_listautoptr = [*c]GList;
pub const GtkSwitch_slistautoptr = [*c]GSList;
pub const GtkSwitch_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSwitch(_ptr: [*c]GtkSwitch) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkSwitch(_ptr: [*c]([*c]GtkSwitch)) void {
    glib_autoptr_clear_GtkSwitch(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkSwitch(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkSwitch(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkSwitch(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTextBuffer_autoptr = [*c]GtkTextBuffer;
pub const GtkTextBuffer_listautoptr = [*c]GList;
pub const GtkTextBuffer_slistautoptr = [*c]GSList;
pub const GtkTextBuffer_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextBuffer(_ptr: [*c]GtkTextBuffer) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTextBuffer(_ptr: [*c]([*c]GtkTextBuffer)) void {
    glib_autoptr_clear_GtkTextBuffer(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTextBuffer(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTextBuffer(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTextBuffer(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTextChildAnchor_autoptr = [*c]GtkTextChildAnchor;
pub const GtkTextChildAnchor_listautoptr = [*c]GList;
pub const GtkTextChildAnchor_slistautoptr = [*c]GSList;
pub const GtkTextChildAnchor_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextChildAnchor(_ptr: [*c]GtkTextChildAnchor) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTextChildAnchor(_ptr: [*c]([*c]GtkTextChildAnchor)) void {
    glib_autoptr_clear_GtkTextChildAnchor(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTextChildAnchor(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTextChildAnchor(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTextChildAnchor(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTextMark_autoptr = [*c]GtkTextMark;
pub const GtkTextMark_listautoptr = [*c]GList;
pub const GtkTextMark_slistautoptr = [*c]GSList;
pub const GtkTextMark_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextMark(_ptr: [*c]GtkTextMark) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTextMark(_ptr: [*c]([*c]GtkTextMark)) void {
    glib_autoptr_clear_GtkTextMark(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTextMark(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTextMark(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTextMark(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTextTag_autoptr = [*c]GtkTextTag;
pub const GtkTextTag_listautoptr = [*c]GList;
pub const GtkTextTag_slistautoptr = [*c]GSList;
pub const GtkTextTag_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextTag(_ptr: [*c]GtkTextTag) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTextTag(_ptr: [*c]([*c]GtkTextTag)) void {
    glib_autoptr_clear_GtkTextTag(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTextTag(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTextTag(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTextTag(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTextTagTable_autoptr = [*c]GtkTextTagTable;
pub const GtkTextTagTable_listautoptr = [*c]GList;
pub const GtkTextTagTable_slistautoptr = [*c]GSList;
pub const GtkTextTagTable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextTagTable(_ptr: [*c]GtkTextTagTable) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTextTagTable(_ptr: [*c]([*c]GtkTextTagTable)) void {
    glib_autoptr_clear_GtkTextTagTable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTextTagTable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTextTagTable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTextTagTable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTextView_autoptr = [*c]GtkTextView;
pub const GtkTextView_listautoptr = [*c]GList;
pub const GtkTextView_slistautoptr = [*c]GSList;
pub const GtkTextView_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextView(_ptr: [*c]GtkTextView) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTextView(_ptr: [*c]([*c]GtkTextView)) void {
    glib_autoptr_clear_GtkTextView(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTextView(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTextView(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTextView(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkToggleButton_autoptr = [*c]GtkToggleButton;
pub const GtkToggleButton_listautoptr = [*c]GList;
pub const GtkToggleButton_slistautoptr = [*c]GSList;
pub const GtkToggleButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkToggleButton(_ptr: [*c]GtkToggleButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkToggleButton(_ptr: [*c]([*c]GtkToggleButton)) void {
    glib_autoptr_clear_GtkToggleButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkToggleButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkToggleButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkToggleButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkToggleToolButton_autoptr = [*c]GtkToggleToolButton;
pub const GtkToggleToolButton_listautoptr = [*c]GList;
pub const GtkToggleToolButton_slistautoptr = [*c]GSList;
pub const GtkToggleToolButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkToggleToolButton(_ptr: [*c]GtkToggleToolButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkToggleToolButton(_ptr: [*c]([*c]GtkToggleToolButton)) void {
    glib_autoptr_clear_GtkToggleToolButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkToggleToolButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkToggleToolButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkToggleToolButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkToolButton_autoptr = [*c]GtkToolButton;
pub const GtkToolButton_listautoptr = [*c]GList;
pub const GtkToolButton_slistautoptr = [*c]GSList;
pub const GtkToolButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkToolButton(_ptr: [*c]GtkToolButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkToolButton(_ptr: [*c]([*c]GtkToolButton)) void {
    glib_autoptr_clear_GtkToolButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkToolButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkToolButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkToolButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkToolItem_autoptr = [*c]GtkToolItem;
pub const GtkToolItem_listautoptr = [*c]GList;
pub const GtkToolItem_slistautoptr = [*c]GSList;
pub const GtkToolItem_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkToolItem(_ptr: [*c]GtkToolItem) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkToolItem(_ptr: [*c]([*c]GtkToolItem)) void {
    glib_autoptr_clear_GtkToolItem(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkToolItem(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkToolItem(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkToolItem(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkToolItemGroup_autoptr = [*c]GtkToolItemGroup;
pub const GtkToolItemGroup_listautoptr = [*c]GList;
pub const GtkToolItemGroup_slistautoptr = [*c]GSList;
pub const GtkToolItemGroup_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkToolItemGroup(_ptr: [*c]GtkToolItemGroup) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkToolItemGroup(_ptr: [*c]([*c]GtkToolItemGroup)) void {
    glib_autoptr_clear_GtkToolItemGroup(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkToolItemGroup(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkToolItemGroup(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkToolItemGroup(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkToolPalette_autoptr = [*c]GtkToolPalette;
pub const GtkToolPalette_listautoptr = [*c]GList;
pub const GtkToolPalette_slistautoptr = [*c]GSList;
pub const GtkToolPalette_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkToolPalette(_ptr: [*c]GtkToolPalette) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkToolPalette(_ptr: [*c]([*c]GtkToolPalette)) void {
    glib_autoptr_clear_GtkToolPalette(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkToolPalette(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkToolPalette(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkToolPalette(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkToolShell_autoptr = ?*GtkToolShell;
pub const GtkToolShell_listautoptr = [*c]GList;
pub const GtkToolShell_slistautoptr = [*c]GSList;
pub const GtkToolShell_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkToolShell(_ptr: ?*GtkToolShell) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkToolShell(_ptr: [*c](?*GtkToolShell)) void {
    glib_autoptr_clear_GtkToolShell(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkToolShell(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkToolShell(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkToolShell(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkToolbar_autoptr = [*c]GtkToolbar;
pub const GtkToolbar_listautoptr = [*c]GList;
pub const GtkToolbar_slistautoptr = [*c]GSList;
pub const GtkToolbar_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkToolbar(_ptr: [*c]GtkToolbar) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkToolbar(_ptr: [*c]([*c]GtkToolbar)) void {
    glib_autoptr_clear_GtkToolbar(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkToolbar(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkToolbar(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkToolbar(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTooltip_autoptr = ?*GtkTooltip;
pub const GtkTooltip_listautoptr = [*c]GList;
pub const GtkTooltip_slistautoptr = [*c]GSList;
pub const GtkTooltip_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTooltip(_ptr: ?*GtkTooltip) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTooltip(_ptr: [*c](?*GtkTooltip)) void {
    glib_autoptr_clear_GtkTooltip(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTooltip(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTooltip(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTooltip(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTreeDragDest_autoptr = ?*GtkTreeDragDest;
pub const GtkTreeDragDest_listautoptr = [*c]GList;
pub const GtkTreeDragDest_slistautoptr = [*c]GSList;
pub const GtkTreeDragDest_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeDragDest(_ptr: ?*GtkTreeDragDest) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTreeDragDest(_ptr: [*c](?*GtkTreeDragDest)) void {
    glib_autoptr_clear_GtkTreeDragDest(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeDragDest(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeDragDest(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeDragDest(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTreeDragSource_autoptr = ?*GtkTreeDragSource;
pub const GtkTreeDragSource_listautoptr = [*c]GList;
pub const GtkTreeDragSource_slistautoptr = [*c]GSList;
pub const GtkTreeDragSource_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeDragSource(_ptr: ?*GtkTreeDragSource) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTreeDragSource(_ptr: [*c](?*GtkTreeDragSource)) void {
    glib_autoptr_clear_GtkTreeDragSource(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeDragSource(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeDragSource(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeDragSource(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTreeModel_autoptr = ?*GtkTreeModel;
pub const GtkTreeModel_listautoptr = [*c]GList;
pub const GtkTreeModel_slistautoptr = [*c]GSList;
pub const GtkTreeModel_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeModel(_ptr: ?*GtkTreeModel) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTreeModel(_ptr: [*c](?*GtkTreeModel)) void {
    glib_autoptr_clear_GtkTreeModel(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeModel(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeModel(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeModel(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTreeModelFilter_autoptr = [*c]GtkTreeModelFilter;
pub const GtkTreeModelFilter_listautoptr = [*c]GList;
pub const GtkTreeModelFilter_slistautoptr = [*c]GSList;
pub const GtkTreeModelFilter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeModelFilter(_ptr: [*c]GtkTreeModelFilter) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTreeModelFilter(_ptr: [*c]([*c]GtkTreeModelFilter)) void {
    glib_autoptr_clear_GtkTreeModelFilter(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeModelFilter(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeModelFilter(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeModelFilter(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTreeModelSort_autoptr = [*c]GtkTreeModelSort;
pub const GtkTreeModelSort_listautoptr = [*c]GList;
pub const GtkTreeModelSort_slistautoptr = [*c]GSList;
pub const GtkTreeModelSort_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeModelSort(_ptr: [*c]GtkTreeModelSort) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTreeModelSort(_ptr: [*c]([*c]GtkTreeModelSort)) void {
    glib_autoptr_clear_GtkTreeModelSort(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeModelSort(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeModelSort(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeModelSort(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTreeSelection_autoptr = [*c]GtkTreeSelection;
pub const GtkTreeSelection_listautoptr = [*c]GList;
pub const GtkTreeSelection_slistautoptr = [*c]GSList;
pub const GtkTreeSelection_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeSelection(_ptr: [*c]GtkTreeSelection) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTreeSelection(_ptr: [*c]([*c]GtkTreeSelection)) void {
    glib_autoptr_clear_GtkTreeSelection(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeSelection(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeSelection(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeSelection(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTreeSortable_autoptr = ?*GtkTreeSortable;
pub const GtkTreeSortable_listautoptr = [*c]GList;
pub const GtkTreeSortable_slistautoptr = [*c]GSList;
pub const GtkTreeSortable_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeSortable(_ptr: ?*GtkTreeSortable) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTreeSortable(_ptr: [*c](?*GtkTreeSortable)) void {
    glib_autoptr_clear_GtkTreeSortable(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeSortable(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeSortable(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeSortable(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTreeStore_autoptr = [*c]GtkTreeStore;
pub const GtkTreeStore_listautoptr = [*c]GList;
pub const GtkTreeStore_slistautoptr = [*c]GSList;
pub const GtkTreeStore_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeStore(_ptr: [*c]GtkTreeStore) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTreeStore(_ptr: [*c]([*c]GtkTreeStore)) void {
    glib_autoptr_clear_GtkTreeStore(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeStore(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeStore(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeStore(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTreeView_autoptr = [*c]GtkTreeView;
pub const GtkTreeView_listautoptr = [*c]GList;
pub const GtkTreeView_slistautoptr = [*c]GSList;
pub const GtkTreeView_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeView(_ptr: [*c]GtkTreeView) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTreeView(_ptr: [*c]([*c]GtkTreeView)) void {
    glib_autoptr_clear_GtkTreeView(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeView(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeView(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeView(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkTreeViewColumn_autoptr = [*c]GtkTreeViewColumn;
pub const GtkTreeViewColumn_listautoptr = [*c]GList;
pub const GtkTreeViewColumn_slistautoptr = [*c]GSList;
pub const GtkTreeViewColumn_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeViewColumn(_ptr: [*c]GtkTreeViewColumn) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkTreeViewColumn(_ptr: [*c]([*c]GtkTreeViewColumn)) void {
    glib_autoptr_clear_GtkTreeViewColumn(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeViewColumn(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeViewColumn(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeViewColumn(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkViewport_autoptr = [*c]GtkViewport;
pub const GtkViewport_listautoptr = [*c]GList;
pub const GtkViewport_slistautoptr = [*c]GSList;
pub const GtkViewport_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkViewport(_ptr: [*c]GtkViewport) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkViewport(_ptr: [*c]([*c]GtkViewport)) void {
    glib_autoptr_clear_GtkViewport(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkViewport(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkViewport(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkViewport(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkVolumeButton_autoptr = [*c]GtkVolumeButton;
pub const GtkVolumeButton_listautoptr = [*c]GList;
pub const GtkVolumeButton_slistautoptr = [*c]GSList;
pub const GtkVolumeButton_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkVolumeButton(_ptr: [*c]GtkVolumeButton) void {
    if (_ptr != null) g_object_unref.?(@ptrCast(gpointer, _ptr));
}
pub fn glib_autoptr_cleanup_GtkVolumeButton(_ptr: [*c]([*c]GtkVolumeButton)) void {
    glib_autoptr_clear_GtkVolumeButton(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkVolumeButton(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkVolumeButton(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkVolumeButton(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), g_object_unref)))));
}
pub const GtkPaperSize_autoptr = ?*GtkPaperSize;
pub const GtkPaperSize_listautoptr = [*c]GList;
pub const GtkPaperSize_slistautoptr = [*c]GSList;
pub const GtkPaperSize_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkPaperSize(_ptr: ?*GtkPaperSize) void {
    if (_ptr != null) gtk_paper_size_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GtkPaperSize(_ptr: [*c](?*GtkPaperSize)) void {
    glib_autoptr_clear_GtkPaperSize(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkPaperSize(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_paper_size_free)))));
}
pub fn glib_slistautoptr_cleanup_GtkPaperSize(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_paper_size_free)))));
}
pub fn glib_queueautoptr_cleanup_GtkPaperSize(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_paper_size_free)))));
}
pub const GtkRecentInfo_autoptr = ?*GtkRecentInfo;
pub const GtkRecentInfo_listautoptr = [*c]GList;
pub const GtkRecentInfo_slistautoptr = [*c]GSList;
pub const GtkRecentInfo_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkRecentInfo(_ptr: ?*GtkRecentInfo) void {
    if (_ptr != null) gtk_recent_info_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GtkRecentInfo(_ptr: [*c](?*GtkRecentInfo)) void {
    glib_autoptr_clear_GtkRecentInfo(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkRecentInfo(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_recent_info_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkRecentInfo(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_recent_info_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkRecentInfo(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_recent_info_unref)))));
}
pub const GtkSelectionData_autoptr = ?*GtkSelectionData;
pub const GtkSelectionData_listautoptr = [*c]GList;
pub const GtkSelectionData_slistautoptr = [*c]GSList;
pub const GtkSelectionData_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkSelectionData(_ptr: ?*GtkSelectionData) void {
    if (_ptr != null) gtk_selection_data_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GtkSelectionData(_ptr: [*c](?*GtkSelectionData)) void {
    glib_autoptr_clear_GtkSelectionData(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkSelectionData(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_selection_data_free)))));
}
pub fn glib_slistautoptr_cleanup_GtkSelectionData(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_selection_data_free)))));
}
pub fn glib_queueautoptr_cleanup_GtkSelectionData(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_selection_data_free)))));
}
pub const GtkTargetList_autoptr = ?*GtkTargetList;
pub const GtkTargetList_listautoptr = [*c]GList;
pub const GtkTargetList_slistautoptr = [*c]GSList;
pub const GtkTargetList_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTargetList(_ptr: ?*GtkTargetList) void {
    if (_ptr != null) gtk_target_list_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GtkTargetList(_ptr: [*c](?*GtkTargetList)) void {
    glib_autoptr_clear_GtkTargetList(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTargetList(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_target_list_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTargetList(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_target_list_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTargetList(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_target_list_unref)))));
}
pub const GtkTextAttributes_autoptr = ?*GtkTextAttributes;
pub const GtkTextAttributes_listautoptr = [*c]GList;
pub const GtkTextAttributes_slistautoptr = [*c]GSList;
pub const GtkTextAttributes_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextAttributes(_ptr: ?*GtkTextAttributes) void {
    if (_ptr != null) gtk_text_attributes_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GtkTextAttributes(_ptr: [*c](?*GtkTextAttributes)) void {
    glib_autoptr_clear_GtkTextAttributes(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTextAttributes(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_text_attributes_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkTextAttributes(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_text_attributes_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkTextAttributes(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_text_attributes_unref)))));
}
pub const GtkTextIter_autoptr = [*c]GtkTextIter;
pub const GtkTextIter_listautoptr = [*c]GList;
pub const GtkTextIter_slistautoptr = [*c]GSList;
pub const GtkTextIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTextIter(_ptr: [*c]GtkTextIter) void {
    if (_ptr != null) gtk_text_iter_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GtkTextIter(_ptr: [*c]([*c]GtkTextIter)) void {
    glib_autoptr_clear_GtkTextIter(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTextIter(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_text_iter_free)))));
}
pub fn glib_slistautoptr_cleanup_GtkTextIter(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_text_iter_free)))));
}
pub fn glib_queueautoptr_cleanup_GtkTextIter(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_text_iter_free)))));
}
pub const GtkTreeIter_autoptr = [*c]GtkTreeIter;
pub const GtkTreeIter_listautoptr = [*c]GList;
pub const GtkTreeIter_slistautoptr = [*c]GSList;
pub const GtkTreeIter_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeIter(_ptr: [*c]GtkTreeIter) void {
    if (_ptr != null) gtk_tree_iter_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GtkTreeIter(_ptr: [*c]([*c]GtkTreeIter)) void {
    glib_autoptr_clear_GtkTreeIter(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeIter(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_tree_iter_free)))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeIter(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_tree_iter_free)))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeIter(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_tree_iter_free)))));
}
pub const GtkTreePath_autoptr = ?*GtkTreePath;
pub const GtkTreePath_listautoptr = [*c]GList;
pub const GtkTreePath_slistautoptr = [*c]GSList;
pub const GtkTreePath_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreePath(_ptr: ?*GtkTreePath) void {
    if (_ptr != null) gtk_tree_path_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GtkTreePath(_ptr: [*c](?*GtkTreePath)) void {
    glib_autoptr_clear_GtkTreePath(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTreePath(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_tree_path_free)))));
}
pub fn glib_slistautoptr_cleanup_GtkTreePath(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_tree_path_free)))));
}
pub fn glib_queueautoptr_cleanup_GtkTreePath(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_tree_path_free)))));
}
pub const GtkTreeRowReference_autoptr = ?*GtkTreeRowReference;
pub const GtkTreeRowReference_listautoptr = [*c]GList;
pub const GtkTreeRowReference_slistautoptr = [*c]GSList;
pub const GtkTreeRowReference_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkTreeRowReference(_ptr: ?*GtkTreeRowReference) void {
    if (_ptr != null) gtk_tree_row_reference_free.?(_ptr);
}
pub fn glib_autoptr_cleanup_GtkTreeRowReference(_ptr: [*c](?*GtkTreeRowReference)) void {
    glib_autoptr_clear_GtkTreeRowReference(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkTreeRowReference(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_tree_row_reference_free)))));
}
pub fn glib_slistautoptr_cleanup_GtkTreeRowReference(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_tree_row_reference_free)))));
}
pub fn glib_queueautoptr_cleanup_GtkTreeRowReference(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_tree_row_reference_free)))));
}
pub const GtkWidgetPath_autoptr = ?*GtkWidgetPath;
pub const GtkWidgetPath_listautoptr = [*c]GList;
pub const GtkWidgetPath_slistautoptr = [*c]GSList;
pub const GtkWidgetPath_queueautoptr = [*c]GQueue;
pub fn glib_autoptr_clear_GtkWidgetPath(_ptr: ?*GtkWidgetPath) void {
    if (_ptr != null) gtk_widget_path_unref.?(_ptr);
}
pub fn glib_autoptr_cleanup_GtkWidgetPath(_ptr: [*c](?*GtkWidgetPath)) void {
    glib_autoptr_clear_GtkWidgetPath(_ptr.?.*);
}
pub fn glib_listautoptr_cleanup_GtkWidgetPath(_l: [*c]([*c]GList)) void {
    g_list_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_widget_path_unref)))));
}
pub fn glib_slistautoptr_cleanup_GtkWidgetPath(_l: [*c]([*c]GSList)) void {
    g_slist_free_full(_l.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_widget_path_unref)))));
}
pub fn glib_queueautoptr_cleanup_GtkWidgetPath(_q: [*c]([*c]GQueue)) void {
    if (_q.?.* != null) g_queue_free_full(_q.?.*, @ptrCast(GDestroyNotify, @alignCast(@alignOf(extern fn (gpointer) void), @ptrCast(?extern fn () void, @alignCast(@alignOf(extern fn () void), gtk_widget_path_unref)))));
}
pub const _FREEENTRY = 0;
pub const G_FILE_ATTRIBUTE_OWNER_USER_REAL = c"owner::user-real";
pub const _HEAPEMPTY = -1;
pub const SIGTERM = 15;
pub const G_MININT8 = if (@typeId(@typeOf(if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT8, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT8, -1) else (-G_MAXINT8)(-1))) == @import("builtin").TypeId.Pointer) @ptrCast(gint8, if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT8, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT8, -1) else (-G_MAXINT8)(-1)) else if (@typeId(@typeOf(if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT8, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT8, -1) else (-G_MAXINT8)(-1))) == @import("builtin").TypeId.Int) @intToPtr(gint8, if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT8, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT8, -1) else (-G_MAXINT8)(-1)) else gint8(if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT8, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT8, -1) else (-G_MAXINT8)(-1));
pub const LLONG_MIN = if (@typeId(@typeOf(-c_longlong(1))) == @import("builtin").TypeId.Pointer) @ptrCast(-__LONG_LONG_MAX__, -c_longlong(1)) else if (@typeId(@typeOf(-c_longlong(1))) == @import("builtin").TypeId.Int) @intToPtr(-__LONG_LONG_MAX__, -c_longlong(1)) else (-__LONG_LONG_MAX__)(-c_longlong(1));
pub const GDK_KEY_zstroke = 16777654;
pub const _MAX_DRIVE = 3;
pub const _REPORT_ERRMODE = 3;
pub const GDK_KEY_Arabic_damma = 1519;
pub const GDK_KEY_braille_dots_246 = 16787498;
pub const GTK_STOCK_ABOUT = if (@typeId(@typeOf(c"gtk-about")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-about") else if (@typeId(@typeOf(c"gtk-about")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-about") else GtkStock(c"gtk-about");
pub const GDK_KEY_Kana_Shift = 65326;
pub const GDK_KEY_punctspace = 2726;
pub const GTK_STYLE_CLASS_UNDERSHOOT = c"undershoot";
pub const GDK_KEY_Q = 81;
pub const GDK_KEY_Arabic_gaf = 16778927;
pub const GDK_KEY_Sinh_tta = 16780711;
pub const GDK_KEY_braille_dots_12568 = 16787635;
pub const G_MAXUINT = UINT_MAX;
pub const GDK_KEY_braille_dots_46 = 16787496;
pub const GDK_KEY_Cyrillic_U_straight_bar = 16778416;
pub const GLIB_DEPRECATED_MACRO_IN_2_34 = GLIB_DEPRECATED_MACRO;
pub const G_MAXSIZE = G_MAXUINT64;
pub const GDK_EVENT_PROPAGATE = FALSE;
pub const GDK_KEY_Arabic_tteh = 16778873;
pub const GDK_KEY_Cyrillic_I_macron = 16778466;
pub const GDK_KEY_seconds = 2775;
pub const G_MAXFLOAT = FLT_MAX;
pub const GLIB_DEPRECATED_IN_2_46 = GLIB_DEPRECATED;
pub const GDK_KEY_Ukrainian_IE = 1716;
pub const GDK_KEY_Ohorn = 16777632;
pub const GDK_KEY_OpenURL = 269025080;
pub const GDK_KEY_Gcircumflex = 728;
pub const GDK_KEY_Greek_beta = 2018;
pub const GDK_KEY_topleftparens = 2219;
pub const GDK_KEY_Cyrillic_CHE_descender = 16778422;
pub const __WCHAR_WIDTH__ = 16;
pub const GDK_KEY_Menu = 65383;
pub const GDK_KEY_KP_Subtract = 65453;
pub const GDK_KEY_minus = 45;
pub const __requires_lock_not_held = lock;
pub const GDK_KEY_3270_Reset = 64776;
pub const GDK_KEY_logicalor = 2271;
pub const GDK_KEY_cedilla = 184;
pub const GDK_KEY_Armenian_tso = 16778625;
pub const GLIB_AVAILABLE_IN_2_28 = _GLIB_EXTERN;
pub const GTK_STOCK_UNDELETE = if (@typeId(@typeOf(c"gtk-undelete")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-undelete") else if (@typeId(@typeOf(c"gtk-undelete")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-undelete") else GtkStock(c"gtk-undelete");
pub const GDK_KEY_dead_u = 65160;
pub const GDK_KEY_wdiaeresis = 16785029;
pub const GTK_STYLE_CLASS_RAISED = c"raised";
pub const __UINT_LEAST64_MAX__ = c_ulonglong(18446744073709551615);
pub const GDK_KEY_Ooblique = 216;
pub const LDBL_ROUNDS = _LDBL_ROUNDS;
pub const _FPCLASS_NN = 8;
pub const GDK_KEY_braille_dots_23568 = 16787638;
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED_USEC = c"time::modified-usec";
pub const GTK_STYLE_CLASS_INLINE_TOOLBAR = c"inline-toolbar";
pub const GDK_KEY_L9 = 65488;
pub const GTK_STYLE_PROPERTY_BORDER_STYLE = c"border-style";
pub const sys_nerr = _sys_nerr;
pub const GDK_KEY_dead_stroke = 65123;
pub const GDK_KEY_Sinh_nga = 16780703;
pub const GDK_KEY_Battery = 269025171;
pub const GDK_KEY_Right = 65363;
pub const GDK_KEY_Hangul_WA = 3784;
pub const GDK_KEY_Gbreve = 683;
pub const GDK_KEY_botintegral = 2213;
pub const __CONSTANT_CFSTRINGS__ = 1;
pub const GDK_KEY_braille_dots_24 = 16787466;
pub const GLIB_DEPRECATED_MACRO_IN_2_56 = GLIB_DEPRECATED_MACRO;
pub const G_KEY_FILE_DESKTOP_KEY_ONLY_SHOW_IN = c"OnlyShowIn";
pub const G_LOG_2_BASE_10 = 0.301030;
pub const GDK_KEY_Switch_VT_11 = 269024779;
pub const GDK_KEY_Launch1 = 269025089;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_58 = GLIB_DEPRECATED_ENUMERATOR;
pub const CAIRO_MIME_TYPE_CCITT_FAX = c"image/g3fax";
pub const GDK_KEY_Arabic_8 = 16778856;
pub const GDK_KEY_Cyrillic_i = 1737;
pub const GDK_KEY_Thai_baht = 3551;
pub const GTK_STYLE_CLASS_CELL = c"cell";
pub const GDK_KEY_M = 77;
pub const GDK_KEY_Ohornhook = 16785118;
pub const ENOTDIR = 20;
pub const GTK_PRINT_SETTINGS_DITHER = c"dither";
pub const RAND_MAX = 32767;
pub const GDK_BUTTON_MIDDLE = 2;
pub const GDK_KEY_Armenian_cha = 16778617;
pub const GTK_STYLE_CLASS_BACKGROUND = c"background";
pub const GTK_STOCK_UNINDENT = if (@typeId(@typeOf(c"gtk-unindent")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-unindent") else if (@typeId(@typeOf(c"gtk-unindent")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-unindent") else GtkStock(c"gtk-unindent");
pub const G_GINT64_FORMAT = c"lli";
pub const GDK_THREADS_DEPRECATED = GDK_DEPRECATED_IN_3_6;
pub const GDK_KEY_Arabic_hamzaunderalef = 1477;
pub const GDK_KEY_R9 = 65498;
pub const GDK_KEY_Pointer_UpLeft = 65252;
pub const GDK_KEY_Armenian_da = 16778596;
pub const GDK_KEY_Hangul_J_NieunJieuj = 3800;
pub const GDK_KEY_Pointer_Drag_Dflt = 65268;
pub const __SIZEOF_PTRDIFF_T__ = 8;
pub const GDK_KEY_Arabic_maddaonalef = 1474;
pub const GTK_STOCK_CDROM = if (@typeId(@typeOf(c"gtk-cdrom")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-cdrom") else if (@typeId(@typeOf(c"gtk-cdrom")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-cdrom") else GtkStock(c"gtk-cdrom");
pub const GDK_KEY_Super_R = 65516;
pub const GDK_KEY_Ocircumflexbelowdot = 16785112;
pub const DBL_MAX_EXP = 1024;
pub const GDK_KEY_Arabic_shadda = 1521;
pub const GDK_PRIORITY_EVENTS = G_PRIORITY_DEFAULT;
pub const GDK_KEY_botleftsummation = 2226;
pub const GDK_KEY_F24 = 65493;
pub const GDK_KEY_Armenian_sha = 16778615;
pub const GDK_KEY_Sinh_lla = 16780741;
pub const GDK_KEY_kana_NI = 1222;
pub const GTK_STYLE_CLASS_SPINNER = c"spinner";
pub const GDK_KEY_Overlay1_Enable = 65144;
pub const GDK_KEY_Thai_lu = 3526;
pub const GDK_KEY_Travel = 269025154;
pub const GDK_KEY_dead_a = 65152;
pub const GTK_PRINT_SETTINGS_PAPER_WIDTH = c"paper-width";
pub const USHRT_MAX = 65535;
pub const GDK_KEY_enopensquarebullet = 2785;
pub const GDK_KEY_macron = 175;
pub const GDK_KEY_ColonSign = 16785569;
pub const EM_ZERODIVIDE = _EM_ZERODIVIDE;
pub const GDK_KEY_partdifferential = 16785922;
pub const GDK_KEY_End = 65367;
pub const GDK_AVAILABLE_IN_3_8 = _GDK_EXTERN;
pub const GDK_KEY_Armenian_za = 16778598;
pub const GDK_KEY_F31 = 65500;
pub const GDK_KEY_Hcircumflex = 678;
pub const GDK_KEY_Greek_iotaaccent = 1972;
pub const GDK_KEY_braille_dots_4567 = 16787576;
pub const __UINT_LEAST8_MAX__ = 255;
pub const GDK_KEY_Arabic_tcheh = 16778886;
pub const GDK_KEY_hebrew_samech = 3313;
pub const GDK_KEY_KbdBrightnessUp = 269025029;
pub const GDK_KEY_ibreve = 16777517;
pub const __RDRND__ = 1;
pub const GDK_KEY_dead_macron = 65108;
pub const GDK_KEY_braille_dots_468 = 16787624;
pub const G_GINT32_MODIFIER = c"";
pub const GDK_PIXBUF_AVAILABLE_IN_2_30 = _GDK_PIXBUF_EXTERN;
pub const GTK_STOCK_DIALOG_WARNING = if (@typeId(@typeOf(c"gtk-dialog-warning")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-dialog-warning") else if (@typeId(@typeOf(c"gtk-dialog-warning")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-dialog-warning") else GtkStock(c"gtk-dialog-warning");
pub const _SW_UNDERFLOW = 2;
pub const GTK_STYLE_CLASS_TROUGH = c"trough";
pub const GDK_EVENT_STOP = TRUE;
pub const GDK_KEY_ubreve = 765;
pub const GDK_KEY_Thai_thothan = 3504;
pub const GDK_KEY_3270_DeleteWord = 64794;
pub const GTK_PRINT_SETTINGS_PAGE_RANGES = c"page-ranges";
pub const GDK_KEY_sevensubscript = 16785543;
pub const GDK_KEY_9 = 57;
pub const PANGO_AVAILABLE_IN_1_28 = _PANGO_EXTERN;
pub const GDK_KEY_PesetaSign = 16785575;
pub const GDK_KEY_braille_dots_34578 = 16787676;
pub const GDK_KEY_Uring = 473;
pub const GDK_KEY_hebrew_tet = 3304;
pub const GTK_TREE_SORTABLE_DEFAULT_SORT_COLUMN_ID = -1;
pub const GDK_KEY_braille_dots_1567 = 16787569;
pub const GDK_KEY_f = 102;
pub const GLIB_AVAILABLE_IN_2_54 = _GLIB_EXTERN;
pub const GDK_KEY_Nacute = 465;
pub const GDK_KEY_Arabic_noon_ghunna = 16778938;
pub const _MSC_EXTENSIONS = 1;
pub const EOTHER = 131;
pub const GDK_KEY_filledtribulletdown = 2793;
pub const GDK_KEY_braille_dots_345 = 16787484;
pub const ENOSYS = 40;
pub const GDK_KEY_Thai_saraii = 3541;
pub const GDK_KEY_braille_dots_235678 = 16787702;
pub const __PTRDIFF_MAX__ = c_longlong(9223372036854775807);
pub const SW_DENORMAL = _SW_DENORMAL;
pub const GDK_DEPRECATED_IN_3_0 = GDK_DEPRECATED;
pub const GDK_KEY_Thai_nikhahit = 3565;
pub const GDK_KEY_braille_dots_3678 = 16787684;
pub const FLT_DIG = 6;
pub const GDK_KEY_Sinh_mba = 16780729;
pub const EACCES = 13;
pub const GDK_KEY_plus = 43;
pub const G_GINT64_MODIFIER = c"ll";
pub const GDK_KEY_Hangul_J_SsangSios = 3815;
pub const __UINTMAX_FMTu__ = c"llu";
pub const cairo_get_font_extents = cairo_get_font_extents_REPLACED_BY_cairo_font_extents;
pub const G_KEY_FILE_DESKTOP_GROUP = c"Desktop Entry";
pub const GDK_KEY_Hangul_J_PanSios = 3832;
pub const GDK_KEY_wcircumflex = 16777589;
pub const GDK_KEY_braille_dots_2678 = 16787682;
pub const SYS_OPEN = _SYS_OPEN;
pub const GDK_PIXBUF_VERSION_MIN_REQUIRED = GDK_PIXBUF_VERSION_CUR_STABLE;
pub const GDK_KEY_Meta_R = 65512;
pub const GDK_KEY_Armenian_ZA = 16778550;
pub const cairo_ps_surface_set_dpi = cairo_ps_surface_set_dpi_REPLACED_BY_cairo_surface_set_fallback_resolution;
pub const GDK_KEY_Cyrillic_BE = 1762;
pub const G_DIR_SEPARATOR_S = c"\\";
pub const GDK_KEY_dead_capital_schwa = 65163;
pub const GDK_KEY_Wgrave = 16785024;
pub const GDK_KEY_Hangul_J_Phieuf = 3821;
pub const GDK_KEY_Pointer_Left = 65248;
pub const GDK_KEY_Sacute = 422;
pub const FOPEN_MAX = 20;
pub const GDK_KEY_dead_circumflex = 65106;
pub const g_macro__has_attribute = __has_attribute;
pub const G_VFS_EXTENSION_POINT_NAME = c"gio-vfs";
pub const __UINTMAX_WIDTH__ = 64;
pub const GDK_KEY_Hangul_J_RieulPhieuf = 3809;
pub const GDK_KEY_Iogonek = 967;
pub const GTK_STOCK_GO_BACK = if (@typeId(@typeOf(c"gtk-go-back")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-go-back") else if (@typeId(@typeOf(c"gtk-go-back")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-go-back") else GtkStock(c"gtk-go-back");
pub const GLIB_DEPRECATED_IN_2_54 = GLIB_DEPRECATED;
pub const GDK_KEY_gcircumflex = 760;
pub const DECIMAL_DIG = DBL_DECIMAL_DIG;
pub const GTK_STOCK_SELECT_ALL = if (@typeId(@typeOf(c"gtk-select-all")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-select-all") else if (@typeId(@typeOf(c"gtk-select-all")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-select-all") else GtkStock(c"gtk-select-all");
pub const GDK_KEY_Thai_sarai = 3540;
pub const GDK_KEY_Arabic_khah = 1486;
pub const GDK_KEY_braille_dots_1678 = 16787681;
pub const GDK_MINOR_VERSION = 24;
pub const GDK_KEY_R = 82;
pub const GDK_KEY_FrameBack = 269025181;
pub const GTK_PRINT_SETTINGS_PAPER_FORMAT = c"paper-format";
pub const GTK_PRINT_SETTINGS_SCALE = c"scale";
pub const GDK_KEY_Documents = 269025115;
pub const GDK_KEY_idotless = 697;
pub const GDK_KEY_braille_dots_78 = 16787648;
pub const GTK_STYLE_CLASS_PROGRESSBAR = c"progressbar";
pub const GTK_PAPER_NAME_A3 = c"iso_a3";
pub const GTK_STOCK_PROPERTIES = if (@typeId(@typeOf(c"gtk-properties")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-properties") else if (@typeId(@typeOf(c"gtk-properties")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-properties") else GtkStock(c"gtk-properties");
pub const GDK_KEY_Hangul_PreviousCandidate = 65342;
pub const GTK_PRINT_SETTINGS_DUPLEX = c"duplex";
pub const GDK_KEY_ecircumflextilde = 16785093;
pub const SIGABRT_COMPAT = 6;
pub const GDK_KEY_ohornbelowdot = 16785123;
pub const GDK_KEY_overbar = 3008;
pub const GDK_KEY_ihook = 16785097;
pub const GDK_KEY_Cyrillic_EN = 1774;
pub const GDK_KEY_ISO_Next_Group = 65032;
pub const ATK_AVAILABLE_IN_2_4 = _ATK_EXTERN;
pub const __DBL_MAX__ = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878;
pub const __UINT64_FMTx__ = c"llx";
pub const GDK_KEY_Thai_fofa = 3517;
pub const GDK_KEY_dead_I = 65157;
pub const GDK_KEY_Cyrillic_SOFTSIGN = 1784;
pub const GDK_KEY_omacron = 1010;
pub const GDK_KEY_braille_dots_12345678 = 16787711;
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_NOTIFY = c"StartupNotify";
pub const GDK_KEY_Thai_hohip = 3531;
pub const GDK_KEY_kana_KO = 1210;
pub const GLIB_DEPRECATED_MACRO_IN_2_40 = GLIB_DEPRECATED_MACRO;
pub const GDK_KEY_braille_dots_8 = 16787584;
pub const GDK_KEY_Greek_OMICRONaccent = 1959;
pub const _Always_impl_ = annos;
pub const ECONNRESET = 108;
pub const _RC_CHOP = 768;
pub const _USE_ATTRIBUTES_FOR_SAL = 0;
pub const GDK_KEY_onehalf = 189;
pub const SEEK_END = 2;
pub const G_VARIANT_TYPE_DOUBLE = if (@typeId(@typeOf(c"d")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"d") else if (@typeId(@typeOf(c"d")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"d") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"d");
pub const GDK_KEY_braille_dots_23567 = 16787574;
pub const GDK_AVAILABLE_IN_3_16 = _GDK_EXTERN;
pub const GTK_STYLE_CLASS_OSD = c"osd";
pub const G_FILE_ATTRIBUTE_STANDARD_COPY_NAME = c"standard::copy-name";
pub const GTK_STYLE_PROPERTY_BACKGROUND_COLOR = c"background-color";
pub const _OUT_TO_STDERR = 1;
pub const GDK_KEY_dollar = 36;
pub const G_BIG_ENDIAN = 4321;
pub const GDK_KEY_Hangul_Jamo = 65333;
pub const G_LN2 = 0.693147;
pub const __UINTPTR_WIDTH__ = 64;
pub const G_KEY_FILE_DESKTOP_KEY_TERMINAL = c"Terminal";
pub const GDK_KEY_braille_dots_23 = 16787462;
pub const GDK_KEY_kana_u = 1193;
pub const GTK_STOCK_COLOR_PICKER = if (@typeId(@typeOf(c"gtk-color-picker")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-color-picker") else if (@typeId(@typeOf(c"gtk-color-picker")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-color-picker") else GtkStock(c"gtk-color-picker");
pub const GTK_STYLE_CLASS_PAPER = c"paper";
pub const GDK_KEY_3270_BackTab = 64773;
pub const GDK_KEY_Switch_VT_10 = 269024778;
pub const GDK_KEY_less = 60;
pub const GDK_KEY_Launch0 = 269025088;
pub const __AES__ = 1;
pub const G_FILE_ATTRIBUTE_OWNER_GROUP = c"owner::group";
pub const L_tmpnam_s = L_tmpnam;
pub const GDK_KEY_hairspace = 2728;
pub const GDK_KEY_Sinh_au2 = 16780766;
pub const GDK_KEY_N = 78;
pub const _GDK_PIXBUF_EXTERN = @"extern";
pub const GDK_KEY_gcedilla = 955;
pub const GDK_KEY_Thai_chochan = 3496;
pub const cairo_xcb_surface_create_for_pixmap_with_visual = cairo_xcb_surface_create_for_pixmap_with_visual_REPLACED_BY_cairo_xcb_surface_create;
pub const _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY = c_ulonglong(1) << 2;
pub const GDK_KEY_filledtribulletup = 2792;
pub const GTK_PRINT_SETTINGS_N_COPIES = c"n-copies";
pub const PANGO_SCALE_X_LARGE = if (@typeId(@typeOf(1.440000)) == @import("builtin").TypeId.Pointer) @ptrCast(double, 1.440000) else if (@typeId(@typeOf(1.440000)) == @import("builtin").TypeId.Int) @intToPtr(double, 1.440000) else double(1.440000);
pub const G_MODULE_IMPORT = @"extern";
pub const GDK_KEY_Armenian_AT = 16778552;
pub const GDK_KEY_Save = 269025143;
pub const GDK_KEY_Sinh_dda = 16780713;
pub const GDK_KEY_Ukrainian_ghe_with_upturn = 1709;
pub const GDK_KEY_R6 = 65495;
pub const GDK_KEY_lessthanequal = 2236;
pub const environ = _environ;
pub const __SIZE_FMTo__ = c"llo";
pub const GDK_KEY_Hangul_Cieuc = 3770;
pub const G_TIME_SPAN_SECOND = if (@typeId(@typeOf(1000000)) == @import("builtin").TypeId.Pointer) @ptrCast(G_GINT64_CONSTANT, 1000000) else if (@typeId(@typeOf(1000000)) == @import("builtin").TypeId.Int) @intToPtr(G_GINT64_CONSTANT, 1000000) else G_GINT64_CONSTANT(1000000);
pub const PANGO_AVAILABLE_IN_1_6 = _PANGO_EXTERN;
pub const __UINT_FAST16_FMTx__ = c"hx";
pub const GLIB_DEPRECATED_TYPE_IN_2_56 = GLIB_DEPRECATED_TYPE;
pub const GDK_KEY_F25 = 65494;
pub const _On_failure_impl_ = annos;
pub const GDK_KEY_Pause = 65299;
pub const GDK_KEY_Cyrillic_ze = 1754;
pub const FPE_ZERODIVIDE = _FPE_ZERODIVIDE;
pub const GDK_KEY_aogonek = 433;
pub const GDK_KEY_numerosign = 1712;
pub const CHAR_BIT = 8;
pub const GDK_PIXBUF_AVAILABLE_IN_2_26 = _GDK_PIXBUF_EXTERN;
pub const G_VARIANT_TYPE_UINT64 = if (@typeId(@typeOf(c"t")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"t") else if (@typeId(@typeOf(c"t")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"t") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"t");
pub const GDK_KEY_Cyrillic_KA_descender = 16778394;
pub const __UINT_FAST64_FMTx__ = c"llx";
pub const cairo_surface_create_for_image = cairo_surface_create_for_image_REPLACED_BY_cairo_image_surface_create_for_data;
pub const GDK_KEY_ISO_Move_Line_Up = 65057;
pub const GDK_KEY_Hangul_PanSios = 3826;
pub const GDK_KEY_OE = 5052;
pub const GDK_KEY_Sinh_uu = 16780684;
pub const G_MENU_ATTRIBUTE_ACTION_NAMESPACE = c"action-namespace";
pub const __SIZE_WIDTH__ = 64;
pub const GLIB_DEPRECATED_IN_2_62 = GLIB_DEPRECATED;
pub const GDK_KEY_notapproxeq = 16785991;
pub const GDK_KEY_F30 = 65499;
pub const GDK_KEY_Oacute = 211;
pub const GDK_KEY_Thai_leksong = 3570;
pub const GDK_KEY_Hangul_YeorinHieuh = 3829;
pub const GDK_KEY_Shift_Lock = 65510;
pub const GDK_KEY_kana_a = 1191;
pub const __INT_MAX__ = 2147483647;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_34 = GLIB_DEPRECATED_ENUMERATOR;
pub const GDK_KEY_Hangul_J_RieulMieum = 3805;
pub const GDK_KEY_kana_HE = 1229;
pub const GTK_STOCK_PRINT_REPORT = if (@typeId(@typeOf(c"gtk-print-report")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-print-report") else if (@typeId(@typeOf(c"gtk-print-report")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-print-report") else GtkStock(c"gtk-print-report");
pub const G_FILE_ATTRIBUTE_THUMBNAIL_IS_VALID = c"thumbnail::is-valid";
pub const __clang_major__ = 9;
pub const EMFILE = 24;
pub const PANGO_DEPRECATED_IN_1_16 = PANGO_DEPRECATED;
pub const GDK_KEY_Thai_saraae = 3553;
pub const GDK_KEY_Cyrillic_de = 1732;
pub const GDK_KEY_ScreenSaver = 269025069;
pub const GDK_KEY_Dcaron = 463;
pub const GDK_KEY_Undo = 65381;
pub const GDK_KEY_rcaron = 504;
pub const GDK_KEY_g = 103;
pub const __UINT_LEAST16_MAX__ = 65535;
pub const G_FILE_ATTRIBUTE_TIME_CHANGED_USEC = c"time::changed-usec";
pub const _HEAPBADPTR = -6;
pub const GDK_KEY_dead_abovedot = 65110;
pub const CAIRO_VERSION_MAJOR = 1;
pub const GDK_KEY_braille_dots_346 = 16787500;
pub const GDK_KEY_breve = 418;
pub const GDK_KEY_rightsinglequotemark = 2769;
pub const GDK_KEY_braille_dots_23467 = 16787566;
pub const GDK_KEY_braille_dots_12 = 16787459;
pub const G_FILE_ATTRIBUTE_DOS_IS_SYSTEM = c"dos::is-system";
pub const __SAL_H_VERSION = 180000000;
pub const __UINT8_FMTu__ = c"hhu";
pub const G_PROXY_EXTENSION_POINT_NAME = c"gio-proxy";
pub const _FPE_MULTIPLE_FAULTS = 142;
pub const GDK_KEY_braille_dots_268 = 16787618;
pub const GDK_KEY_Scircumflex = 734;
pub const GDK_KEY_Arabic_zah = 1496;
pub const GDK_KEY_opentribulletup = 2787;
pub const GDK_KEY_Away = 269025165;
pub const GDK_KEY_braille_dots_1234567 = 16787583;
pub const GLIB_AVAILABLE_IN_2_40 = _GLIB_EXTERN;
pub const GDK_KEY_WindowClear = 269025109;
pub const GDK_KEY_Sinh_lu2 = 16780767;
pub const GTK_STYLE_PROPERTY_BACKGROUND_IMAGE = c"background-image";
pub const __has_lock_property = kind;
pub const GDK_KEY_guillemotleft = 171;
pub const GDK_KEY_3270_ExSelect = 64795;
pub const GDK_KEY_braille_dots_3468 = 16787628;
pub const G_TIME_SPAN_HOUR = if (@typeId(@typeOf(3600000000)) == @import("builtin").TypeId.Pointer) @ptrCast(G_GINT64_CONSTANT, 3600000000) else if (@typeId(@typeOf(3600000000)) == @import("builtin").TypeId.Int) @intToPtr(G_GINT64_CONSTANT, 3600000000) else G_GINT64_CONSTANT(3600000000);
pub const GDK_KEY_Ediaeresis = 203;
pub const PANGO_DEPRECATED_IN_1_34 = PANGO_DEPRECATED;
pub const GLIB_VERSION_MAX_ALLOWED = GLIB_VERSION_CUR_STABLE;
pub const ATK_DEPRECATED_IN_2_12 = ATK_DEPRECATED;
pub const EOF = -1;
pub const GDK_KEY_Armenian_HI = 16778565;
pub const GDK_KEY_hebrew_taf = 3322;
pub const GDK_KEY_NewSheqelSign = 16785578;
pub const GTK_PRINT_SETTINGS_OUTPUT_BIN = c"output-bin";
pub const EM_UNDERFLOW = _EM_UNDERFLOW;
pub const GDK_KEY_Ukranian_YI = 1719;
pub const _IOLBF = 64;
pub const __UINT32_FMTu__ = c"u";
pub const _Acquires_exclusive_lock_ = lock;
pub const GDK_KEY_downshoe = 3030;
pub const GDK_KEY_tintegral = 16785965;
pub const GDK_KEY_percent = 37;
pub const G_VARIANT_TYPE_VARIANT = if (@typeId(@typeOf(c"v")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"v") else if (@typeId(@typeOf(c"v")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"v") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"v");
pub const GDK_KEY_Utilde = 989;
pub const GDK_KEY_eth = 240;
pub const G_KEY_FILE_DESKTOP_KEY_TRY_EXEC = c"TryExec";
pub const GDK_KEY_Hangul_WAE = 3785;
pub const GDK_KEY_Cyrillic_DE = 1764;
pub const GDK_KEY_Greek_ALPHA = 1985;
pub const G_FILE_ATTRIBUTE_ID_FILESYSTEM = c"id::filesystem";
pub const GDK_KEY_horizlinescan1 = 2543;
pub const GDK_KEY_braille_dots_248 = 16787594;
pub const GDK_KEY_Greek_omega = 2041;
pub const GDK_KEY_Redo = 65382;
pub const GDK_KEY_S = 83;
pub const G_KEY_FILE_DESKTOP_KEY_URL = c"URL";
pub const GDK_KEY_Rcedilla = 931;
pub const GDK_KEY_udoubleacute = 507;
pub const cairo_set_alpha = cairo_set_alpha_DEPRECATED_BY_cairo_set_source_rgba_OR_cairo_paint_with_alpha;
pub const G_TYPE_RESERVED_BSE_LAST = 48;
pub const RC_UP = _RC_UP;
pub const __INT_LEAST16_TYPE__ = short;
pub const GTK_PAPER_NAME_A4 = c"iso_a4";
pub const GLIB_DEPRECATED_MACRO_IN_2_36 = GLIB_DEPRECATED_MACRO;
pub const GDK_KEY_Armenian_DZA = 16778561;
pub const GDK_KEY_colon = 58;
pub const GDK_KEY_Thai_leksam = 3571;
pub const GLIB_DEPRECATED_IN_2_40 = GLIB_DEPRECATED;
pub const GDK_CURRENT_TIME = c_long(0);
pub const GDK_KEY_Hangul_J_KkogjiDalrinIeung = 3833;
pub const GDK_KEY_Thai_thothung = 3510;
pub const G_TIME_SPAN_MILLISECOND = if (@typeId(@typeOf(1000)) == @import("builtin").TypeId.Pointer) @ptrCast(G_GINT64_CONSTANT, 1000) else if (@typeId(@typeOf(1000)) == @import("builtin").TypeId.Int) @intToPtr(G_GINT64_CONSTANT, 1000) else G_GINT64_CONSTANT(1000);
pub const _HEAPBADBEGIN = -3;
pub const G_TYPE_RESERVED_GLIB_LAST = 31;
pub const GDK_KEY_ae = 230;
pub const __SIZEOF_INT__ = 4;
pub const _Valid_ = _Valid_impl_;
pub const _Success_impl_ = expr;
pub const GTK_STOCK_CANCEL = if (@typeId(@typeOf(c"gtk-cancel")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-cancel") else if (@typeId(@typeOf(c"gtk-cancel")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-cancel") else GtkStock(c"gtk-cancel");
pub const GDK_KEY_Cyrillic_O_bar = 16778472;
pub const G_TIME_SPAN_MINUTE = if (@typeId(@typeOf(60000000)) == @import("builtin").TypeId.Pointer) @ptrCast(G_GINT64_CONSTANT, 60000000) else if (@typeId(@typeOf(60000000)) == @import("builtin").TypeId.Int) @intToPtr(G_GINT64_CONSTANT, 60000000) else G_GINT64_CONSTANT(60000000);
pub const GDK_KEY_Hangul_switch = 65406;
pub const GLIB_DEPRECATED_TYPE_IN_2_38 = GLIB_DEPRECATED_TYPE;
pub const TIME_UTC = 1;
pub const GDK_KEY_Ohorngrave = 16785116;
pub const GDK_KEY_kana_ME = 1234;
pub const GDK_KEY_Armenian_VEV = 16778574;
pub const GDK_KEY_Ukranian_yi = 1703;
pub const GDK_KEY_topvertsummationconnector = 2227;
pub const GDK_KEY_Support = 269025150;
pub const GDK_KEY_Ncedilla = 977;
pub const GDK_KEY_uhornacute = 16785129;
pub const GDK_KEY_RockerUp = 269025059;
pub const GDK_KEY_abovedot = 511;
pub const GTK_STOCK_MEDIA_REWIND = if (@typeId(@typeOf(c"gtk-media-rewind")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-media-rewind") else if (@typeId(@typeOf(c"gtk-media-rewind")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-media-rewind") else GtkStock(c"gtk-media-rewind");
pub const GTK_STOCK_REVERT_TO_SAVED = if (@typeId(@typeOf(c"gtk-revert-to-saved")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-revert-to-saved") else if (@typeId(@typeOf(c"gtk-revert-to-saved")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-revert-to-saved") else GtkStock(c"gtk-revert-to-saved");
pub const STRUNCATE = 80;
pub const cairo_set_target_ps = cairo_set_target_ps_DEPRECATED_BY_cairo_ps_surface_create;
pub const GDK_KEY_trademarkincircle = 2763;
pub const GTK_STOCK_MEDIA_PAUSE = if (@typeId(@typeOf(c"gtk-media-pause")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-media-pause") else if (@typeId(@typeOf(c"gtk-media-pause")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-media-pause") else GtkStock(c"gtk-media-pause");
pub const FLT_HAS_SUBNORM = 1;
pub const __ANNOTATION = fun;
pub const GDK_KEY_braille_dots_12468 = 16787627;
pub const GDK_KEY_kana_tsu = 1199;
pub const GTK_STYLE_CLASS_LIST = c"list";
pub const GDK_KEY_ISO_Next_Group_Lock = 65033;
pub const GTK_STOCK_FIND = if (@typeId(@typeOf(c"gtk-find")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-find") else if (@typeId(@typeOf(c"gtk-find")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-find") else GtkStock(c"gtk-find");
pub const GLIB_DEPRECATED_MACRO_IN_2_54 = GLIB_DEPRECATED_MACRO;
pub const GDK_KEY_Hangul_SsangSios = 3766;
pub const GDK_KEY_braille_dots_168 = 16787617;
pub const GDK_KEY_Sinh_ai = 16780691;
pub const GDK_KEY_Caps_Lock = 65509;
pub const GTK_STOCK_CLOSE = if (@typeId(@typeOf(c"gtk-close")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-close") else if (@typeId(@typeOf(c"gtk-close")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-close") else GtkStock(c"gtk-close");
pub const __UINT64_FMTo__ = c"llo";
pub const GDK_KEY_Launch7 = 269025095;
pub const __ATOMIC_ACQ_REL = 4;
pub const G_GSSIZE_FORMAT = c"lli";
pub const GDK_KEY_ISO_Level5_Latch = 65042;
pub const GDK_KEY_permille = 2773;
pub const GDK_KEY_Serbian_DZE = 1727;
pub const FLT_RADIX = 2;
pub const GTK_STOCK_ZOOM_FIT = if (@typeId(@typeOf(c"gtk-zoom-fit")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-zoom-fit") else if (@typeId(@typeOf(c"gtk-zoom-fit")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-zoom-fit") else GtkStock(c"gtk-zoom-fit");
pub const GDK_KEY_O = 79;
pub const GDK_KEY_hebrew_beth = 3297;
pub const GDK_KEY_ISO_Level3_Shift = 65027;
pub const GDK_KEY_Cyrillic_ghe_bar = 16778387;
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT = c"1.3.6.1.5.5.7.3.2";
pub const GDK_KEY_CD = 269025107;
pub const GTK_STYLE_CLASS_TOUCH_SELECTION = c"touch-selection";
pub const GDK_KEY_Pointer_DfltBtnNext = 65275;
pub const GDK_KEY_Thai_phosamphao = 3520;
pub const __INT64_MAX__ = c_longlong(9223372036854775807);
pub const GDK_KEY_R7 = 65496;
pub const __releases_lock = lock;
pub const GDK_KEY_Greek_UPSILON = 2005;
pub const GDK_KEY_Greek_RHO = 2001;
pub const G_PI = 3.141593;
pub const GDK_KEY_AE = 198;
pub const GDK_KEY_braille_dots_34678 = 16787692;
pub const GDK_KEY_Ccedilla = 199;
pub const GDK_KEY_Ytilde = 16785144;
pub const GDK_KEY_topt = 2551;
pub const GTK_STYLE_CLASS_NEEDS_ATTENTION = c"needs-attention";
pub const GDK_KEY_icircumflex = 238;
pub const GDK_KEY_F26 = 65495;
pub const GDK_KEY_iTouch = 269025120;
pub const GTK_STOCK_NEW = if (@typeId(@typeOf(c"gtk-new")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-new") else if (@typeId(@typeOf(c"gtk-new")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-new") else GtkStock(c"gtk-new");
pub const _Analysis_assume_ = expr;
pub const ENOSR = 124;
pub const GTK_STYLE_CLASS_ACCELERATOR = c"accelerator";
pub const __GNUC_VA_LIST = 1;
pub const GDK_KEY_braille_dots_148 = 16787593;
pub const GDK_KEY_Uhook = 16785126;
pub const GDK_KEY_Xfer = 269025162;
pub const GTK_STYLE_REGION_COLUMN = c"column";
pub const __SIG_ATOMIC_WIDTH__ = 32;
pub const __UINT_FAST64_FMTX__ = c"llX";
pub const ATK_MINOR_VERSION = 34;
pub const GLIB_DEPRECATED_TYPE_IN_2_62 = GLIB_DEPRECATED_TYPE;
pub const _ALLOCA_S_STACK_MARKER = 52428;
pub const GDK_AVAILABLE_IN_ALL = _GDK_EXTERN;
pub const GDK_KEY_dintegral = 16785964;
pub const GDK_KEY_KP_Home = 65429;
pub const _Deref2_ret1_impl_ = p1;
pub const GDK_KEY_dead_ogonek = 65116;
pub const GDK_KEY_Codeinput = 65335;
pub const GDK_PIXBUF_AVAILABLE_IN_2_36 = _GDK_PIXBUF_EXTERN;
pub const GDK_KEY_aacute = 225;
pub const GDK_KEY_UserPB = 269025156;
pub const GDK_KEY_Hangul_AraeA = 3830;
pub const GDK_KEY_Cyrillic_je = 1704;
pub const GDK_KEY_Aring = 197;
pub const GDK_KEY_Armenian_accent = 16778587;
pub const GDK_KEY_identical = 2255;
pub const _TMP_MAX_S = TMP_MAX;
pub const GDK_KEY_Armenian_YECH = 16778549;
pub const GDK_KEY_Sinh_h2 = 16780675;
pub const __byte_readableTo = size;
pub const GDK_KEY_DongSign = 16785579;
pub const GDK_KEY_x = 120;
pub const GLIB_AVAILABLE_IN_2_56 = _GLIB_EXTERN;
pub const G_MAXINT16 = if (@typeId(@typeOf(32767)) == @import("builtin").TypeId.Pointer) @ptrCast(gint16, 32767) else if (@typeId(@typeOf(32767)) == @import("builtin").TypeId.Int) @intToPtr(gint16, 32767) else gint16(32767);
pub const PANGO_VERSION_STRING = c"1.43.0";
pub const GDK_KEY_braille_dots_4578 = 16787672;
pub const __DBL_MIN_EXP__ = -1021;
pub const EPROTONOSUPPORT = 135;
pub const G_FILE_ATTRIBUTE_UNIX_BLOCK_SIZE = c"unix::block-size";
pub const GDK_KEY_Babovedot = 16784898;
pub const GDK_KEY_Cyrillic_shha = 16778427;
pub const GDK_KEY_braille_dots_347 = 16787532;
pub const _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS = c_ulonglong(1) << 1;
pub const GDK_KEY_braille_dots_13 = 16787461;
pub const GDK_KEY_lowrightcorner = 2538;
pub const GDK_KEY_leftopentriangle = 2764;
pub const GDK_KEY_wgrave = 16785025;
pub const GDK_DEPRECATED_IN_3_2 = GDK_DEPRECATED;
pub const __SIZEOF_SHORT__ = 2;
pub const GDK_KEY_Armenian_verjaket = 16778633;
pub const __UINT16_FMTX__ = c"hX";
pub const GDK_KEY_braille_dots_1234568 = 16787647;
pub const GTK_STYLE_CLASS_LEVEL_BAR = c"level-bar";
pub const GDK_KEY_WWW = 269025070;
pub const GDK_KEY_ehook = 16785083;
pub const G_URI_RESERVED_CHARS_SUBCOMPONENT_DELIMITERS = c"!$&\'()*+,;=";
pub const GDK_KEY_hebrew_kaph = 3307;
pub const GDK_KEY_period = 46;
pub const GDK_KEY_leftdoublequotemark = 2770;
pub const cairo_init_clip = cairo_init_clip_REPLACED_BY_cairo_reset_clip;
pub const GDK_KEY_Game = 269025118;
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VOLATILE = c"standard::is-volatile";
pub const GDK_KEY_uprightcorner = 2539;
pub const GTK_PRINT_SETTINGS_PRINT_PAGES = c"print-pages";
pub const _Releases_shared_lock_ = lock;
pub const GDK_KEY_rightmiddlecurlybrace = 2224;
pub const GDK_KEY_Greek_OMEGAaccent = 1963;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES = 0;
pub const GDK_KEY_EcuSign = 16785568;
pub const GDK_KEY_Cyrillic_JE = 1720;
pub const GDK_KEY_Arabic_madda_above = 16778835;
pub const SCHAR_MIN = -128;
pub const G_FILE_ATTRIBUTE_PREVIEW_ICON = c"preview::icon";
pub const GDK_KEY_braille_dot_8 = 65528;
pub const GDK_KEY_Sinh_tha = 16780717;
pub const GDK_KEY_Cyrillic_O = 1775;
pub const G_FILE_ATTRIBUTE_SELINUX_CONTEXT = c"selinux::context";
pub const _Releases_exclusive_lock_ = lock;
pub const GDK_KEY_Thai_sorusi = 3529;
pub const __DBL_MANT_DIG__ = 53;
pub const GDK_KEY_Thai_sarao = 3554;
pub const GDK_KEY_T = 84;
pub const GDK_KEY_kana_tu = 1199;
pub const GDK_KEY_obelowdot = 16785101;
pub const GDK_KEY_Georgian_kan = 16781529;
pub const GDK_KEY_Thai_leksun = 3568;
pub const GDK_KEY_kana_SO = 1215;
pub const GDK_KEY_Hangul_Nieun = 3748;
pub const GDK_KEY_hebrew_resh = 3320;
pub const GTK_PAPER_NAME_A5 = c"iso_a5";
pub const GDK_KEY_Pointer_UpRight = 65253;
pub const __SIZEOF_SIZE_T__ = 8;
pub const GLIB_MAJOR_VERSION = 2;
pub const G_FILE_ATTRIBUTE_ETAG_VALUE = c"etag::value";
pub const GDK_KEY_braille_dots_234578 = 16787678;
pub const GTK_STOCK_NO = if (@typeId(@typeOf(c"gtk-no")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-no") else if (@typeId(@typeOf(c"gtk-no")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-no") else GtkStock(c"gtk-no");
pub const __UINT_LEAST16_FMTo__ = c"ho";
pub const GDK_KEY_currency = 164;
pub const GDK_KEY_ISO_Release_Both_Margins = 65067;
pub const GTK_STYLE_CLASS_CONTEXT_MENU = c"context-menu";
pub const _FPCLASS_SNAN = 1;
pub const GDK_KEY_maltesecross = 2800;
pub const GDK_KEY_AudioRandomPlay = 269025177;
pub const FPE_STACKOVERFLOW = _FPE_STACKOVERFLOW;
pub const GDK_KEY_Memo = 269025054;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_TYPE = c"filesystem::type";
pub const _Pre_satisfies_impl_ = expr;
pub const _Deref_ret1_impl_ = p1;
pub const ATK_AVAILABLE_IN_2_6 = _ATK_EXTERN;
pub const GDK_KEY_DOS = 269025114;
pub const GDK_KEY_Acircumflexhook = 16785064;
pub const GDK_KEY_toprightsqbracket = 2217;
pub const GDK_KEY_Arabic_sad = 1493;
pub const GDK_KEY_dead_O = 65159;
pub const GDK_KEY_EZH = 16777655;
pub const GDK_KEY_Greek_upsilonaccentdieresis = 1978;
pub const GDK_KEY_quad = 3020;
pub const GLIB_DEPRECATED_MACRO_IN_2_42 = GLIB_DEPRECATED_MACRO;
pub const GLIB_SYSDEF_AF_INET = 2;
pub const GDK_KEY_kcedilla = 1011;
pub const G_TYPE_FUNDAMENTAL_MAX = 255 << G_TYPE_FUNDAMENTAL_SHIFT;
pub const __code_model_small_ = 1;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_40 = GLIB_DEPRECATED_ENUMERATOR;
pub const GDK_AVAILABLE_IN_3_10 = _GDK_EXTERN;
pub const G_VARIANT_TYPE_BYTE = if (@typeId(@typeOf(c"y")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"y") else if (@typeId(@typeOf(c"y")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"y") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"y");
pub const G_VARIANT_TYPE_BASIC = if (@typeId(@typeOf(c"?")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"?") else if (@typeId(@typeOf(c"?")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"?") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"?");
pub const GDK_KEY_Thai_thothong = 3512;
pub const GTK_STYLE_CLASS_OVERSHOOT = c"overshoot";
pub const G_FILE_ATTRIBUTE_DOS_REPARSE_POINT_TAG = c"dos::reparse-point-tag";
pub const __INT16_MAX__ = 32767;
pub const GDK_KEY_L4 = 65483;
pub const GTK_STOCK_MEDIA_PLAY = if (@typeId(@typeOf(c"gtk-media-play")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-media-play") else if (@typeId(@typeOf(c"gtk-media-play")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-media-play") else GtkStock(c"gtk-media-play");
pub const GDK_KEY_Thai_popla = 3515;
pub const GDK_KEY_FrameForward = 269025182;
pub const GDK_KEY_digitspace = 2725;
pub const __CLANG_ATOMIC_POINTER_LOCK_FREE = 2;
pub const __WINT_WIDTH__ = 16;
pub const GDK_KEY_Sinh_sa = 16780739;
pub const __SHRT_MAX__ = 32767;
pub const GDK_KEY_Hangul_YE = 3782;
pub const GDK_KEY_Acircumflexgrave = 16785062;
pub const GDK_KEY_Calendar = 269025056;
pub const __INT32_FMTd__ = c"d";
pub const GDK_KEY_sevensuperior = 16785527;
pub const GDK_KEY_Launch6 = 269025094;
pub const __INTPTR_WIDTH__ = 64;
pub const GDK_KEY_Hangul_PostHanja = 65339;
pub const __INT_FAST32_TYPE__ = int;
pub const _Deref_pre1_impl_ = p1;
pub const GDK_KEY_kana_TU = 1218;
pub const _Post1_impl_ = p1;
pub const GDK_KEY_Hangul_J_Ieung = 3816;
pub const GTK_STYLE_PROVIDER_PRIORITY_THEME = 200;
pub const _LDBL_ROUNDS = _DBL_ROUNDS;
pub const GDK_KEY_kana_middledot = 1189;
pub const GDK_KEY_THORN = 222;
pub const GDK_KEY_Macedonia_kje = 1708;
pub const GDK_KEY_Greek_IOTAdiaeresis = 1957;
pub const ATK_VERSION_MIN_REQUIRED = ATK_VERSION_CUR_STABLE;
pub const GDK_KEY_Arabic_tehmarbuta = 1481;
pub const G_SOURCE_CONTINUE = TRUE;
pub const cairo_set_target_quartz = cairo_set_target_quartz_DEPRECATED_BY_cairo_quartz_surface_create;
pub const GDK_KEY_ifonlyif = 2253;
pub const GDK_MICRO_VERSION = 12;
pub const GDK_KEY_R4 = 65493;
pub const GTK_STOCK_PRINT_ERROR = if (@typeId(@typeOf(c"gtk-print-error")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-print-error") else if (@typeId(@typeOf(c"gtk-print-error")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-print-error") else GtkStock(c"gtk-print-error");
pub const G_NETWORK_MONITOR_EXTENSION_POINT_NAME = c"gio-network-monitor";
pub const GDK_KEY_Thai_leksi = 3572;
pub const GTK_STYLE_CLASS_TOP = c"top";
pub const CAIRO_HAS_OBSERVER_SURFACE = 1;
pub const GTK_STYLE_CLASS_PANE_SEPARATOR = c"pane-separator";
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 = 1;
pub const PANGO_AVAILABLE_IN_1_8 = _PANGO_EXTERN;
pub const TMP_MAX_S = TMP_MAX;
pub const GDK_KEY_kana_closingbracket = 1187;
pub const G_OPTION_REMAINING = c"";
pub const __OPENCL_MEMORY_SCOPE_ALL_SVM_DEVICES = 3;
pub const GDK_KEY_Hangul_Jeonja = 65336;
pub const GDK_KEY_F27 = 65496;
pub const GLIB_DEPRECATED_TYPE_IN_2_54 = GLIB_DEPRECATED_TYPE;
pub const cairo_concat_matrix = cairo_concat_matrix_REPLACED_BY_cairo_transform;
pub const G_GUINT16_FORMAT = c"hu";
pub const __INT8_FMTd__ = c"hhd";
pub const GDK_KEY_hebrew_finalzade = 3317;
pub const GDK_KEY_MillSign = 16785573;
pub const GDK_KEY_Cyrillic_te = 1748;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START = c"mountable::can-start";
pub const __XSAVE__ = 1;
pub const GDK_KEY_lcaron = 437;
pub const GDK_KEY_zerosubscript = 16785536;
pub const GLIB_DEPRECATED_IN_2_60 = GLIB_DEPRECATED;
pub const GDK_KEY_Hangul_RieulSios = 3757;
pub const GDK_KEY_3270_PrintScreen = 64797;
pub const GDK_KEY_Armenian_tyun = 16778623;
pub const GDK_KEY_abreveacute = 16785071;
pub const FPE_UNDERFLOW = _FPE_UNDERFLOW;
pub const __UINTMAX_MAX__ = c_ulonglong(18446744073709551615);
pub const GDK_KEY_Video = 269025159;
pub const GDK_KEY_Serbian_NJE = 1722;
pub const GDK_KEY_Mail = 269025049;
pub const GDK_KEY_AccessX_Enable = 65136;
pub const GDK_KEY_Greek_IOTA = 1993;
pub const GTK_STOCK_GO_UP = if (@typeId(@typeOf(c"gtk-go-up")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-go-up") else if (@typeId(@typeOf(c"gtk-go-up")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-go-up") else GtkStock(c"gtk-go-up");
pub const GDK_KEY_KP_Down = 65433;
pub const GTK_PRINT_SETTINGS_REVERSE = c"reverse";
pub const GDK_KEY_Mabovedot = 16784960;
pub const GDK_KEY_KP_8 = 65464;
pub const __STDC_WANT_SECURE_LIB__ = 1;
pub const GDK_KEY_braille_dots_567 = 16787568;
pub const GDK_KEY_hebrew_gimel = 3298;
pub const GDK_KEY_kana_TA = 1216;
pub const G_GUINT64_FORMAT = c"llu";
pub const G_STR_DELIMITERS = c"_-\x7c> <.";
pub const GDK_KEY_acircumflextilde = 16785067;
pub const GDK_KEY_Acircumflexacute = 16785060;
pub const _IC_PROJECTIVE = 0;
pub const GDK_KEY_y = 121;
pub const GDK_KEY_Pointer_DblClick4 = 65266;
pub const G_ALLOCATOR_LIST = 1;
pub const GDK_KEY_Armenian_amanak = 16778588;
pub const ENOEXEC = 8;
pub const GDK_KEY_Arabic_heh_doachashmee = 16778942;
pub const GDK_KEY_Georgian_qar = 16781543;
pub const GDK_KEY_Arabic_fullstop = 16778964;
pub const GDK_KEY_Thai_lekhok = 3574;
pub const GDK_KEY_Hangul_Special = 65343;
pub const G_PID_FORMAT = c"p";
pub const __analysis_assume = expr;
pub const GDK_KEY_ohorntilde = 16785121;
pub const GDK_KEY_Arabic_sheen = 1492;
pub const GDK_PIXBUF_VERSION_MAX_ALLOWED = GDK_PIXBUF_VERSION_MIN_REQUIRED;
pub const GLIB_AVAILABLE_IN_2_46 = _GLIB_EXTERN;
pub const GDK_KEY_openstar = 2789;
pub const __INT_FAST32_FMTi__ = c"i";
pub const GDK_KEY_Sinh_uu2 = 16780758;
pub const GDK_KEY_Ukranian_I = 1718;
pub const GDK_KEY_Hangul_SunkyeongeumMieum = 3824;
pub const GDK_KEY_hebrew_zadi = 3318;
pub const GDK_KEY_Arabic_sukun = 1522;
pub const GDK_KEY_intersection = 2268;
pub const FPE_DENORMAL = _FPE_DENORMAL;
pub const GDK_KEY_Georgian_nar = 16781532;
pub const GDK_KEY_Cyrillic_TE = 1780;
pub const PANGO_DEPRECATED_IN_1_32 = PANGO_DEPRECATED;
pub const GDK_KEY_diamond = 2797;
pub const GDK_KEY_threeeighths = 2756;
pub const ATK_DEPRECATED_IN_2_10 = ATK_DEPRECATED;
pub const GDK_KEY_Cyrillic_HARDSIGN = 1791;
pub const G_VOLUME_IDENTIFIER_KIND_LABEL = c"label";
pub const __UINT32_FMTX__ = c"X";
pub const GDK_KEY_Arabic_waw = 1512;
pub const LDBL_HAS_SUBNORM = DBL_HAS_SUBNORM;
pub const GDK_KEY_HomePage = 269025048;
pub const GDK_KEY_kana_YU = 1237;
pub const _status87 = _statusfp;
pub const GDK_KEY_braille_dots_12367 = 16787559;
pub const GDK_KEY_Sinh_nna = 16780715;
pub const GDK_KEY_3270_EraseEOF = 64774;
pub const GDK_KEY_Ungrab = 269024800;
pub const GTK_STOCK_GO_DOWN = if (@typeId(@typeOf(c"gtk-go-down")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-go-down") else if (@typeId(@typeOf(c"gtk-go-down")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-go-down") else GtkStock(c"gtk-go-down");
pub const ENETDOWN = 116;
pub const GDK_KEY_Ukrainian_i = 1702;
pub const FPE_UNEMULATED = _FPE_UNEMULATED;
pub const GDK_KEY_dagger = 2801;
pub const GDK_KEY_Arabic_hamza = 1473;
pub const GDK_KEY_Abreveacute = 16785070;
pub const GDK_KEY_braille_dots_368 = 16787620;
pub const GTK_STYLE_CLASS_SCROLLBAR = c"scrollbar";
pub const _MCW_PC = 196608;
pub const GDK_KEY_Gcedilla = 939;
pub const GDK_KEY_braille_dot_9 = 65529;
pub const GDK_KEY_threefifths = 2740;
pub const __inner_control_entrypoint = category;
pub const GTK_STOCK_REMOVE = if (@typeId(@typeOf(c"gtk-remove")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-remove") else if (@typeId(@typeOf(c"gtk-remove")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-remove") else GtkStock(c"gtk-remove");
pub const __ATOMIC_RELEASE = 3;
pub const GDK_KEY_notsign = 172;
pub const GDK_KEY_horizlinescan3 = 2544;
pub const GDK_KEY_Thai_ru = 3524;
pub const __SIZEOF_LONG_DOUBLE__ = 8;
pub const GDK_KEY_upshoe = 3011;
pub const _FPE_MULTIPLE_TRAPS = 141;
pub const GDK_KEY_U = 85;
pub const G_SEARCHPATH_SEPARATOR = 59;
pub const GDK_KEY_Armenian_MEN = 16778564;
pub const FILENAME_MAX = 260;
pub const GTK_STYLE_CLASS_LABEL = c"label";
pub const _INTEGRAL_MAX_BITS = 64;
pub const GDK_KEY_Arabic_yeh = 1514;
pub const __SSE2_MATH__ = 1;
pub const GLIB_DEPRECATED_MACRO_IN_2_38 = GLIB_DEPRECATED_MACRO;
pub const G_KEY_FILE_DESKTOP_KEY_DBUS_ACTIVATABLE = c"DBusActivatable";
pub const GLIB_AVAILABLE_IN_ALL = _GLIB_EXTERN;
pub const G_FILE_ATTRIBUTE_TIME_ACCESS_USEC = c"time::access-usec";
pub const GLIB_DEPRECATED_IN_2_42 = GLIB_DEPRECATED;
pub const GDK_KEY_Cyrillic_ef = 1734;
pub const GDK_KEY_hebrew_waw = 3301;
pub const GDK_KEY_Fabovedot = 16784926;
pub const GDK_KEY_comma = 44;
pub const GTK_PRINT_SETTINGS_WIN32_DRIVER_VERSION = c"win32-driver-version";
pub const GDK_KEY_Sinh_kha = 16780699;
pub const __UINT64_FMTu__ = c"llu";
pub const GDK_KEY_Cyrillic_ES = 1779;
pub const GDK_KEY_vertconnector = 2214;
pub const GDK_KEY_braille_dots_134578 = 16787677;
pub const GDK_KEY_Greek_OMEGA = 2009;
pub const GDK_KEY_Arabic_dad = 1494;
pub const GDK_KEY_LogGrabInfo = 269024805;
pub const GDK_KEY_Greek_sigma = 2034;
pub const GDK_KEY_Ocircumflexgrave = 16785106;
pub const GDK_KEY_ecaron = 492;
pub const GDK_KEY_Serbian_DJE = 1713;
pub const RC_CHOP = _RC_CHOP;
pub const GTK_STYLE_CLASS_INSERTION_CURSOR = c"insertion-cursor";
pub const GDK_KEY_Hangul_WEO = 3789;
pub const GDK_KEY_eacute = 233;
pub const GDK_KEY_Armenian_PYUR = 16778579;
pub const GDK_KEY_L5 = 65484;
pub const GDK_KEY_Thai_saraaimaimalai = 3556;
pub const __DBL_MAX_EXP__ = 1024;
pub const GDK_KEY_Georgian_hoe = 16781557;
pub const L_tmpnam = 260;
pub const GDK_KEY_oe = 5053;
pub const GDK_KEY_kana_YA = 1236;
pub const G_FILE_ATTRIBUTE_THUMBNAILING_FAILED = c"thumbnail::failed";
pub const GDK_KEY_Arabic_hamza_above = 16778836;
pub const DBL_MIN_10_EXP = -307;
pub const GDK_KEY_Switch_VT_8 = 269024776;
pub const GDK_KEY_Cut = 269025112;
pub const GDK_KEY_oslash = 248;
pub const GDK_KEY_acircumflexbelowdot = 16785069;
pub const GDK_KEY_Katakana = 65318;
pub const GLIB_DEPRECATED_MACRO_IN_2_52 = GLIB_DEPRECATED_MACRO;
pub const _SW_INEXACT = 1;
pub const GDK_KEY_Farsi_8 = 16779000;
pub const GDK_KEY_ytilde = 16785145;
pub const GDK_KEY_Search = 269025051;
pub const g_slist_free1 = g_slist_free_1;
pub const GDK_KEY_kana_openingbracket = 1186;
pub const GDK_KEY_braille_dots_2468 = 16787626;
pub const GDK_KEY_Hangul_Ieung = 3767;
pub const GDK_KEY_Launch5 = 269025093;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_54 = GLIB_DEPRECATED_ENUMERATOR;
pub const GDK_KEY_Arabic_comma = 1452;
pub const GDK_KEY_infinity = 2242;
pub const GDK_KEY_Sinh_ru2 = 16780760;
pub const GDK_KEY_Cyrillic_e = 1756;
pub const G_VOLUME_IDENTIFIER_KIND_UUID = c"uuid";
pub const GDK_KEY_Thai_wowaen = 3527;
pub const GTK_PRINT_SETTINGS_MEDIA_TYPE = c"media-type";
pub const _Deref2_pre1_impl_ = p1;
pub const GDK_KEY_Arabic_qaf = 1506;
pub const GTK_PRINT_SETTINGS_OUTPUT_URI = c"output-uri";
pub const GDK_KEY_A = 65;
pub const GDK_KEY_ISO_Partial_Space_Right = 65062;
pub const GDK_KEY_Cyrillic_schwa = 16778457;
pub const GDK_KEY_hebrew_samekh = 3313;
pub const GDK_KEY_Georgian_fi = 16781558;
pub const GDK_KEY_F8 = 65477;
pub const GDK_KEY_Next_Virtual_Screen = 65234;
pub const GDK_KEY_R5 = 65494;
pub const GDK_KEY_Sinh_ca = 16780704;
pub const GDK_KEY_C_h = 65188;
pub const GDK_KEY_botrightparens = 2222;
pub const EDEADLOCK = EDEADLK;
pub const GDK_KEY_leftradical = 2209;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 = 1;
pub const GDK_KEY_nacute = 497;
pub const GDK_KEY_Ahook = 16785058;
pub const GDK_KEY_toprightsummation = 2229;
pub const GDK_KEY_Thai_chochang = 3498;
pub const GDK_KEY_approxeq = 16785992;
pub const cairo_xcb_surface_create_for_window_with_visual = cairo_xcb_surface_create_for_window_with_visual_REPLACED_BY_cairo_xcb_surface_create;
pub const cairo_matrix_create = cairo_matrix_create_DEPRECATED_BY_cairo_matrix_t;
pub const GDK_KEY_club = 2796;
pub const GDK_KEY_Reply = 269025138;
pub const G_TYPE_FLAG_RESERVED_ID_BIT = if (@typeId(@typeOf(1 << 0)) == @import("builtin").TypeId.Pointer) @ptrCast(GType, 1 << 0) else if (@typeId(@typeOf(1 << 0)) == @import("builtin").TypeId.Int) @intToPtr(GType, 1 << 0) else GType(1 << 0);
pub const GDK_KEY_lowleftcorner = 2541;
pub const GDK_KEY_Lstroke = 419;
pub const GDK_KEY_Armenian_GHAT = 16778562;
pub const GDK_KEY_kana_NU = 1223;
pub const GDK_KEY_dead_belowdot = 65120;
pub const GDK_KEY_Sinh_ga = 16780700;
pub const GDK_KEY_Alt_L = 65513;
pub const GDK_KEY_dead_e = 65154;
pub const GDK_KEY_Ocircumflextilde = 16785110;
pub const _FPE_EXPLICITGEN = 140;
pub const GDK_KEY_Cyrillic_GHE_bar = 16778386;
pub const GDK_KEY_dead_hook = 65121;
pub const GDK_KEY_leftcaret = 2979;
pub const GTK_STYLE_CLASS_RUBBERBAND = c"rubberband";
pub const GTK_STYLE_CLASS_HEADER = c"header";
pub const __ATOMIC_CONSUME = 1;
pub const GDK_KEY_hebrew_dalet = 3299;
pub const GDK_KEY_Hangul_Tieut = 3772;
pub const GDK_KEY_bracketright = 93;
pub const GDK_KEY_braille_dots_1457 = 16787545;
pub const GDK_KEY_Armenian_but = 16778589;
pub const GLIB_DEPRECATED_TYPE_IN_2_60 = GLIB_DEPRECATED_TYPE;
pub const GDK_KEY_F35 = 65504;
pub const __INT_LEAST16_FMTd__ = c"hd";
pub const GTK_STOCK_PAGE_SETUP = if (@typeId(@typeOf(c"gtk-page-setup")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-page-setup") else if (@typeId(@typeOf(c"gtk-page-setup")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-page-setup") else GtkStock(c"gtk-page-setup");
pub const G_FILE_ATTRIBUTE_UNIX_UID = c"unix::uid";
pub const cairo_svg_surface_set_dpi = cairo_svg_surface_set_dpi_REPLACED_BY_cairo_surface_set_fallback_resolution;
pub const __INT_LEAST64_FMTd__ = c"lld";
pub const GDK_KEY_Greek_horizbar = 1967;
pub const G_TYPE_FUNDAMENTAL_SHIFT = 2;
pub const GDK_KEY_registered = 174;
pub const GDK_KEY_Hyper_L = 65517;
pub const _USE_DECLSPECS_FOR_SAL = 0;
pub const GDK_KEY_ohornacute = 16785115;
pub const GDK_PIXBUF_AVAILABLE_IN_2_34 = _GDK_PIXBUF_EXTERN;
pub const GDK_KEY_KP_9 = 65465;
pub const GDK_KEY_Uhornhook = 16785132;
pub const GDK_KEY_3270_Record = 64792;
pub const GDK_KEY_Lcedilla = 934;
pub const CAIRO_VERSION_MICRO = 0;
pub const GDK_KEY_kana_RA = 1239;
pub const GDK_KEY_em3space = 2723;
pub const GDK_KEY_Prior = 65365;
pub const GDK_KEY_Georgian_vin = 16781525;
pub const GDK_KEY_foursubscript = 16785540;
pub const GTK_STOCK_SAVE = if (@typeId(@typeOf(c"gtk-save")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-save") else if (@typeId(@typeOf(c"gtk-save")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-save") else GtkStock(c"gtk-save");
pub const GDK_KEY_braille_dots_568 = 16787632;
pub const GDK_KEY_ISO_Fast_Cursor_Up = 65070;
pub const GTK_STYLE_CLASS_TOOLBAR = c"toolbar";
pub const GDK_KEY_sacute = 438;
pub const GDK_KEY_Ohornbelowdot = 16785122;
pub const GDK_KEY_uhook = 16785127;
pub const G_STMT_START = do;
pub const GDK_KEY_z = 122;
pub const GDK_KEY_Byelorussian_shortu = 1710;
pub const GDK_KEY_ISO_Level3_Latch = 65028;
pub const GLIB_AVAILABLE_IN_2_58 = _GLIB_EXTERN;
pub const GDK_KEY_signifblank = 2732;
pub const GDK_KEY_Pointer_DblClick5 = 65267;
pub const GDK_KEY_braille_dots_12348 = 16787599;
pub const GTK_STYLE_CLASS_COMBOBOX_ENTRY = c"combobox-entry";
pub const PANGO_SCALE_XX_SMALL = if (@typeId(@typeOf(0.578704)) == @import("builtin").TypeId.Pointer) @ptrCast(double, 0.578704) else if (@typeId(@typeOf(0.578704)) == @import("builtin").TypeId.Int) @intToPtr(double, 0.578704) else double(0.578704);
pub const G_FILE_ATTRIBUTE_TIME_CREATED = c"time::created";
pub const CAIRO_HAS_GOBJECT_FUNCTIONS = 1;
pub const GDK_KEY_ISO_Level3_Lock = 65029;
pub const GDK_KEY_braille_dots_245678 = 16787706;
pub const GDK_KEY_doublelowquotemark = 2814;
pub const EOWNERDEAD = 133;
pub const GTK_STOCK_DISCONNECT = if (@typeId(@typeOf(c"gtk-disconnect")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-disconnect") else if (@typeId(@typeOf(c"gtk-disconnect")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-disconnect") else GtkStock(c"gtk-disconnect");
pub const GDK_DEPRECATED_IN_3_4 = GDK_DEPRECATED;
pub const __UINT_LEAST16_FMTX__ = c"hX";
pub const E2BIG = 7;
pub const _Requires_lock_not_held_ = lock;
pub const GDK_KEY_Arabic_jeem = 1484;
pub const __amd64__ = 1;
pub const GDK_KEY_signaturemark = 2762;
pub const CAIRO_HAS_RECORDING_SURFACE = 1;
pub const GDK_KEY_ISO_Last_Group_Lock = 65039;
pub const __PTRDIFF_FMTi__ = c"lli";
pub const G_FILE_ATTRIBUTE_STANDARD_IS_BACKUP = c"standard::is-backup";
pub const GDK_KEY_Break = 65387;
pub const GDK_KEY_Hangul_A = 3775;
pub const GDK_KEY_Armenian_vev = 16778622;
pub const GDK_KEY_Thai_dodek = 3508;
pub const cairo_inverse_transform_distance = cairo_inverse_transform_distance_REPLACED_BY_cairo_device_to_user_distance;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_28 = GLIB_DEPRECATED_ENUMERATOR;
pub const SIGILL = 4;
pub const GTK_STOCK_SORT_DESCENDING = if (@typeId(@typeOf(c"gtk-sort-descending")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-sort-descending") else if (@typeId(@typeOf(c"gtk-sort-descending")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-sort-descending") else GtkStock(c"gtk-sort-descending");
pub const GDK_KEY_ContrastAdjust = 269025058;
pub const _Has_lock_level_ = level;
pub const G_FILE_ATTRIBUTE_STANDARD_FAST_CONTENT_TYPE = c"standard::fast-content-type";
pub const GDK_MAX_TIMECOORD_AXES = 128;
pub const GDK_KEY_ISO_Move_Line_Down = 65058;
pub const GDK_KEY_Odiaeresis = 214;
pub const GDK_KEY_zerosuperior = 16785520;
pub const GDK_KEY_Cyrillic_CHE_vertstroke = 16778424;
pub const _CRT_FUNCTIONS_REQUIRED = 1;
pub const GDK_KEY_Hangul_RieulTieut = 3758;
pub const G_VOLUME_MONITOR_EXTENSION_POINT_NAME = c"gio-volume-monitor";
pub const __INTMAX_MAX__ = c_longlong(9223372036854775807);
pub const GDK_KEY_Eacute = 201;
pub const GDK_KEY_braille_dots_1368 = 16787621;
pub const G_KEY_FILE_DESKTOP_KEY_NAME = c"Name";
pub const ETIMEDOUT = 138;
pub const __CLANG_ATOMIC_CHAR32_T_LOCK_FREE = 2;
pub const GDK_KEY_braille_dots_2456 = 16787514;
pub const GDK_KEY_Georgian_in = 16781528;
pub const GDK_KEY_doubleacute = 445;
pub const _RC_DOWN = 256;
pub const GDK_KEY_uhornbelowdot = 16785137;
pub const GDK_PIXBUF_AVAILABLE_IN_2_2 = _GDK_PIXBUF_EXTERN;
pub const GDK_KEY_braille_dot_6 = 65526;
pub const GDK_KEY_Armenian_RE = 16778576;
pub const GLIB_DEPRECATED_IN_2_58 = GLIB_DEPRECATED;
pub const __analysis_assume_lock_acquired = lock;
pub const GDK_KEY_fivesubscript = 16785541;
pub const GDK_KEY_SCHWA = 16777615;
pub const GDK_KEY_Georgian_las = 16781530;
pub const GDK_KEY_V = 86;
pub const EISDIR = 21;
pub const _countof = __crt_countof;
pub const SCHAR_MAX = 127;
pub const LDBL_MIN_EXP = DBL_MIN_EXP;
pub const ECONNABORTED = 106;
pub const GDK_KEY_MenuKB = 269025125;
pub const GDK_KEY_dead_breve = 65109;
pub const GDK_KEY_Arabic_kasra = 1520;
pub const GDK_KEY_braille_dots_123567 = 16787575;
pub const GDK_KEY_NairaSign = 16785574;
pub const GDK_KEY_Mode_switch = 65406;
pub const GDK_KEY_upcaret = 2985;
pub const GDK_KEY_Finance = 269025084;
pub const GDK_KEY_braille_dots_124567 = 16787579;
pub const __clang_version__ = c"9.0.0 (tags/RELEASE_900/final)";
pub const GDK_KEY_downtack = 3010;
pub const __UINT_LEAST8_FMTo__ = c"hho";
pub const GDK_KEY_rcedilla = 947;
pub const GDK_KEY_Greek_XI = 1998;
pub const __INTMAX_FMTd__ = c"lld";
pub const GDK_KEY_Cyrillic_ER = 1778;
pub const ATK_AVAILABLE_IN_2_8 = _ATK_EXTERN;
pub const __CLANG_ATOMIC_CHAR_LOCK_FREE = 2;
pub const GDK_KEY_F11 = 65480;
pub const GDK_KEY_Cyrillic_ka_vertstroke = 16778397;
pub const _GLIB_EXTERN = @"extern";
pub const GTK_BINARY_AGE = 2412;
pub const _FPCLASS_PN = 256;
pub const GDK_KEY_Arabic_keheh = 16778921;
pub const GDK_PIXBUF_AVAILABLE_IN_2_10 = _GDK_PIXBUF_EXTERN;
pub const GDK_KEY_hebrew_taw = 3322;
pub const GDK_AVAILABLE_IN_3_12 = _GDK_EXTERN;
pub const GDK_KEY_Georgian_hie = 16781554;
pub const GDK_KEY_kana_WA = 1244;
pub const GDK_KEY_Hankaku = 65321;
pub const GDK_KEY_L6 = 65485;
pub const GDK_KEY_hebrew_doublelowline = 3295;
pub const GDK_KEY_Next_VMode = 269024802;
pub const GDK_KEY_Cyrillic_SCHWA = 16778456;
pub const GDK_KEY_braille_dots_13567 = 16787573;
pub const GDK_KEY_ninesuperior = 16785529;
pub const GDK_KEY_Cyrillic_zhe_descender = 16778391;
pub const GDK_KEY_Switch_VT_9 = 269024777;
pub const G_BYTE_ORDER = G_LITTLE_ENDIAN;
pub const _Releases_lock_ = lock;
pub const GDK_KEY_braille_dots_12467 = 16787563;
pub const UCHAR_MAX = 255;
pub const GLIB_VERSION_MIN_REQUIRED = GLIB_VERSION_CUR_STABLE;
pub const GDK_KEY_Farsi_9 = 16779001;
pub const _Requires_exclusive_lock_held_ = lock;
pub const GDK_KEY_acircumflexhook = 16785065;
pub const LDBL_MANT_DIG = DBL_MANT_DIG;
pub const GDK_KEY_3270_Enter = 64798;
pub const GDK_KEY_Launch4 = 269025092;
pub const FLT_MANT_DIG = 24;
pub const PANGO_DEPRECATED_IN_1_20 = PANGO_DEPRECATED;
pub const GDK_KEY_oacute = 243;
pub const GDK_KEY_asterisk = 42;
pub const ATK_DEPRECATED_IN_2_30 = ATK_DEPRECATED;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_START_STOP_TYPE = c"mountable::start-stop-type";
pub const _NFILE = _NSTREAM_;
pub const __SSSE3__ = 1;
pub const GDK_KEY_hebrew_finalnun = 3311;
pub const GDK_KEY_B = 66;
pub const GTK_STYLE_CLASS_IMAGE = c"image";
pub const G_MINOFFSET = G_MININT64;
pub const GDK_KEY_thorn = 254;
pub const GDK_KEY_parenright = 41;
pub const GTK_STYLE_CLASS_DND = c"dnd";
pub const G_SIGNAL_FLAGS_MASK = 511;
pub const GDK_KEY_F9 = 65478;
pub const GDK_KEY_Wacute = 16785026;
pub const GDK_KEY_sixsuperior = 16785526;
pub const GDK_KEY_Sinh_ya = 16780730;
pub const G_MAXUINT32 = if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Pointer) @ptrCast(guint32, 4294967295) else if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Int) @intToPtr(guint32, 4294967295) else guint32(4294967295);
pub const GLIB_AVAILABLE_IN_2_32 = _GLIB_EXTERN;
pub const GTK_STYLE_CLASS_ARROW = c"arrow";
pub const GDK_KEY_R2 = 65491;
pub const GDK_KEY_Shop = 269025078;
pub const ATK_VERSION_MAX_ALLOWED = ATK_VERSION_CUR_STABLE;
pub const GDK_KEY_ISO_Emphasize = 65074;
pub const GDK_KEY_dead_belowtilde = 65130;
pub const GDK_KEY_KP_Prior = 65434;
pub const __INT_FAST16_FMTi__ = c"hi";
pub const GDK_KEY_Thai_maihanakat = 3537;
pub const GDK_KEY_Sleep = 269025071;
pub const GTK_STYLE_CLASS_DOCK = c"dock";
pub const PANGO_VERSION_MIN_REQUIRED = PANGO_VERSION_CUR_STABLE;
pub const GDK_KEY_hebrew_qoph = 3319;
pub const GLIB_DEPRECATED_IN_2_28 = GLIB_DEPRECATED;
pub const GDK_KEY_Hangul_J_RieulTieut = 3808;
pub const GDK_KEY_Greek_xi = 2030;
pub const _GDK_EXTERN = @"extern";
pub const GDK_KEY_Pointer_DfltBtnPrev = 65276;
pub const GTK_STYLE_CLASS_SUGGESTED_ACTION = c"suggested-action";
pub const SIG_ERR = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(_crt_signal_t, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(_crt_signal_t, -1) else _crt_signal_t(-1);
pub const GDK_KEY_Hangul_SsangDikeud = 3752;
pub const __INT64_C_SUFFIX__ = LL;
pub const LDBL_MAX_EXP = DBL_MAX_EXP;
pub const GDK_KEY_Armenian_pe = 16778618;
pub const GDK_KEY_ClearGrab = 269024801;
pub const _EM_OVERFLOW = 4;
pub const G_GOFFSET_FORMAT = G_GINT64_FORMAT;
pub const GDK_KEY_twofifths = 2739;
pub const GDK_KEY_hebrew_shin = 3321;
pub const GDK_KEY_AudioPlay = 269025044;
pub const GTK_STYLE_CLASS_EXPANDER = c"expander";
pub const G_FILE_ATTRIBUTE_GVFS_BACKEND = c"gvfs::backend";
pub const __SIG_ATOMIC_MAX__ = 2147483647;
pub const EBADMSG = 104;
pub const GDK_KEY_Georgian_san = 16781537;
pub const GDK_KEY_agrave = 224;
pub const _Analysis_assume_lock_acquired_ = lock;
pub const __UINT64_MAX__ = c_ulonglong(18446744073709551615);
pub const PANGO_AVAILABLE_IN_1_38 = _PANGO_EXTERN;
pub const GDK_KEY_Armenian_GIM = 16778547;
pub const GDK_KEY_circle = 3023;
pub const GDK_KEY_parenleft = 40;
pub const GDK_KEY_3270_Rule = 64788;
pub const G_CSET_A_2_Z = c"ABCDEFGHIJKLMNOPQRSTUVWXYZ";
pub const GDK_KEY_uhorntilde = 16785135;
pub const GDK_KEY_AudioPause = 269025073;
pub const GDK_KEY_Cyrillic_ha = 1736;
pub const GDK_KEY_braille_dots_1456 = 16787513;
pub const SIG_IGN = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(_crt_signal_t, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(_crt_signal_t, 1) else _crt_signal_t(1);
pub const GDK_KEY_Begin = 65368;
pub const GDK_KEY_F34 = 65503;
pub const _Acquires_nonreentrant_lock_ = lock;
pub const G_HAVE_ISO_VARARGS = 1;
pub const __UINT_FAST16_FMTu__ = c"hu";
pub const cairo_transform_distance = cairo_transform_distance_REPLACED_BY_cairo_user_to_device_distance;
pub const GDK_KEY_braille_dots_4678 = 16787688;
pub const __INTPTR_FMTi__ = c"lli";
pub const GDK_KEY_hebrew_aleph = 3296;
pub const GDK_KEY_rightdoublequotemark = 2771;
pub const GDK_KEY_kana_e = 1194;
pub const GDK_KEY_braille_dots_456 = 16787512;
pub const GDK_KEY_kana_HA = 1226;
pub const GDK_KEY_braille_dots_467 = 16787560;
pub const __SEG_GS = 1;
pub const GDK_KEY_Arabic_feh = 1505;
pub const GDK_KEY_braille_dots_13678 = 16787685;
pub const GDK_KEY_elementof = 16785928;
pub const __UINT8_FMTo__ = c"hho";
pub const GDK_KEY_vertbar = 2552;
pub const GDK_KEY_Thai_maitri = 3562;
pub const GTK_PRINT_SETTINGS_NUMBER_UP = c"number-up";
pub const GTK_MAJOR_VERSION = 3;
pub const __UINT_FAST8_FMTu__ = c"hhu";
pub const G_HAVE_GROWING_STACK = 0;
pub const GDK_KEY_braille_dots_23678 = 16787686;
pub const __fallthrough = __inner_fallthrough;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_SIZE = c"filesystem::size";
pub const GDK_KEY_braille_dots_12678 = 16787683;
pub const GDK_KEY_yhook = 16785143;
pub const GDK_BUTTON_SECONDARY = 3;
pub const GDK_KEY_Sinh_ri = 16780685;
pub const __MOVBE__ = 1;
pub const G_FILE_ATTRIBUTE_STANDARD_SORT_ORDER = c"standard::sort-order";
pub const _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY = c_ulonglong(1) << 3;
pub const LDBL_TRUE_MIN = DBL_TRUE_MIN;
pub const GDK_KEY_braille_dots_16 = 16787489;
pub const GDK_KEY_ibelowdot = 16785099;
pub const GDK_KEY_Hangul_PieubSios = 3764;
pub const GDK_KEY_Abrevetilde = 16785076;
pub const GDK_KEY_Hangul_RieulPieub = 3756;
pub const TRUE = !FALSE;
pub const __UINT_LEAST8_FMTX__ = c"hhX";
pub const SIGABRT = 22;
pub const cairo_set_target_win32 = cairo_set_target_win32_DEPRECATED_BY_cairo_win32_surface_create;
pub const GDK_KEY_Armenian_PE = 16778570;
pub const GDK_KEY_Sinh_ddha = 16780714;
pub const GDK_KEY_Market = 269025122;
pub const GDK_KEY_braille_dots_34568 = 16787644;
pub const PANGO_GLYPH_EMPTY = if (@typeId(@typeOf(268435455)) == @import("builtin").TypeId.Pointer) @ptrCast(PangoGlyph, 268435455) else if (@typeId(@typeOf(268435455)) == @import("builtin").TypeId.Int) @intToPtr(PangoGlyph, 268435455) else PangoGlyph(268435455);
pub const GDK_KEY_Refresh = 269025065;
pub const G_FILE_ATTRIBUTE_STANDARD_EDIT_NAME = c"standard::edit-name";
pub const GLIB_AVAILABLE_IN_2_44 = _GLIB_EXTERN;
pub const _SW_SQRTNEG = 128;
pub const _M_AMD64 = 100;
pub const GDK_KEY_hebrew_daleth = 3299;
pub const __POINTER_WIDTH__ = 64;
pub const GTK_STOCK_ADD = if (@typeId(@typeOf(c"gtk-add")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-add") else if (@typeId(@typeOf(c"gtk-add")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-add") else GtkStock(c"gtk-add");
pub const __tune_corei7__ = 1;
pub const GTK_STYLE_CLASS_PULSE = c"pulse";
pub const GDK_KEY_KP_Page_Up = 65434;
pub const GDK_KEY_Greek_delta = 2020;
pub const __SIZEOF_LONG__ = 4;
pub const GDK_KEY_Georgian_rae = 16781536;
pub const PANGO_DEPRECATED_IN_1_30 = PANGO_DEPRECATED;
pub const __crt_typefix = ctype;
pub const PANGO_VERSION_MAX_ALLOWED = PANGO_VERSION_CUR_STABLE;
pub const GDK_KEY_abreve = 483;
pub const ATK_DEPRECATED_IN_2_6 = ATK_DEPRECATED;
pub const GDK_KEY_Armenian_hyphen = 16778634;
pub const SW_SQRTNEG = _SW_SQRTNEG;
pub const G_GOFFSET_MODIFIER = G_GINT64_MODIFIER;
pub const GDK_KEY_Cyrillic_HA = 1768;
pub const __NO_INLINE__ = 1;
pub const GDK_KEY_rightmiddlesummation = 2231;
pub const GDK_KEY_Arabic_ain = 1497;
pub const GDK_KEY_braille_dots_1367 = 16787557;
pub const GDK_KEY_View = 269025185;
pub const GDK_KEY_Thai_kokai = 3489;
pub const GDK_KEY_History = 269025079;
pub const GDK_KEY_kana_HU = 1228;
pub const GDK_KEY_braille_dots_2457 = 16787546;
pub const GDK_KEY_Ecircumflexgrave = 16785088;
pub const GDK_KEY_Thai_leknung = 3569;
pub const GDK_KEY_ModeLock = 269025025;
pub const CAIRO_MIME_TYPE_CCITT_FAX_PARAMS = c"application/x-cairo.ccitt.params";
pub const GDK_KEY_Georgian_har = 16781556;
pub const GDK_KEY_Farsi_yeh = 16778956;
pub const GDK_KEY_braille_dot_7 = 65527;
pub const GDK_KEY_hexagram = 2778;
pub const GDK_KEY_horizlinescan5 = 2545;
pub const GTK_PRINT_SETTINGS_FINISHINGS = c"finishings";
pub const GDK_KEY_Arabic_switch = 65406;
pub const _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS = c_ulonglong(1) << 2;
pub const GDK_KEY_Thai_phophan = 3518;
pub const GDK_KEY_dead_grave = 65104;
pub const EM_DENORMAL = _EM_DENORMAL;
pub const GDK_KEY_Hangul_J_PieubSios = 3813;
pub const GDK_KEY_W = 87;
pub const GDK_KEY_Cyrillic_io = 1699;
pub const EIDRM = 111;
pub const GDK_KEY_Thai_khokhai = 3490;
pub const PANGO_DEPRECATED_IN_1_2 = PANGO_DEPRECATED;
pub const SIG_ACK = if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Pointer) @ptrCast(_crt_signal_t, 4) else if (@typeId(@typeOf(4)) == @import("builtin").TypeId.Int) @intToPtr(_crt_signal_t, 4) else _crt_signal_t(4);
pub const GDK_KEY_Armenian_O = 16778581;
pub const ATK_AVAILABLE_IN_2_30 = _ATK_EXTERN;
pub const G_MINSSIZE = G_MININT64;
pub const GDK_KEY_Cyrillic_en_descender = 16778403;
pub const GDK_KEY_Arabic_seen = 1491;
pub const GDK_KEY_exclamdown = 161;
pub const ENOTSOCK = 128;
pub const GDK_KEY_kappa = 930;
pub const _SAL_nop_impl_ = X;
pub const GDK_KEY_Greek_KAPPA = 1994;
pub const GDK_KEY_SplitScreen = 269025149;
pub const GDK_KEY_Henkan = 65315;
pub const GDK_KEY_Page_Down = 65366;
pub const __DBL_MAX_10_EXP__ = 308;
pub const GDK_KEY_braille_dots_1238 = 16787591;
pub const G_VARIANT_TYPE_INT32 = if (@typeId(@typeOf(c"i")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"i") else if (@typeId(@typeOf(c"i")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"i") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"i");
pub const __PIC__ = 2;
pub const GDK_KEY_Dabovedot = 16784906;
pub const GTK_STOCK_DIALOG_AUTHENTICATION = if (@typeId(@typeOf(c"gtk-dialog-authentication")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-dialog-authentication") else if (@typeId(@typeOf(c"gtk-dialog-authentication")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-dialog-authentication") else GtkStock(c"gtk-dialog-authentication");
pub const G_MENU_ATTRIBUTE_TARGET = c"target";
pub const GDK_KEY_Hangul_SsangKiyeog = 3746;
pub const FPE_STACKUNDERFLOW = _FPE_STACKUNDERFLOW;
pub const GDK_KEY_braille_dots_68 = 16787616;
pub const CAIRO_MIME_TYPE_JBIG2_GLOBAL = c"application/x-cairo.jbig2-global";
pub const GDK_KEY_F10 = 65479;
pub const GDK_KEY_braille_dots_12457 = 16787547;
pub const DBL_MAX_10_EXP = 308;
pub const GDK_KEY_Arabic_peh = 16778878;
pub const GDK_KEY_Ecaron = 460;
pub const GLIB_DEPRECATED_TYPE_IN_2_34 = GLIB_DEPRECATED_TYPE;
pub const GDK_KEY_3270_Ident = 64787;
pub const GDK_KEY_braille_dots_678 = 16787680;
pub const G_KEY_FILE_DESKTOP_KEY_VERSION = c"Version";
pub const GDK_KEY_Sinh_luu2 = 16780787;
pub const GDK_KEY_Eisu_toggle = 65328;
pub const __has_lock_level = level;
pub const GDK_KEY_kana_MA = 1231;
pub const GDK_KEY_Ocircumflexhook = 16785108;
pub const _FPE_INEXACT = 134;
pub const G_VA_COPY = va_copy;
pub const _FPCLASS_ND = 16;
pub const G_VALUE_NOCOPY_CONTENTS = 1 << 27;
pub const GDK_KEY_Cabovedot = 709;
pub const GDK_KEY_hebrew_het = 3303;
pub const GDK_PIXBUF_AVAILABLE_IN_2_40 = _GDK_PIXBUF_EXTERN;
pub const MB_LEN_MAX = 5;
pub const GDK_KEY_L7 = 65486;
pub const GDK_KEY_Time = 269025183;
pub const GDK_KEY_Greek_iotadieresis = 1973;
pub const GDK_KEY_Ohook = 16785102;
pub const GDK_KEY_dead_greek = 65164;
pub const GLIB_DEPRECATED_MACRO_IN_2_50 = GLIB_DEPRECATED_MACRO;
pub const CAIRO_MIME_TYPE_EPS_PARAMS = c"application/x-cairo.eps.params";
pub const EDEADLK = 36;
pub const GDK_KEY_AudioPrev = 269025046;
pub const G_FILE_ATTRIBUTE_DOS_IS_MOUNTPOINT = c"dos::is-mountpoint";
pub const GDK_KEY_Farsi_6 = 16778998;
pub const G_ANALYZER_ANALYZING = 0;
pub const GDK_KEY_Pictures = 269025169;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_56 = GLIB_DEPRECATED_ENUMERATOR;
pub const GDK_KEY_Thai_maitho = 3561;
pub const GDK_KEY_Cyrillic_IO = 1715;
pub const GDK_KEY_C = 67;
pub const cairo_surface_get_filter = cairo_surface_get_filter_DEPRECATED_BY_cairo_pattern_get_filter;
pub const GDK_KEY_Wcircumflex = 16777588;
pub const _UNALIGNED = __unaligned;
pub const _Has_lock_kind_ = kind;
pub const GDK_KEY_Cyrillic_SHHA = 16778426;
pub const GDK_KEY_CH = 65186;
pub const __RETURN_POLICY_SAME = _FunctionCall;
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_WRITE = c"access::can-write";
pub const _SW_ZERODIVIDE = 8;
pub const GDK_KEY_Arabic_question_mark = 1471;
pub const GDK_KEY_braille_dots_48 = 16787592;
pub const G_GNUC_FORMAT = arg_idx;
pub const __INTMAX_C_SUFFIX__ = LL;
pub const GDK_KEY_R3 = 65492;
pub const G_FILE_ATTRIBUTE_TIME_ACCESS = c"time::access";
pub const _Post_ = _Post_impl_;
pub const __INT16_FMTd__ = c"hd";
pub const GDK_KEY_Etilde = 16785084;
pub const LONG_LONG_MIN = if (@typeId(@typeOf(-c_longlong(1))) == @import("builtin").TypeId.Pointer) @ptrCast(-__LONG_LONG_MAX__, -c_longlong(1)) else if (@typeId(@typeOf(-c_longlong(1))) == @import("builtin").TypeId.Int) @intToPtr(-__LONG_LONG_MAX__, -c_longlong(1)) else (-__LONG_LONG_MAX__)(-c_longlong(1));
pub const G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK = c"standard::is-symlink";
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 = 1;
pub const G_PROXY_RESOLVER_EXTENSION_POINT_NAME = c"gio-proxy-resolver";
pub const GDK_KEY_Linefeed = 65290;
pub const GDK_KEY_3270_Copy = 64789;
pub const G_MENU_LINK_SUBMENU = c"submenu";
pub const __INTMAX_WIDTH__ = 64;
pub const GDK_KEY_braille_dots_1267 = 16787555;
pub const GDK_KEY_braille_dots_1345 = 16787485;
pub const GDK_KEY_Greek_upsilon = 2037;
pub const GDK_KEY_uacute = 250;
pub const _Writable_bytes_impl_ = size;
pub const EAGAIN = 11;
pub const GDK_KEY_braille_dots_7 = 16787520;
pub const __INT_FAST8_FMTi__ = c"hhi";
pub const GDK_KEY_kana_MU = 1233;
pub const G_POLLFD_FORMAT = c"%#llx";
pub const G_SIGNAL_MATCH_MASK = 63;
pub const GDK_KEY_logicaland = 2270;
pub const GDK_KEY_dead_belowbreve = 65131;
pub const GDK_KEY_Udoubleacute = 475;
pub const GDK_KEY_MySites = 269025127;
pub const GDK_KEY_trademark = 2761;
pub const G_LOG_DOMAIN = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast([*c]gchar, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr([*c]gchar, 0) else ([*c]gchar)(0);
pub const GDK_KEY_Pointer_Button2 = 65258;
pub const GDK_KEY_Ukrainian_YI = 1719;
pub const GDK_KEY_Escape = 65307;
pub const CAIRO_MIME_TYPE_JBIG2 = c"application/x-cairo.jbig2";
pub const __FLT_MANT_DIG__ = 24;
pub const __requires_shared_lock_held = lock;
pub const GDK_KEY_braille_dots_457 = 16787544;
pub const GDK_KEY_Greek_UPSILONaccent = 1960;
pub const G_GSIZE_MODIFIER = c"ll";
pub const cairo_get_path_flat = cairo_get_path_flat_DEPRECATED_BY_cairo_get_path_flat;
pub const DBL_MANT_DIG = 53;
pub const G_MAXINT32 = if (@typeId(@typeOf(2147483647)) == @import("builtin").TypeId.Pointer) @ptrCast(gint32, 2147483647) else if (@typeId(@typeOf(2147483647)) == @import("builtin").TypeId.Int) @intToPtr(gint32, 2147483647) else gint32(2147483647);
pub const GLIB_DEPRECATED_IN_2_30 = GLIB_DEPRECATED;
pub const GDK_KEY_Scaron = 425;
pub const __INTPTR_FMTd__ = c"lld";
pub const GDK_KEY_Hangul_OE = 3786;
pub const GDK_KEY_Pointer_DownRight = 65255;
pub const GDK_KEY_Armenian_men = 16778612;
pub const GDK_KEY_3270_Play = 64790;
pub const GDK_KEY_Arabic_farsi_yeh = 16778956;
pub const GDK_KEY_Hangul_RieulPhieuf = 3759;
pub const _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR = c_ulonglong(1) << 1;
pub const __INT_FAST16_MAX__ = 32767;
pub const PANGO_VERSION_MINOR = 43;
pub const GDK_KEY_braille_dots_123458 = 16787615;
pub const GDK_KEY_braille_dots_3458 = 16787612;
pub const _FPE_OVERFLOW = 132;
pub const GLIB_DEPRECATED_TYPE_IN_2_48 = GLIB_DEPRECATED_TYPE;
pub const GDK_KEY_Thai_moma = 3521;
pub const GTK_STYLE_PROVIDER_PRIORITY_APPLICATION = 600;
pub const GDK_KEY_MouseKeys_Accel_Enable = 65143;
pub const GDK_KEY_ff = 2531;
pub const INT_MIN = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-2147483647, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-2147483647, -1) else (-2147483647)(-1);
pub const GDK_KEY_leftmiddlecurlybrace = 2223;
pub const GDK_KEY_braille_dots_23468 = 16787630;
pub const GDK_KEY_braille_dots_17 = 16787521;
pub const __analysis_suppress_lock_checking = lock;
pub const GDK_KEY_radical = 2262;
pub const GDK_KEY_semivoicedsound = 1247;
pub const G_VARIANT_TYPE_UINT32 = if (@typeId(@typeOf(c"u")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"u") else if (@typeId(@typeOf(c"u")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"u") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"u");
pub const GDK_KEY_Super_L = 65515;
pub const GDK_KEY_ydiaeresis = 255;
pub const GDK_DEPRECATED_IN_3_6 = GDK_DEPRECATED;
pub const GDK_KEY_Cyrillic_dzhe = 1711;
pub const __FLT_DENORM_MIN__ = 0.000000;
pub const cairo_current_font_extents = cairo_current_font_extents_REPLACED_BY_cairo_font_extents;
pub const EDESTADDRREQ = 109;
pub const cairo_xlib_surface_create_for_pixmap_with_visual = cairo_xlib_surface_create_for_pixmap_with_visual_REPLACED_BY_cairo_xlib_surface_create;
pub const __LDBL_HAS_QUIET_NAN__ = 1;
pub const TMP_MAX = _CRT_INT_MAX;
pub const _FPE_STACKUNDERFLOW = 139;
pub const GDK_KEY_Alt_R = 65514;
pub const GDK_KEY_3270_Duplicate = 64769;
pub const GDK_KEY_braille_dots_234678 = 16787694;
pub const GDK_KEY_Ydiaeresis = 5054;
pub const GDK_KEY_kana_KU = 1208;
pub const ENOENT = 2;
pub const GDK_KEY_braille_dots_258 = 16787602;
pub const __UINT16_FMTu__ = c"hu";
pub const _EM_ZERODIVIDE = 8;
pub const _NLSCMPERROR = _CRT_INT_MAX;
pub const _DBL_ROUNDS = FLT_ROUNDS;
pub const GDK_KEY_Ukrainian_yi = 1703;
pub const __LDBL_MIN_EXP__ = -1021;
pub const SIZE_MAX = _UI64_MAX;
pub const FLT_TRUE_MIN = 0.000000;
pub const GDK_PARENT_RELATIVE = c_long(1);
pub const GDK_AVAILABLE_IN_3_6 = _GDK_EXTERN;
pub const __clang_patchlevel__ = 0;
pub const ESPIPE = 29;
pub const RC_NEAR = _RC_NEAR;
pub const GDK_KEY_braille_dots_13478 = 16787661;
pub const GDK_KEY_Cacute = 454;
pub const GDK_KEY_ohornhook = 16785119;
pub const GDK_KEY_braille_dots_3478 = 16787660;
pub const GTK_STYLE_PROPERTY_BORDER_WIDTH = c"border-width";
pub const GDK_KEY_Hangul_J_Tieut = 3820;
pub const GDK_KEY_ycircumflex = 16777591;
pub const G_VARIANT_TYPE_ARRAY = if (@typeId(@typeOf(c"a*")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"a*") else if (@typeId(@typeOf(c"a*")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"a*") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"a*");
pub const GDK_KEY_braille_dots_367 = 16787556;
pub const FLT_MAX = 340282346600000016151267322115014000640.000000;
pub const GDK_PIXBUF_AVAILABLE_IN_2_0 = _GDK_PIXBUF_EXTERN;
pub const GDK_KEY_braille_dot_4 = 65524;
pub const G_FILE_ATTRIBUTE_TIME_MODIFIED = c"time::modified";
pub const GTK_PRINT_SETTINGS_QUALITY = c"quality";
pub const __writableTo = size;
pub const GDK_KEY_Armenian_yentamna = 16778634;
pub const GDK_KEY_h = 104;
pub const GDK_KEY_Sinh_ha = 16780740;
pub const G_VARIANT_TYPE_DICTIONARY = if (@typeId(@typeOf(c"a{?*}")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"a{?*}") else if (@typeId(@typeOf(c"a{?*}")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"a{?*}") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"a{?*}");
pub const GDK_KEY_Georgian_zhar = 16781535;
pub const GLIB_DEPRECATED_TYPE_IN_2_26 = GLIB_DEPRECATED_TYPE;
pub const _SECURECRT_FILL_BUFFER_PATTERN = 254;
pub const GDK_KEY_onesubscript = 16785537;
pub const GTK_STOCK_MEDIA_STOP = if (@typeId(@typeOf(c"gtk-media-stop")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-media-stop") else if (@typeId(@typeOf(c"gtk-media-stop")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-media-stop") else GtkStock(c"gtk-media-stop");
pub const GDK_KEY_plusminus = 177;
pub const __UINTMAX_FMTx__ = c"llx";
pub const GDK_KEY_Greek_BETA = 1986;
pub const GDK_KEY_Armenian_se = 16778621;
pub const GDK_KEY_braille_dots_238 = 16787590;
pub const GDK_KEY_Sinh_la = 16780733;
pub const GDK_KEY_ncaron = 498;
pub const __INT_LEAST16_MAX__ = 32767;
pub const GDK_KEY_Thai_thonangmontho = 3505;
pub const __UINT32_FMTo__ = c"o";
pub const GDK_KEY_Cyrillic_ya = 1745;
pub const _IONBF = 4;
pub const GDK_KEY_kana_fullstop = 1185;
pub const GDK_KEY_F13 = 65482;
pub const GDK_KEY_braille_dots_12456 = 16787515;
pub const GDK_DEPRECATED_IN_3_18 = GDK_DEPRECATED;
pub const G_FILE_ATTRIBUTE_STANDARD_CONTENT_TYPE = c"standard::content-type";
pub const GDK_KEY_braille_dots_123 = 16787463;
pub const GDK_KEY_braille_dots_14578 = 16787673;
pub const _MCW_RC = 768;
pub const GDK_KEY_Overlay2_Enable = 65145;
pub const PANGO_SCALE_X_SMALL = if (@typeId(@typeOf(0.644444)) == @import("builtin").TypeId.Pointer) @ptrCast(double, 0.644444) else if (@typeId(@typeOf(0.644444)) == @import("builtin").TypeId.Int) @intToPtr(double, 0.644444) else double(0.644444);
pub const GDK_KEY_kana_KA = 1206;
pub const GDK_KEY_fiveeighths = 2757;
pub const GDK_KEY_ISO_Level2_Latch = 65026;
pub const GTK_STOCK_HELP = if (@typeId(@typeOf(c"gtk-help")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-help") else if (@typeId(@typeOf(c"gtk-help")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-help") else GtkStock(c"gtk-help");
pub const G_ALLOC_AND_FREE = 2;
pub const GDK_PIXBUF_AVAILABLE_IN_2_12 = _GDK_PIXBUF_EXTERN;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_44 = GLIB_DEPRECATED_ENUMERATOR;
pub const GDK_KEY_dead_belowring = 65127;
pub const GDK_KEY_leftsinglequotemark = 2768;
pub const GDK_KEY_toprightparens = 2221;
pub const MCW_EM = _MCW_EM;
pub const GDK_KEY_semicolon = 59;
pub const _Writable_elements_impl_ = size;
pub const G_MENU_ATTRIBUTE_ACTION = c"action";
pub const __amd64 = 1;
pub const __OBJC_BOOL_IS_BOOL = 0;
pub const G_FILE_ATTRIBUTE_UNIX_DEVICE = c"unix::device";
pub const GDK_KEY_Hangul_YI = 3794;
pub const GDK_KEY_Farsi_7 = 16778999;
pub const GDK_KEY_udiaeresis = 252;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_60 = GLIB_DEPRECATED_ENUMERATOR;
pub const GDK_KEY_Umacron = 990;
pub const GDK_KEY_ISO_Set_Margin_Right = 65064;
pub const GDK_KEY_Armenian_VYUN = 16778578;
pub const GDK_KEY_Arabic_1 = 16778849;
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_READ = c"access::can-read";
pub const PANGO_DEPRECATED_IN_1_22 = PANGO_DEPRECATED;
pub const _Analysis_assume_lock_held_ = lock;
pub const G_MAXULONG = ULONG_MAX;
pub const GDK_KEY_cuberoot = 16785947;
pub const GDK_KEY_uhorngrave = 16785131;
pub const GDK_KEY_D = 68;
pub const GDK_KEY_Armenian_exclam = 16778588;
pub const GTK_MAX_COMPOSE_LEN = 7;
pub const __SSE4_1__ = 1;
pub const ENOMEM = 12;
pub const GDK_KEY_jcircumflex = 700;
pub const GDK_KEY_Yhook = 16785142;
pub const GDK_KEY_Thai_thophuthao = 3506;
pub const G_MINDOUBLE = DBL_MIN;
pub const GTK_STOCK_MEDIA_RECORD = if (@typeId(@typeOf(c"gtk-media-record")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-media-record") else if (@typeId(@typeOf(c"gtk-media-record")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-media-record") else GtkStock(c"gtk-media-record");
pub const GTK_STOCK_GOTO_TOP = if (@typeId(@typeOf(c"gtk-goto-top")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-goto-top") else if (@typeId(@typeOf(c"gtk-goto-top")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-goto-top") else GtkStock(c"gtk-goto-top");
pub const GDK_KEY_Armenian_BEN = 16778546;
pub const GDK_KEY_braille_dots_178 = 16787649;
pub const CAIRO_HAS_SCRIPT_SURFACE = 1;
pub const GLIB_AVAILABLE_IN_2_30 = _GLIB_EXTERN;
pub const G_FILE_ATTRIBUTE_STANDARD_SYMBOLIC_ICON = c"standard::symbolic-icon";
pub const G_GINTPTR_FORMAT = c"lli";
pub const GDK_KEY_TouchpadOn = 269025200;
pub const _Ret1_impl_ = p1;
pub const GDK_KEY_Hstroke = 673;
pub const GDK_KEY_twothirds = 2737;
pub const GDK_KEY_fourthroot = 16785948;
pub const GDK_KEY_Armenian_SE = 16778573;
pub const GDK_KEY_Sinh_ee = 16780690;
pub const GDK_KEY_KP_Right = 65432;
pub const GDK_KEY_Armenian_lyun = 16778604;
pub const GDK_KEY_Cyrillic_KA = 1771;
pub const GDK_KEY_ISO_Level5_Lock = 65043;
pub const DBL_HAS_SUBNORM = 1;
pub const ENOLCK = 39;
pub const SIG_DFL = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(_crt_signal_t, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(_crt_signal_t, 0) else _crt_signal_t(0);
pub const GDK_KEY_nl = 2536;
pub const GDK_KEY_Greek_lamda = 2027;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_FREE = c"filesystem::free";
pub const GDK_KEY_braille_dots_6 = 16787488;
pub const _M_X64 = 100;
pub const __OPENCL_MEMORY_SCOPE_WORK_ITEM = 0;
pub const GDK_KEY_Serbian_TSHE = 1723;
pub const __DECIMAL_DIG__ = __LDBL_DECIMAL_DIG__;
pub const GDK_KEY_Armenian_TSA = 16778558;
pub const __INT32_FMTi__ = c"i";
pub const GDK_KEY_AudioRaiseVolume = 269025043;
pub const __DBL_HAS_INFINITY__ = 1;
pub const GDK_KEY_Pointer_Button3 = 65259;
pub const G_VARIANT_TYPE_BYTESTRING_ARRAY = if (@typeId(@typeOf(c"aay")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"aay") else if (@typeId(@typeOf(c"aay")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"aay") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"aay");
pub const __precond = expr;
pub const G_FILE_ATTRIBUTE_TRASH_DELETION_DATE = c"trash::deletion-date";
pub const GDK_KEY_Thai_topatak = 3503;
pub const G_MAXUINT16 = if (@typeId(@typeOf(65535)) == @import("builtin").TypeId.Pointer) @ptrCast(guint16, 65535) else if (@typeId(@typeOf(65535)) == @import("builtin").TypeId.Int) @intToPtr(guint16, 65535) else guint16(65535);
pub const _MAX_ENV = 32767;
pub const GDK_KEY_Hangul_YU = 3792;
pub const GDK_KEY_Arabic_heh = 1511;
pub const GDK_KEY_hebrew_chet = 3303;
pub const GDK_KEY_Ccircumflex = 710;
pub const GDK_KEY_braille_dots_158 = 16787601;
pub const GDK_KEY_KP_4 = 65460;
pub const GDK_KEY_dabovedot = 16784907;
pub const GDK_KEY_Greek_iotaaccentdieresis = 1974;
pub const GDK_KEY_braille_dots_2368 = 16787622;
pub const PANGO_AVAILABLE_IN_1_10 = _PANGO_EXTERN;
pub const _DBL_RADIX = 2;
pub const cairo_scale_font = cairo_scale_font_REPLACED_BY_cairo_set_font_size;
pub const CAIRO_HAS_WIN32_SURFACE = 1;
pub const GDK_KEY_ISO_Fast_Cursor_Left = 65068;
pub const GDK_KEY_kana_TE = 1219;
pub const GDK_KEY_Copy = 269025111;
pub const GDK_KEY_Ohorntilde = 16785120;
pub const ECONNREFUSED = 107;
pub const GDK_KEY_Ukrainian_GHE_WITH_UPTURN = 1725;
pub const GDK_KEY_0 = 48;
pub const GDK_KEY_3270_CursorSelect = 64796;
pub const GDK_KEY_Armenian_re = 16778624;
pub const GTK_PRINT_SETTINGS_PRINTER = c"printer";
pub const GDK_KEY_Greek_psi = 2040;
pub const GDK_KEY_Hangul_J_RieulHieuh = 3810;
pub const GDK_BUTTON_PRIMARY = 1;
pub const GDK_KEY_onesuperior = 185;
pub const GDK_KEY_Blue = 269025190;
pub const G_SQRT2 = 1.414214;
pub const GLIB_SYSDEF_AF_UNIX = 1;
pub const GDK_KEY_Armenian_e = 16778599;
pub const GDK_KEY_braille_dots_14 = 16787465;
pub const GDK_KEY_Hangul_SunkyeongeumPieub = 3825;
pub const DBL_DECIMAL_DIG = 17;
pub const GDK_KEY_Greek_iota = 2025;
pub const GDK_KEY_ScrollUp = 269025144;
pub const GDK_KEY_amacron = 992;
pub const cairo_set_target_xcb = cairo_set_target_xcb_DEPRECATED_BY_cairo_xcb_surface_create;
pub const GTK_STYLE_REGION_TAB = c"tab";
pub const G_CSET_a_2_z = c"abcdefghijklmnopqrstuvwxyz";
pub const GDK_KEY_zabovedot = 447;
pub const GDK_KEY_Sinh_o2 = 16780764;
pub const GDK_KEY_paragraph = 182;
pub const GDK_KEY_ISO_Continuous_Underline = 65072;
pub const G_TYPE_RESERVED_GLIB_FIRST = 22;
pub const _WRITE_ABORT_MSG = 1;
pub const PC_24 = _PC_24;
pub const GDK_KEY_Sinh_luu = 16780688;
pub const GDK_KEY_botvertsummationconnector = 2228;
pub const GTK_PRINT_SETTINGS_USE_COLOR = c"use-color";
pub const EM_OVERFLOW = _EM_OVERFLOW;
pub const GDK_PIXBUF_AVAILABLE_IN_2_28 = _GDK_PIXBUF_EXTERN;
pub const GDK_KEY_Sinh_bha = 16780727;
pub const GDK_KEY_apostrophe = 39;
pub const __ATOMIC_RELAXED = 0;
pub const ATK_DEPRECATED_IN_2_14 = ATK_DEPRECATED;
pub const _DN_SAVE_OPERANDS_FLUSH_RESULTS = 50331648;
pub const GTK_STYLE_CLASS_SCALE = c"scale";
pub const GDK_KEY_braille_dots_357 = 16787540;
pub const GDK_KEY_Armenian_HO = 16778560;
pub const __UINT_FAST16_MAX__ = 65535;
pub const ATK_DEPRECATED_IN_2_4 = ATK_DEPRECATED;
pub const GDK_KEY_3270_PA1 = 64778;
pub const GDK_KEY_Thai_khokhon = 3493;
pub const GTK_STOCK_CONNECT = if (@typeId(@typeOf(c"gtk-connect")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-connect") else if (@typeId(@typeOf(c"gtk-connect")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-connect") else GtkStock(c"gtk-connect");
pub const GDK_KEY_braille_dots_1234578 = 16787679;
pub const GDK_KEY_abrevetilde = 16785077;
pub const GDK_KEY_ISO_Prev_Group_Lock = 65035;
pub const GDK_KEY_Sinh_pa = 16780724;
pub const GDK_KEY_therefore = 2240;
pub const GTK_STOCK_ORIENTATION_REVERSE_PORTRAIT = if (@typeId(@typeOf(c"gtk-orientation-reverse-portrait")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-orientation-reverse-portrait") else if (@typeId(@typeOf(c"gtk-orientation-reverse-portrait")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-orientation-reverse-portrait") else GtkStock(c"gtk-orientation-reverse-portrait");
pub const GDK_KEY_CycleAngle = 269025180;
pub const _PC_64 = 0;
pub const __STDC_HOSTED__ = 1;
pub const EADDRINUSE = 100;
pub const GDK_KEY_fivesuperior = 16785525;
pub const GDK_KEY_hebrew_finalmem = 3309;
pub const cairo_default_matrix = cairo_default_matrix_REPLACED_BY_cairo_identity_matrix;
pub const __INT_LEAST32_TYPE__ = int;
pub const ENOTSUP = 129;
pub const GDK_KEY_Arabic_fathatan = 1515;
pub const G_SOURCE_REMOVE = FALSE;
pub const PANGO_DEPRECATED_IN_1_18 = PANGO_DEPRECATED;
pub const GDK_KEY_braille_dot_5 = 65525;
pub const G_FILE_ATTRIBUTE_THUMBNAIL_PATH = c"thumbnail::path";
pub const GDK_KEY_Greek_NU = 1997;
pub const GDK_KEY_horizlinescan7 = 2546;
pub const GDK_KEY_Sinh_fa = 16780742;
pub const GDK_KEY_stricteq = 16786019;
pub const GDK_KEY_Ocircumflex = 212;
pub const GDK_KEY_Hangul_Phieuf = 3773;
pub const GDK_KEY_Greek_omicron = 2031;
pub const GDK_KEY_ninesubscript = 16785545;
pub const GDK_KEY_i = 105;
pub const GDK_KEY_braille_dots_1568 = 16787633;
pub const PANGO_DEPRECATED_IN_1_4 = PANGO_DEPRECATED;
pub const cairo_set_rgb_color = cairo_set_rgb_color_REPLACED_BY_cairo_set_source_rgb;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_UNMOUNT = c"mountable::can-unmount";
pub const __CLANG_ATOMIC_INT_LOCK_FREE = 2;
pub const GDK_KEY_hebrew_he = 3300;
pub const GDK_KEY_Arabic_tah = 1495;
pub const GDK_KEY_braille_dots_348 = 16787596;
pub const SW_UNDERFLOW = _SW_UNDERFLOW;
pub const GDK_KEY_leftarrow = 2299;
pub const GTK_STYLE_CLASS_SLIDER = c"slider";
pub const GDK_KEY_Sinh_ja = 16780706;
pub const GTK_STOCK_INFO = if (@typeId(@typeOf(c"gtk-info")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-info") else if (@typeId(@typeOf(c"gtk-info")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-info") else GtkStock(c"gtk-info");
pub const GDK_KEY_acircumflex = 226;
pub const G_KEY_FILE_DESKTOP_KEY_NO_DISPLAY = c"NoDisplay";
pub const GDK_KEY_dead_currency = 65135;
pub const GDK_KEY_Greek_upsilonaccent = 1976;
pub const CAIRO_HAS_PS_SURFACE = 1;
pub const GDK_KEY_blank = 2527;
pub const SHRT_MAX = 32767;
pub const GTK_STYLE_PROVIDER_PRIORITY_SETTINGS = 400;
pub const status87 = _status87;
pub const GTK_STYLE_CLASS_SEPARATOR = c"separator";
pub const __inner_typefix = ctype;
pub const G_ALLOCATOR_NODE = 3;
pub const GDK_KEY_F12 = 65481;
pub const GDK_KEY_Greek_epsilonaccent = 1970;
pub const GDK_KEY_braille_dots_124 = 16787467;
pub const GDK_KEY_Cyrillic_YU = 1760;
pub const GDK_KEY_KbdBrightnessDown = 269025030;
pub const GLIB_DEPRECATED_TYPE_IN_2_36 = GLIB_DEPRECATED_TYPE;
pub const FPE_INEXACT = _FPE_INEXACT;
pub const GDK_KEY_braille_dots_234568 = 16787646;
pub const GTK_LEVEL_BAR_OFFSET_LOW = c"low";
pub const WEOF = if (@typeId(@typeOf(65535)) == @import("builtin").TypeId.Pointer) @ptrCast(wint_t, 65535) else if (@typeId(@typeOf(65535)) == @import("builtin").TypeId.Int) @intToPtr(wint_t, 65535) else wint_t(65535);
pub const G_FILE_ATTRIBUTE_UNIX_BLOCKS = c"unix::blocks";
pub const EHOSTUNREACH = 110;
pub const GDK_KEY_Imacron = 975;
pub const GDK_KEY_Cyrillic_SHCHA = 1789;
pub const GTK_STOCK_UNDO = if (@typeId(@typeOf(c"gtk-undo")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-undo") else if (@typeId(@typeOf(c"gtk-undo")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-undo") else GtkStock(c"gtk-undo");
pub const GDK_KEY_L1 = 65480;
pub const GDK_KEY_bar = 124;
pub const GDK_KEY_variation = 2241;
pub const SW_UNEMULATED = _SW_UNEMULATED;
pub const GDK_KEY_braille_dots_2345678 = 16787710;
pub const GDK_KEY_LaunchC = 269025100;
pub const ENOTEMPTY = 41;
pub const onexit_t = _onexit_t;
pub const GTK_STOCK_DND_MULTIPLE = if (@typeId(@typeOf(c"gtk-dnd-multiple")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-dnd-multiple") else if (@typeId(@typeOf(c"gtk-dnd-multiple")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-dnd-multiple") else GtkStock(c"gtk-dnd-multiple");
pub const GDK_KEY_Farsi_4 = 16778996;
pub const cairo_matrix_set_affine = cairo_matrix_set_affine_REPLACED_BY_cairo_matrix_init;
pub const PANGO_GLYPH_UNKNOWN_FLAG = if (@typeId(@typeOf(268435456)) == @import("builtin").TypeId.Pointer) @ptrCast(PangoGlyph, 268435456) else if (@typeId(@typeOf(268435456)) == @import("builtin").TypeId.Int) @intToPtr(PangoGlyph, 268435456) else PangoGlyph(268435456);
pub const GDK_KEY_AudioCycleTrack = 269025179;
pub const GDK_KEY_Sinh_rii = 16780686;
pub const __FLT_DIG__ = 6;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_50 = GLIB_DEPRECATED_ENUMERATOR;
pub const G_VARIANT_TYPE_BYTESTRING = if (@typeId(@typeOf(c"ay")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"ay") else if (@typeId(@typeOf(c"ay")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"ay") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"ay");
pub const EMLINK = 31;
pub const GDK_KEY_Arabic_0 = 16778848;
pub const GDK_KEY_Cyrillic_a = 1729;
pub const GDK_KEY_braille_dots_2567 = 16787570;
pub const GDK_KEY_braille_dots_3568 = 16787636;
pub const __UINT_LEAST16_FMTu__ = c"hu";
pub const G_VARIANT_TYPE_INT16 = if (@typeId(@typeOf(c"n")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"n") else if (@typeId(@typeOf(c"n")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"n") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"n");
pub const GDK_KEY_Ograve = 210;
pub const GDK_KEY_Hangul_Rieul = 3753;
pub const GDK_KEY_Armenian_ZHE = 16778554;
pub const GDK_KEY_E = 69;
pub const GDK_KEY_braille_dots_1356 = 16787509;
pub const GDK_KEY_Thai_choching = 3497;
pub const GTK_STYLE_CLASS_SCROLLBARS_JUNCTION = c"scrollbars-junction";
pub const GDK_KEY_idiaeresis = 239;
pub const GDK_KEY_periodcentered = 183;
pub const G_DRIVE_IDENTIFIER_KIND_UNIX_DEVICE = c"unix-device";
pub const GDK_KEY_R1 = 65490;
pub const cairo_current_target_surface = cairo_current_target_surface_REPLACED_BY_cairo_get_target;
pub const GTK_STYLE_CLASS_SIDEBAR = c"sidebar";
pub const GDK_KEY_latincross = 2777;
pub const __UINT_FAST32_FMTX__ = c"X";
pub const _SYS_OPEN = 20;
pub const GDK_KEY_Greek_TAU = 2004;
pub const __corei7__ = 1;
pub const GDK_KEY_Cyrillic_shorti = 1738;
pub const GDK_KEY_uogonek = 1017;
pub const GDK_KEY_Uacute = 218;
pub const GDK_KEY_braille_dots_1347 = 16787533;
pub const GDK_KEY_PowerOff = 269025066;
pub const GDK_KEY_topleftradical = 2210;
pub const GDK_KEY_emfilledrect = 2783;
pub const GDK_KEY_ENG = 957;
pub const GDK_KEY_emopencircle = 2766;
pub const GDK_KEY_braille_dots_5 = 16787472;
pub const GDK_KEY_Cyrillic_ha_descender = 16778419;
pub const GDK_KEY_Georgian_en = 16781524;
pub const __INT32_TYPE__ = int;
pub const GDK_KEY_Armenian_NU = 16778566;
pub const FLT_MIN = 0.000000;
pub const GDK_KEY_L10 = 65489;
pub const GDK_KEY_Georgian_char = 16781549;
pub const GDK_KEY_Cyrillic_pe = 1744;
pub const GLIB_DEPRECATED_IN_2_32 = GLIB_DEPRECATED;
pub const GDK_KEY_KP_5 = 65461;
pub const GDK_KEY_space = 32;
pub const GDK_KEY_kana_RE = 1242;
pub const GDK_KEY_Cyrillic_u = 1749;
pub const GDK_KEY_Uhornacute = 16785128;
pub const __INT_LEAST8_FMTd__ = c"hhd";
pub const __GOT_SECURE_LIB__ = __STDC_SECURE_LIB__;
pub const _MSC_BUILD = 1;
pub const GDK_KEY_Ecircumflexbelowdot = 16785094;
pub const PANGO_AVAILABLE_IN_1_20 = _PANGO_EXTERN;
pub const GDK_KEY_1 = 49;
pub const GDK_KEY_Cyrillic_ka_descender = 16778395;
pub const GDK_KEY_KP_Begin = 65437;
pub const GDK_KEY_Pointer_DblClick1 = 65263;
pub const G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER = c"1.3.6.1.5.5.7.3.1";
pub const _MAX_EXT = 256;
pub const GDK_KEY_braille_dots_2345 = 16787486;
pub const GDK_KEY_dead_diaeresis = 65111;
pub const GDK_KEY_Thai_fofan = 3519;
pub const _SW_OVERFLOW = 4;
pub const GDK_KEY_Odoubleacute = 469;
pub const GDK_KEY_braille_dots_15 = 16787473;
pub const GDK_KEY_Sinh_a = 16780677;
pub const GDK_KEY_Meeting = 269025123;
pub const __DBL_EPSILON__ = 0.000000;
pub const GDK_KEY_hebrew_ayin = 3314;
pub const GDK_KEY_ezh = 16777874;
pub const GDK_KEY_topintegral = 2212;
pub const GDK_KEY_F28 = 65497;
pub const ENOLINK = 121;
pub const GDK_KEY_kana_NE = 1224;
pub const GDK_KEY_Hangul_E = 3780;
pub const __INT16_FMTi__ = c"hi";
pub const G_DIR_SEPARATOR = 92;
pub const GDK_KEY_dead_U = 65161;
pub const G_GSSIZE_MODIFIER = c"ll";
pub const EILSEQ = 42;
pub const __UINT_FAST32_MAX__ = c_uint(4294967295);
pub const GDK_KEY_braille_dots_356 = 16787508;
pub const GDK_KEY_braille_dots_256 = 16787506;
pub const GDK_KEY_seveneighths = 2758;
pub const GDK_KEY_kana_yo = 1198;
pub const GDK_KEY_braille_dots_123467 = 16787567;
pub const _SW_UNEMULATED = 64;
pub const GDK_KEY_3270_PA2 = 64779;
pub const GDK_KEY_asciicircum = 94;
pub const GDK_KEY_Georgian_jil = 16781547;
pub const GTK_STYLE_PROPERTY_PADDING = c"padding";
pub const DBL_MIN = 0.000000;
pub const CLOCKS_PER_SEC = if (@typeId(@typeOf(1000)) == @import("builtin").TypeId.Pointer) @ptrCast(clock_t, 1000) else if (@typeId(@typeOf(1000)) == @import("builtin").TypeId.Int) @intToPtr(clock_t, 1000) else clock_t(1000);
pub const GDK_KEY_lbelowdot = 16784951;
pub const GDK_AVAILABLE_IN_3_4 = _GDK_EXTERN;
pub const GLIB_SIZEOF_SSIZE_T = 8;
pub const GTK_STOCK_INDEX = if (@typeId(@typeOf(c"gtk-index")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-index") else if (@typeId(@typeOf(c"gtk-index")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-index") else GtkStock(c"gtk-index");
pub const GLIB_DEPRECATED_MACRO_IN_2_28 = GLIB_DEPRECATED_MACRO;
pub const GDK_KEY_dead_small_schwa = 65162;
pub const _DN_FLUSH = 16777216;
pub const _Write_guarded_by_ = lock;
pub const GDK_KEY_LiraSign = 16785572;
pub const __releases_exclusive_lock = lock;
pub const GDK_KEY_PreviousCandidate = 65342;
pub const GDK_KEY_Tools = 269025153;
pub const GDK_PIXBUF_AVAILABLE_IN_2_6 = _GDK_PIXBUF_EXTERN;
pub const GDK_KEY_braille_dot_2 = 65522;
pub const GDK_KEY_Armenian_RA = 16778572;
pub const GDK_KEY_Cyrillic_I = 1769;
pub const G_MININT = INT_MIN;
pub const G_FILE_ATTRIBUTE_UNIX_INODE = c"unix::inode";
pub const GDK_KEY_Thai_nonu = 3513;
pub const __UINT32_C_SUFFIX__ = U;
pub const GDK_KEY_Greek_switch = 65406;
pub const SW_STACKOVERFLOW = _SW_STACKOVERFLOW;
pub const LONG_LONG_MAX = __LONG_LONG_MAX__;
pub const GDK_KEY_Thai_saraa = 3536;
pub const _MCW_DN = 50331648;
pub const GDK_KEY_Egrave = 200;
pub const GTK_STOCK_FIND_AND_REPLACE = if (@typeId(@typeOf(c"gtk-find-and-replace")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-find-and-replace") else if (@typeId(@typeOf(c"gtk-find-and-replace")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-find-and-replace") else GtkStock(c"gtk-find-and-replace");
pub const GDK_KEY_j = 106;
pub const GDK_KEY_Macedonia_KJE = 1724;
pub const GDK_KEY_kana_switch = 65406;
pub const GDK_KEY_braille_dots_13467 = 16787565;
pub const GDK_KEY_ecircumflexgrave = 16785089;
pub const GDK_KEY_braille_dots_12567 = 16787571;
pub const __STDC_UTF_16__ = 1;
pub const __UINTMAX_C_SUFFIX__ = ULL;
pub const _ACRTIMP_ALT = _ACRTIMP;
pub const GDK_KEY_Cyrillic_em = 1741;
pub const GDK_KEY_imacron = 1007;
pub const GDK_KEY_Serbian_tshe = 1707;
pub const GDK_KEY_Hangul_Codeinput = 65335;
pub const GDK_KEY_Abreve = 451;
pub const GDK_KEY_F15 = 65484;
pub const GDK_KEY_Greek_tau = 2036;
pub const GDK_KEY_dead_A = 65153;
pub const GDK_KEY_braille_dots_125 = 16787475;
pub const GDK_KEY_Greek_IOTAaccent = 1956;
pub const G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET = c"standard::symlink-target";
pub const GLIB_DEPRECATED_MACRO_IN_2_48 = GLIB_DEPRECATED_MACRO;
pub const GDK_KEY_doubledagger = 2802;
pub const PANGO_AVAILABLE_IN_ALL = _PANGO_EXTERN;
pub const GDK_KEY_dead_psili = 65124;
pub const GDK_PIXBUF_AVAILABLE_IN_2_14 = _GDK_PIXBUF_EXTERN;
pub const GDK_KEY_enfilledcircbullet = 2790;
pub const GDK_KEY_Shift_R = 65506;
pub const GDK_KEY_Ucircumflex = 219;
pub const __BYTE_ORDER__ = __ORDER_LITTLE_ENDIAN__;
pub const GTK_STOCK_FLOPPY = if (@typeId(@typeOf(c"gtk-floppy")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-floppy") else if (@typeId(@typeOf(c"gtk-floppy")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-floppy") else GtkStock(c"gtk-floppy");
pub const GDK_KEY_L2 = 65481;
pub const G_VARIANT_TYPE_ANY = if (@typeId(@typeOf(c"*")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"*") else if (@typeId(@typeOf(c"*")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"*") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"*");
pub const GDK_KEY_Macedonia_dse = 1701;
pub const GDK_KEY_Thai_lekchet = 3575;
pub const GDK_KEY_ohorn = 16777633;
pub const ENETUNREACH = 118;
pub const GDK_KEY_braille_dots_14567 = 16787577;
pub const _SA_annotes0 = n;
pub const GDK_KEY_ebelowdot = 16785081;
pub const GDK_KEY_LaunchB = 269025099;
pub const GDK_KEY_ccaron = 488;
pub const GDK_KEY_Farsi_5 = 16778997;
pub const GDK_KEY_braille_dots_167 = 16787553;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_62 = GLIB_DEPRECATED_ENUMERATOR;
pub const GDK_KEY_WakeUp = 269025067;
pub const GTK_STOCK_MISSING_IMAGE = if (@typeId(@typeOf(c"gtk-missing-image")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-missing-image") else if (@typeId(@typeOf(c"gtk-missing-image")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-missing-image") else GtkStock(c"gtk-missing-image");
pub const GDK_KEY_Thai_rorua = 3523;
pub const GDK_KEY_Kanji_Bangou = 65335;
pub const GDK_KEY_Arabic_3 = 16778851;
pub const PANGO_DEPRECATED_IN_1_24 = PANGO_DEPRECATED;
pub const GDK_KEY_Henkan_Mode = 65315;
pub const GDK_KEY_tcaron = 443;
pub const GDK_KEY_Cyrillic_GHE = 1767;
pub const G_PARAM_MASK = 255;
pub const G_VARIANT_TYPE_OBJECT_PATH = if (@typeId(@typeOf(c"o")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"o") else if (@typeId(@typeOf(c"o")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"o") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"o");
pub const GDK_KEY_F = 70;
pub const GDK_KEY_tcedilla = 510;
pub const GDK_KEY_Sabovedot = 16784992;
pub const GDK_KEY_braille_dots_1357 = 16787541;
pub const GDK_KEY_braille_dots_13578 = 16787669;
pub const GDK_KEY_leftshoe = 3034;
pub const GLIB_DEPRECATED_MACRO_IN_2_62 = GLIB_DEPRECATED_MACRO;
pub const GDK_KEY_hebrew_bet = 3297;
pub const GLIB_AVAILABLE_IN_2_36 = _GLIB_EXTERN;
pub const GDK_KEY_section = 167;
pub const GDK_KEY_emacron = 954;
pub const GDK_KEY_dead_doubleacute = 65113;
pub const GDK_KEY_ISO_Release_Margin_Left = 65065;
pub const G_KEY_FILE_DESKTOP_KEY_ICON = c"Icon";
pub const G_PI_4 = 0.785398;
pub const __STDC_SECURE_LIB__ = c_long(200411);
pub const GDK_KEY_ucircumflex = 251;
pub const SW_OVERFLOW = _SW_OVERFLOW;
pub const GDK_KEY_grave = 96;
pub const GDK_KEY_braille_dots_1346 = 16787501;
pub const GDK_KEY_Control_R = 65508;
pub const GDK_KEY_partialderivative = 2287;
pub const GDK_KEY_Pointer_Right = 65249;
pub const GTK_STYLE_CLASS_ERROR = c"error";
pub const GLIB_MINOR_VERSION = 62;
pub const _Analysis_assume_lock_not_held_ = lock;
pub const GDK_KEY_Armenian_LYUN = 16778556;
pub const G_VARIANT_TYPE_STRING_ARRAY = if (@typeId(@typeOf(c"as")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"as") else if (@typeId(@typeOf(c"as")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"as") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"as");
pub const GDK_KEY_braille_dots_4 = 16787464;
pub const G_MAXLONG = LONG_MAX;
pub const GDK_KEY_Armenian_tche = 16778611;
pub const GTK_STYLE_PROPERTY_FONT = c"font";
pub const GDK_KEY_braille_dots_24568 = 16787642;
pub const __POPCNT__ = 1;
pub const GDK_KEY_Thai_chochoe = 3500;
pub const GDK_KEY_braceleft = 123;
pub const GDK_KEY_Pointer_Button1 = 65257;
pub const __INT_FAST16_FMTd__ = c"hd";
pub const __UINT_LEAST32_FMTu__ = c"u";
pub const GDK_KEY_Cyrillic_ve = 1751;
pub const G_FILE_ATTRIBUTE_UNIX_MODE = c"unix::mode";
pub const GDK_KEY_Ibreve = 16777516;
pub const GDK_KEY_braille_dots_14678 = 16787689;
pub const BUFSIZ = 512;
pub const GDK_KEY_kana_i = 1192;
pub const ETIME = 137;
pub const GDK_KEY_Armenian_KHE = 16778557;
pub const GDK_KEY_Green = 269025188;
pub const GDK_KEY_KP_6 = 65462;
pub const GDK_KEY_mu = 181;
pub const EINPROGRESS = 112;
pub const GDK_KEY_Thai_saraam = 3539;
pub const __FLT_MIN_10_EXP__ = -37;
pub const PANGO_AVAILABLE_IN_1_12 = _PANGO_EXTERN;
pub const GTK_STYLE_CLASS_NOTEBOOK = c"notebook";
pub const GDK_KEY_endash = 2730;
pub const GTK_STOCK_HOME = if (@typeId(@typeOf(c"gtk-home")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-home") else if (@typeId(@typeOf(c"gtk-home")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-home") else GtkStock(c"gtk-home");
pub const GDK_KEY_onefifth = 2738;
pub const GDK_KEY_2 = 50;
pub const G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME = c"standard::display-name";
pub const GDK_KEY_hebrew_gimmel = 3298;
pub const GDK_KEY_Ygrave = 16785138;
pub const _EM_UNDERFLOW = 2;
pub const cairo_get_path = cairo_get_path_DEPRECATED_BY_cairo_copy_path;
pub const GDK_KEY_braille_dots_15678 = 16787697;
pub const GTK_STOCK_CONVERT = if (@typeId(@typeOf(c"gtk-convert")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-convert") else if (@typeId(@typeOf(c"gtk-convert")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-convert") else GtkStock(c"gtk-convert");
pub const GDK_KEY_Lacute = 453;
pub const GDK_KEY_Thai_maichattawa = 3563;
pub const GDK_KEY_Pointer_DblClick2 = 65264;
pub const GDK_KEY_ubelowdot = 16785125;
pub const GDK_KEY_SlowKeys_Enable = 65139;
pub const _ATK_EXTERN = @"extern";
pub const GDK_KEY_braille_dots_2346 = 16787502;
pub const GTK_STOCK_ZOOM_OUT = if (@typeId(@typeOf(c"gtk-zoom-out")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-zoom-out") else if (@typeId(@typeOf(c"gtk-zoom-out")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-zoom-out") else GtkStock(c"gtk-zoom-out");
pub const GDK_KEY_jot = 3018;
pub const CAIRO_HAS_PNG_FUNCTIONS = 1;
pub const GTK_STYLE_CLASS_VIEW = c"view";
pub const GDK_KEY_ncedilla = 1009;
pub const GDK_KEY_Thai_maiek = 3560;
pub const GDK_KEY_braille_dots_578 = 16787664;
pub const GDK_KEY_Arabic_hamzaonwaw = 1476;
pub const G_KEY_FILE_DESKTOP_KEY_PATH = c"Path";
pub const GDK_KEY_3270_ChangeScreen = 64793;
pub const GDK_KEY_fivesixths = 2743;
pub const PANGO_VERSION_MICRO = 0;
pub const GDK_KEY_Igrave = 204;
pub const GLIB_AVAILABLE_IN_2_48 = _GLIB_EXTERN;
pub const GDK_KEY_F29 = 65498;
pub const __UINT_FAST8_FMTx__ = c"hhx";
pub const GDK_KEY_3270_Left2 = 64772;
pub const FLT_MIN_EXP = -125;
pub const GDK_KEY_dead_abovering = 65112;
pub const GDK_KEY_braille_dots_2357 = 16787542;
pub const CAIRO_MIME_TYPE_JPEG = c"image/jpeg";
pub const GDK_KEY_dead_voiced_sound = 65118;
pub const _HEAP_MAXREQ = 18446744073709551584;
pub const G_PRIORITY_DEFAULT_IDLE = 200;
pub const __UINT16_FMTx__ = c"hx";
pub const GLIB_SIZEOF_VOID_P = 8;
pub const GDK_AVAILABLE_IN_3_24 = _GDK_EXTERN;
pub const G_FILE_ATTRIBUTE_STANDARD_NAME = c"standard::name";
pub const DBL_EPSILON = 0.000000;
pub const __UINTPTR_FMTu__ = c"llu";
pub const clear87 = _clear87;
pub const GDK_KEY_braille_dots_257 = 16787538;
pub const ATK_DEPRECATED_IN_2_2 = ATK_DEPRECATED;
pub const GDK_KEY_3270_PA3 = 64780;
pub const G_ALLOCATOR_SLIST = 2;
pub const G_FILE_ATTRIBUTE_STANDARD_TARGET_URI = c"standard::target-uri";
pub const GDK_KEY_KP_Page_Down = 65435;
pub const GDK_KEY_Arabic_ghain = 1498;
pub const GTK_STYLE_CLASS_MARK = c"mark";
pub const G_SEARCHPATH_SEPARATOR_S = c";";
pub const _RC_UP = 512;
pub const GDK_KEY_kana_U = 1203;
pub const GDK_KEY_Arabic_hamzaonyeh = 1478;
pub const GDK_KEY_braille_dots_1345678 = 16787709;
pub const GDK_KEY_Sinh_ruu2 = 16780786;
pub const GDK_KEY_braille_dots_12356 = 16787511;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_38 = GLIB_DEPRECATED_ENUMERATOR;
pub const GDK_KEY_Hangul = 65329;
pub const _WConst_return = _CONST_RETURN;
pub const GDK_KEY_Macedonia_gje = 1698;
pub const G_MINFLOAT = FLT_MIN;
pub const __LONG_LONG_MAX__ = c_longlong(9223372036854775807);
pub const GDK_KEY_Ibelowdot = 16785098;
pub const MCW_PC = _MCW_PC;
pub const GDK_KEY_Hangul_J_RieulPieub = 3806;
pub const GDK_KEY_braille_dot_3 = 65523;
pub const GDK_KEY_BounceKeys_Enable = 65140;
pub const GDK_KEY_3270_KeyClick = 64785;
pub const GTK_STYLE_CLASS_FLAT = c"flat";
pub const GDK_KEY_Hangul_J_Dikeud = 3802;
pub const GDK_KEY_emdash = 2729;
pub const GDK_KEY_braille_dots_145678 = 16787705;
pub const GDK_KEY_KP_Delete = 65439;
pub const GDK_KEY_k = 107;
pub const GDK_KEY_Rcaron = 472;
pub const PANGO_DEPRECATED_IN_1_6 = PANGO_DEPRECATED;
pub const PANGO_VERSION_MAJOR = 1;
pub const GDK_KEY_braille_dots_12347 = 16787535;
pub const GDK_KEY_braille_dots_45678 = 16787704;
pub const GDK_KEY_Armenian_ghat = 16778610;
pub const GDK_KEY_Arabic_percent = 16778858;
pub const wcswcs = wcsstr;
pub const GTK_STYLE_CLASS_TITLEBAR = c"titlebar";
pub const GLIB_DEPRECATED_IN_2_48 = GLIB_DEPRECATED;
pub const GDK_KEY_Cyrillic_el = 1740;
pub const GDK_KEY_Georgian_shin = 16781544;
pub const GTK_STOCK_ORIENTATION_REVERSE_LANDSCAPE = if (@typeId(@typeOf(c"gtk-orientation-reverse-landscape")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-orientation-reverse-landscape") else if (@typeId(@typeOf(c"gtk-orientation-reverse-landscape")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-orientation-reverse-landscape") else GtkStock(c"gtk-orientation-reverse-landscape");
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT = 0;
pub const GDK_KEY_Hangul_End = 65331;
pub const GDK_KEY_BrightnessAdjust = 269025083;
pub const GDK_KEY_Thai_nonen = 3507;
pub const __BIGGEST_ALIGNMENT__ = 16;
pub const IC_PROJECTIVE = _IC_PROJECTIVE;
pub const GDK_KEY_dead_tilde = 65107;
pub const __INT64_FMTd__ = c"lld";
pub const GDK_KEY_hebrew_mem = 3310;
pub const GDK_KEY_F14 = 65483;
pub const GDK_KEY_Pointer_EnableKeys = 65273;
pub const GDK_KEY_braille_dots_126 = 16787491;
pub const G_PRIORITY_HIGH_IDLE = 100;
pub const GDK_KEY_Armenian_tsa = 16778606;
pub const __LZCNT__ = 1;
pub const _CRT_INTERNAL_SCANF_SECURECRT = c_ulonglong(1) << 0;
pub const GDK_KEY_Sinh_ssha = 16780738;
pub const GLIB_DEPRECATED_TYPE_IN_2_30 = GLIB_DEPRECATED_TYPE;
pub const __INVPCID__ = 1;
pub const GDK_KEY_ecircumflexbelowdot = 16785095;
pub const ATK_MAJOR_VERSION = 2;
pub const GTK_STOCK_FILE = if (@typeId(@typeOf(c"gtk-file")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-file") else if (@typeId(@typeOf(c"gtk-file")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-file") else GtkStock(c"gtk-file");
pub const GDK_KEY_Ecircumflexhook = 16785090;
pub const GDK_KEY_dead_cedilla = 65115;
pub const GDK_KEY_Cyrillic_ZHE = 1782;
pub const GDK_KEY_braille_dots_1468 = 16787625;
pub const GDK_KEY_L3 = 65482;
pub const GDK_KEY_AudioMedia = 269025074;
pub const __FMA__ = 1;
pub const GDK_KEY_gcaron = 16777703;
pub const GDK_KEY_Sinh_dhha = 16780720;
pub const __MMX__ = 1;
pub const GDK_KEY_kana_A = 1201;
pub const GDK_KEY_figdash = 2747;
pub const GDK_KEY_Georgian_phar = 16781540;
pub const GDK_KEY_braille_dots_137 = 16787525;
pub const GDK_KEY_LaunchA = 269025098;
pub const G_MAXSHORT = SHRT_MAX;
pub const GDK_KEY_Farsi_2 = 16778994;
pub const GDK_KEY_Hyper_R = 65518;
pub const GDK_KEY_dead_semivoiced_sound = 65119;
pub const GDK_KEY_Arabic_noon = 1510;
pub const EADDRNOTAVAIL = 101;
pub const GDK_KEY_Ebelowdot = 16785080;
pub const FLT_MAX_EXP = 128;
pub const GDK_KEY_Mae_Koho = 65342;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_52 = GLIB_DEPRECATED_ENUMERATOR;
pub const GDK_KEY_Greek_lambda = 2027;
pub const GDK_KEY_Arabic_2 = 16778850;
pub const GDK_KEY_Greek_EPSILON = 1989;
pub const GDK_KEY_Cyrillic_i_macron = 16778467;
pub const _Deref_post1_impl_ = p1;
pub const __PTRDIFF_FMTd__ = c"lld";
pub const GDK_KEY_Serbian_dze = 1711;
pub const GDK_KEY_G = 71;
pub const GDK_KEY_questiondown = 191;
pub const GTK_STYLE_CLASS_FRAME = c"frame";
pub const GDK_KEY_Cyrillic_EN_descender = 16778402;
pub const G_DATE_BAD_YEAR = c_uint(0);
pub const GDK_KEY_bracketleft = 91;
pub const __UINT_LEAST64_FMTx__ = c"llx";
pub const GDK_KEY_abelowdot = 16785057;
pub const GDK_KEY_Hangul_Hanja = 65332;
pub const GDK_KEY_F2 = 65471;
pub const _PC_24 = 131072;
pub const GDK_KEY_ISO_Center_Object = 65075;
pub const LONG_MIN = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-c_long(2147483647), -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-c_long(2147483647), -1) else (-c_long(2147483647))(-1);
pub const GTK_STOCK_DELETE = if (@typeId(@typeOf(c"gtk-delete")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-delete") else if (@typeId(@typeOf(c"gtk-delete")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-delete") else GtkStock(c"gtk-delete");
pub const GTK_STOCK_JUSTIFY_FILL = if (@typeId(@typeOf(c"gtk-justify-fill")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-justify-fill") else if (@typeId(@typeOf(c"gtk-justify-fill")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-justify-fill") else GtkStock(c"gtk-justify-fill");
pub const _EM_AMBIGUOUS = 2147483648;
pub const __NO_MATH_INLINES = 1;
pub const GDK_KEY_Armenian_vo = 16778616;
pub const __PTRDIFF_WIDTH__ = 64;
pub const GLIB_AVAILABLE_IN_2_26 = _GLIB_EXTERN;
pub const GDK_KEY_Arabic_yeh_baree = 16778962;
pub const GTK_STOCK_CUT = if (@typeId(@typeOf(c"gtk-cut")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-cut") else if (@typeId(@typeOf(c"gtk-cut")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-cut") else GtkStock(c"gtk-cut");
pub const _Function_ignore_lock_checking_ = lock;
pub const GDK_KEY_braille_dots_3 = 16787460;
pub const GDK_KEY_hebrew_finalkaph = 3306;
pub const GDK_KEY_notelementof = 16785929;
pub const GDK_KEY_Thai_maiyamok = 3558;
pub const _IOFBF = 0;
pub const cairo_set_pattern = cairo_set_pattern_REPLACED_BY_cairo_set_source;
pub const GDK_KEY_PowerDown = 269025057;
pub const GLIB_SYSDEF_MSG_DONTROUTE = 4;
pub const GDK_KEY_Arabic_alef = 1479;
pub const GDK_KEY_Zenkaku = 65320;
pub const GTK_PRINT_SETTINGS_RESOLUTION = c"resolution";
pub const ATK_BINARY_AGE = 23411;
pub const cairo_set_target_surface = cairo_set_target_surface_DEPRECATED_BY_cairo_create;
pub const GDK_KEY_Thai_thanthakhat = 3564;
pub const GDK_KEY_Sinh_ae = 16780679;
pub const GLIB_DEPRECATED_IN_2_34 = GLIB_DEPRECATED;
pub const GDK_KEY_ocaron = 16777682;
pub const __FLT_DECIMAL_DIG__ = 9;
pub const GDK_KEY_ybelowdot = 16785141;
pub const GDK_KEY_KP_7 = 65463;
pub const __DBL_DIG__ = 15;
pub const GTK_STYLE_CLASS_STATUSBAR = c"statusbar";
pub const G_TEST_OPTION_ISOLATE_DIRS = c"isolate_dirs";
pub const GTK_STOCK_EDIT = if (@typeId(@typeOf(c"gtk-edit")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-edit") else if (@typeId(@typeOf(c"gtk-edit")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-edit") else GtkStock(c"gtk-edit");
pub const GTK_STYLE_CLASS_VERTICAL = c"vertical";
pub const GDK_KEY_Select = 65376;
pub const PANGO_AVAILABLE_IN_1_22 = _PANGO_EXTERN;
pub const GDK_KEY_3 = 51;
pub const GDK_KEY_Cancel = 65385;
pub const GDK_KEY_heart = 2798;
pub const GDK_KEY_p = 112;
pub const GDK_KEY_rightt = 2549;
pub const GDK_KEY_Pointer_DblClick3 = 65265;
pub const GDK_KEY_soliddiamond = 2528;
pub const SHRT_MIN = -32768;
pub const G_KEY_FILE_DESKTOP_TYPE_LINK = c"Link";
pub const GDK_KEY_checkmark = 2803;
pub const GDK_KEY_Serbian_LJE = 1721;
pub const GDK_KEY_Sinh_dha = 16780719;
pub const CAIRO_MIME_TYPE_URI = c"text/x-uri";
pub const GDK_KEY_braille_dots_2347 = 16787534;
pub const EINVAL = 22;
pub const EISCONN = 113;
pub const __UINT_LEAST16_FMTx__ = c"hx";
pub const GDK_KEY_Thai_khokhuat = 3491;
pub const __VERSION__ = c"Clang 9.0.0 (tags/RELEASE_900/final)";
pub const GTK_TREE_SORTABLE_UNSORTED_SORT_COLUMN_ID = -2;
pub const GTK_PAPER_NAME_B5 = c"iso_b5";
pub const GDK_KEY_ISO_Fast_Cursor_Right = 65069;
pub const __UINT_LEAST64_FMTo__ = c"llo";
pub const _Post_satisfies_impl_ = expr;
pub const GDK_KEY_zacute = 444;
pub const GDK_KEY_singlelowquotemark = 2813;
pub const GDK_KEY_Cyrillic_SHA = 1787;
pub const G_GINT16_FORMAT = c"hi";
pub const GDK_KEY_braille_dots_267 = 16787554;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE_FILE = c"mountable::unix-device-file";
pub const EOVERFLOW = 132;
pub const GDK_KEY_braille_dots_123478 = 16787663;
pub const GDK_KEY_squareroot = 16785946;
pub const _NSTREAM_ = 512;
pub const GDK_KEY_Cyrillic_NJE = 1722;
pub const GDK_KEY_Cyrillic_TSE = 1763;
pub const __UINT16_MAX__ = 65535;
pub const G_GINTPTR_MODIFIER = c"ll";
pub const GDK_KEY_Armenian_VO = 16778568;
pub const GDK_KEY_AudioRecord = 269025052;
pub const GDK_KEY_Serbian_JE = 1720;
pub const GDK_KEY_hebrew_lamed = 3308;
pub const GDK_KEY_Greek_zeta = 2022;
pub const GDK_KEY_MenuPB = 269025126;
pub const __SIZEOF_WINT_T__ = 2;
pub const GDK_KEY_braille_dots_2356 = 16787510;
pub const __CLRCALL_OR_CDECL = __cdecl;
pub const GDK_KEY_gabovedot = 757;
pub const GDK_MAJOR_VERSION = 3;
pub const __WINT_UNSIGNED__ = 1;
pub const GDK_KEY_KP_Decimal = 65454;
pub const GTK_STOCK_MEDIA_PREVIOUS = if (@typeId(@typeOf(c"gtk-media-previous")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-media-previous") else if (@typeId(@typeOf(c"gtk-media-previous")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-media-previous") else GtkStock(c"gtk-media-previous");
pub const G_KEY_FILE_DESKTOP_KEY_MIME_TYPE = c"MimeType";
pub const GDK_KEY_Down = 65364;
pub const GDK_KEY_caret = 2812;
pub const GDK_KEY_WheelButton = 269025160;
pub const GTK_STOCK_GOTO_FIRST = if (@typeId(@typeOf(c"gtk-goto-first")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-goto-first") else if (@typeId(@typeOf(c"gtk-goto-first")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-goto-first") else GtkStock(c"gtk-goto-first");
pub const GDK_AVAILABLE_IN_3_2 = _GDK_EXTERN;
pub const GTK_PRINT_SETTINGS_PAGE_SET = c"page-set";
pub const GDK_PIXBUF_MAJOR = 2;
pub const GDK_KEY_Hangul_SunkyeongeumPhieuf = 3828;
pub const GDK_KEY_Hibernate = 269025192;
pub const GLIB_DEPRECATED_MACRO_IN_2_26 = GLIB_DEPRECATED_MACRO;
pub const GDK_KEY_Arabic_kaf = 1507;
pub const GDK_KEY_braille_dots_12357 = 16787543;
pub const _Acquires_shared_lock_ = lock;
pub const GDK_KEY_News = 269025129;
pub const _CRT_INT_MAX = 2147483647;
pub const GTK_STOCK_ZOOM_IN = if (@typeId(@typeOf(c"gtk-zoom-in")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-zoom-in") else if (@typeId(@typeOf(c"gtk-zoom-in")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-zoom-in") else GtkStock(c"gtk-zoom-in");
pub const GDK_KEY_User2KB = 269025158;
pub const DBL_MAX = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878;
pub const GDK_KEY_Aacute = 193;
pub const _MAX_FNAME = 256;
pub const GDK_PIXBUF_AVAILABLE_IN_2_4 = _GDK_PIXBUF_EXTERN;
pub const GDK_KEY_Arabic_teh = 1482;
pub const __INT_FAST32_MAX__ = 2147483647;
pub const LDBL_MAX_10_EXP = DBL_MAX_10_EXP;
pub const GDK_KEY_Cyrillic_u_straight = 16778415;
pub const GDK_KEY_rightarrow = 2301;
pub const GTK_PRINT_SETTINGS_ORIENTATION = c"orientation";
pub const G_FILE_ATTRIBUTE_TIME_CHANGED = c"time::changed";
pub const GDK_KEY_l = 108;
pub const GDK_KEY_braille_dots_12346 = 16787503;
pub const GDK_KEY_Sinh_jnya = 16780709;
pub const GTK_STOCK_INDENT = if (@typeId(@typeOf(c"gtk-indent")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-indent") else if (@typeId(@typeOf(c"gtk-indent")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-indent") else GtkStock(c"gtk-indent");
pub const G_MAXDOUBLE = DBL_MAX;
pub const CAIRO_HAS_WIN32_FONT = 1;
pub const GDK_KEY_Hangul_J_Nieun = 3799;
pub const GDK_KEY_ocircumflexgrave = 16785107;
pub const __PRAGMA_REDEFINE_EXTNAME = 1;
pub const GDK_KEY_uptack = 3022;
pub const GTK_PRINT_SETTINGS_WIN32_DRIVER_EXTRA = c"win32-driver-extra";
pub const GDK_KEY_filledrectbullet = 2779;
pub const GDK_KEY_eng = 959;
pub const GDK_KEY_Sinh_ii2 = 16780755;
pub const GDK_KEY_UWB = 269025174;
pub const g_cclosure_marshal_BOOL__BOXED_BOXED = g_cclosure_marshal_BOOLEAN__BOXED_BOXED;
pub const __UINT_FAST64_FMTu__ = c"llu";
pub const G_VARIANT_TYPE_SIGNATURE = if (@typeId(@typeOf(c"g")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"g") else if (@typeId(@typeOf(c"g")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"g") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"g");
pub const GDK_KEY_F17 = 65486;
pub const __INT_FAST16_TYPE__ = short;
pub const GDK_KEY_telephone = 2809;
pub const GDK_KEY_braille_dots_127 = 16787523;
pub const cairo_current_line_width = cairo_current_line_width_REPLACED_BY_cairo_get_line_width;
pub const GDK_KEY_kana_KE = 1209;
pub const GDK_KEY_Udiaeresis = 220;
pub const GDK_PIXBUF_AVAILABLE_IN_2_16 = _GDK_PIXBUF_EXTERN;
pub const GDK_AVAILABLE_IN_3_18 = _GDK_EXTERN;
pub const GDK_KEY_Armenian_pyur = 16778627;
pub const cairo_select_font = cairo_select_font_REPLACED_BY_cairo_select_font_face;
pub const GDK_KEY_braille_dots_1248 = 16787595;
pub const GDK_KEY_Thai_khorakhang = 3494;
pub const GDK_KEY_Community = 269025085;
pub const GDK_KEY_Meta_L = 65511;
pub const GDK_KEY_Sinh_ng = 16780674;
pub const GTK_STOCK_PRINT_PAUSED = if (@typeId(@typeOf(c"gtk-print-paused")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-print-paused") else if (@typeId(@typeOf(c"gtk-print-paused")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-print-paused") else GtkStock(c"gtk-print-paused");
pub const __LDBL_DECIMAL_DIG__ = 17;
pub const GDK_KEY_braille_dots_58 = 16787600;
pub const GDK_KEY_quoteleft = 96;
pub const GDK_KEY_KP_F4 = 65428;
pub const GDK_KEY_braille_dots_136 = 16787493;
pub const GDK_KEY_Hangul_KkogjiDalrinIeung = 3827;
pub const GDK_KEY_Farsi_3 = 16778995;
pub const GDK_KEY_approximate = 2248;
pub const GDK_KEY_ediaeresis = 235;
pub const GDK_KEY_ISO_Left_Tab = 65056;
pub const GDK_KEY_dead_iota = 65117;
pub const GDK_KEY_Arabic_5 = 16778853;
pub const PANGO_DEPRECATED_IN_1_26 = PANGO_DEPRECATED;
pub const GTK_STYLE_CLASS_ENTRY = c"entry";
pub const GDK_KEY_braille_dot_10 = 65530;
pub const GDK_KEY_Tabovedot = 16785002;
pub const G_VARIANT_TYPE_UINT16 = if (@typeId(@typeOf(c"q")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"q") else if (@typeId(@typeOf(c"q")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"q") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"q");
pub const GDK_KEY_AudioStop = 269025045;
pub const cairo_surface_set_repeat = cairo_surface_set_repeat_DEPRECATED_BY_cairo_pattern_set_extend;
pub const _MSC_VER = 1916;
pub const CAIRO_HAS_IMAGE_SURFACE = 1;
pub const GDK_KEY_X = 88;
pub const G_VARIANT_TYPE_INT64 = if (@typeId(@typeOf(c"x")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"x") else if (@typeId(@typeOf(c"x")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"x") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"x");
pub const GDK_KEY_Cyrillic_HA_descender = 16778418;
pub const GDK_KEY_underbar = 3014;
pub const _DEBUG = 1;
pub const GDK_KEY_Arabic_semicolon = 1467;
pub const GDK_KEY_F3 = 65472;
pub const GDK_KEY_Thai_phophung = 3516;
pub const G_NATIVE_VOLUME_MONITOR_EXTENSION_POINT_NAME = c"gio-native-volume-monitor";
pub const GLIB_DEPRECATED_MACRO_IN_2_60 = GLIB_DEPRECATED_MACRO;
pub const GLIB_AVAILABLE_IN_2_34 = _GLIB_EXTERN;
pub const GDK_KEY_botleftparens = 2220;
pub const GDK_KEY_Georgian_tan = 16781527;
pub const GTK_STYLE_PROVIDER_PRIORITY_USER = 800;
pub const GDK_KEY_Greek_phi = 2038;
pub const GDK_KEY_braille_dots_1268 = 16787619;
pub const G_MAXOFFSET = G_MAXINT64;
pub const GDK_KEY_Sinh_oo = 16780693;
pub const GDK_KEY_braille_dots_38 = 16787588;
pub const GDK_KEY_braille_dots_2 = 16787458;
pub const GDK_KEY_Adiaeresis = 196;
pub const GDK_KEY_RockerDown = 269025060;
pub const G_VARIANT_TYPE_HANDLE = if (@typeId(@typeOf(c"h")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"h") else if (@typeId(@typeOf(c"h")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"h") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"h");
pub const GDK_KEY_dstroke = 496;
pub const GDK_KEY_Hangul_Dikeud = 3751;
pub const PANGO_DEPRECATED_IN_1_44 = PANGO_DEPRECATED;
pub const G_MAXINT = INT_MAX;
pub const _ALLOCA_S_MARKER_SIZE = 16;
pub const GTK_PATH_PRIO_MASK = 15;
pub const GDK_KEY_kana_WO = 1190;
pub const __CLANG_ATOMIC_BOOL_LOCK_FREE = 2;
pub const EXIT_FAILURE = 1;
pub const G_MENU_LINK_SECTION = c"section";
pub const GDK_KEY_downcaret = 2984;
pub const __UINT_LEAST32_FMTo__ = c"o";
pub const cairo_current_point = cairo_current_point_REPLACED_BY_cairo_get_current_point;
pub const GDK_KEY_kana_o = 1195;
pub const __FLT_MIN_EXP__ = -125;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_HAL_UDI = c"mountable::hal-udi";
pub const GDK_KEY_dead_dasia = 65125;
pub const __UINT_LEAST64_FMTu__ = c"llu";
pub const GDK_KEY_KP_Up = 65431;
pub const GDK_KEY_KP_0 = 65456;
pub const GDK_KEY_Sinh_thha = 16780718;
pub const GDK_KEY_Sinh_aa2 = 16780751;
pub const __INT_FAST64_FMTd__ = c"lld";
pub const G_VARIANT_TYPE_TUPLE = if (@typeId(@typeOf(c"r")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"r") else if (@typeId(@typeOf(c"r")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"r") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"r");
pub const PANGO_AVAILABLE_IN_1_14 = _PANGO_EXTERN;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_STOP = c"mountable::can-stop";
pub const GTK_STYLE_REGION_COLUMN_HEADER = c"column-header";
pub const GDK_KEY_kana_TI = 1217;
pub const GDK_KEY_Thai_lakkhangyao = 3557;
pub const GTK_STOCK_JUSTIFY_LEFT = if (@typeId(@typeOf(c"gtk-justify-left")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-justify-left") else if (@typeId(@typeOf(c"gtk-justify-left")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-justify-left") else GtkStock(c"gtk-justify-left");
pub const GDK_KEY_4 = 52;
pub const GDK_KEY_Armenian_ra = 16778620;
pub const GDK_KEY_filledlefttribullet = 2780;
pub const GDK_KEY_Greek_theta = 2024;
pub const GDK_KEY_q = 113;
pub const GDK_KEY_WebCam = 269025167;
pub const _SW_STACKUNDERFLOW = 1024;
pub const __UINT_LEAST8_FMTx__ = c"hhx";
pub const GDK_KEY_Georgian_an = 16781520;
pub const GDK_KEY_braille_dots_2348 = 16787598;
pub const __SSE4_2__ = 1;
pub const GDK_KEY_braille_dots_18 = 16787585;
pub const GTK_STYLE_CLASS_LIST_ROW = c"list-row";
pub const _Notref_ = _Notref_impl_;
pub const GDK_KEY_Cyrillic_o_bar = 16778473;
pub const GDK_KEY_malesymbol = 2807;
pub const GDK_KEY_MonBrightnessUp = 269025026;
pub const SIGINT = 2;
pub const stdin = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast(__acrt_iob_func, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr(__acrt_iob_func, 0) else __acrt_iob_func(0);
pub const __DBL_DENORM_MIN__ = 0.000000;
pub const GDK_KEY_Cyrillic_SHORTI = 1770;
pub const GDK_KEY_Cyrillic_shcha = 1757;
pub const GLIB_DEPRECATED_TYPE_IN_2_58 = GLIB_DEPRECATED_TYPE;
pub const GDK_KEY_Zstroke = 16777653;
pub const G_KEY_FILE_DESKTOP_KEY_TYPE = c"Type";
pub const GDK_KEY_Thai_sosua = 3530;
pub const GDK_KEY_openrectbullet = 2786;
pub const _CRT_INSECURE_DEPRECATE_MEMORY = _Replacement;
pub const GDK_KEY_Display = 269025113;
pub const GDK_KEY_braille_dots_23478 = 16787662;
pub const sys_errlist = _sys_errlist;
pub const GDK_KEY_Greek_eta = 2023;
pub const GDK_KEY_onethird = 2736;
pub const GDK_KEY_Macedonia_DSE = 1717;
pub const GDK_KEY_lf = 2533;
pub const PANGO_AVAILABLE_IN_1_36 = _PANGO_EXTERN;
pub const GTK_STOCK_SPELL_CHECK = if (@typeId(@typeOf(c"gtk-spell-check")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-spell-check") else if (@typeId(@typeOf(c"gtk-spell-check")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-spell-check") else GtkStock(c"gtk-spell-check");
pub const GDK_KEY_division = 247;
pub const GDK_KEY_Cyrillic_be = 1730;
pub const __LDBL_HAS_DENORM__ = 1;
pub const GDK_KEY_Hangul_RieulYeorinHieuh = 3823;
pub const GDK_KEY_Armenian_to = 16778601;
pub const GDK_KEY_Hangul_J_Jieuj = 3817;
pub const GDK_KEY_VoidSymbol = 16777215;
pub const GTK_STYLE_CLASS_POPUP = c"popup";
pub const GDK_KEY_acute = 180;
pub const G_VARIANT_TYPE_MAYBE = if (@typeId(@typeOf(c"m*")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"m*") else if (@typeId(@typeOf(c"m*")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"m*") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"m*");
pub const GDK_KEY_ISO_Last_Group = 65038;
pub const GDK_KEY_foursuperior = 16785524;
pub const GDK_KEY_BackForward = 269025087;
pub const GTK_STYLE_CLASS_MENUBAR = c"menubar";
pub const GDK_KEY_Hangul_J_Rieul = 3803;
pub const GDK_KEY_Close = 269025110;
pub const PC_53 = _PC_53;
pub const GDK_KEY_ISO_Group_Lock = 65031;
pub const GTK_STYLE_CLASS_RADIO = c"radio";
pub const GDK_KEY_Abrevebelowdot = 16785078;
pub const GDK_KEY_Hangul_EU = 3793;
pub const GLIB_SYSDEF_MSG_OOB = 1;
pub const GDK_KEY_kana_HO = 1230;
pub const GTK_STYLE_CLASS_SCALE_HAS_MARKS_BELOW = c"scale-has-marks-below";
pub const GTK_STOCK_GO_FORWARD = if (@typeId(@typeOf(c"gtk-go-forward")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-go-forward") else if (@typeId(@typeOf(c"gtk-go-forward")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-go-forward") else GtkStock(c"gtk-go-forward");
pub const GDK_KEY_MultipleCandidate = 65341;
pub const __SIZE_FMTu__ = c"llu";
pub const GDK_KEY_braille_dot_1 = 65521;
pub const GDK_KEY_Uhorntilde = 16785134;
pub const G_MENU_ATTRIBUTE_LABEL = c"label";
pub const GDK_KEY_ugrave = 249;
pub const EPROTOTYPE = 136;
pub const GDK_KEY_m = 109;
pub const GDK_KEY_Hangul_J_NieunHieuh = 3801;
pub const GDK_KEY_braille_dots_3457 = 16787548;
pub const cairo_pdf_surface_set_dpi = cairo_pdf_surface_set_dpi_REPLACED_BY_cairo_surface_set_fallback_resolution;
pub const GTK_STYLE_CLASS_LEFT = c"left";
pub const GDK_KEY_Ecircumflex = 202;
pub const __PCLMUL__ = 1;
pub const GDK_KEY_braille_dots_12345 = 16787487;
pub const GDK_KEY_Sinh_ndha = 16780723;
pub const GDK_KEY_RotationPB = 269025141;
pub const GDK_KEY_StickyKeys_Enable = 65141;
pub const GDK_KEY_Insert = 65379;
pub const G_VOLUME_IDENTIFIER_KIND_UNIX_DEVICE = c"unix-device";
pub const cairo_status_string = cairo_status_string_DEPRECATED_BY_cairo_status_AND_cairo_status_to_string;
pub const GDK_KEY_adiaeresis = 228;
pub const EBUSY = 16;
pub const GDK_KEY_KP_Next = 65435;
pub const GDK_KEY_Help = 65386;
pub const GTK_STOCK_JUSTIFY_CENTER = if (@typeId(@typeOf(c"gtk-justify-center")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-justify-center") else if (@typeId(@typeOf(c"gtk-justify-center")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-justify-center") else GtkStock(c"gtk-justify-center");
pub const GDK_KEY_Cyrillic_en = 1742;
pub const GDK_KEY_Pointer_Accelerate = 65274;
pub const GDK_KEY_Cyrillic_lje = 1705;
pub const GDK_KEY_copyright = 169;
pub const GDK_KEY_Greek_ALPHAaccent = 1953;
pub const GTK_STYLE_CLASS_SPINBUTTON = c"spinbutton";
pub const GDK_KEY_CruzeiroSign = 16785570;
pub const GDK_KEY_Scroll_Lock = 65300;
pub const GDK_KEY_F16 = 65485;
pub const GDK_KEY_hebrew_zade = 3318;
pub const GDK_KEY_Thai_maitaikhu = 3559;
pub const GDK_KEY_braille_dots_128 = 16787587;
pub const GDK_KEY_Next = 65366;
pub const GDK_KEY_Arabic_dal = 1487;
pub const GDK_KEY_femalesymbol = 2808;
pub const GLIB_DEPRECATED_TYPE_IN_2_32 = GLIB_DEPRECATED_TYPE;
pub const GTK_INPUT_ERROR = -1;
pub const G_MEM_ALIGN = GLIB_SIZEOF_VOID_P;
pub const G_HAVE_GINT64 = 1;
pub const GDK_KEY_Pointer_Up = 65250;
pub const __x86_64__ = 1;
pub const _FPCLASS_NZ = 32;
pub const GDK_KEY_Armenian_yech = 16778597;
pub const GDK_KEY_Armenian_TO = 16778553;
pub const GDK_KEY_Greek_EPSILONaccent = 1954;
pub const GDK_KEY_careof = 2744;
pub const GDK_KEY_Greek_kappa = 2026;
pub const GDK_KEY_Sinh_ai2 = 16780763;
pub const _PANGO_EXTERN = @"extern";
pub const GDK_KEY_Greek_pi = 2032;
pub const GDK_KEY_onequarter = 188;
pub const GDK_KEY_overline = 1150;
pub const GDK_KEY_Macedonia_GJE = 1714;
pub const EAFNOSUPPORT = 102;
pub const GTK_STYLE_CLASS_TITLE = c"title";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_EXECUTE = c"access::can-execute";
pub const GDK_KEY_hcircumflex = 694;
pub const __LDBL_MIN_10_EXP__ = -307;
pub const __ORDER_BIG_ENDIAN__ = 4321;
pub const GDK_KEY_braille_dots_135 = 16787477;
pub const cairo_set_target_image = cairo_set_target_image_DEPRECATED_BY_cairo_image_surface_create_for_data;
pub const GDK_KEY_Farsi_0 = 16778992;
pub const GDK_KEY_Greek_IOTAdieresis = 1957;
pub const CAIRO_MIME_TYPE_PNG = c"image/png";
pub const GDK_KEY_Greek_mu = 2028;
pub const GDK_KEY_notidentical = 16786018;
pub const GDK_KEY_Arabic_4 = 16778852;
pub const GDK_KEY_Calculator = 269025053;
pub const G_GINT16_MODIFIER = c"h";
pub const GDK_KEY_pabovedot = 16784983;
pub const GDK_KEY_Armenian_paruyk = 16778590;
pub const GDK_KEY_Y = 89;
pub const __SIZEOF_INT128__ = 16;
pub const GDK_KEY_Armenian_at = 16778600;
pub const G_FILE_ATTRIBUTE_RECENT_MODIFIED = c"recent::modified";
pub const GDK_KEY_quoteright = 39;
pub const EOPNOTSUPP = 130;
pub const GDK_KEY_SingleCandidate = 65340;
pub const GDK_KEY_phonographcopyright = 2811;
pub const EFBIG = 27;
pub const GDK_KEY_Start = 269025050;
pub const G_KEY_FILE_DESKTOP_KEY_EXEC = c"Exec";
pub const LDBL_MIN = DBL_MIN;
pub const G_PRIORITY_HIGH = -100;
pub const GDK_KEY_Hangul_J_YeorinHieuh = 3834;
pub const GDK_KEY_Greek_finalsmallsigma = 2035;
pub const _DN_SAVE = 0;
pub const GDK_KEY_Yellow = 269025189;
pub const __clang__ = 1;
pub const G_VARIANT_TYPE_OBJECT_PATH_ARRAY = if (@typeId(@typeOf(c"ao")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"ao") else if (@typeId(@typeOf(c"ao")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"ao") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"ao");
pub const GDK_KEY_Arabic_jeh = 16778904;
pub const GDK_KEY_KbdLightOnOff = 269025028;
pub const __LDBL_DIG__ = 15;
pub const DBL_DIG = 15;
pub const ENODEV = 19;
pub const PANGO_ATTR_INDEX_FROM_TEXT_BEGINNING = 0;
pub const GTK_STOCK_EXECUTE = if (@typeId(@typeOf(c"gtk-execute")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-execute") else if (@typeId(@typeOf(c"gtk-execute")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-execute") else GtkStock(c"gtk-execute");
pub const G_MENU_ATTRIBUTE_ICON = c"icon";
pub const PANGO_ANALYSIS_FLAG_CENTERED_BASELINE = 1 << 0;
pub const GDK_KEY_Ukranian_i = 1702;
pub const GDK_KEY_Pointer_Drag4 = 65272;
pub const _FPE_UNEMULATED = 135;
pub const GDK_KEY_Hangul_RieulHieuh = 3760;
pub const GDK_KEY_dead_belowmacron = 65128;
pub const GDK_KEY_braille_dots_1 = 16787457;
pub const GDK_KEY_MouseKeys_Enable = 65142;
pub const GDK_KEY_prolongedsound = 1200;
pub const GDK_KEY_braille_dots_24567 = 16787578;
pub const GDK_KEY_Home = 65360;
pub const G_FILE_ATTRIBUTE_STANDARD_SIZE = c"standard::size";
pub const GTK_STOCK_COPY = if (@typeId(@typeOf(c"gtk-copy")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-copy") else if (@typeId(@typeOf(c"gtk-copy")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-copy") else GtkStock(c"gtk-copy");
pub const G_FILE_ATTRIBUTE_DOS_IS_ARCHIVE = c"dos::is-archive";
pub const GDK_KEY_braille_dots_124678 = 16787691;
pub const GDK_KEY_Pointer_Button4 = 65260;
pub const GDK_KEY_kana_FU = 1228;
pub const GDK_KEY_Switch_VT_4 = 269024772;
pub const GDK_KEY_Hangul_WI = 3791;
pub const G_KEY_FILE_DESKTOP_TYPE_DIRECTORY = c"Directory";
pub const GDK_KEY_R15 = 65504;
pub const GDK_KEY_Cyrillic_CHE = 1790;
pub const GDK_KEY_Sinh_oo2 = 16780765;
pub const __FLT_HAS_DENORM__ = 1;
pub const GDK_KEY_racute = 480;
pub const GDK_KEY_Subtitle = 269025178;
pub const GDK_KEY_Hangul_AraeAE = 3831;
pub const GDK_KEY_Eject = 269025068;
pub const GLIB_DEPRECATED_IN_2_36 = GLIB_DEPRECATED;
pub const G_KEY_FILE_DESKTOP_KEY_GENERIC_NAME = c"GenericName";
pub const _MCW_IC = 262144;
pub const G_HOOK_FLAG_USER_SHIFT = 4;
pub const GDK_KEY_Launch9 = 269025097;
pub const GDK_KEY_KP_1 = 65457;
pub const GDK_KEY_kana_RI = 1240;
pub const __FINITE_MATH_ONLY__ = 0;
pub const GDK_KEY_guillemotright = 187;
pub const ELOOP = 114;
pub const GTK_STYLE_CLASS_QUESTION = c"question";
pub const GDK_KEY_Sinh_nya = 16780708;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USE_PREVIEW = c"filesystem::use-preview";
pub const GDK_KEY_braille_dots_125678 = 16787699;
pub const GTK_STOCK_QUIT = if (@typeId(@typeOf(c"gtk-quit")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-quit") else if (@typeId(@typeOf(c"gtk-quit")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-quit") else GtkStock(c"gtk-quit");
pub const PANGO_AVAILABLE_IN_1_24 = _PANGO_EXTERN;
pub const GDK_KEY_5 = 53;
pub const GDK_KEY_Hangul_YEO = 3781;
pub const GDK_KEY_r = 114;
pub const GDK_KEY_Iabovedot = 681;
pub const __INT_LEAST32_FMTi__ = c"i";
pub const __function_ignore_lock_checking = lock;
pub const __LDBL_EPSILON__ = 0.000000;
pub const __STDC_UTF_32__ = 1;
pub const GDK_KEY_braille_dots_5678 = 16787696;
pub const cairo_get_status_string = cairo_get_status_string_DEPRECATED_BY_cairo_status_AND_cairo_status_to_string;
pub const _FPE_UNDERFLOW = 133;
pub const __SEG_FS = 1;
pub const GDK_KEY_Ehook = 16785082;
pub const GDK_KEY_Sinh_e = 16780689;
pub const GDK_KEY_egrave = 232;
pub const __GCC_ASM_FLAG_OUTPUTS__ = 1;
pub const __SIZEOF_DOUBLE__ = 8;
pub const G_IEEE754_FLOAT_BIAS = 127;
pub const GTK_UNIT_PIXEL = GTK_UNIT_NONE;
pub const GDK_KEY_upleftcorner = 2540;
pub const _OUT_TO_DEFAULT = 0;
pub const GDK_KEY_Terminate_Server = 65237;
pub const GDK_KEY_question = 63;
pub const GTK_STOCK_DIALOG_QUESTION = if (@typeId(@typeOf(c"gtk-dialog-question")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-dialog-question") else if (@typeId(@typeOf(c"gtk-dialog-question")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-dialog-question") else GtkStock(c"gtk-dialog-question");
pub const GDK_KEY_Thai_sarauee = 3543;
pub const GDK_KEY_AudioLowerVolume = 269025041;
pub const __SIZE_FMTX__ = c"llX";
pub const _FPE_DENORMAL = 130;
pub const GDK_KEY_kana_NA = 1221;
pub const __inner_data_entrypoint = category;
pub const CAIRO_FONT_TYPE_ATSUI = CAIRO_FONT_TYPE_QUARTZ;
pub const GDK_KEY_Hangul_I = 3795;
pub const GDK_KEY_asciitilde = 126;
pub const GDK_KEY_Armenian_hi = 16778613;
pub const GDK_KEY_dead_i = 65156;
pub const GDK_KEY_Hangul_Kiyeog = 3745;
pub const GDK_KEY_braille_dots_3467 = 16787564;
pub const GTK_STOCK_PRINT_PREVIEW = if (@typeId(@typeOf(c"gtk-print-preview")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-print-preview") else if (@typeId(@typeOf(c"gtk-print-preview")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-print-preview") else GtkStock(c"gtk-print-preview");
pub const GDK_KEY_Last_Virtual_Screen = 65236;
pub const GDK_KEY_ISO_Fast_Cursor_Down = 65071;
pub const G_GINT32_FORMAT = c"i";
pub const G_FILE_ATTRIBUTE_UNIX_NLINK = c"unix::nlink";
pub const ECHILD = 10;
pub const GDK_KEY_em4space = 2724;
pub const GDK_KEY_leftanglebracket = 2748;
pub const _Readable_bytes_impl_ = size;
pub const g_list_free1 = g_list_free_1;
pub const GDK_AVAILABLE_IN_3_0 = _GDK_EXTERN;
pub const G_FILE_ATTRIBUTE_STANDARD_IS_VIRTUAL = c"standard::is-virtual";
pub const GDK_KEY_braceright = 125;
pub const GDK_KEY_righttack = 3068;
pub const cairo_set_target_drawable = cairo_set_target_drawable_DEPRECATED_BY_cairo_xlib_surface_create;
pub const GDK_KEY_function = 2294;
pub const CAIRO_HAS_MIME_SURFACE = 1;
pub const GDK_KEY_KP_Equal = 65469;
pub const _OUT_TO_MSGBOX = 2;
pub const GDK_PIXBUF_AVAILABLE_IN_2_38 = _GDK_PIXBUF_EXTERN;
pub const __write_guarded_by = lock;
pub const __CLANG_ATOMIC_SHORT_LOCK_FREE = 2;
pub const GDK_KEY_kana_RU = 1241;
pub const GDK_KEY_lstroke = 435;
pub const GDK_KEY_Cyrillic_E = 1788;
pub const GDK_KEY_Wdiaeresis = 16785028;
pub const GTK_STOCK_STOP = if (@typeId(@typeOf(c"gtk-stop")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-stop") else if (@typeId(@typeOf(c"gtk-stop")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-stop") else GtkStock(c"gtk-stop");
pub const GLIB_SIZEOF_SIZE_T = 8;
pub const GDK_KEY_cent = 162;
pub const ENODATA = 120;
pub const _Analysis_assume_nullterminated_ = x;
pub const _LDBL_RADIX = _DBL_RADIX;
pub const GDK_KEY_ISO_Set_Margin_Left = 65063;
pub const GDK_KEY_Thai_sarae = 3552;
pub const G_CSET_DIGITS = c"0123456789";
pub const GDK_KEY_braille_dots_123456 = 16787519;
pub const GDK_KEY_n = 110;
pub const GDK_KEY_braille_dots_3456 = 16787516;
pub const GDK_KEY_Arabic_rreh = 16778897;
pub const GDK_KEY_Armenian_ben = 16778594;
pub const GDK_KEY_Left = 65361;
pub const __SCHAR_MAX__ = 127;
pub const ATK_AVAILABLE_IN_ALL = _ATK_EXTERN;
pub const GDK_KEY_Hangul_Pieub = 3762;
pub const GDK_KEY_kana_SU = 1213;
pub const MCW_RC = _MCW_RC;
pub const ENXIO = 6;
pub const GDK_KEY_C_H = 65189;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_MOUNT = c"mountable::can-mount";
pub const _Analysis_suppress_lock_checking_ = lock;
pub const GDK_KEY_Touroku = 65323;
pub const GDK_KEY_Armenian_gim = 16778595;
pub const GDK_DEPRECATED_IN_3_8 = GDK_DEPRECATED;
pub const GDK_KEY_ISO_Enter = 65076;
pub const GDK_KEY_Hangul_J_Hieuh = 3822;
pub const GDK_KEY_brokenbar = 166;
pub const GDK_KEY_Sinh_ndda = 16780716;
pub const __LDBL_MANT_DIG__ = 53;
pub const GDK_PIXBUF_VERSION = c"2.40.0";
pub const GDK_KEY_Georgian_xan = 16781550;
pub const GDK_KEY_Num_Lock = 65407;
pub const GDK_KEY_Phone = 269025134;
pub const __UINT64_FMTX__ = c"llX";
pub const GDK_KEY_Hangul_U = 3788;
pub const GDK_KEY_F19 = 65488;
pub const GDK_KEY_sixsubscript = 16785542;
pub const GDK_KEY_dead_E = 65155;
pub const GDK_DEPRECATED_IN_3_12 = GDK_DEPRECATED;
pub const GDK_KEY_RockerEnter = 269025061;
pub const GDK_KEY_Armenian_TCHE = 16778563;
pub const GTK_STOCK_CLEAR = if (@typeId(@typeOf(c"gtk-clear")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-clear") else if (@typeId(@typeOf(c"gtk-clear")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-clear") else GtkStock(c"gtk-clear");
pub const GDK_KEY_Standby = 269025040;
pub const GDK_PIXBUF_AVAILABLE_IN_2_18 = _GDK_PIXBUF_EXTERN;
pub const __inexpressible_writableTo = size;
pub const GDK_KEY_braille_blank = 16787456;
pub const GTK_STOCK_ZOOM_100 = if (@typeId(@typeOf(c"gtk-zoom-100")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-zoom-100") else if (@typeId(@typeOf(c"gtk-zoom-100")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-zoom-100") else GtkStock(c"gtk-zoom-100");
pub const GDK_KEY_scedilla = 442;
pub const GDK_KEY_braille_dots_123578 = 16787671;
pub const GDK_KEY_Armenian_separation_mark = 16778589;
pub const GTK_STOCK_SAVE_AS = if (@typeId(@typeOf(c"gtk-save-as")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-save-as") else if (@typeId(@typeOf(c"gtk-save-as")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-save-as") else GtkStock(c"gtk-save-as");
pub const GDK_KEY_multiply = 215;
pub const __SSE__ = 1;
pub const GDK_KEY_rightanglebracket = 2750;
pub const G_VOLUME_IDENTIFIER_KIND_NFS_MOUNT = c"nfs-mount";
pub const GDK_KEY_ZoomIn = 269025163;
pub const GDK_KEY_KP_End = 65436;
pub const GDK_KEY_KP_F2 = 65426;
pub const GDK_KEY_eogonek = 490;
pub const GDK_KEY_braille_dots_134 = 16787469;
pub const cairo_pattern_add_color_stop = cairo_pattern_add_color_stop_REPLACED_BY_cairo_pattern_add_color_stop_rgba;
pub const _MSC_FULL_VER = 191627030;
pub const GDK_KEY_Arabic_hamzaonalef = 1475;
pub const GDK_KEY_LaunchF = 269025103;
pub const GDK_KEY_Cyrillic_KA_vertstroke = 16778396;
pub const g_macro__has_feature = __has_feature;
pub const GDK_KEY_Hangul_YO = 3787;
pub const GDK_KEY_rightpointer = 2795;
pub const __UINTPTR_MAX__ = c_ulonglong(18446744073709551615);
pub const GDK_KEY_Farsi_1 = 16778993;
pub const GDK_KEY_3270_EraseInput = 64775;
pub const GDK_KEY_Multi_key = 65312;
pub const GDK_KEY_Georgian_hae = 16781552;
pub const GDK_KEY_utilde = 1021;
pub const __UINT_LEAST8_FMTu__ = c"hhu";
pub const GDK_KEY_Hiragana = 65317;
pub const GDK_KEY_TaskPane = 269025151;
pub const G_KEY_FILE_DESKTOP_KEY_STARTUP_WM_CLASS = c"StartupWMClass";
pub const _RC_NEAR = 0;
pub const GDK_KEY_Arabic_7 = 16778855;
pub const GDK_KEY_hebrew_zain = 3302;
pub const PANGO_DEPRECATED_IN_1_28 = PANGO_DEPRECATED;
pub const GDK_KEY_KP_Left = 65430;
pub const GTK_STYLE_PROPERTY_BORDER_RADIUS = c"border-radius";
pub const cairo_get_status = cairo_get_status_REPLACED_BY_cairo_status;
pub const __SIZEOF_WCHAR_T__ = 2;
pub const GDK_KEY_ScrollClick = 269025146;
pub const GTK_STYLE_CLASS_HORIZONTAL = c"horizontal";
pub const __LDBL_MAX__ = 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878;
pub const GDK_KEY_Z = 90;
pub const GDK_KEY_Sinh_kunddaliya = 16780788;
pub const GDK_KEY_Greek_ZETA = 1990;
pub const GDK_KEY_F1 = 65470;
pub const GDK_KEY_Spell = 269025148;
pub const GTK_STYLE_CLASS_BUTTON = c"button";
pub const GTK_STYLE_CLASS_GRIP = c"grip";
pub const GDK_KEY_Cyrillic_sha = 1755;
pub const GDK_KEY_kana_SA = 1211;
pub const GDK_KEY_includedin = 2266;
pub const GDK_KEY_containsas = 16785931;
pub const GDK_KEY_braille_dots_378 = 16787652;
pub const __UINTPTR_FMTX__ = c"llX";
pub const GDK_KEY_Sinh_e2 = 16780761;
pub const GTK_STOCK_NETWORK = if (@typeId(@typeOf(c"gtk-network")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-network") else if (@typeId(@typeOf(c"gtk-network")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-network") else GtkStock(c"gtk-network");
pub const _CRT_PACKING = 8;
pub const _Create_lock_level_ = level;
pub const _IOB_ENTRIES = 3;
pub const GDK_KEY_ht = 2530;
pub const GDK_KEY_First_Virtual_Screen = 65232;
pub const _Releases_nonreentrant_lock_ = lock;
pub const GDK_KEY_lcedilla = 950;
pub const GDK_KEY_Cyrillic_EF = 1766;
pub const GTK_STOCK_ORIENTATION_LANDSCAPE = if (@typeId(@typeOf(c"gtk-orientation-landscape")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-orientation-landscape") else if (@typeId(@typeOf(c"gtk-orientation-landscape")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-orientation-landscape") else GtkStock(c"gtk-orientation-landscape");
pub const GDK_KEY_Arabic_kasratan = 1517;
pub const GDK_KEY_voicedsound = 1246;
pub const GDK_KEY_Pointer_Drag5 = 65277;
pub const GDK_KEY_Tslash = 940;
pub const GDK_KEY_Greek_LAMBDA = 1995;
pub const __guarded_by = lock;
pub const _clear87 = _clearfp;
pub const _FPCLASS_PZ = 64;
pub const GDK_KEY_Serbian_je = 1704;
pub const GDK_KEY_EuroSign = 8364;
pub const GTK_STYLE_CLASS_CALENDAR = c"calendar";
pub const GDK_KEY_KP_Enter = 65421;
pub const GDK_KEY_Arabic_hamza_below = 16778837;
pub const G_FILE_ATTRIBUTE_UNIX_IS_MOUNTPOINT = c"unix::is-mountpoint";
pub const EDOM = 33;
pub const G_TIME_SPAN_DAY = if (@typeId(@typeOf(86400000000)) == @import("builtin").TypeId.Pointer) @ptrCast(G_GINT64_CONSTANT, 86400000000) else if (@typeId(@typeOf(86400000000)) == @import("builtin").TypeId.Int) @intToPtr(G_GINT64_CONSTANT, 86400000000) else G_GINT64_CONSTANT(86400000000);
pub const PANGO_DEPRECATED_IN_1_42 = PANGO_DEPRECATED;
pub const G_ALLOC_ONLY = 1;
pub const GDK_KEY_igrave = 236;
pub const cairo_set_target_png = cairo_set_target_png_DEPRECATED_BY_cairo_surface_write_to_png;
pub const GTK_STOCK_SELECT_COLOR = if (@typeId(@typeOf(c"gtk-select-color")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-select-color") else if (@typeId(@typeOf(c"gtk-select-color")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-select-color") else GtkStock(c"gtk-select-color");
pub const __BMI__ = 1;
pub const GDK_KEY_Arabic_fatha = 1518;
pub const GDK_KEY_Hangul_SingleCandidate = 65340;
pub const GDK_KEY_Pointer_Button5 = 65261;
pub const GDK_KEY_Ybelowdot = 16785140;
pub const GDK_KEY_Acircumflex = 194;
pub const GDK_KEY_Delete = 65535;
pub const GDK_KEY_Switch_VT_5 = 269024773;
pub const GDK_KEY_ahook = 16785059;
pub const GDK_KEY_braille_dots_4568 = 16787640;
pub const GDK_KEY_R14 = 65503;
pub const GDK_KEY_Music = 269025170;
pub const GDK_KEY_hebrew_yod = 3305;
pub const GDK_KEY_Emacron = 938;
pub const GDK_KEY_marker = 2751;
pub const G_GSIZE_FORMAT = c"llu";
pub const GDK_VERSION_MIN_REQUIRED = GDK_VERSION_CUR_STABLE;
pub const GDK_KEY_braille_dots_2467 = 16787562;
pub const GDK_KEY_Launch8 = 269025096;
pub const SEEK_SET = 0;
pub const ESRCH = 3;
pub const GDK_KEY_KP_2 = 65458;
pub const GDK_KEY_Prev_Virtual_Screen = 65233;
pub const GDK_KEY_Sinh_ka = 16780698;
pub const GDK_KEY_Hangul_Jieuj = 3768;
pub const GDK_KEY_ampersand = 38;
pub const GDK_KEY_braille_dots_2568 = 16787634;
pub const GDK_KEY_braille_dots_3567 = 16787572;
pub const GDK_KEY_Sinh_ttha = 16780712;
pub const PANGO_AVAILABLE_IN_1_16 = _PANGO_EXTERN;
pub const GDK_KEY_dcaron = 495;
pub const GDK_KEY_Arabic_meem = 1509;
pub const GDK_KEY_kana_TO = 1220;
pub const GDK_KEY_Georgian_ban = 16781521;
pub const __FLT_MIN__ = 0.000000;
pub const GDK_KEY_6 = 54;
pub const __readableTo = extent;
pub const GDK_KEY_s = 115;
pub const GTK_STYLE_CLASS_MESSAGE_DIALOG = c"message-dialog";
pub const GDK_KEY_Otilde = 213;
pub const __useHeader = _Use_decl_anno_impl_;
pub const ULONG_MAX = c_ulong(4294967295);
pub const __releases_shared_lock = lock;
pub const __UINT_LEAST32_FMTX__ = c"X";
pub const GDK_KEY_Hangul_J_Pieub = 3812;
pub const G_USEC_PER_SEC = 1000000;
pub const GDK_KEY_Uhorngrave = 16785130;
pub const __UINT_FAST16_FMTo__ = c"ho";
pub const GTK_STYLE_CLASS_READ_ONLY = c"read-only";
pub const PANGO_ANALYSIS_FLAG_IS_ELLIPSIS = 1 << 1;
pub const GDK_KEY_twosuperior = 178;
pub const _Acquires_lock_ = lock;
pub const SIGBREAK = 21;
pub const GDK_KEY_Lcaron = 421;
pub const _HEAPOK = -2;
pub const GDK_KEY_3270_Jump = 64786;
pub const GDK_KEY_Sinh_ee2 = 16780762;
pub const GTK_STOCK_DISCARD = if (@typeId(@typeOf(c"gtk-discard")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-discard") else if (@typeId(@typeOf(c"gtk-discard")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-discard") else GtkStock(c"gtk-discard");
pub const __SIZE_FMTx__ = c"llx";
pub const GDK_KEY_Thai_phinthu = 3546;
pub const GDK_AVAILABLE_IN_3_20 = _GDK_EXTERN;
pub const PANGO_AVAILABLE_IN_1_34 = _PANGO_EXTERN;
pub const GDK_KEY_3270_Attn = 64782;
pub const GDK_KEY_Agrave = 192;
pub const GTK_STYLE_CLASS_MENU = c"menu";
pub const EBADF = 9;
pub const GTK_STYLE_CLASS_SCALE_HAS_MARKS_ABOVE = c"scale-has-marks-above";
pub const GDK_KEY_Open = 269025131;
pub const GDK_KEY_umacron = 1022;
pub const GDK_KEY_Tab = 65289;
pub const cairo_surface_get_matrix = cairo_surface_get_matrix_DEPRECATED_BY_cairo_pattern_get_matrix;
pub const _FPCLASS_QNAN = 2;
pub const GDK_KEY_dead_acute = 65105;
pub const DBL_TRUE_MIN = 0.000000;
pub const SW_ZERODIVIDE = _SW_ZERODIVIDE;
pub const FLT_EVAL_METHOD = 0;
pub const GDK_KEY_emopenrectangle = 2767;
pub const _Guarded_by_ = lock;
pub const GDK_KEY_ocircumflex = 244;
pub const __llvm__ = 1;
pub const G_MINSHORT = SHRT_MIN;
pub const __UINT_FAST64_MAX__ = c_ulonglong(18446744073709551615);
pub const G_VARIANT_TYPE_BOOLEAN = if (@typeId(@typeOf(c"b")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"b") else if (@typeId(@typeOf(c"b")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"b") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"b");
pub const GDK_KEY_Back = 269025062;
pub const GDK_KEY_Armenian_zhe = 16778602;
pub const GDK_KEY_Pointer_DownLeft = 65254;
pub const GDK_KEY_Pabovedot = 16784982;
pub const GDK_KEY_braille_dots_123457 = 16787551;
pub const GDK_KEY_o = 111;
pub const GDK_KEY_Thorn = 222;
pub const GDK_KEY_Cyrillic_u_macron = 16778479;
pub const CAIRO_MIME_TYPE_JBIG2_GLOBAL_ID = c"application/x-cairo.jbig2-global-id";
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES = 1;
pub const GDK_KEY_Up = 65362;
pub const GDK_KEY_Hangul_Mieum = 3761;
pub const GDK_KEY_lacute = 485;
pub const _HEAPEND = -5;
pub const GDK_PIXBUF_MINOR = 40;
pub const __INT32_MAX__ = 2147483647;
pub const GTK_MINOR_VERSION = 24;
pub const GDK_KEY_KP_Space = 65408;
pub const GDK_KEY_ISO_Group_Latch = 65030;
pub const GTK_LEVEL_BAR_OFFSET_FULL = c"full";
pub const _IC_AFFINE = 262144;
pub const GDK_KEY_braille_dots_1378 = 16787653;
pub const GTK_STYLE_CLASS_RIGHT = c"right";
pub const GDK_KEY_botrightsummation = 2230;
pub const GDK_KEY_braille_dots_12378 = 16787655;
pub const DBL_ROUNDS = _DBL_ROUNDS;
pub const __UINT_LEAST32_MAX__ = c_uint(4294967295);
pub const GDK_KEY_ToDoList = 269025055;
pub const GDK_KEY_F18 = 65487;
pub const GDK_KEY_Serbian_nje = 1706;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_READONLY = c"filesystem::readonly";
pub const GDK_KEY_Thai_totao = 3509;
pub const GDK_KEY_Eabovedot = 972;
pub const GDK_KEY_similarequal = 2249;
pub const LDBL_DECIMAL_DIG = __LDBL_DECIMAL_DIG__;
pub const GDK_KEY_Ncaron = 466;
pub const GDK_KEY_Armenian_full_stop = 16778633;
pub const CAIRO_TAG_DEST = c"cairo.dest";
pub const GDK_KEY_vt = 2537;
pub const G_FILE_ATTRIBUTE_STANDARD_TYPE = c"standard::type";
pub const GDK_KEY_Atilde = 195;
pub const GDK_KEY_3270_AltCursor = 64784;
pub const PANGO_GLYPH_INVALID_INPUT = if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Pointer) @ptrCast(PangoGlyph, 4294967295) else if (@typeId(@typeOf(4294967295)) == @import("builtin").TypeId.Int) @intToPtr(PangoGlyph, 4294967295) else PangoGlyph(4294967295);
pub const SIG_GET = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(_crt_signal_t, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(_crt_signal_t, 2) else _crt_signal_t(2);
pub const GDK_KEY_KP_Divide = 65455;
pub const GDK_KEY_enspace = 2722;
pub const GDK_KEY_Obelowdot = 16785100;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_REMOTE = c"filesystem::remote";
pub const GDK_KEY_Ohornacute = 16785114;
pub const __INT_FAST8_MAX__ = 127;
pub const G_GUINTPTR_FORMAT = c"llu";
pub const GDK_KEY_kana_E = 1204;
pub const GDK_KEY_checkerboard = 2529;
pub const GDK_KEY_KP_F3 = 65427;
pub const GTK_PRINT_SETTINGS_RESOLUTION_Y = c"resolution-y";
pub const G_PRIORITY_DEFAULT = 0;
pub const GDK_KEY_LaunchE = 269025102;
pub const GLIB_DEPRECATED_MACRO_IN_2_58 = GLIB_DEPRECATED_MACRO;
pub const __INTPTR_MAX__ = c_longlong(9223372036854775807);
pub const GDK_KEY_dead_belowcomma = 65134;
pub const GDK_KEY_dead_perispomeni = 65107;
pub const GDK_KEY_Thai_bobaimai = 3514;
pub const GDK_KEY_Greek_THETA = 1992;
pub const GDK_KEY_Icircumflex = 206;
pub const GDK_KEY_threesubscript = 16785539;
pub const GDK_KEY_Thai_lekkao = 3577;
pub const GDK_KEY_AudioMicMute = 269025202;
pub const GDK_KEY_Arabic_6 = 16778854;
pub const __INTMAX_FMTi__ = c"lli";
pub const GDK_KEY_horizlinescan9 = 2547;
pub const GDK_KEY_twosubscript = 16785538;
pub const GDK_KEY_Cyrillic_ghe = 1735;
pub const GDK_KEY_New = 269025128;
pub const GTK_STOCK_PASTE = if (@typeId(@typeOf(c"gtk-paste")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-paste") else if (@typeId(@typeOf(c"gtk-paste")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-paste") else GtkStock(c"gtk-paste");
pub const CAIRO_HAS_PDF_SURFACE = 1;
pub const _MAX_DIR = 256;
pub const GDK_KEY_Reload = 269025139;
pub const GDK_KEY_braille_dots_1358 = 16787605;
pub const GDK_KEY_braille_dots_134567 = 16787581;
pub const GTK_STYLE_CLASS_PRIMARY_TOOLBAR = c"primary-toolbar";
pub const GDK_KEY_Thai_saraaimaimuan = 3555;
pub const GLIB_DEPRECATED_ENUMERATOR = G_DEPRECATED;
pub const EM_INVALID = _EM_INVALID;
pub const GDK_KEY_F6 = 65475;
pub const GTK_STYLE_REGION_ROW = c"row";
pub const GDK_KEY_Armenian_KEN = 16778559;
pub const GDK_KEY_ISO_Release_Margin_Right = 65066;
pub const g_cclosure_marshal_BOOL__FLAGS = g_cclosure_marshal_BOOLEAN__FLAGS;
pub const GDK_KEY_Armenian_question = 16778590;
pub const GDK_KEY_Greek_accentdieresis = 1966;
pub const ENOPROTOOPT = 123;
pub const GTK_STOCK_JUMP_TO = if (@typeId(@typeOf(c"gtk-jump-to")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-jump-to") else if (@typeId(@typeOf(c"gtk-jump-to")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-jump-to") else GtkStock(c"gtk-jump-to");
pub const GDK_KEY_Sinh_pha = 16780725;
pub const ENOMSG = 122;
pub const cairo_atsui_font_face_create_for_atsu_font_id = cairo_atsui_font_face_create_for_atsu_font_id_REPLACED_BY_cairo_quartz_font_face_create_for_atsu_font_id;
pub const GDK_KEY_opentribulletdown = 2788;
pub const GDK_KEY_Pointer_Down = 65251;
pub const GDK_KEY_Greek_ETA = 1991;
pub const PANGO_SCALE = 1024;
pub const GDK_KEY_decimalpoint = 2749;
pub const __ATOMIC_SEQ_CST = 5;
pub const GDK_KEY_Hangul_YAE = 3778;
pub const GDK_KEY_3270_Setup = 64791;
pub const GDK_KEY_script_switch = 65406;
pub const SIGSEGV = 11;
pub const __SIZEOF_LONG_LONG__ = 8;
pub const _Use_decl_annotations_ = _Use_decl_anno_impl_;
pub const GDK_KEY_Scedilla = 426;
pub const LDBL_MIN_10_EXP = DBL_MIN_10_EXP;
pub const _Readable_elements_impl_ = size;
pub const GDK_KEY_Switch_VT_6 = 269024774;
pub const GDK_KEY_Abelowdot = 16785056;
pub const __UINT8_MAX__ = 255;
pub const cairo_current_tolerance = cairo_current_tolerance_REPLACED_BY_cairo_get_tolerance;
pub const _CRT_HAS_CXX17 = 0;
pub const cairo_current_line_join = cairo_current_line_join_REPLACED_BY_cairo_get_line_join;
pub const GDK_KEY_ograve = 242;
pub const __UINT16_FMTo__ = c"ho";
pub const PC_64 = _PC_64;
pub const __OPENCL_MEMORY_SCOPE_DEVICE = 2;
pub const GDK_KEY_Armenian_fe = 16778630;
pub const GDK_KEY_Sinh_aa = 16780678;
pub const _Notvalid_ = _Notvalid_impl_;
pub const GLIB_DEPRECATED_IN_2_38 = GLIB_DEPRECATED;
pub const __elem_readableTo = size;
pub const GDK_KEY_hyphen = 173;
pub const GDK_KEY_KP_3 = 65459;
pub const GDK_KEY_equal = 61;
pub const GDK_KEY_Georgian_don = 16781523;
pub const GTK_ENTRY_BUFFER_MAX_SIZE = G_MAXUSHORT;
pub const GDK_KEY_Cyrillic_o = 1743;
pub const GDK_KEY_c_h = 65187;
pub const _Pre_ = _Pre_impl_;
pub const GDK_KEY_Word = 269025161;
pub const __FLT_MAX__ = 340282346999999984391321947108527833088.000000;
pub const PANGO_AVAILABLE_IN_1_26 = _PANGO_EXTERN;
pub const GDK_KEY_7 = 55;
pub const GDK_KEY_VendorHome = 269025076;
pub const GDK_KEY_LightBulb = 269025077;
pub const GDK_KEY_t = 116;
pub const _EM_AMBIGUIOUS = 2147483648;
pub const G_KEY_FILE_DESKTOP_KEY_ACTIONS = c"Actions";
pub const PANGO_SCALE_SMALL = if (@typeId(@typeOf(0.833333)) == @import("builtin").TypeId.Pointer) @ptrCast(double, 0.833333) else if (@typeId(@typeOf(0.833333)) == @import("builtin").TypeId.Int) @intToPtr(double, 0.833333) else double(0.833333);
pub const GLIB_DEPRECATED_TYPE_IN_2_40 = GLIB_DEPRECATED_TYPE;
pub const GTK_MICRO_VERSION = 12;
pub const G_FILE_ATTRIBUTE_TIME_CREATED_USEC = c"time::created-usec";
pub const GDK_KEY_musicalsharp = 2805;
pub const GDK_KEY_scircumflex = 766;
pub const EM_AMBIGUIOUS = _EM_AMBIGUOUS;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY = 0;
pub const GDK_KEY_Jcircumflex = 684;
pub const _DN_FLUSH_OPERANDS_SAVE_RESULTS = 33554432;
pub const __UINTPTR_FMTx__ = c"llx";
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 = 1;
pub const GDK_KEY_Greek_omegaaccent = 1979;
pub const GDK_KEY_schwa = 16777817;
pub const _GrouP_impl_ = annos;
pub const GDK_KEY_Execute = 65378;
pub const GDK_KEY_Prev_VMode = 269024803;
pub const EROFS = 30;
pub const __INT_LEAST8_MAX__ = 127;
pub const GDK_KEY_Hangul_O = 3783;
pub const GDK_KEY_Romaji = 65316;
pub const GDK_KEY_dead_o = 65158;
pub const GDK_KEY_Georgian_on = 16781533;
pub const ENOTTY = 25;
pub const GDK_KEY_braille_dots_35678 = 16787700;
pub const GDK_KEY_kana_yu = 1197;
pub const PANGO_SCALE_MEDIUM = if (@typeId(@typeOf(1.000000)) == @import("builtin").TypeId.Pointer) @ptrCast(double, 1.000000) else if (@typeId(@typeOf(1.000000)) == @import("builtin").TypeId.Int) @intToPtr(double, 1.000000) else double(1.000000);
pub const LLONG_MAX = __LONG_LONG_MAX__;
pub const PANGO_AVAILABLE_IN_1_44 = _PANGO_EXTERN;
pub const G_TYPE_RESERVED_BSE_FIRST = 32;
pub const GTK_STYLE_CLASS_WIDE = c"wide";
pub const GDK_KEY_Greek_PI = 2000;
pub const __inexpressible_readableTo = size;
pub const CHAR_MIN = SCHAR_MIN;
pub const GDK_KEY_Armenian_FE = 16778582;
pub const GDK_KEY_Armenian_vyun = 16778626;
pub const GDK_KEY_LogOff = 269025121;
pub const GDK_KEY_Sinh_au = 16780694;
pub const GTK_STOCK_PRINT = if (@typeId(@typeOf(c"gtk-print")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-print") else if (@typeId(@typeOf(c"gtk-print")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-print") else GtkStock(c"gtk-print");
pub const GDK_KEY_AudibleBell_Enable = 65146;
pub const __UINT_FAST32_FMTo__ = c"o";
pub const GDK_KEY_braille_dots_2367 = 16787558;
pub const GDK_KEY_filledrighttribullet = 2781;
pub const FLT_MIN_10_EXP = -37;
pub const GDK_KEY_Red = 269025187;
pub const __XSAVEOPT__ = 1;
pub const GDK_KEY_Greek_MU = 1996;
pub const _TRUNCATE = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(size_t, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(size_t, -1) else size_t(-1);
pub const GDK_KEY_Lbelowdot = 16784950;
pub const GDK_KEY_braille_dots_124578 = 16787675;
pub const FPE_SQRTNEG = _FPE_SQRTNEG;
pub const GDK_KEY_braille_dots_13456 = 16787517;
pub const GDK_KEY_Cyrillic_U_straight = 16778414;
pub const ATK_MICRO_VERSION = 1;
pub const GDK_KEY_3270_FieldMark = 64770;
pub const GDK_KEY_AudioRewind = 269025086;
pub const G_LITTLE_ENDIAN = 1234;
pub const ENOTCONN = 126;
pub const __UINT_LEAST32_FMTx__ = c"x";
pub const GDK_KEY_Cyrillic_es = 1747;
pub const GTK_STOCK_DND = if (@typeId(@typeOf(c"gtk-dnd")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-dnd") else if (@typeId(@typeOf(c"gtk-dnd")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-dnd") else GtkStock(c"gtk-dnd");
pub const GDK_KEY_Tcaron = 427;
pub const CAIRO_HAS_SVG_SURFACE = 1;
pub const GDK_KEY_Arabic_heh_goal = 16778945;
pub const FLT_NORMALIZE = 0;
pub const GDK_DEPRECATED_IN_3_10 = GDK_DEPRECATED;
pub const G_KEY_FILE_DESKTOP_KEY_HIDDEN = c"Hidden";
pub const GDK_KEY_kana_ya = 1196;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_START_DEGRADED = c"mountable::can-start-degraded";
pub const _FPE_INVALID = 129;
pub const cairo_current_line_cap = cairo_current_line_cap_REPLACED_BY_cairo_get_line_cap;
pub const GTK_STOCK_ORIENTATION_PORTRAIT = if (@typeId(@typeOf(c"gtk-orientation-portrait")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-orientation-portrait") else if (@typeId(@typeOf(c"gtk-orientation-portrait")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-orientation-portrait") else GtkStock(c"gtk-orientation-portrait");
pub const G_STRFUNC = if (@typeId(@typeOf(__func__)) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]char)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]char) else if (@typeId(@typeOf([*c]char)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]char) else @"const"([*c]char), __func__) else if (@typeId(@typeOf(__func__)) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]char)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]char) else if (@typeId(@typeOf([*c]char)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]char) else @"const"([*c]char), __func__) else if (@typeId(@typeOf([*c]char)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]char) else if (@typeId(@typeOf([*c]char)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]char) else @"const"([*c]char)(__func__);
pub const GDK_KEY_leftpointer = 2794;
pub const GDK_KEY_Cyrillic_che = 1758;
pub const GDK_KEY_ocircumflextilde = 16785111;
pub const __STDC_VERSION__ = c_long(201112);
pub const G_GNUC_STRFTIME = format_idx;
pub const CAIRO_MIME_TYPE_JP2 = c"image/jp2";
pub const GDK_KEY_braille_dots_25678 = 16787698;
pub const GDK_KEY_OfficeHome = 269025130;
pub const G_IEEE754_DOUBLE_BIAS = 1023;
pub const __INT_LEAST8_FMTi__ = c"hhi";
pub const G_MININT32 = if (@typeId(@typeOf(if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT32, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT32, -1) else (-G_MAXINT32)(-1))) == @import("builtin").TypeId.Pointer) @ptrCast(gint32, if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT32, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT32, -1) else (-G_MAXINT32)(-1)) else if (@typeId(@typeOf(if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT32, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT32, -1) else (-G_MAXINT32)(-1))) == @import("builtin").TypeId.Int) @intToPtr(gint32, if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT32, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT32, -1) else (-G_MAXINT32)(-1)) else gint32(if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT32, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT32, -1) else (-G_MAXINT32)(-1));
pub const SW_INVALID = _SW_INVALID;
pub const GTK_PRINT_SETTINGS_RESOLUTION_X = c"resolution-x";
pub const GDK_KEY_LaunchD = 269025101;
pub const _ALLOCA_S_HEAP_MARKER = 56797;
pub const GDK_KEY_braille_dots_12578 = 16787667;
pub const _Maybevalid_ = _Maybevalid_impl_;
pub const GDK_KEY_downstile = 3012;
pub const __INT_LEAST16_FMTi__ = c"hi";
pub const GLIB_DEPRECATED_IN_2_52 = GLIB_DEPRECATED;
pub const RC_DOWN = _RC_DOWN;
pub const GDK_KEY_braille_dots_1478 = 16787657;
pub const __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 = 1;
pub const GDK_KEY_Cyrillic_YERU = 1785;
pub const GDK_KEY_Armenian_dza = 16778609;
pub const FPE_OVERFLOW = _FPE_OVERFLOW;
pub const GDK_KEY_F7 = 65476;
pub const GDK_KEY_tabovedot = 16785003;
pub const GDK_KEY_Greek_SIGMA = 2002;
pub const GDK_KEY_WLAN = 269025173;
pub const GDK_KEY_Thai_paiyannoi = 3535;
pub const GDK_KEY_ohook = 16785103;
pub const GDK_KEY_Georgian_gan = 16781522;
pub const GDK_KEY_Georgian_he = 16781553;
pub const GLIB_SYSDEF_MSG_PEEK = 2;
pub const GLIB_AVAILABLE_IN_2_38 = _GLIB_EXTERN;
pub const __FSGSBASE__ = 1;
pub const G_MAXUSHORT = USHRT_MAX;
pub const __FLT_EVAL_METHOD__ = 0;
pub const __SSE_MATH__ = 1;
pub const GDK_KEY_braille_dots_23578 = 16787670;
pub const GTK_STOCK_JUSTIFY_RIGHT = if (@typeId(@typeOf(c"gtk-justify-right")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-justify-right") else if (@typeId(@typeOf(c"gtk-justify-right")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-justify-right") else GtkStock(c"gtk-justify-right");
pub const GDK_KEY_Armenian_shesht = 16778587;
pub const GDK_KEY_braille_dots_234 = 16787470;
pub const __UINT_FAST8_FMTo__ = c"hho";
pub const FLT_EPSILON = 0.000000;
pub const G_PI_2 = 1.570796;
pub const __INT8_MAX__ = 127;
pub const GDK_KEY_Arabic_ddal = 16778888;
pub const GDK_KEY_Acircumflexbelowdot = 16785068;
pub const GTK_STOCK_APPLY = if (@typeId(@typeOf(c"gtk-apply")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-apply") else if (@typeId(@typeOf(c"gtk-apply")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-apply") else GtkStock(c"gtk-apply");
pub const GDK_KEY_MyComputer = 269025075;
pub const GDK_KEY_musicalflat = 2806;
pub const __DBL_DECIMAL_DIG__ = 17;
pub const GTK_PRINT_SETTINGS_OUTPUT_DIR = c"output-dir";
pub const FALSE = 0;
pub const GDK_KEY_braille_dots_34 = 16787468;
pub const GDK_KEY_Thai_lochula = 3532;
pub const GDK_KEY_Armenian_KE = 16778580;
pub const GDK_KEY_Return = 65293;
pub const GDK_KEY_union = 2269;
pub const GDK_KEY_Armenian_INI = 16778555;
pub const GDK_KEY_Hangul_AE = 3776;
pub const PANGO_DEPRECATED_IN_1_40 = PANGO_DEPRECATED;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_48 = GLIB_DEPRECATED_ENUMERATOR;
pub const __LDBL_MAX_EXP__ = 1024;
pub const G_VARIANT_TYPE_VARDICT = if (@typeId(@typeOf(c"a{sv}")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"a{sv}") else if (@typeId(@typeOf(c"a{sv}")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"a{sv}") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"a{sv}");
pub const GDK_KEY_3270_Test = 64781;
pub const _WIN64 = 1;
pub const GDK_KEY_ecircumflexhook = 16785091;
pub const GTK_PAPER_NAME_EXECUTIVE = c"na_executive";
pub const __LONG_MAX__ = c_long(2147483647);
pub const EM_AMBIGUOUS = _EM_AMBIGUOUS;
pub const G_KEY_FILE_DESKTOP_KEY_COMMENT = c"Comment";
pub const GDK_KEY_yen = 165;
pub const __pic__ = 2;
pub const GDK_KEY_braille_dots_1458 = 16787609;
pub const GDK_KEY_KP_Insert = 65438;
pub const GDK_KEY_obarred = 16777845;
pub const GDK_KEY_Switch_VT_7 = 269024775;
pub const __LDBL_DENORM_MIN__ = 0.000000;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_EJECT = c"mountable::can-eject";
pub const GDK_KEY_braille_dots_458 = 16787608;
pub const GDK_KEY_Suspend = 269025191;
pub const GDK_KEY_Greek_DELTA = 1988;
pub const GDK_KEY_Cyrillic_che_descender = 16778423;
pub const FPE_INVALID = _FPE_INVALID;
pub const CAIRO_HAS_FT_FONT = 1;
pub const GDK_KEY_Ukrainian_I = 1718;
pub const GDK_KEY_eightsuperior = 16785528;
pub const GDK_KEY_topleftsqbracket = 2215;
pub const GDK_KEY_dead_doublegrave = 65126;
pub const GDK_KEY_Iacute = 205;
pub const GDK_KEY_odoubleacute = 501;
pub const CLK_TCK = CLOCKS_PER_SEC;
pub const G_FILE_ATTRIBUTE_UNIX_RDEV = c"unix::rdev";
pub const PANGO_AVAILABLE_IN_1_18 = _PANGO_EXTERN;
pub const GDK_KEY_cr = 2532;
pub const _MAX_PATH = 260;
pub const GDK_KEY_H = 72;
pub const GDK_KEY_Sinh_ma = 16780728;
pub const GDK_KEY_eabovedot = 1004;
pub const GDK_KEY_Ntilde = 209;
pub const GDK_KEY_u = 117;
pub const GDK_KEY_Georgian_chin = 16781545;
pub const GDK_KEY_Greek_PSI = 2008;
pub const GDK_VERSION_MAX_ALLOWED = GDK_VERSION_MIN_REQUIRED;
pub const EEXIST = 17;
pub const GDK_KEY_Armenian_ayb = 16778593;
pub const __ATOMIC_ACQUIRE = 2;
pub const GDK_KEY_ISO_First_Group = 65036;
pub const __requires_exclusive_lock_held = lock;
pub const GTK_STYLE_CLASS_DIM_LABEL = c"dim-label";
pub const EM_INEXACT = _EM_INEXACT;
pub const GDK_KEY_ballotcross = 2804;
pub const __UINT_FAST8_FMTX__ = c"hhX";
pub const GDK_KEY_Arabic_hah = 1485;
pub const GDK_KEY_Georgian_we = 16781555;
pub const GTK_STOCK_DIALOG_ERROR = if (@typeId(@typeOf(c"gtk-dialog-error")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-dialog-error") else if (@typeId(@typeOf(c"gtk-dialog-error")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-dialog-error") else GtkStock(c"gtk-dialog-error");
pub const GDK_KEY_FFrancSign = 16785571;
pub const __UINT_FAST16_FMTX__ = c"hX";
pub const GDK_KEY_emfilledcircle = 2782;
pub const __UINT_FAST32_FMTx__ = c"x";
pub const GDK_KEY_Ukranian_je = 1700;
pub const control87 = _control87;
pub const EMSGSIZE = 115;
pub const GDK_KEY_Sinh_ii = 16780682;
pub const GDK_KEY_braille_dots_478 = 16787656;
pub const GDK_PIXBUF_AVAILABLE_IN_2_20 = _GDK_PIXBUF_EXTERN;
pub const GDK_AVAILABLE_IN_3_22 = _GDK_EXTERN;
pub const GDK_KEY_Racute = 448;
pub const PANGO_AVAILABLE_IN_1_32 = _PANGO_EXTERN;
pub const GDK_KEY_Hangul_SsangJieuj = 3769;
pub const GDK_KEY_braille_dots_123468 = 16787631;
pub const GDK_KEY_Hangul_Banja = 65337;
pub const GDK_KEY_Thai_khokhwai = 3492;
pub const __x86_64 = 1;
pub const cairo_current_fill_rule = cairo_current_fill_rule_REPLACED_BY_cairo_get_fill_rule;
pub const GDK_KEY_caron = 439;
pub const GDK_KEY_MonBrightnessDown = 269025027;
pub const GDK_KEY_Zacute = 428;
pub const cairo_matrix_get_affine = cairo_matrix_get_affine_DEPRECATED_BY_cairo_matrix_t;
pub const __UINTMAX_FMTo__ = c"llo";
pub const GDK_KEY_Thai_saraue = 3542;
pub const GDK_KEY_Muhenkan = 65314;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_32 = GLIB_DEPRECATED_ENUMERATOR;
pub const GDK_KEY_sabovedot = 16784993;
pub const GDK_KEY_hebrew_kuf = 3319;
pub const __F16C__ = 1;
pub const _EM_INVALID = 16;
pub const PANGO_DEPRECATED_IN_1_10 = PANGO_DEPRECATED;
pub const GLIB_SYSDEF_AF_INET6 = 23;
pub const GTK_STYLE_CLASS_MONOSPACE = c"monospace";
pub const GDK_KEY_a = 97;
pub const _CRT_BUILD_DESKTOP_APP = 1;
pub const cairo_copy = cairo_copy_DEPRECATED_BY_cairo_create_AND_MANY_INDIVIDUAL_FUNCTIONS;
pub const GDK_KEY_hebrew_teth = 3304;
pub const GDK_KEY_braille_dots_13457 = 16787549;
pub const GDK_KEY_quotedbl = 34;
pub const GDK_KEY_Greek_alpha = 2017;
pub const GDK_KEY_minutes = 2774;
pub const GDK_KEY_Explorer = 269025117;
pub const GDK_KEY_Sinh_nja = 16780710;
pub const GTK_STOCK_CAPS_LOCK_WARNING = if (@typeId(@typeOf(c"gtk-caps-lock-warning")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-caps-lock-warning") else if (@typeId(@typeOf(c"gtk-caps-lock-warning")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-caps-lock-warning") else GtkStock(c"gtk-caps-lock-warning");
pub const GDK_KEY_Cyrillic_er = 1746;
pub const GDK_KEY_AudioRepeat = 269025176;
pub const G_KEY_FILE_DESKTOP_KEY_NOT_SHOW_IN = c"NotShowIn";
pub const cairo_current_matrix = cairo_current_matrix_REPLACED_BY_cairo_get_matrix;
pub const __FLT_RADIX__ = 2;
pub const GDK_KEY_dead_belowdiaeresis = 65132;
pub const GDK_KEY_hebrew_pe = 3316;
pub const GDK_KEY_kana_conjunctive = 1189;
pub const GDK_KEY_braille_dots_345678 = 16787708;
pub const SW_INEXACT = _SW_INEXACT;
pub const GDK_KEY_BackSpace = 65288;
pub const GDK_KEY_Print = 65377;
pub const GDK_KEY_Cyrillic_LJE = 1721;
pub const GDK_KEY_Sinh_ba = 16780726;
pub const G_DATALIST_FLAGS_MASK = 3;
pub const GDK_KEY_Cyrillic_U_macron = 16778478;
pub const GDK_KEY_Kana_Lock = 65325;
pub const _Satisfies_impl_ = expr;
pub const _ARGMAX = 100;
pub const ATK_AVAILABLE_IN_2_10 = _ATK_EXTERN;
pub const GTK_STOCK_GOTO_BOTTOM = if (@typeId(@typeOf(c"gtk-goto-bottom")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-goto-bottom") else if (@typeId(@typeOf(c"gtk-goto-bottom")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-goto-bottom") else GtkStock(c"gtk-goto-bottom");
pub const GDK_KEY_Hangul_RieulKiyeog = 3754;
pub const __INT64_FMTi__ = c"lli";
pub const GDK_KEY_braille_dots_1245 = 16787483;
pub const GDK_KEY_masculine = 186;
pub const GDK_KEY_Arabic_zain = 1490;
pub const GDK_KEY_lefttack = 3036;
pub const GDK_KEY_Hangul_Start = 65330;
pub const GDK_KEY_KP_F1 = 65425;
pub const GDK_DEPRECATED_IN_3_24 = GDK_DEPRECATED;
pub const GDK_KEY_Thai_loling = 3525;
pub const __LDBL_MIN__ = 0.000000;
pub const GDK_KEY_Armenian_TYUN = 16778575;
pub const _CRT_SIZE_MAX = if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(size_t, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(size_t, -1) else size_t(-1);
pub const __CLANG_ATOMIC_LLONG_LOCK_FREE = 2;
pub const GTK_STOCK_DIALOG_INFO = if (@typeId(@typeOf(c"gtk-dialog-info")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-dialog-info") else if (@typeId(@typeOf(c"gtk-dialog-info")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-dialog-info") else GtkStock(c"gtk-dialog-info");
pub const GDK_KEY_threequarters = 190;
pub const GDK_KEY_braille_dots_1258 = 16787603;
pub const __CRTDECL = __CLRCALL_PURE_OR_CDECL;
pub const __UINT_LEAST64_FMTX__ = c"llX";
pub const __clang_minor__ = 0;
pub const GDK_KEY_Page_Up = 65365;
pub const _CRT_STDIO_INLINE = __inline;
pub const GDK_KEY_Cyrillic_ie = 1733;
pub const PANGO_DEPRECATED_IN_1_8 = PANGO_DEPRECATED;
pub const GDK_KEY_braille_dots_13468 = 16787629;
pub const _FPE_ZERODIVIDE = 131;
pub const GDK_KEY_F4 = 65473;
pub const FLT_DECIMAL_DIG = 9;
pub const G_TYPE_RESERVED_USER_FIRST = 49;
pub const __UINT_FAST64_FMTo__ = c"llo";
pub const GTK_STOCK_UNDERLINE = if (@typeId(@typeOf(c"gtk-underline")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-underline") else if (@typeId(@typeOf(c"gtk-underline")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-underline") else GtkStock(c"gtk-underline");
pub const GDK_KEY_Armenian_E = 16778551;
pub const GLIB_DEPRECATED_MACRO_IN_2_30 = GLIB_DEPRECATED_MACRO;
pub const GDK_KEY_botleftsqbracket = 2216;
pub const _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS = c_ulonglong(1) << 4;
pub const GDK_KEY_Thai_yoying = 3501;
pub const GDK_KEY_Arabic_theh = 1483;
pub const GDK_KEY_Cyrillic_nje = 1706;
pub const GDK_KEY_braille_dots_235 = 16787478;
pub const GDK_KEY_Armenian_AYB = 16778545;
pub const GDK_KEY_because = 16785973;
pub const stderr = if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Pointer) @ptrCast(__acrt_iob_func, 2) else if (@typeId(@typeOf(2)) == @import("builtin").TypeId.Int) @intToPtr(__acrt_iob_func, 2) else __acrt_iob_func(2);
pub const GDK_KEY_Cyrillic_tse = 1731;
pub const GDK_KEY_kana_comma = 1188;
pub const GDK_KEY_Greek_UPSILONdieresis = 1961;
pub const __UINT8_FMTX__ = c"hhX";
pub const __byte_writableTo = size;
pub const GDK_KEY_braille_dots_35 = 16787476;
pub const GDK_KEY_Cyrillic_YA = 1777;
pub const GDK_KEY_dead_belowcircumflex = 65129;
pub const cairo_transform_point = cairo_transform_point_REPLACED_BY_cairo_user_to_device;
pub const GDK_KEY_kana_MO = 1235;
pub const GDK_KEY_braille_dots_24678 = 16787690;
pub const GDK_KEY_acircumflexgrave = 16785063;
pub const __UINT8_FMTx__ = c"hhx";
pub const _EM_INEXACT = 1;
pub const _FPE_STACKOVERFLOW = 138;
pub const GDK_KEY_braille_dots_1278 = 16787651;
pub const GDK_KEY_eightsubscript = 16785544;
pub const __ORDER_LITTLE_ENDIAN__ = 1234;
pub const GDK_KEY_rightopentriangle = 2765;
pub const GDK_KEY_Hangul_WE = 3790;
pub const GDK_KEY_nabla = 2245;
pub const GDK_KEY_braille_dots_14568 = 16787641;
pub const GDK_KEY_R11 = 65500;
pub const GDK_KEY_Eisu_Shift = 65327;
pub const GDK_KEY_braille_dots_28 = 16787586;
pub const GDK_KEY_ETH = 208;
pub const GDK_KEY_Arabic_alefmaksura = 1513;
pub const GDK_KEY_Massyo = 65324;
pub const _FPCLASS_NINF = 4;
pub const GTK_STOCK_OK = if (@typeId(@typeOf(c"gtk-ok")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-ok") else if (@typeId(@typeOf(c"gtk-ok")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-ok") else GtkStock(c"gtk-ok");
pub const MAXPATHLEN = 1024;
pub const __RETURN_POLICY_VOID = _FunctionCall;
pub const ENOSPC = 28;
pub const GDK_KEY_Cyrillic_IE = 1765;
pub const g_macro__has_builtin = __has_builtin;
pub const GDK_KEY_I = 73;
pub const GDK_KEY_Forward = 269025063;
pub const G_FILE_ATTRIBUTE_ID_FILE = c"id::file";
pub const GDK_KEY_v = 118;
pub const GDK_KEY_LogWindowTree = 269024804;
pub const G_LOG_LEVEL_USER_SHIFT = 8;
pub const GDK_KEY_RotateWindows = 269025140;
pub const _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION = c_ulonglong(1) << 0;
pub const GDK_KEY_Thai_soso = 3499;
pub const __acquires_shared_lock = lock;
pub const GDK_KEY_Arabic_superscript_alef = 16778864;
pub const __elem_writableTo = size;
pub const GTK_PRINT_SETTINGS_COLLATE = c"collate";
pub const GDK_KEY_wacute = 16785027;
pub const GDK_KEY_Hangul_J_SsangKiyeog = 3797;
pub const __CLANG_ATOMIC_LONG_LOCK_FREE = 2;
pub const GDK_KEY_Sinh_i = 16780681;
pub const GDK_KEY_ccircumflex = 742;
pub const __acquires_exclusive_lock = lock;
pub const _MCW_EM = 524319;
pub const SW_STACKUNDERFLOW = _SW_STACKUNDERFLOW;
pub const GLIB_MICRO_VERSION = 1;
pub const GTK_STOCK_LEAVE_FULLSCREEN = if (@typeId(@typeOf(c"gtk-leave-fullscreen")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-leave-fullscreen") else if (@typeId(@typeOf(c"gtk-leave-fullscreen")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-leave-fullscreen") else GtkStock(c"gtk-leave-fullscreen");
pub const GDK_KEY_F20 = 65489;
pub const __INT_LEAST64_FMTi__ = c"lli";
pub const GDK_KEY_Arabic_beh = 1480;
pub const __AVX__ = 1;
pub const GDK_KEY_Cyrillic_u_straight_bar = 16778417;
pub const GDK_KEY_botrightsqbracket = 2218;
pub const GDK_KEY_Greek_OMICRON = 1999;
pub const GDK_KEY_braille_dots_2358 = 16787606;
pub const GDK_KEY_ApplicationLeft = 269025104;
pub const __CLANG_ATOMIC_CHAR16_T_LOCK_FREE = 2;
pub const GDK_KEY_Abrevehook = 16785074;
pub const GDK_KEY_braille_dots_146 = 16787497;
pub const GTK_STYLE_CLASS_WARNING = c"warning";
pub const EWOULDBLOCK = 140;
pub const PANGO_AVAILABLE_IN_1_42 = _PANGO_EXTERN;
pub const GTK_PAPER_NAME_LETTER = c"na_letter";
pub const GDK_KEY_Bluetooth = 269025172;
pub const GDK_KEY_ellipsis = 2734;
pub const GTK_STOCK_REFRESH = if (@typeId(@typeOf(c"gtk-refresh")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-refresh") else if (@typeId(@typeOf(c"gtk-refresh")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-refresh") else GtkStock(c"gtk-refresh");
pub const GDK_KEY_ISO_Lock = 65025;
pub const GDK_KEY_slash = 47;
pub const GDK_KEY_Cyrillic_yeru = 1753;
pub const GDK_KEY_acircumflexacute = 16785061;
pub const GDK_KEY_emptyset = 16785925;
pub const GDK_KEY_Eth = 208;
pub const GTK_STYLE_CLASS_MENUITEM = c"menuitem";
pub const GDK_KEY_xabovedot = 16785035;
pub const CAIRO_MIME_TYPE_EPS = c"application/postscript";
pub const GDK_KEY_braille_dots_157 = 16787537;
pub const GDK_KEY_Gabovedot = 725;
pub const GDK_KEY_MailForward = 269025168;
pub const GDK_KEY_Cyrillic_A = 1761;
pub const GDK_KEY_sterling = 163;
pub const GDK_KEY_braille_dots_278 = 16787650;
pub const __UINT_FAST8_MAX__ = 255;
pub const __DBL_MIN_10_EXP__ = -307;
pub const LONG_MAX = c_long(2147483647);
pub const GDK_KEY_Armenian_ligature_ew = 16778631;
pub const CHAR_MAX = SCHAR_MAX;
pub const G_FILE_ATTRIBUTE_FILESYSTEM_USED = c"filesystem::used";
pub const GDK_KEY_Hangul_KiyeogSios = 3747;
pub const GDK_KEY_b = 98;
pub const GDK_KEY_cacute = 486;
pub const GLIB_AVAILABLE_IN_2_50 = _GLIB_EXTERN;
pub const GDK_KEY_Hangul_NieunHieuh = 3750;
pub const __SSE3__ = 1;
pub const GDK_KEY_Cyrillic_softsign = 1752;
pub const GDK_KEY_braille_dots_13458 = 16787613;
pub const GDK_KEY_Oslash = 216;
pub const GTK_STOCK_DIRECTORY = if (@typeId(@typeOf(c"gtk-directory")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-directory") else if (@typeId(@typeOf(c"gtk-directory")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-directory") else GtkStock(c"gtk-directory");
pub const __UINT_FAST32_FMTu__ = c"u";
pub const GDK_KEY_Amacron = 960;
pub const GDK_KEY_horizconnector = 2211;
pub const GDK_KEY_Georgian_par = 16781534;
pub const GDK_KEY_Terminal = 269025152;
pub const __SSP_STRONG__ = 2;
pub const GDK_KEY_Greek_epsilon = 2021;
pub const GDK_KEY_Sinh_u = 16780683;
pub const GDK_KEY_braille_dots_2378 = 16787654;
pub const GDK_KEY_nobreakspace = 160;
pub const GDK_KEY_rightcaret = 2982;
pub const GDK_KEY_Thai_honokhuk = 3534;
pub const GTK_STOCK_PREFERENCES = if (@typeId(@typeOf(c"gtk-preferences")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-preferences") else if (@typeId(@typeOf(c"gtk-preferences")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-preferences") else GtkStock(c"gtk-preferences");
pub const GDK_KEY_Ubelowdot = 16785124;
pub const GDK_KEY_Hangul_Khieuq = 3771;
pub const GDK_KEY_ogonek = 434;
pub const GDK_KEY_Hangul_NieunJieuj = 3749;
pub const GDK_KEY_braille_dots_1235 = 16787479;
pub const GTK_STYLE_CLASS_POPOVER = c"popover";
pub const GDK_KEY_Zenkaku_Hankaku = 65322;
pub const GDK_KEY_Uhorn = 16777647;
pub const __FXSR__ = 1;
pub const GDK_KEY_Thai_oang = 3533;
pub const __WCHAR_UNSIGNED__ = 1;
pub const cairo_current_path_flat = cairo_current_path_flat_DEPRECATED_BY_cairo_copy_path_flat;
pub const __UINT32_FMTx__ = c"x";
pub const GDK_KEY_uparrow = 2300;
pub const GDK_DEPRECATED_IN_3_16 = GDK_DEPRECATED;
pub const G_E = 2.718282;
pub const GDK_KEY_dead_horn = 65122;
pub const __SIZE_MAX__ = c_ulonglong(18446744073709551615);
pub const cairo_matrix_destroy = cairo_matrix_destroy_DEPRECATED_BY_cairo_matrix_t;
pub const GDK_KEY_Abrevegrave = 16785072;
pub const GDK_KEY_Sinh_ae2 = 16780752;
pub const GDK_KEY_KP_Multiply = 65450;
pub const GDK_KEY_braille_dots_234567 = 16787582;
pub const CAIRO_HAS_FC_FONT = 1;
pub const GDK_KEY_RepeatKeys_Enable = 65138;
pub const G_FILE_ATTRIBUTE_TRASH_ITEM_COUNT = c"trash::item-count";
pub const ENAMETOOLONG = 38;
pub const GDK_KEY_tslash = 956;
pub const GDK_KEY_braille_dots_1246 = 16787499;
pub const GDK_KEY_braille_dots_1467 = 16787561;
pub const GDK_KEY_Sinh_na = 16780721;
pub const GDK_KEY_Georgian_cil = 16781548;
pub const GDK_KEY_Arabic_thal = 1488;
pub const GDK_KEY_Greek_LAMDA = 1995;
pub const GDK_KEY_Ubreve = 733;
pub const GDK_KEY_braille_dots_138 = 16787589;
pub const __UINT64_C_SUFFIX__ = ULL;
pub const GDK_KEY_Zen_Koho = 65341;
pub const _Analysis_assume_lock_released_ = lock;
pub const _SW_DENORMAL = 524288;
pub const GDK_KEY_Sinh_cha = 16780705;
pub const GTK_INTERFACE_AGE = 7;
pub const GTK_STOCK_REDO = if (@typeId(@typeOf(c"gtk-redo")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-redo") else if (@typeId(@typeOf(c"gtk-redo")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-redo") else GtkStock(c"gtk-redo");
pub const G_FILE_ATTRIBUTE_STANDARD_ALLOCATED_SIZE = c"standard::allocated-size";
pub const GDK_KEY_Cyrillic_U = 1781;
pub const G_MODULE_SUFFIX = c"dll";
pub const GDK_KEY_Gcaron = 16777702;
pub const GDK_KEY_Thai_maihanakat_maitho = 3550;
pub const GLIB_DEPRECATED_IN_2_50 = GLIB_DEPRECATED;
pub const _HEAPBADNODE = -4;
pub const GDK_KEY_braille_dots_1257 = 16787539;
pub const GDK_KEY_ch = 65184;
pub const GDK_KEY_braille_dots_245 = 16787482;
pub const GDK_KEY_gbreve = 699;
pub const GDK_KEY_Thai_sarau = 3544;
pub const GDK_KEY_Idiaeresis = 207;
pub const GDK_KEY_Greek_nu = 2029;
pub const GDK_KEY_Thai_lekpaet = 3576;
pub const GDK_KEY_F5 = 65474;
pub const GDK_KEY_kana_SE = 1214;
pub const GDK_KEY_braille_dots_123678 = 16787687;
pub const GDK_KEY_enopencircbullet = 2784;
pub const GDK_KEY_braille_dots_45 = 16787480;
pub const GLIB_DEPRECATED_TYPE_IN_2_28 = GLIB_DEPRECATED_TYPE;
pub const GDK_KEY_leftt = 2548;
pub const GDK_KEY_Sinh_jha = 16780707;
pub const GDK_KEY_enfilledsqbullet = 2791;
pub const GDK_KEY_abrevehook = 16785075;
pub const CW_DEFAULT = _CW_DEFAULT;
pub const __LDBL_MAX_10_EXP__ = 308;
pub const GDK_KEY_Arabic_lam = 1508;
pub const GDK_KEY_Favorites = 269025072;
pub const GDK_KEY_braille_dots_236 = 16787494;
pub const GDK_KEY_otilde = 245;
pub const GDK_KEY_uring = 505;
pub const GDK_KEY_Serbian_dje = 1697;
pub const GDK_KEY_AudioNext = 269025047;
pub const GTK_STOCK_ITALIC = if (@typeId(@typeOf(c"gtk-italic")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-italic") else if (@typeId(@typeOf(c"gtk-italic")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-italic") else GtkStock(c"gtk-italic");
pub const cairo_matrix_copy = cairo_matrix_copy_DEPRECATED_BY_cairo_matrix_t;
pub const GDK_KEY_bott = 2550;
pub const GDK_KEY_Pointer_Drag1 = 65269;
pub const GDK_KEY_braille_dots_12458 = 16787611;
pub const GDK_KEY_threesuperior = 179;
pub const GDK_KEY_braille_dots_36 = 16787492;
pub const GTK_STYLE_CLASS_LINKED = c"linked";
pub const GLIB_DEPRECATED_MACRO_IN_2_44 = GLIB_DEPRECATED_MACRO;
pub const GDK_KEY_braille_dots_3578 = 16787668;
pub const GDK_KEY_rightshoe = 3032;
pub const GTK_STYLE_CLASS_DEFAULT = c"default";
pub const G_TLS_BACKEND_EXTENSION_POINT_NAME = c"gio-tls-backend";
pub const GDK_KEY_braille_dots_1235678 = 16787703;
pub const __INT_FAST32_FMTd__ = c"d";
pub const GDK_KEY_HotLinks = 269025082;
pub const GDK_KEY_Arabic_tatweel = 1504;
pub const GDK_KEY_babovedot = 16784899;
pub const GDK_KEY_Switch_VT_1 = 269024769;
pub const GDK_KEY_braille_dots_56 = 16787504;
pub const __OPENCL_MEMORY_SCOPE_SUB_GROUP = 4;
pub const GDK_KEY_R10 = 65499;
pub const GDK_KEY_braille_dots_27 = 16787522;
pub const GDK_KEY_Hangul_RieulMieum = 3755;
pub const GDK_KEY_Georgian_ghan = 16781542;
pub const UINT_MAX = 4294967295;
pub const GDK_KEY_Hangul_EO = 3779;
pub const GDK_KEY_Sinh_al = 16780746;
pub const GDK_KEY_braille_dots_23458 = 16787614;
pub const gdk_pixbuf_save = gdk_pixbuf_save_utf8;
pub const GTK_STOCK_PRINT_WARNING = if (@typeId(@typeOf(c"gtk-print-warning")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-print-warning") else if (@typeId(@typeOf(c"gtk-print-warning")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-print-warning") else GtkStock(c"gtk-print-warning");
pub const GDK_KEY_Armenian_khe = 16778605;
pub const GDK_KEY_ssharp = 223;
pub const GDK_KEY_braille_dots_1234678 = 16787695;
pub const GDK_KEY_Georgian_man = 16781531;
pub const __INT_LEAST64_MAX__ = c_longlong(9223372036854775807);
pub const GDK_KEY_J = 74;
pub const GDK_KEY_Thai_yoyak = 3522;
pub const GDK_KEY_w = 119;
pub const GDK_KEY_Hangul_J_RieulKiyeog = 3804;
pub const GDK_KEY_kra = 930;
pub const GDK_KEY_Hangul_J_Khieuq = 3819;
pub const GDK_KEY_Clear = 65291;
pub const G_PRIORITY_LOW = 300;
pub const GTK_STYLE_PROVIDER_PRIORITY_FALLBACK = 1;
pub const FPE_EXPLICITGEN = _FPE_EXPLICITGEN;
pub const GDK_KEY_braille_dots_12478 = 16787659;
pub const GDK_KEY_Ukrainian_ie = 1700;
pub const GDK_KEY_Armenian_o = 16778629;
pub const GDK_KEY_Acircumflextilde = 16785066;
pub const PANGO_ATTR_INDEX_TO_TEXT_END = G_MAXUINT;
pub const GDK_KEY_crossinglines = 2542;
pub const EXIT_SUCCESS = 0;
pub const PANGO_AVAILABLE_IN_1_2 = _PANGO_EXTERN;
pub const G_URI_RESERVED_CHARS_GENERIC_DELIMITERS = c":/?#[]@";
pub const __SIZEOF_FLOAT__ = 4;
pub const GDK_KEY_Georgian_zen = 16781526;
pub const _FPCLASS_PINF = 512;
pub const __requires_lock_held = lock;
pub const GDK_KEY_RupeeSign = 16785576;
pub const GTK_PRINT_SETTINGS_OUTPUT_FILE_FORMAT = c"output-file-format";
pub const __INT_LEAST32_FMTd__ = c"d";
pub const GDK_KEY_Ocircumflexacute = 16785104;
pub const GDK_KEY_ISO_Partial_Line_Up = 65059;
pub const GDK_KEY_F21 = 65490;
pub const GLIB_DEPRECATED_TYPE_IN_2_52 = GLIB_DEPRECATED_TYPE;
pub const GDK_KEY_Sinh_sha = 16780737;
pub const __postcond = expr;
pub const GDK_KEY_Paste = 269025133;
pub const GDK_KEY_Hangul_Hieuh = 3774;
pub const GDK_KEY_numbersign = 35;
pub const GDK_KEY_Greek_CHI = 2007;
pub const ECANCELED = 105;
pub const GDK_KEY_mabovedot = 16784961;
pub const _EM_DENORMAL = 524288;
pub const GDK_PIXBUF_AVAILABLE_IN_2_22 = _GDK_PIXBUF_EXTERN;
pub const GDK_KEY_braille_dots_147 = 16787529;
pub const PANGO_AVAILABLE_IN_1_30 = _PANGO_EXTERN;
pub const GDK_KEY_Armenian_TSO = 16778577;
pub const cairo_surface_set_filter = cairo_surface_set_filter_DEPRECATED_BY_cairo_pattern_set_filter;
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_TRASH = c"access::can-trash";
pub const CAIRO_MIME_TYPE_UNIQUE_ID = c"application/x-cairo.uuid";
pub const _Requires_lock_held_ = lock;
pub const GDK_KEY_Sinh_u2 = 16780756;
pub const GDK_KEY_Yacute = 221;
pub const GDK_KEY_atilde = 227;
pub const GTK_STYLE_PROPERTY_COLOR = c"color";
pub const G_MAXINT8 = if (@typeId(@typeOf(127)) == @import("builtin").TypeId.Pointer) @ptrCast(gint8, 127) else if (@typeId(@typeOf(127)) == @import("builtin").TypeId.Int) @intToPtr(gint8, 127) else gint8(127);
pub const GDK_KEY_Messenger = 269025166;
pub const GDK_KEY_Stop = 269025064;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_30 = GLIB_DEPRECATED_ENUMERATOR;
pub const CAIRO_HAS_USER_FONT = 1;
pub const alloca = _alloca;
pub const GDK_KEY_kana_HI = 1227;
pub const __declare_lock_level = level;
pub const GDK_KEY_Hangul_J_Cieuc = 3818;
pub const GDK_KEY_braille_dots_156 = 16787505;
pub const EPIPE = 32;
pub const GDK_KEY_Pointer_Button_Dflt = 65256;
pub const GDK_KEY_Cyrillic_PE = 1776;
pub const PANGO_DEPRECATED_IN_1_12 = PANGO_DEPRECATED;
pub const GDK_KEY_Thai_saraaa = 3538;
pub const GDK_KEY_itilde = 949;
pub const GTK_PRINT_SETTINGS_OUTPUT_BASENAME = c"output-basename";
pub const ETXTBSY = 139;
pub const __override = __inner_override;
pub const __DBL_HAS_DENORM__ = 1;
pub const GDK_KEY_c = 99;
pub const GDK_KEY_integral = 2239;
pub const GDK_KEY_SelectButton = 269025184;
pub const GDK_KEY_Sinh_ra = 16780731;
pub const GDK_KEY_Armenian_DA = 16778548;
pub const DBL_RADIX = _DBL_RADIX;
pub const GLIB_AVAILABLE_IN_2_60 = _GLIB_EXTERN;
pub const GDK_KEY_Ch = 65185;
pub const GDK_KEY_exclam = 33;
pub const GDK_KEY_Ihook = 16785096;
pub const EPERM = 1;
pub const GDK_KEY_abrevegrave = 16785073;
pub const GDK_KEY_Option = 269025132;
pub const GDK_KEY_AudioMute = 269025042;
pub const __AVX2__ = 1;
pub const __WINT_MAX__ = 65535;
pub const CAIRO_VERSION_MINOR = 16;
pub const GDK_KEY_Armenian_CHA = 16778569;
pub const GTK_PAPER_NAME_LEGAL = c"na_legal";
pub const GDK_KEY_Hangul_J_RieulSios = 3807;
pub const GDK_KEY_braille_dots_123568 = 16787639;
pub const ENFILE = 23;
pub const G_KEY_FILE_DESKTOP_TYPE_APPLICATION = c"Application";
pub const _USEDENTRY = 1;
pub const CAIRO_TAG_LINK = c"Link";
pub const GDK_KEY_braille_dots_1234 = 16787471;
pub const __acquires_lock = lock;
pub const _PC_53 = 65536;
pub const GDK_KEY_Sinh_va = 16780736;
pub const GDK_KEY_TouchpadToggle = 269025193;
pub const _HAS_EXCEPTIONS = 1;
pub const GTK_STYLE_PROPERTY_BORDER_COLOR = c"border-color";
pub const GDK_KEY_Armenian_ini = 16778603;
pub const GDK_KEY_Find = 65384;
pub const stdout = if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Pointer) @ptrCast(__acrt_iob_func, 1) else if (@typeId(@typeOf(1)) == @import("builtin").TypeId.Int) @intToPtr(__acrt_iob_func, 1) else __acrt_iob_func(1);
pub const EIO = 5;
pub const cairo_surface_set_matrix = cairo_surface_set_matrix_DEPRECATED_BY_cairo_pattern_set_matrix;
pub const GDK_KEY_Zcaron = 430;
pub const PANGO_DEPRECATED_IN_1_38 = PANGO_DEPRECATED;
pub const GDK_KEY_Armenian_SHA = 16778567;
pub const ATK_AVAILABLE_IN_2_12 = _ATK_EXTERN;
pub const GDK_KEY_Armenian_ke = 16778628;
pub const GDK_KEY_uhornhook = 16785133;
pub const GDK_KEY_braille_dots_1247 = 16787531;
pub const GDK_KEY_kana_YO = 1238;
pub const GDK_KEY_Cyrillic_zhe = 1750;
pub const __INT_LEAST32_MAX__ = 2147483647;
pub const GDK_KEY_kana_I = 1202;
pub const GDK_KEY_Ecircumflexacute = 16785086;
pub const GDK_DEPRECATED_IN_3_22 = GDK_DEPRECATED;
pub const GDK_KEY_ISO_Discontinuous_Underline = 65073;
pub const __OPENCL_MEMORY_SCOPE_WORK_GROUP = 1;
pub const GDK_KEY_Hangul_PreHanja = 65338;
pub const GTK_STYLE_CLASS_INFO = c"info";
pub const GDK_KEY_notequal = 2237;
pub const GTK_STYLE_CLASS_SUBTITLE = c"subtitle";
pub const __LITTLE_ENDIAN__ = 1;
pub const GDK_KEY_Ecircumflextilde = 16785092;
pub const __FLT_HAS_QUIET_NAN__ = 1;
pub const GDK_KEY_braille_dots_1256 = 16787507;
pub const __RETURN_POLICY_DST = _FunctionCall;
pub const __CLANG_ATOMIC_WCHAR_T_LOCK_FREE = 2;
pub const GDK_KEY_iogonek = 999;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_IS_MEDIA_CHECK_AUTOMATIC = c"mountable::is-media-check-automatic";
pub const GDK_KEY_cursor = 2815;
pub const GTK_STYLE_CLASS_CURSOR_HANDLE = c"cursor-handle";
pub const IC_AFFINE = _IC_AFFINE;
pub const G_PDP_ENDIAN = 3412;
pub const GLIB_DEPRECATED_MACRO_IN_2_32 = GLIB_DEPRECATED_MACRO;
pub const GTK_STOCK_SELECT_FONT = if (@typeId(@typeOf(c"gtk-select-font")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-select-font") else if (@typeId(@typeOf(c"gtk-select-font")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-select-font") else GtkStock(c"gtk-select-font");
pub const GDK_KEY_Cyrillic_ka = 1739;
pub const GTK_STYLE_CLASS_CHECK = c"check";
pub const GDK_KEY_Greek_omicronaccent = 1975;
pub const GTK_STOCK_YES = if (@typeId(@typeOf(c"gtk-yes")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-yes") else if (@typeId(@typeOf(c"gtk-yes")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-yes") else GtkStock(c"gtk-yes");
pub const GDK_KEY_etilde = 16785085;
pub const GLIB_DEPRECATED_IN_2_44 = GLIB_DEPRECATED;
pub const GDK_KEY_Korean_Won = 3839;
pub const GDK_KEY_Georgian_khar = 16781541;
pub const LDBL_EPSILON = DBL_EPSILON;
pub const GDK_KEY_emspace = 2721;
pub const EINTR = 4;
pub const GDK_KEY_Armenian_apostrophe = 16778586;
pub const GDK_KEY_braille_dots_237 = 16787526;
pub const GDK_KEY_ISO_First_Group_Lock = 65037;
pub const GDK_KEY_Cyrillic_EM = 1773;
pub const GDK_KEY_thinspace = 2727;
pub const GDK_KEY_Hangul_J_Mieum = 3811;
pub const GDK_KEY_WonSign = 16785577;
pub const GDK_KEY_Pointer_Drag2 = 65270;
pub const PANGO_SCALE_XX_LARGE = if (@typeId(@typeOf(1.728000)) == @import("builtin").TypeId.Pointer) @ptrCast(double, 1.728000) else if (@typeId(@typeOf(1.728000)) == @import("builtin").TypeId.Int) @intToPtr(double, 1.728000) else double(1.728000);
pub const __FLT_MAX_10_EXP__ = 38;
pub const GDK_KEY_braille_dots_37 = 16787524;
pub const GDK_KEY_oneeighth = 2755;
pub const GDK_KEY_hebrew_nun = 3312;
pub const GDK_KEY_Kcedilla = 979;
pub const GDK_KEY_kana_MI = 1232;
pub const GDK_KEY_Ukranian_JE = 1716;
pub const G_UNICHAR_MAX_DECOMPOSITION_LENGTH = 18;
pub const GLIB_SIZEOF_LONG = 4;
pub const GDK_KEY_Sinh_aee2 = 16780753;
pub const G_VARIANT_TYPE_STRING = if (@typeId(@typeOf(c"s")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"s") else if (@typeId(@typeOf(c"s")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"s") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"s");
pub const __DBL_MIN__ = 0.000000;
pub const EPROTO = 134;
pub const GDK_KEY_Arabic_dammatan = 1516;
pub const _WIN32 = 1;
pub const GDK_KEY_Greek_chi = 2039;
pub const GDK_KEY_braille_dots_135678 = 16787701;
pub const GDK_KEY_braille_dots_13568 = 16787637;
pub const cairo_current_operator = cairo_current_operator_REPLACED_BY_cairo_get_operator;
pub const GDK_KEY_Switch_VT_2 = 269024770;
pub const GDK_KEY_braille_dots_57 = 16787536;
pub const GDK_KEY_TopMenu = 269025186;
pub const GDK_KEY_R13 = 65502;
pub const GTK_STYLE_PROPERTY_MARGIN = c"margin";
pub const GDK_KEY_braille_dots_26 = 16787490;
pub const INT_MAX = 2147483647;
pub const GDK_KEY_Greek_ETAaccent = 1955;
pub const GDK_KEY_ohorngrave = 16785117;
pub const GTK_STOCK_GOTO_LAST = if (@typeId(@typeOf(c"gtk-goto-last")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-goto-last") else if (@typeId(@typeOf(c"gtk-goto-last")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-goto-last") else GtkStock(c"gtk-goto-last");
pub const GDK_KEY_Thai_dochada = 3502;
pub const GDK_KEY_braille_dots_23457 = 16787550;
pub const GDK_KEY_Launch3 = 269025091;
pub const GDK_KEY_kana_RO = 1243;
pub const GDK_KEY_Georgian_un = 16781539;
pub const _Group_impl_ = annos;
pub const GDK_KEY_Byelorussian_SHORTU = 1726;
pub const GDK_KEY_braille_dots_134678 = 16787693;
pub const GTK_LEVEL_BAR_OFFSET_HIGH = c"high";
pub const GDK_KEY_K = 75;
pub const GTK_STOCK_FULLSCREEN = if (@typeId(@typeOf(c"gtk-fullscreen")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-fullscreen") else if (@typeId(@typeOf(c"gtk-fullscreen")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-fullscreen") else GtkStock(c"gtk-fullscreen");
pub const GDK_KEY_KP_Tab = 65417;
pub const GDK_KEY_3270_Quit = 64777;
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_DELETE = c"access::can-delete";
pub const GDK_KEY_greaterthanequal = 2238;
pub const GLIB_DEPRECATED_TYPE_IN_2_44 = GLIB_DEPRECATED_TYPE;
pub const GDK_KEY_Omacron = 978;
pub const __INT_FAST8_FMTd__ = c"hhd";
pub const GDK_KEY_ISO_Group_Shift = 65406;
pub const ENOTRECOVERABLE = 127;
pub const GDK_KEY_hebrew_zayin = 3302;
pub const _FPE_SQRTNEG = 136;
pub const GTK_STYLE_CLASS_HIGHLIGHT = c"highlight";
pub const G_FILE_ATTRIBUTE_UNIX_GID = c"unix::gid";
pub const GDK_KEY_Serbian_lje = 1705;
pub const FLT_GUARD = 0;
pub const GDK_KEY_Sinh_o = 16780692;
pub const G_GUINT32_FORMAT = c"u";
pub const G_FILE_ATTRIBUTE_MOUNTABLE_UNIX_DEVICE = c"mountable::unix-device";
pub const G_FILE_ATTRIBUTE_ACCESS_CAN_RENAME = c"access::can-rename";
pub const _SW_INVALID = 16;
pub const GDK_KEY_braille_dots_2578 = 16787666;
pub const cairo_show_surface = cairo_show_surface_DEPRECATED_BY_cairo_set_source_surface_AND_cairo_paint;
pub const GDK_KEY_Hangul_Romaja = 65334;
pub const GDK_KEY_ordfeminine = 170;
pub const GDK_KEY_Armenian_je = 16778619;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE = 1;
pub const _Requires_shared_lock_held_ = lock;
pub const GDK_KEY_Hangul_J_Kiyeog = 3796;
pub const __FLT_MAX_EXP__ = 128;
pub const GDK_KEY_Hiragana_Katakana = 65319;
pub const GDK_KEY_Hangul_SsangPieub = 3763;
pub const GDK_KEY_F22 = 65491;
pub const GDK_KEY_Cyrillic_che_vertstroke = 16778425;
pub const GDK_KEY_kana_NO = 1225;
pub const __INT_FAST64_FMTi__ = c"lli";
pub const G_FILE_ATTRIBUTE_STANDARD_ICON = c"standard::icon";
pub const cairo_current_miter_limit = cairo_current_miter_limit_REPLACED_BY_cairo_get_miter_limit;
pub const GDK_KEY_Armenian_ho = 16778608;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_26 = GLIB_DEPRECATED_ENUMERATOR;
pub const cairo_inverse_transform_point = cairo_inverse_transform_point_REPLACED_BY_cairo_device_to_user;
pub const GDK_KEY_greater = 62;
pub const _SAL_VERSION = 20;
pub const GDK_KEY_fourfifths = 2741;
pub const GDK_KEY_Arabic_ha = 1511;
pub const GDK_KEY_KP_Add = 65451;
pub const GDK_KEY_braille_dots_1245678 = 16787707;
pub const G_MINLONG = LONG_MIN;
pub const PANGO_AVAILABLE_IN_1_40 = _PANGO_EXTERN;
pub const GDK_KEY_ccedilla = 231;
pub const GDK_KEY_Thai_thothahan = 3511;
pub const GDK_KEY_F33 = 65502;
pub const ENETRESET = 117;
pub const GDK_KEY_braille_dots_1578 = 16787665;
pub const GDK_KEY_3270_CursorBlink = 64783;
pub const GTK_PRINT_SETTINGS_PAPER_HEIGHT = c"paper-height";
pub const cairo_matrix_set_identity = cairo_matrix_set_identity_REPLACED_BY_cairo_matrix_init_identity;
pub const GDK_KEY_Greek_GAMMA = 1987;
pub const GDK_KEY_Cyrillic_VE = 1783;
pub const __inner_blocksOn = resource;
pub const G_MAXUINT8 = if (@typeId(@typeOf(255)) == @import("builtin").TypeId.Pointer) @ptrCast(guint8, 255) else if (@typeId(@typeOf(255)) == @import("builtin").TypeId.Int) @intToPtr(guint8, 255) else guint8(255);
pub const GDK_KEY_Cyrillic_hardsign = 1759;
pub const GDK_PIXBUF_AVAILABLE_IN_2_32 = _GDK_PIXBUF_EXTERN;
pub const GDK_KEY_braille_dots_24578 = 16787674;
pub const GDK_KEY_Ocaron = 16777681;
pub const G_MAXSSIZE = G_MAXINT64;
pub const LDBL_MAX = DBL_MAX;
pub const __CHAR_BIT__ = 8;
pub const GDK_KEY_Georgian_can = 16781546;
pub const SEEK_CUR = 1;
pub const GDK_KEY_ocircumflexacute = 16785105;
pub const __callback = __inner_callback;
pub const GDK_KEY_d = 100;
pub const GLIB_AVAILABLE_IN_2_52 = _GLIB_EXTERN;
pub const __FLT_EPSILON__ = 0.000000;
pub const GTK_STOCK_HARDDISK = if (@typeId(@typeOf(c"gtk-harddisk")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-harddisk") else if (@typeId(@typeOf(c"gtk-harddisk")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-harddisk") else GtkStock(c"gtk-harddisk");
pub const SIG_SGE = if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Pointer) @ptrCast(_crt_signal_t, 3) else if (@typeId(@typeOf(3)) == @import("builtin").TypeId.Int) @intToPtr(_crt_signal_t, 3) else _crt_signal_t(3);
pub const G_FILE_ATTRIBUTE_OWNER_USER = c"owner::user";
pub const GDK_KEY_Aogonek = 417;
pub const GDK_KEY_Ugrave = 217;
pub const GDK_KEY_ZoomOut = 269025164;
pub const GDK_KEY_Georgian_tar = 16781538;
pub const G_SIGNAL_TYPE_STATIC_SCOPE = G_TYPE_FLAG_RESERVED_ID_BIT;
pub const GDK_KEY_ApplicationRight = 269025105;
pub const __FLT_HAS_INFINITY__ = 1;
pub const G_LN10 = 2.302585;
pub const GDK_KEY_Armenian_JE = 16778571;
pub const NULL = if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Pointer) @ptrCast([*c]void, 0) else if (@typeId(@typeOf(0)) == @import("builtin").TypeId.Int) @intToPtr([*c]void, 0) else ([*c]void)(0);
pub const GDK_KEY_Sinh_lu = 16780687;
pub const GDK_KEY_braille_dots_1237 = 16787527;
pub const GDK_KEY_Cyrillic_ZE = 1786;
pub const GDK_KEY_Hangul_J_KiyeogSios = 3798;
pub const GDK_KEY_braille_dots_34567 = 16787580;
pub const GDK_KEY_at = 64;
pub const ATK_INTERFACE_AGE = 1;
pub const G_KEY_FILE_DESKTOP_KEY_CATEGORIES = c"Categories";
pub const GDK_KEY_Cyrillic_yu = 1728;
pub const GDK_KEY_topleftsummation = 2225;
pub const GDK_DEPRECATED_IN_3_14 = GDK_DEPRECATED;
pub const CAIRO_HAS_TEE_SURFACE = 1;
pub const GDK_KEY_ooblique = 248;
pub const GDK_KEY_AccessX_Feedback_Enable = 65137;
pub const GDK_KEY_braille_dots_358 = 16787604;
pub const GDK_KEY_hebrew_finalpe = 3315;
pub const __DBL_HAS_QUIET_NAN__ = 1;
pub const GDK_KEY_Shift_L = 65505;
pub const GDK_PIXBUF_MICRO = 0;
pub const GDK_KEY_braille_dots_12368 = 16787623;
pub const GDK_KEY_kana_N = 1245;
pub const GDK_KEY_Xabovedot = 16785034;
pub const GDK_KEY_ecircumflex = 234;
pub const __ORDER_PDP_ENDIAN__ = 3412;
pub const GDK_KEY_uhorn = 16777648;
pub const GDK_KEY_telephonerecorder = 2810;
pub const GDK_KEY_braille_dots_2458 = 16787610;
pub const G_DATE_BAD_DAY = c_uint(0);
pub const G_VOLUME_IDENTIFIER_KIND_CLASS = c"class";
pub const GDK_KEY_AudioForward = 269025175;
pub const GDK_KEY_doubbaselinedot = 2735;
pub const __INT16_TYPE__ = short;
pub const GDK_KEY_Cyrillic_ZHE_descender = 16778390;
pub const GDK_PIXBUF_AVAILABLE_IN_2_8 = _GDK_PIXBUF_EXTERN;
pub const GDK_KEY_Hangul_J_Sios = 3814;
pub const G_FILE_ATTRIBUTE_STANDARD_IS_HIDDEN = c"standard::is-hidden";
pub const GLIB_DEPRECATED_IN_2_56 = GLIB_DEPRECATED;
pub const cairo_xlib_surface_create_for_window_with_visual = cairo_xlib_surface_create_for_window_with_visual_REPLACED_BY_cairo_xlib_surface_create;
pub const GDK_KEY_onesixth = 2742;
pub const GDK_KEY_Hangul_Sios = 3765;
pub const cairo_current_path = cairo_current_path_DEPRECATED_BY_cairo_copy_path;
pub const GDK_KEY_Thai_lekha = 3573;
pub const GDK_KEY_braille_dots_247 = 16787530;
pub const GDK_KEY_Uhornbelowdot = 16785136;
pub const G_FILE_ATTRIBUTE_STANDARD_DESCRIPTION = c"standard::description";
pub const GDK_KEY_P = 80;
pub const GDK_KEY_braille_dots_134568 = 16787645;
pub const GDK_KEY_iacute = 237;
pub const _Pre1_impl_ = p1;
pub const GDK_KEY_Excel = 269025116;
pub const GDK_KEY_Eogonek = 458;
pub const GDK_KEY_TouchpadOff = 269025201;
pub const GDK_KEY_Armenian_ken = 16778607;
pub const __SSE2__ = 1;
pub const GDK_KEY_kana_CHI = 1217;
pub const GDK_KEY_braille_dots_47 = 16787528;
pub const GLIB_DEPRECATED_TYPE = G_DEPRECATED;
pub const GDK_KEY_ntilde = 241;
pub const GDK_KEY_User1KB = 269025157;
pub const __UINT32_MAX__ = c_uint(4294967295);
pub const GDK_KEY_Ycircumflex = 16777590;
pub const GDK_KEY_Go = 269025119;
pub const GDK_KEY_Cyrillic_EL = 1772;
pub const GDK_KEY_braille_dots_1348 = 16787597;
pub const GDK_KEY_Greek_PHI = 2006;
pub const ATK_AVAILABLE_IN_2_2 = _ATK_EXTERN;
pub const GTK_STOCK_MEDIA_FORWARD = if (@typeId(@typeOf(c"gtk-media-forward")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-media-forward") else if (@typeId(@typeOf(c"gtk-media-forward")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-media-forward") else GtkStock(c"gtk-media-forward");
pub const GDK_KEY_braille_dots_67 = 16787552;
pub const __INT8_FMTi__ = c"hhi";
pub const G_VARIANT_TYPE_DICT_ENTRY = if (@typeId(@typeOf(c"{?*}")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"{?*}") else if (@typeId(@typeOf(c"{?*}")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"{?*}") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"{?*}");
pub const GDK_KEY_Pointer_Drag3 = 65271;
pub const GDK_KEY_ISO_Prev_Group = 65034;
pub const GDK_KEY_abrevebelowdot = 16785079;
pub const _ALLOCA_S_THRESHOLD = 1024;
pub const GDK_KEY_Sinh_aee = 16780680;
pub const __CLRCALL_PURE_OR_CDECL = __cdecl;
pub const GLIB_DEPRECATED_MACRO_IN_2_46 = GLIB_DEPRECATED_MACRO;
pub const GDK_KEY_kana_KI = 1207;
pub const GDK_KEY_RotationKB = 269025142;
pub const GDK_KEY_kana_SHI = 1212;
pub const cairo_set_target_pdf = cairo_set_target_pdf_DEPRECATED_BY_cairo_pdf_surface_create;
pub const _FPCLASS_PD = 128;
pub const GDK_KEY_Armenian_nu = 16778614;
pub const GDK_KEY_braille_dots_2478 = 16787658;
pub const GTK_STOCK_STRIKETHROUGH = if (@typeId(@typeOf(c"gtk-strikethrough")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-strikethrough") else if (@typeId(@typeOf(c"gtk-strikethrough")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-strikethrough") else GtkStock(c"gtk-strikethrough");
pub const GDK_KEY_dead_invertedbreve = 65133;
pub const GDK_KEY_Ccaron = 456;
pub const GDK_AVAILABLE_IN_3_14 = _GDK_EXTERN;
pub const GDK_KEY_Sinh_i2 = 16780754;
pub const GDK_KEY_Dstroke = 464;
pub const G_DATE_BAD_JULIAN = c_uint(0);
pub const GDK_KEY_ISO_Partial_Line_Down = 65060;
pub const GDK_KEY_L8 = 65487;
pub const GDK_PIXBUF_AVAILABLE_IN_ALL = _GDK_PIXBUF_EXTERN;
pub const __INT_FAST64_MAX__ = c_longlong(9223372036854775807);
pub const GDK_KEY_Switch_VT_3 = 269024771;
pub const MCW_IC = _MCW_IC;
pub const GDK_KEY_R12 = 65501;
pub const GDK_KEY_braille_dots_25 = 16787474;
pub const __analysis_assume_lock_released = lock;
pub const GDK_KEY_Hangul_YA = 3777;
pub const GDK_KEY_implies = 2254;
pub const GDK_KEY_Zabovedot = 431;
pub const GDK_KEY_Switch_VT_12 = 269024780;
pub const GTK_STOCK_OPEN = if (@typeId(@typeOf(c"gtk-open")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-open") else if (@typeId(@typeOf(c"gtk-open")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-open") else GtkStock(c"gtk-open");
pub const ENOBUFS = 119;
pub const GDK_KEY_braille_dots_23456 = 16787518;
pub const GDK_KEY_Launch2 = 269025090;
pub const __BMI2__ = 1;
pub const GDK_KEY_Arabic_9 = 16778857;
pub const GDK_KEY_Uogonek = 985;
pub const GDK_KEY_L = 76;
pub const NSIG = 23;
pub const GDK_KEY_Hangul_MultipleCandidate = 65341;
pub const cairo_transform_font = cairo_transform_font_REPLACED_BY_cairo_set_font_matrix;
pub const __SIZEOF_POINTER__ = 8;
pub const GDK_KEY_hstroke = 689;
pub const GDK_KEY_includes = 2267;
pub const GDK_KEY_yacute = 253;
pub const GDK_KEY_Sys_Req = 65301;
pub const GDK_KEY_R8 = 65497;
pub const GDK_KEY_Send = 269025147;
pub const GDK_KEY_ocircumflexbelowdot = 16785113;
pub const GDK_KEY_Sinh_gha = 16780701;
pub const __corei7 = 1;
pub const GLIB_DEPRECATED_IN_2_26 = GLIB_DEPRECATED;
pub const PANGO_AVAILABLE_IN_1_4 = _PANGO_EXTERN;
pub const PANGO_SCALE_LARGE = if (@typeId(@typeOf(1.200000)) == @import("builtin").TypeId.Pointer) @ptrCast(double, 1.200000) else if (@typeId(@typeOf(1.200000)) == @import("builtin").TypeId.Int) @intToPtr(double, 1.200000) else double(1.200000);
pub const GDK_KEY_ygrave = 16785139;
pub const GDK_KEY_dead_abovecomma = 65124;
pub const GDK_KEY_ocircumflexhook = 16785109;
pub const ERANGE = 34;
pub const G_FILE_ATTRIBUTE_MOUNTABLE_CAN_POLL = c"mountable::can-poll";
pub const GDK_KEY_diaeresis = 168;
pub const GDK_KEY_Obarred = 16777631;
pub const GDK_KEY_cabovedot = 741;
pub const GDK_KEY_Control_L = 65507;
pub const GLIB_DEPRECATED_TYPE_IN_2_50 = GLIB_DEPRECATED_TYPE;
pub const GDK_KEY_F23 = 65492;
pub const __LDBL_HAS_INFINITY__ = 1;
pub const GDK_KEY_Greek_etaaccent = 1971;
pub const SIGFPE = 8;
pub const GDK_KEY_Greek_alphaaccent = 1969;
pub const GDK_KEY_Greek_gamma = 2019;
pub const GDK_KEY_degree = 176;
pub const G_MININT16 = if (@typeId(@typeOf(if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT16, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT16, -1) else (-G_MAXINT16)(-1))) == @import("builtin").TypeId.Pointer) @ptrCast(gint16, if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT16, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT16, -1) else (-G_MAXINT16)(-1)) else if (@typeId(@typeOf(if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT16, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT16, -1) else (-G_MAXINT16)(-1))) == @import("builtin").TypeId.Int) @intToPtr(gint16, if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT16, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT16, -1) else (-G_MAXINT16)(-1)) else gint16(if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Pointer) @ptrCast(-G_MAXINT16, -1) else if (@typeId(@typeOf(-1)) == @import("builtin").TypeId.Int) @intToPtr(-G_MAXINT16, -1) else (-G_MAXINT16)(-1));
pub const __UINTPTR_FMTo__ = c"llo";
pub const GDK_KEY_dead_abovereversedcomma = 65125;
pub const DBL_MIN_EXP = -1021;
pub const GDK_KEY_ISO_Level5_Shift = 65041;
pub const GDK_KEY_Arabic_ra = 1489;
pub const GDK_KEY_hebrew_finalzadi = 3317;
pub const GDK_KEY_Kanji = 65313;
pub const GDK_PIXBUF_AVAILABLE_IN_2_24 = _GDK_PIXBUF_EXTERN;
pub const GTK_STYLE_CLASS_BOTTOM = c"bottom";
pub const GDK_KEY_braille_dots_145 = 16787481;
pub const GDK_KEY_Greek_upsilondieresis = 1977;
pub const GDK_PIXBUF_FEATURES_H = 1;
pub const _SW_STACKOVERFLOW = 512;
pub const ATK_DEPRECATED_IN_2_8 = ATK_DEPRECATED;
pub const _CRT_INTERNAL_STDIO_SYMBOL_PREFIX = c"";
pub const GTK_STYLE_CLASS_CSD = c"csd";
pub const GDK_KEY_scaron = 441;
pub const GDK_KEY_AddFavorite = 269025081;
pub const GDK_KEY_backslash = 92;
pub const ENOSTR = 125;
pub const GDK_KEY_F32 = 65501;
pub const GDK_KEY_braille_dots_12358 = 16787607;
pub const GLIB_DEPRECATED_ENUMERATOR_IN_2_36 = GLIB_DEPRECATED_ENUMERATOR;
pub const GTK_STYLE_CLASS_TOOLTIP = c"tooltip";
pub const _CALL_REPORTFAULT = 2;
pub const GDK_KEY_Book = 269025106;
pub const GDK_KEY_prescription = 2772;
pub const GDK_KEY_Thai_ngongu = 3495;
pub const GDK_KEY_ISO_Partial_Space_Left = 65061;
pub const GDK_KEY_kana_TSU = 1218;
pub const GDK_KEY_Georgian_jhan = 16781551;
pub const GDK_KEY_Itilde = 933;
pub const PANGO_DEPRECATED_IN_1_14 = PANGO_DEPRECATED;
pub const GDK_KEY_Hebrew_switch = 65406;
pub const GDK_KEY_Pointer_DblClick_Dflt = 65262;
pub const GTK_PRINT_SETTINGS_NUMBER_UP_LAYOUT = c"number-up-layout";
pub const G_FILE_ATTRIBUTE_TRASH_ORIG_PATH = c"trash::orig-path";
pub const G_WIN32_MSG_HANDLE = 19981206;
pub const GDK_KEY_8 = 56;
pub const GDK_KEY_zcaron = 446;
pub const EFAULT = 14;
pub const GDK_KEY_upstile = 3027;
pub const GDK_KEY_e = 101;
pub const GDK_KEY_aring = 229;
pub const GLIB_AVAILABLE_IN_2_62 = _GLIB_EXTERN;
pub const GDK_KEY_odiaeresis = 246;
pub const G_VARIANT_TYPE_UNIT = if (@typeId(@typeOf(c"()")) == @import("builtin").TypeId.Pointer) @ptrCast(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"()") else if (@typeId(@typeOf(c"()")) == @import("builtin").TypeId.Int) @intToPtr(if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType), c"()") else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Pointer) @ptrCast(@"const", [*c]GVariantType) else if (@typeId(@typeOf([*c]GVariantType)) == @import("builtin").TypeId.Int) @intToPtr(@"const", [*c]GVariantType) else @"const"([*c]GVariantType)(c"()");
pub const GDK_KEY_ecircumflexacute = 16785087;
pub const GTK_PRINT_SETTINGS_DEFAULT_SOURCE = c"default-source";
pub const GDK_KEY_Cyrillic_DZHE = 1727;
pub const EALREADY = 103;
pub const G_PARAM_USER_SHIFT = 8;
pub const GDK_KEY_braille_dots_1236 = 16787495;
pub const GDK_KEY_braille_dots_124568 = 16787643;
pub const GDK_KEY_Arabic_veh = 16778916;
pub const GLIB_AVAILABLE_IN_2_42 = _GLIB_EXTERN;
pub const LDBL_DIG = DBL_DIG;
pub const GDK_KEY_Greek_rho = 2033;
pub const GTK_PRINT_SETTINGS_PRINTER_LPI = c"printer-lpi";
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY = 0;
pub const GDK_KEY_KP_Separator = 65452;
pub const __WCHAR_MAX__ = 65535;
pub const PANGO_DEPRECATED_IN_1_36 = PANGO_DEPRECATED;
pub const GDK_KEY_ScrollDown = 269025145;
pub const GDK_KEY_underscore = 95;
pub const ATK_AVAILABLE_IN_2_14 = _ATK_EXTERN;
pub const GTK_STYLE_CLASS_DESTRUCTIVE_ACTION = c"destructive-action";
pub const GDK_KEY_3270_Right2 = 64771;
pub const __UINTMAX_FMTX__ = c"llX";
pub const GDK_KEY_dead_caron = 65114;
pub const GDK_KEY_fabovedot = 16784927;
pub const GDK_KEY_Tcedilla = 478;
pub const GTK_STOCK_MEDIA_NEXT = if (@typeId(@typeOf(c"gtk-media-next")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-media-next") else if (@typeId(@typeOf(c"gtk-media-next")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-media-next") else GtkStock(c"gtk-media-next");
pub const GTK_STOCK_BOLD = if (@typeId(@typeOf(c"gtk-bold")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-bold") else if (@typeId(@typeOf(c"gtk-bold")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-bold") else GtkStock(c"gtk-bold");
pub const _Deref2_post1_impl_ = p1;
pub const GDK_KEY_downarrow = 2302;
pub const LDBL_RADIX = _LDBL_RADIX;
pub const GDK_KEY_Thai_sosala = 3528;
pub const GDK_KEY_Sinh_ng2 = 16780702;
pub const GTK_STOCK_SORT_ASCENDING = if (@typeId(@typeOf(c"gtk-sort-ascending")) == @import("builtin").TypeId.Pointer) @ptrCast(GtkStock, c"gtk-sort-ascending") else if (@typeId(@typeOf(c"gtk-sort-ascending")) == @import("builtin").TypeId.Int) @intToPtr(GtkStock, c"gtk-sort-ascending") else GtkStock(c"gtk-sort-ascending");
pub const GDK_KEY_kana_O = 1205;
pub const FLT_MAX_10_EXP = 38;
pub const GDK_KEY_Thai_sarauu = 3545;
pub const GDK_DEPRECATED_IN_3_20 = GDK_DEPRECATED;
pub const EXDEV = 18;
pub const __crt_locale_data = struct___crt_locale_data;
pub const __crt_multibyte_data = struct___crt_multibyte_data;
pub const _iobuf = struct__iobuf;
pub const _div_t = struct__div_t;
pub const _ldiv_t = struct__ldiv_t;
pub const _lldiv_t = struct__lldiv_t;
pub const tm = struct_tm;
pub const _timespec32 = struct__timespec32;
pub const _timespec64 = struct__timespec64;
pub const timespec = struct_timespec;
pub const _GDoubleIEEE754 = union__GDoubleIEEE754;
pub const _GFloatIEEE754 = union__GFloatIEEE754;
pub const _GTimeVal = struct__GTimeVal;
pub const _heapinfo = struct__heapinfo;
pub const _GBytes = struct__GBytes;
pub const _GArray = struct__GArray;
pub const _GByteArray = struct__GByteArray;
pub const _GPtrArray = struct__GPtrArray;
pub const _GError = struct__GError;
pub const _GDebugKey = struct__GDebugKey;
pub const _GThread = struct__GThread;
pub const _GMutex = union__GMutex;
pub const _GRecMutex = struct__GRecMutex;
pub const _GRWLock = struct__GRWLock;
pub const _GCond = struct__GCond;
pub const _GPrivate = struct__GPrivate;
pub const _GOnce = struct__GOnce;
pub const _GAsyncQueue = struct__GAsyncQueue;
pub const _GBookmarkFile = struct__GBookmarkFile;
pub const _GChecksum = struct__GChecksum;
pub const _GIConv = struct__GIConv;
pub const _GData = struct__GData;
pub const _GDate = struct__GDate;
pub const _GTimeZone = struct__GTimeZone;
pub const _GDateTime = struct__GDateTime;
pub const _GDir = struct__GDir;
pub const _GMemVTable = struct__GMemVTable;
pub const _GNode = struct__GNode;
pub const _GList = struct__GList;
pub const _GHashTable = struct__GHashTable;
pub const _GHashTableIter = struct__GHashTableIter;
pub const _GHmac = struct__GHmac;
pub const _GHook = struct__GHook;
pub const _GHookList = struct__GHookList;
pub const _GPollFD = struct__GPollFD;
pub const _GSList = struct__GSList;
pub const _GMainContext = struct__GMainContext;
pub const _GMainLoop = struct__GMainLoop;
pub const _GSourceCallbackFuncs = struct__GSourceCallbackFuncs;
pub const _GSourceFuncs = struct__GSourceFuncs;
pub const _GSourcePrivate = struct__GSourcePrivate;
pub const _GSource = struct__GSource;
pub const _GString = struct__GString;
pub const _GIOChannel = struct__GIOChannel;
pub const _GIOFuncs = struct__GIOFuncs;
pub const _GKeyFile = struct__GKeyFile;
pub const _GMappedFile = struct__GMappedFile;
pub const _GMarkupParseContext = struct__GMarkupParseContext;
pub const _GMarkupParser = struct__GMarkupParser;
pub const _GVariantType = struct__GVariantType;
pub const _GVariant = struct__GVariant;
pub const _GVariantIter = struct__GVariantIter;
pub const _GVariantBuilder = struct__GVariantBuilder;
pub const _GVariantDict = struct__GVariantDict;
pub const _GLogField = struct__GLogField;
pub const _GOptionContext = struct__GOptionContext;
pub const _GOptionGroup = struct__GOptionGroup;
pub const _GOptionEntry = struct__GOptionEntry;
pub const _GPatternSpec = struct__GPatternSpec;
pub const _GQueue = struct__GQueue;
pub const _GRand = struct__GRand;
pub const _GRegex = struct__GRegex;
pub const _GMatchInfo = struct__GMatchInfo;
pub const _GScannerConfig = struct__GScannerConfig;
pub const _GTokenValue = union__GTokenValue;
pub const _GScanner = struct__GScanner;
pub const _GSequence = struct__GSequence;
pub const _GSequenceNode = struct__GSequenceNode;
pub const _GStringChunk = struct__GStringChunk;
pub const _GThreadPool = struct__GThreadPool;
pub const _GTimer = struct__GTimer;
pub const _GTrashStack = struct__GTrashStack;
pub const _GTree = struct__GTree;
pub const _GAllocator = struct__GAllocator;
pub const _GMemChunk = struct__GMemChunk;
pub const _GCache = struct__GCache;
pub const _GCompletion = struct__GCompletion;
pub const _GRelation = struct__GRelation;
pub const _GTuples = struct__GTuples;
pub const _GThreadFunctions = struct__GThreadFunctions;
pub const _GStaticRecMutex = struct__GStaticRecMutex;
pub const _GStaticRWLock = struct__GStaticRWLock;
pub const _GStaticPrivate = struct__GStaticPrivate;
pub const _GValue = struct__GValue;
pub const _GTypeCValue = union__GTypeCValue;
pub const _GTypePlugin = struct__GTypePlugin;
pub const _GTypeClass = struct__GTypeClass;
pub const _GTypeInterface = struct__GTypeInterface;
pub const _GTypeInstance = struct__GTypeInstance;
pub const _GTypeValueTable = struct__GTypeValueTable;
pub const _GTypeInfo = struct__GTypeInfo;
pub const _GTypeFundamentalInfo = struct__GTypeFundamentalInfo;
pub const _GInterfaceInfo = struct__GInterfaceInfo;
pub const _GTypeQuery = struct__GTypeQuery;
pub const _GParamSpec = struct__GParamSpec;
pub const _GParamSpecClass = struct__GParamSpecClass;
pub const _GParameter = struct__GParameter;
pub const _GParamSpecPool = struct__GParamSpecPool;
pub const _GParamSpecTypeInfo = struct__GParamSpecTypeInfo;
pub const _GClosure = struct__GClosure;
pub const _GClosureNotifyData = struct__GClosureNotifyData;
pub const _GCClosure = struct__GCClosure;
pub const _GSignalQuery = struct__GSignalQuery;
pub const _GSignalInvocationHint = struct__GSignalInvocationHint;
pub const _GObject = struct__GObject;
pub const _GObjectConstructParam = struct__GObjectConstructParam;
pub const _GObjectClass = struct__GObjectClass;
pub const _GBinding = struct__GBinding;
pub const _GEnumValue = struct__GEnumValue;
pub const _GEnumClass = struct__GEnumClass;
pub const _GFlagsValue = struct__GFlagsValue;
pub const _GFlagsClass = struct__GFlagsClass;
pub const _GParamSpecChar = struct__GParamSpecChar;
pub const _GParamSpecUChar = struct__GParamSpecUChar;
pub const _GParamSpecBoolean = struct__GParamSpecBoolean;
pub const _GParamSpecInt = struct__GParamSpecInt;
pub const _GParamSpecUInt = struct__GParamSpecUInt;
pub const _GParamSpecLong = struct__GParamSpecLong;
pub const _GParamSpecULong = struct__GParamSpecULong;
pub const _GParamSpecInt64 = struct__GParamSpecInt64;
pub const _GParamSpecUInt64 = struct__GParamSpecUInt64;
pub const _GParamSpecUnichar = struct__GParamSpecUnichar;
pub const _GParamSpecEnum = struct__GParamSpecEnum;
pub const _GParamSpecFlags = struct__GParamSpecFlags;
pub const _GParamSpecFloat = struct__GParamSpecFloat;
pub const _GParamSpecDouble = struct__GParamSpecDouble;
pub const _GParamSpecString = struct__GParamSpecString;
pub const _GParamSpecParam = struct__GParamSpecParam;
pub const _GParamSpecBoxed = struct__GParamSpecBoxed;
pub const _GParamSpecPointer = struct__GParamSpecPointer;
pub const _GParamSpecValueArray = struct__GParamSpecValueArray;
pub const _GParamSpecObject = struct__GParamSpecObject;
pub const _GParamSpecOverride = struct__GParamSpecOverride;
pub const _GParamSpecGType = struct__GParamSpecGType;
pub const _GParamSpecVariant = struct__GParamSpecVariant;
pub const _GTypeModule = struct__GTypeModule;
pub const _GTypeModuleClass = struct__GTypeModuleClass;
pub const _GTypePluginClass = struct__GTypePluginClass;
pub const _GValueArray = struct__GValueArray;
pub const _GTlsPasswordFlags = enum__GTlsPasswordFlags;
pub const _GAppLaunchContextPrivate = struct__GAppLaunchContextPrivate;
pub const _GAppLaunchContext = struct__GAppLaunchContext;
pub const _GAppInfo = struct__GAppInfo;
pub const _GAsyncResult = struct__GAsyncResult;
pub const _GAsyncInitable = struct__GAsyncInitable;
pub const _GInputStreamPrivate = struct__GInputStreamPrivate;
pub const _GInputStream = struct__GInputStream;
pub const _GFilterInputStream = struct__GFilterInputStream;
pub const _GBufferedInputStreamPrivate = struct__GBufferedInputStreamPrivate;
pub const _GBufferedInputStream = struct__GBufferedInputStream;
pub const _GOutputStreamPrivate = struct__GOutputStreamPrivate;
pub const _GOutputStream = struct__GOutputStream;
pub const _GFilterOutputStream = struct__GFilterOutputStream;
pub const _GBufferedOutputStreamPrivate = struct__GBufferedOutputStreamPrivate;
pub const _GBufferedOutputStream = struct__GBufferedOutputStream;
pub const _GCancellablePrivate = struct__GCancellablePrivate;
pub const _GCancellable = struct__GCancellable;
pub const _GCharsetConverter = struct__GCharsetConverter;
pub const _GConverter = struct__GConverter;
pub const _GConverterInputStreamPrivate = struct__GConverterInputStreamPrivate;
pub const _GConverterInputStream = struct__GConverterInputStream;
pub const _GConverterOutputStreamPrivate = struct__GConverterOutputStreamPrivate;
pub const _GConverterOutputStream = struct__GConverterOutputStream;
pub const _GDatagramBased = struct__GDatagramBased;
pub const _GDataInputStreamPrivate = struct__GDataInputStreamPrivate;
pub const _GDataInputStream = struct__GDataInputStream;
pub const _GSimplePermission = struct__GSimplePermission;
pub const _GZlibCompressor = struct__GZlibCompressor;
pub const _GZlibDecompressor = struct__GZlibDecompressor;
pub const _GSimpleActionGroupPrivate = struct__GSimpleActionGroupPrivate;
pub const _GSimpleActionGroup = struct__GSimpleActionGroup;
pub const _GRemoteActionGroup = struct__GRemoteActionGroup;
pub const _GDBusActionGroup = struct__GDBusActionGroup;
pub const _GActionMap = struct__GActionMap;
pub const _GActionGroup = struct__GActionGroup;
pub const _GPropertyAction = struct__GPropertyAction;
pub const _GSimpleAction = struct__GSimpleAction;
pub const _GAction = struct__GAction;
pub const _GApplicationPrivate = struct__GApplicationPrivate;
pub const _GApplication = struct__GApplication;
pub const _GApplicationCommandLinePrivate = struct__GApplicationCommandLinePrivate;
pub const _GApplicationCommandLine = struct__GApplicationCommandLine;
pub const _GSettingsBackend = struct__GSettingsBackend;
pub const _GSettingsPrivate = struct__GSettingsPrivate;
pub const _GSettings = struct__GSettings;
pub const _GPermissionPrivate = struct__GPermissionPrivate;
pub const _GPermission = struct__GPermission;
pub const _GMenuModelPrivate = struct__GMenuModelPrivate;
pub const _GMenuModel = struct__GMenuModel;
pub const _GNotification = struct__GNotification;
pub const _GDrive = struct__GDrive;
pub const _GFileEnumeratorPrivate = struct__GFileEnumeratorPrivate;
pub const _GFileEnumerator = struct__GFileEnumerator;
pub const _GFileMonitorPrivate = struct__GFileMonitorPrivate;
pub const _GFileMonitor = struct__GFileMonitor;
pub const _GFile = struct__GFile;
pub const _GFileInfo = struct__GFileInfo;
pub const _GFileAttributeMatcher = struct__GFileAttributeMatcher;
pub const _GFileAttributeInfo = struct__GFileAttributeInfo;
pub const _GFileAttributeInfoList = struct__GFileAttributeInfoList;
pub const _GFileDescriptorBased = struct__GFileDescriptorBased;
pub const _GFileInputStreamPrivate = struct__GFileInputStreamPrivate;
pub const _GFileInputStream = struct__GFileInputStream;
pub const _GFileOutputStreamPrivate = struct__GFileOutputStreamPrivate;
pub const _GFileOutputStream = struct__GFileOutputStream;
pub const _GIOStreamPrivate = struct__GIOStreamPrivate;
pub const _GIOStream = struct__GIOStream;
pub const _GFileIOStreamPrivate = struct__GFileIOStreamPrivate;
pub const _GFileIOStream = struct__GFileIOStream;
pub const _GFileIcon = struct__GFileIcon;
pub const _GFilenameCompleter = struct__GFilenameCompleter;
pub const _GIcon = struct__GIcon;
pub const _GInetAddressPrivate = struct__GInetAddressPrivate;
pub const _GInetAddress = struct__GInetAddress;
pub const _GInetAddressMaskPrivate = struct__GInetAddressMaskPrivate;
pub const _GInetAddressMask = struct__GInetAddressMask;
pub const _GSocketAddress = struct__GSocketAddress;
pub const _GInetSocketAddressPrivate = struct__GInetSocketAddressPrivate;
pub const _GInetSocketAddress = struct__GInetSocketAddress;
pub const _GNativeSocketAddressPrivate = struct__GNativeSocketAddressPrivate;
pub const _GNativeSocketAddress = struct__GNativeSocketAddress;
pub const _GInitable = struct__GInitable;
pub const _GIOModule = struct__GIOModule;
pub const _GIOExtensionPoint = struct__GIOExtensionPoint;
pub const _GIOExtension = struct__GIOExtension;
pub const _GIOSchedulerJob = struct__GIOSchedulerJob;
pub const _GIOStreamAdapter = struct__GIOStreamAdapter;
pub const _GLoadableIcon = struct__GLoadableIcon;
pub const _GBytesIcon = struct__GBytesIcon;
pub const _GMemoryInputStreamPrivate = struct__GMemoryInputStreamPrivate;
pub const _GMemoryInputStream = struct__GMemoryInputStream;
pub const _GMemoryOutputStreamPrivate = struct__GMemoryOutputStreamPrivate;
pub const _GMemoryOutputStream = struct__GMemoryOutputStream;
pub const _GMount = struct__GMount;
pub const _GMountOperationPrivate = struct__GMountOperationPrivate;
pub const _GMountOperation = struct__GMountOperation;
pub const _GNetworkAddressPrivate = struct__GNetworkAddressPrivate;
pub const _GNetworkAddress = struct__GNetworkAddress;
pub const _GNetworkMonitor = struct__GNetworkMonitor;
pub const _GNetworkServicePrivate = struct__GNetworkServicePrivate;
pub const _GNetworkService = struct__GNetworkService;
pub const _GSimpleIOStream = struct__GSimpleIOStream;
pub const _GPollableInputStream = struct__GPollableInputStream;
pub const _GPollableOutputStream = struct__GPollableOutputStream;
pub const _GResolverPrivate = struct__GResolverPrivate;
pub const _GResolver = struct__GResolver;
pub const _GResource = struct__GResource;
pub const _GSeekable = struct__GSeekable;
pub const _GSimpleAsyncResult = struct__GSimpleAsyncResult;
pub const _GSocketPrivate = struct__GSocketPrivate;
pub const _GSocket = struct__GSocket;
pub const _GSocketControlMessagePrivate = struct__GSocketControlMessagePrivate;
pub const _GSocketControlMessage = struct__GSocketControlMessage;
pub const _GSocketClientPrivate = struct__GSocketClientPrivate;
pub const _GSocketClient = struct__GSocketClient;
pub const _GSocketConnectionPrivate = struct__GSocketConnectionPrivate;
pub const _GSocketConnection = struct__GSocketConnection;
pub const _GSocketListenerPrivate = struct__GSocketListenerPrivate;
pub const _GSocketListener = struct__GSocketListener;
pub const _GSocketServicePrivate = struct__GSocketServicePrivate;
pub const _GSocketService = struct__GSocketService;
pub const _GSocketAddressEnumerator = struct__GSocketAddressEnumerator;
pub const _GSocketConnectable = struct__GSocketConnectable;
pub const _GSrvTarget = struct__GSrvTarget;
pub const _GTask = struct__GTask;
pub const _GTcpConnectionPrivate = struct__GTcpConnectionPrivate;
pub const _GTcpConnection = struct__GTcpConnection;
pub const _GTcpWrapperConnectionPrivate = struct__GTcpWrapperConnectionPrivate;
pub const _GTcpWrapperConnection = struct__GTcpWrapperConnection;
pub const _GThreadedSocketServicePrivate = struct__GThreadedSocketServicePrivate;
pub const _GThreadedSocketService = struct__GThreadedSocketService;
pub const _GDtlsConnection = struct__GDtlsConnection;
pub const _GDtlsClientConnection = struct__GDtlsClientConnection;
pub const _GDtlsServerConnection = struct__GDtlsServerConnection;
pub const _GThemedIcon = struct__GThemedIcon;
pub const _GTlsCertificatePrivate = struct__GTlsCertificatePrivate;
pub const _GTlsCertificate = struct__GTlsCertificate;
pub const _GTlsClientConnection = struct__GTlsClientConnection;
pub const _GTlsConnectionPrivate = struct__GTlsConnectionPrivate;
pub const _GTlsConnection = struct__GTlsConnection;
pub const _GTlsDatabasePrivate = struct__GTlsDatabasePrivate;
pub const _GTlsDatabase = struct__GTlsDatabase;
pub const _GTlsFileDatabase = struct__GTlsFileDatabase;
pub const _GTlsInteractionPrivate = struct__GTlsInteractionPrivate;
pub const _GTlsInteraction = struct__GTlsInteraction;
pub const _GTlsPasswordPrivate = struct__GTlsPasswordPrivate;
pub const _GTlsPassword = struct__GTlsPassword;
pub const _GTlsServerConnection = struct__GTlsServerConnection;
pub const _GVfs = struct__GVfs;
pub const _GProxyResolver = struct__GProxyResolver;
pub const _GProxy = struct__GProxy;
pub const _GProxyAddressPrivate = struct__GProxyAddressPrivate;
pub const _GProxyAddress = struct__GProxyAddress;
pub const _GProxyAddressEnumeratorPrivate = struct__GProxyAddressEnumeratorPrivate;
pub const _GProxyAddressEnumerator = struct__GProxyAddressEnumerator;
pub const _GVolume = struct__GVolume;
pub const _GVolumeMonitor = struct__GVolumeMonitor;
pub const _GInputVector = struct__GInputVector;
pub const _GInputMessage = struct__GInputMessage;
pub const _GOutputVector = struct__GOutputVector;
pub const _GOutputMessage = struct__GOutputMessage;
pub const _GCredentials = struct__GCredentials;
pub const _GUnixCredentialsMessage = struct__GUnixCredentialsMessage;
pub const _GUnixFDList = struct__GUnixFDList;
pub const _GDBusMessage = struct__GDBusMessage;
pub const _GDBusConnection = struct__GDBusConnection;
pub const _GDBusProxyPrivate = struct__GDBusProxyPrivate;
pub const _GDBusProxy = struct__GDBusProxy;
pub const _GDBusMethodInvocation = struct__GDBusMethodInvocation;
pub const _GDBusServer = struct__GDBusServer;
pub const _GDBusAuthObserver = struct__GDBusAuthObserver;
pub const _GDBusErrorEntry = struct__GDBusErrorEntry;
pub const _GDBusInterfaceVTable = struct__GDBusInterfaceVTable;
pub const _GDBusAnnotationInfo = struct__GDBusAnnotationInfo;
pub const _GDBusArgInfo = struct__GDBusArgInfo;
pub const _GDBusMethodInfo = struct__GDBusMethodInfo;
pub const _GDBusSignalInfo = struct__GDBusSignalInfo;
pub const _GDBusPropertyInfo = struct__GDBusPropertyInfo;
pub const _GDBusInterfaceInfo = struct__GDBusInterfaceInfo;
pub const _GDBusSubtreeVTable = struct__GDBusSubtreeVTable;
pub const _GDBusNodeInfo = struct__GDBusNodeInfo;
pub const _GDBusInterface = struct__GDBusInterface;
pub const _GDBusInterfaceSkeletonPrivate = struct__GDBusInterfaceSkeletonPrivate;
pub const _GDBusInterfaceSkeleton = struct__GDBusInterfaceSkeleton;
pub const _GDBusObject = struct__GDBusObject;
pub const _GDBusObjectSkeletonPrivate = struct__GDBusObjectSkeletonPrivate;
pub const _GDBusObjectSkeleton = struct__GDBusObjectSkeleton;
pub const _GDBusObjectProxyPrivate = struct__GDBusObjectProxyPrivate;
pub const _GDBusObjectProxy = struct__GDBusObjectProxy;
pub const _GDBusObjectManager = struct__GDBusObjectManager;
pub const _GDBusObjectManagerClientPrivate = struct__GDBusObjectManagerClientPrivate;
pub const _GDBusObjectManagerClient = struct__GDBusObjectManagerClient;
pub const _GDBusObjectManagerServerPrivate = struct__GDBusObjectManagerServerPrivate;
pub const _GDBusObjectManagerServer = struct__GDBusObjectManagerServer;
pub const _GTestDBus = struct__GTestDBus;
pub const _GSubprocess = struct__GSubprocess;
pub const _GSubprocessLauncher = struct__GSubprocessLauncher;
pub const _GActionInterface = struct__GActionInterface;
pub const _GActionGroupInterface = struct__GActionGroupInterface;
pub const _GActionMapInterface = struct__GActionMapInterface;
pub const _GActionEntry = struct__GActionEntry;
pub const _GAppLaunchContextClass = struct__GAppLaunchContextClass;
pub const _GAppInfoIface = struct__GAppInfoIface;
pub const _GAppInfoMonitor = struct__GAppInfoMonitor;
pub const _GApplicationClass = struct__GApplicationClass;
pub const _GApplicationCommandLineClass = struct__GApplicationCommandLineClass;
pub const _GInitableIface = struct__GInitableIface;
pub const _GAsyncInitableIface = struct__GAsyncInitableIface;
pub const _GAsyncResultIface = struct__GAsyncResultIface;
pub const _GInputStreamClass = struct__GInputStreamClass;
pub const _GFilterInputStreamClass = struct__GFilterInputStreamClass;
pub const _GBufferedInputStreamClass = struct__GBufferedInputStreamClass;
pub const _GOutputStreamClass = struct__GOutputStreamClass;
pub const _GFilterOutputStreamClass = struct__GFilterOutputStreamClass;
pub const _GBufferedOutputStreamClass = struct__GBufferedOutputStreamClass;
pub const _GCancellableClass = struct__GCancellableClass;
pub const _GConverterIface = struct__GConverterIface;
pub const _GCharsetConverterClass = struct__GCharsetConverterClass;
pub const _GConverterInputStreamClass = struct__GConverterInputStreamClass;
pub const _GConverterOutputStreamClass = struct__GConverterOutputStreamClass;
pub const _GCredentialsClass = struct__GCredentialsClass;
pub const _GDatagramBasedInterface = struct__GDatagramBasedInterface;
pub const _GDataInputStreamClass = struct__GDataInputStreamClass;
pub const _GDataOutputStreamPrivate = struct__GDataOutputStreamPrivate;
pub const _GDataOutputStream = struct__GDataOutputStream;
pub const _GDataOutputStreamClass = struct__GDataOutputStreamClass;
pub const _GDBusProxyClass = struct__GDBusProxyClass;
pub const _GDriveIface = struct__GDriveIface;
pub const _GDtlsConnectionInterface = struct__GDtlsConnectionInterface;
pub const _GDtlsClientConnectionInterface = struct__GDtlsClientConnectionInterface;
pub const _GDtlsServerConnectionInterface = struct__GDtlsServerConnectionInterface;
pub const _GIconIface = struct__GIconIface;
pub const _GEmblem = struct__GEmblem;
pub const _GEmblemClass = struct__GEmblemClass;
pub const _GEmblemedIconPrivate = struct__GEmblemedIconPrivate;
pub const _GEmblemedIcon = struct__GEmblemedIcon;
pub const _GEmblemedIconClass = struct__GEmblemedIconClass;
pub const _GFileEnumeratorClass = struct__GFileEnumeratorClass;
pub const _GFileIface = struct__GFileIface;
pub const _GFileIconClass = struct__GFileIconClass;
pub const _GFileInfoClass = struct__GFileInfoClass;
pub const _GFileInputStreamClass = struct__GFileInputStreamClass;
pub const _GIOStreamClass = struct__GIOStreamClass;
pub const _GFileIOStreamClass = struct__GFileIOStreamClass;
pub const _GFileMonitorClass = struct__GFileMonitorClass;
pub const _GFilenameCompleterClass = struct__GFilenameCompleterClass;
pub const _GFileOutputStreamClass = struct__GFileOutputStreamClass;
pub const _GInetAddressClass = struct__GInetAddressClass;
pub const _GInetAddressMaskClass = struct__GInetAddressMaskClass;
pub const _GSocketAddressClass = struct__GSocketAddressClass;
pub const _GInetSocketAddressClass = struct__GInetSocketAddressClass;
pub const _GModule = struct__GModule;
pub const _GIOModuleScope = struct__GIOModuleScope;
pub const _GIOModuleClass = struct__GIOModuleClass;
pub const _GLoadableIconIface = struct__GLoadableIconIface;
pub const _GMemoryInputStreamClass = struct__GMemoryInputStreamClass;
pub const _GMemoryOutputStreamClass = struct__GMemoryOutputStreamClass;
pub const _GMountIface = struct__GMountIface;
pub const _GMountOperationClass = struct__GMountOperationClass;
pub const _GNativeSocketAddressClass = struct__GNativeSocketAddressClass;
pub const _GVolumeMonitorClass = struct__GVolumeMonitorClass;
pub const _GNativeVolumeMonitor = struct__GNativeVolumeMonitor;
pub const _GNativeVolumeMonitorClass = struct__GNativeVolumeMonitorClass;
pub const _GNetworkAddressClass = struct__GNetworkAddressClass;
pub const _GNetworkMonitorInterface = struct__GNetworkMonitorInterface;
pub const _GNetworkServiceClass = struct__GNetworkServiceClass;
pub const _GPermissionClass = struct__GPermissionClass;
pub const _GPollableInputStreamInterface = struct__GPollableInputStreamInterface;
pub const _GPollableOutputStreamInterface = struct__GPollableOutputStreamInterface;
pub const _GProxyInterface = struct__GProxyInterface;
pub const _GProxyAddressClass = struct__GProxyAddressClass;
pub const _GSocketAddressEnumeratorClass = struct__GSocketAddressEnumeratorClass;
pub const _GProxyAddressEnumeratorClass = struct__GProxyAddressEnumeratorClass;
pub const _GProxyResolverInterface = struct__GProxyResolverInterface;
pub const _GResolverClass = struct__GResolverClass;
pub const _GStaticResource = struct__GStaticResource;
pub const _GSeekableIface = struct__GSeekableIface;
pub const _GSettingsSchemaSource = struct__GSettingsSchemaSource;
pub const _GSettingsSchema = struct__GSettingsSchema;
pub const _GSettingsSchemaKey = struct__GSettingsSchemaKey;
pub const _GSettingsClass = struct__GSettingsClass;
pub const _GSimpleActionGroupClass = struct__GSimpleActionGroupClass;
pub const _GSimpleAsyncResultClass = struct__GSimpleAsyncResultClass;
pub const _GSocketClientClass = struct__GSocketClientClass;
pub const _GSocketConnectableIface = struct__GSocketConnectableIface;
pub const _GSocketClass = struct__GSocketClass;
pub const _GSocketConnectionClass = struct__GSocketConnectionClass;
pub const _GSocketControlMessageClass = struct__GSocketControlMessageClass;
pub const _GSocketListenerClass = struct__GSocketListenerClass;
pub const _GSocketServiceClass = struct__GSocketServiceClass;
pub const _GSimpleProxyResolverPrivate = struct__GSimpleProxyResolverPrivate;
pub const _GSimpleProxyResolver = struct__GSimpleProxyResolver;
pub const _GSimpleProxyResolverClass = struct__GSimpleProxyResolverClass;
pub const _GTaskClass = struct__GTaskClass;
pub const _GTcpConnectionClass = struct__GTcpConnectionClass;
pub const _GTcpWrapperConnectionClass = struct__GTcpWrapperConnectionClass;
pub const _GThemedIconClass = struct__GThemedIconClass;
pub const _GThreadedSocketServiceClass = struct__GThreadedSocketServiceClass;
pub const _GTlsBackend = struct__GTlsBackend;
pub const _GTlsBackendInterface = struct__GTlsBackendInterface;
pub const _GTlsCertificateClass = struct__GTlsCertificateClass;
pub const _GTlsConnectionClass = struct__GTlsConnectionClass;
pub const _GTlsClientConnectionInterface = struct__GTlsClientConnectionInterface;
pub const _GTlsDatabaseClass = struct__GTlsDatabaseClass;
pub const _GTlsFileDatabaseInterface = struct__GTlsFileDatabaseInterface;
pub const _GTlsInteractionClass = struct__GTlsInteractionClass;
pub const _GTlsServerConnectionInterface = struct__GTlsServerConnectionInterface;
pub const _GTlsPasswordClass = struct__GTlsPasswordClass;
pub const _GVfsClass = struct__GVfsClass;
pub const _GVolumeIface = struct__GVolumeIface;
pub const _GZlibCompressorClass = struct__GZlibCompressorClass;
pub const _GZlibDecompressorClass = struct__GZlibDecompressorClass;
pub const _GDBusInterfaceIface = struct__GDBusInterfaceIface;
pub const _GDBusInterfaceSkeletonClass = struct__GDBusInterfaceSkeletonClass;
pub const _GDBusObjectIface = struct__GDBusObjectIface;
pub const _GDBusObjectSkeletonClass = struct__GDBusObjectSkeletonClass;
pub const _GDBusObjectProxyClass = struct__GDBusObjectProxyClass;
pub const _GDBusObjectManagerIface = struct__GDBusObjectManagerIface;
pub const _GDBusObjectManagerClientClass = struct__GDBusObjectManagerClientClass;
pub const _GDBusObjectManagerServerClass = struct__GDBusObjectManagerServerClass;
pub const _GRemoteActionGroupInterface = struct__GRemoteActionGroupInterface;
pub const _GMenuAttributeIterPrivate = struct__GMenuAttributeIterPrivate;
pub const _GMenuAttributeIter = struct__GMenuAttributeIter;
pub const _GMenuLinkIterPrivate = struct__GMenuLinkIterPrivate;
pub const _GMenuLinkIter = struct__GMenuLinkIter;
pub const _GMenuModelClass = struct__GMenuModelClass;
pub const _GMenuAttributeIterClass = struct__GMenuAttributeIterClass;
pub const _GMenuLinkIterClass = struct__GMenuLinkIterClass;
pub const _GMenuItem = struct__GMenuItem;
pub const _GMenu = struct__GMenu;
pub const _GDBusMenuModel = struct__GDBusMenuModel;
pub const _GListModel = struct__GListModel;
pub const _GListModelInterface = struct__GListModelInterface;
pub const _GListStore = struct__GListStore;
pub const _PangoCoverage = struct__PangoCoverage;
pub const _PangoLogAttr = struct__PangoLogAttr;
pub const _PangoEngineLang = struct__PangoEngineLang;
pub const _PangoEngineShape = struct__PangoEngineShape;
pub const _PangoFont = struct__PangoFont;
pub const _PangoFontMap = struct__PangoFontMap;
pub const _PangoRectangle = struct__PangoRectangle;
pub const _PangoMatrix = struct__PangoMatrix;
pub const _PangoScriptIter = struct__PangoScriptIter;
pub const _PangoLanguage = struct__PangoLanguage;
pub const _PangoFontDescription = struct__PangoFontDescription;
pub const _PangoFontMetrics = struct__PangoFontMetrics;
pub const _PangoFontFamily = struct__PangoFontFamily;
pub const _PangoFontFace = struct__PangoFontFace;
pub const _PangoColor = struct__PangoColor;
pub const _PangoAttrClass = struct__PangoAttrClass;
pub const _PangoAttribute = struct__PangoAttribute;
pub const _PangoAttrString = struct__PangoAttrString;
pub const _PangoAttrLanguage = struct__PangoAttrLanguage;
pub const _PangoAttrInt = struct__PangoAttrInt;
pub const _PangoAttrSize = struct__PangoAttrSize;
pub const _PangoAttrFloat = struct__PangoAttrFloat;
pub const _PangoAttrColor = struct__PangoAttrColor;
pub const _PangoAttrFontDesc = struct__PangoAttrFontDesc;
pub const _PangoAttrShape = struct__PangoAttrShape;
pub const _PangoAttrFontFeatures = struct__PangoAttrFontFeatures;
pub const _PangoAttrList = struct__PangoAttrList;
pub const _PangoAttrIterator = struct__PangoAttrIterator;
pub const _PangoAnalysis = struct__PangoAnalysis;
pub const _PangoItem = struct__PangoItem;
pub const _PangoFontset = struct__PangoFontset;
pub const _PangoContext = struct__PangoContext;
pub const _PangoContextClass = struct__PangoContextClass;
pub const _PangoGlyphGeometry = struct__PangoGlyphGeometry;
pub const _PangoGlyphVisAttr = struct__PangoGlyphVisAttr;
pub const _PangoGlyphInfo = struct__PangoGlyphInfo;
pub const _PangoGlyphString = struct__PangoGlyphString;
pub const _PangoGlyphItem = struct__PangoGlyphItem;
pub const _PangoGlyphItemIter = struct__PangoGlyphItemIter;
pub const _PangoTabArray = struct__PangoTabArray;
pub const _PangoLayout = struct__PangoLayout;
pub const _PangoLayoutClass = struct__PangoLayoutClass;
pub const _PangoLayoutLine = struct__PangoLayoutLine;
pub const _PangoLayoutIter = struct__PangoLayoutIter;
pub const _PangoRendererPrivate = struct__PangoRendererPrivate;
pub const _PangoRenderer = struct__PangoRenderer;
pub const _PangoRendererClass = struct__PangoRendererClass;
pub const _cairo = struct__cairo;
pub const _cairo_surface = struct__cairo_surface;
pub const _cairo_device = struct__cairo_device;
pub const _cairo_matrix = struct__cairo_matrix;
pub const _cairo_pattern = struct__cairo_pattern;
pub const _cairo_user_data_key = struct__cairo_user_data_key;
pub const _cairo_status = enum__cairo_status;
pub const _cairo_content = enum__cairo_content;
pub const _cairo_format = enum__cairo_format;
pub const _cairo_rectangle_int = struct__cairo_rectangle_int;
pub const _cairo_operator = enum__cairo_operator;
pub const _cairo_antialias = enum__cairo_antialias;
pub const _cairo_fill_rule = enum__cairo_fill_rule;
pub const _cairo_line_cap = enum__cairo_line_cap;
pub const _cairo_line_join = enum__cairo_line_join;
pub const _cairo_rectangle = struct__cairo_rectangle;
pub const _cairo_rectangle_list = struct__cairo_rectangle_list;
pub const _cairo_scaled_font = struct__cairo_scaled_font;
pub const _cairo_font_face = struct__cairo_font_face;
pub const _cairo_text_cluster_flags = enum__cairo_text_cluster_flags;
pub const _cairo_font_slant = enum__cairo_font_slant;
pub const _cairo_font_weight = enum__cairo_font_weight;
pub const _cairo_subpixel_order = enum__cairo_subpixel_order;
pub const _cairo_hint_style = enum__cairo_hint_style;
pub const _cairo_hint_metrics = enum__cairo_hint_metrics;
pub const _cairo_font_options = struct__cairo_font_options;
pub const _cairo_font_type = enum__cairo_font_type;
pub const _cairo_path_data_type = enum__cairo_path_data_type;
pub const _cairo_path_data_t = union__cairo_path_data_t;
pub const cairo_path = struct_cairo_path;
pub const _cairo_device_type = enum__cairo_device_type;
pub const _cairo_surface_type = enum__cairo_surface_type;
pub const _cairo_pattern_type = enum__cairo_pattern_type;
pub const _cairo_extend = enum__cairo_extend;
pub const _cairo_filter = enum__cairo_filter;
pub const _cairo_region = struct__cairo_region;
pub const _cairo_region_overlap = enum__cairo_region_overlap;
pub const _GdkPoint = struct__GdkPoint;
pub const _GdkAtom = struct__GdkAtom;
pub const _GdkColor = struct__GdkColor;
pub const _GdkRGBA = struct__GdkRGBA;
pub const _GdkCursor = struct__GdkCursor;
pub const _GdkVisual = struct__GdkVisual;
pub const _GdkDevice = struct__GdkDevice;
pub const _GdkDragContext = struct__GdkDragContext;
pub const _GdkDisplayManager = struct__GdkDisplayManager;
pub const _GdkDeviceManager = struct__GdkDeviceManager;
pub const _GdkDisplay = struct__GdkDisplay;
pub const _GdkScreen = struct__GdkScreen;
pub const _GdkWindow = struct__GdkWindow;
pub const _GdkKeymap = struct__GdkKeymap;
pub const _GdkAppLaunchContext = struct__GdkAppLaunchContext;
pub const _GdkSeat = struct__GdkSeat;
pub const _GdkGLContext = struct__GdkGLContext;
pub const _GdkTimeCoord = struct__GdkTimeCoord;
pub const _GdkDeviceTool = struct__GdkDeviceTool;
pub const _GdkEventAny = struct__GdkEventAny;
pub const _GdkEventExpose = struct__GdkEventExpose;
pub const _GdkEventVisibility = struct__GdkEventVisibility;
pub const _GdkEventMotion = struct__GdkEventMotion;
pub const _GdkEventButton = struct__GdkEventButton;
pub const _GdkEventSequence = struct__GdkEventSequence;
pub const _GdkEventTouch = struct__GdkEventTouch;
pub const _GdkEventScroll = struct__GdkEventScroll;
pub const _GdkEventKey = struct__GdkEventKey;
pub const _GdkEventFocus = struct__GdkEventFocus;
pub const _GdkEventCrossing = struct__GdkEventCrossing;
pub const _GdkEventConfigure = struct__GdkEventConfigure;
pub const _GdkEventProperty = struct__GdkEventProperty;
pub const _GdkEventSelection = struct__GdkEventSelection;
pub const _GdkEventOwnerChange = struct__GdkEventOwnerChange;
pub const _GdkEventProximity = struct__GdkEventProximity;
pub const _GdkEventDND = struct__GdkEventDND;
pub const _GdkEventWindowState = struct__GdkEventWindowState;
pub const _GdkEventSetting = struct__GdkEventSetting;
pub const _GdkEventGrabBroken = struct__GdkEventGrabBroken;
pub const _GdkEventTouchpadSwipe = struct__GdkEventTouchpadSwipe;
pub const _GdkEventTouchpadPinch = struct__GdkEventTouchpadPinch;
pub const _GdkEventPadButton = struct__GdkEventPadButton;
pub const _GdkEventPadAxis = struct__GdkEventPadAxis;
pub const _GdkEventPadGroupMode = struct__GdkEventPadGroupMode;
pub const _GdkEvent = union__GdkEvent;
pub const _GdkDrawingContext = struct__GdkDrawingContext;
pub const _GdkDrawingContextClass = struct__GdkDrawingContextClass;
pub const _GdkFrameTimings = struct__GdkFrameTimings;
pub const _GdkFrameClock = struct__GdkFrameClock;
pub const _GdkFrameClockPrivate = struct__GdkFrameClockPrivate;
pub const _GdkFrameClockClass = struct__GdkFrameClockClass;
pub const _GdkGeometry = struct__GdkGeometry;
pub const _GdkWindowAttr = struct__GdkWindowAttr;
pub const _GdkWindowRedirect = struct__GdkWindowRedirect;
pub const _GdkWindowClass = struct__GdkWindowClass;
pub const _GdkMonitor = struct__GdkMonitor;
pub const _GdkMonitorClass = struct__GdkMonitorClass;
pub const _GdkPixbuf = struct__GdkPixbuf;
pub const _GdkPixbufAnimation = struct__GdkPixbufAnimation;
pub const _GdkPixbufAnimationIter = struct__GdkPixbufAnimationIter;
pub const _GdkPixbufSimpleAnim = struct__GdkPixbufSimpleAnim;
pub const _GdkPixbufSimpleAnimClass = struct__GdkPixbufSimpleAnimClass;
pub const _GdkPixbufFormat = struct__GdkPixbufFormat;
pub const _GdkPixbufLoader = struct__GdkPixbufLoader;
pub const _GdkPixbufLoaderClass = struct__GdkPixbufLoaderClass;
pub const _PangoCairoFont = struct__PangoCairoFont;
pub const _PangoCairoFontMap = struct__PangoCairoFontMap;
pub const _GdkDevicePad = struct__GdkDevicePad;
pub const _GdkDevicePadInterface = struct__GdkDevicePadInterface;
pub const _GdkKeymapKey = struct__GdkKeymapKey;
pub const _GtkAccelGroupPrivate = struct__GtkAccelGroupPrivate;
pub const _GtkAccelGroup = struct__GtkAccelGroup;
pub const _GtkAccelGroupClass = struct__GtkAccelGroupClass;
pub const _GtkAccelKey = struct__GtkAccelKey;
pub const _GtkAccelGroupEntry = struct__GtkAccelGroupEntry;
pub const _GtkBorder = struct__GtkBorder;
pub const _GtkAdjustmentPrivate = struct__GtkAdjustmentPrivate;
pub const _GtkAdjustment = struct__GtkAdjustment;
pub const _GtkBuilderPrivate = struct__GtkBuilderPrivate;
pub const _GtkBuilder = struct__GtkBuilder;
pub const _GtkClipboard = struct__GtkClipboard;
pub const _GtkIconSet = struct__GtkIconSet;
pub const _GtkIconSource = struct__GtkIconSource;
pub const _GtkRcStyle = struct__GtkRcStyle;
pub const _GtkRequisition = struct__GtkRequisition;
pub const _GtkSelectionData = struct__GtkSelectionData;
pub const _GtkSettingsPrivate = struct__GtkSettingsPrivate;
pub const _GtkSettings = struct__GtkSettings;
pub const _GtkStyle = struct__GtkStyle;
pub const _GtkStyleContextPrivate = struct__GtkStyleContextPrivate;
pub const _GtkStyleContext = struct__GtkStyleContext;
pub const _GtkTooltip = struct__GtkTooltip;
pub const _GtkWidgetPrivate = struct__GtkWidgetPrivate;
pub const _GtkWidget = struct__GtkWidget;
pub const _GtkWidgetPath = struct__GtkWidgetPath;
pub const _GtkContainerPrivate = struct__GtkContainerPrivate;
pub const _GtkContainer = struct__GtkContainer;
pub const _GtkBinPrivate = struct__GtkBinPrivate;
pub const _GtkBin = struct__GtkBin;
pub const _GtkWindowPrivate = struct__GtkWindowPrivate;
pub const _GtkWindow = struct__GtkWindow;
pub const _AtkAttribute = struct__AtkAttribute;
pub const _AtkImplementor = struct__AtkImplementor;
pub const _AtkRelationSet = struct__AtkRelationSet;
pub const _AtkObject = struct__AtkObject;
pub const _AtkImplementorIface = struct__AtkImplementorIface;
pub const _AtkStateSet = struct__AtkStateSet;
pub const _AtkPropertyValues = struct__AtkPropertyValues;
pub const _AtkObjectClass = struct__AtkObjectClass;
pub const _AtkAction = struct__AtkAction;
pub const _AtkActionIface = struct__AtkActionIface;
pub const _AtkUtil = struct__AtkUtil;
pub const _AtkKeyEventStruct = struct__AtkKeyEventStruct;
pub const _AtkUtilClass = struct__AtkUtilClass;
pub const _AtkComponent = struct__AtkComponent;
pub const _AtkRectangle = struct__AtkRectangle;
pub const _AtkComponentIface = struct__AtkComponentIface;
pub const _AtkDocument = struct__AtkDocument;
pub const _AtkDocumentIface = struct__AtkDocumentIface;
pub const _AtkText = struct__AtkText;
pub const _AtkTextRectangle = struct__AtkTextRectangle;
pub const _AtkTextRange = struct__AtkTextRange;
pub const _AtkTextIface = struct__AtkTextIface;
pub const _AtkEditableText = struct__AtkEditableText;
pub const _AtkEditableTextIface = struct__AtkEditableTextIface;
pub const _AtkGObjectAccessible = struct__AtkGObjectAccessible;
pub const _AtkGObjectAccessibleClass = struct__AtkGObjectAccessibleClass;
pub const _AtkHyperlink = struct__AtkHyperlink;
pub const _AtkHyperlinkClass = struct__AtkHyperlinkClass;
pub const _AtkHyperlinkImpl = struct__AtkHyperlinkImpl;
pub const _AtkHyperlinkImplIface = struct__AtkHyperlinkImplIface;
pub const _AtkHypertext = struct__AtkHypertext;
pub const _AtkHypertextIface = struct__AtkHypertextIface;
pub const _AtkImage = struct__AtkImage;
pub const _AtkImageIface = struct__AtkImageIface;
pub const _AtkNoOpObject = struct__AtkNoOpObject;
pub const _AtkNoOpObjectClass = struct__AtkNoOpObjectClass;
pub const _AtkObjectFactory = struct__AtkObjectFactory;
pub const _AtkObjectFactoryClass = struct__AtkObjectFactoryClass;
pub const _AtkNoOpObjectFactory = struct__AtkNoOpObjectFactory;
pub const _AtkNoOpObjectFactoryClass = struct__AtkNoOpObjectFactoryClass;
pub const _AtkPlug = struct__AtkPlug;
pub const _AtkPlugClass = struct__AtkPlugClass;
pub const _AtkRange = struct__AtkRange;
pub const _AtkRegistry = struct__AtkRegistry;
pub const _AtkRegistryClass = struct__AtkRegistryClass;
pub const _AtkRelation = struct__AtkRelation;
pub const _AtkRelationClass = struct__AtkRelationClass;
pub const _AtkRelationSetClass = struct__AtkRelationSetClass;
pub const _AtkSelection = struct__AtkSelection;
pub const _AtkSelectionIface = struct__AtkSelectionIface;
pub const _AtkSocket = struct__AtkSocket;
pub const _AtkSocketClass = struct__AtkSocketClass;
pub const _AtkStateSetClass = struct__AtkStateSetClass;
pub const _AtkStreamableContent = struct__AtkStreamableContent;
pub const _AtkStreamableContentIface = struct__AtkStreamableContentIface;
pub const _AtkTable = struct__AtkTable;
pub const _AtkTableIface = struct__AtkTableIface;
pub const _AtkTableCell = struct__AtkTableCell;
pub const _AtkTableCellIface = struct__AtkTableCellIface;
pub const _AtkMisc = struct__AtkMisc;
pub const _AtkMiscClass = struct__AtkMiscClass;
pub const _AtkValue = struct__AtkValue;
pub const _AtkValueIface = struct__AtkValueIface;
pub const _AtkWindow = struct__AtkWindow;
pub const _AtkWindowIface = struct__AtkWindowIface;
pub const _GtkWidgetClassPrivate = struct__GtkWidgetClassPrivate;
pub const _GtkWidgetClass = struct__GtkWidgetClass;
pub const _GtkApplicationPrivate = struct__GtkApplicationPrivate;
pub const _GtkApplication = struct__GtkApplication;
pub const _GtkApplicationClass = struct__GtkApplicationClass;
pub const _GtkContainerClass = struct__GtkContainerClass;
pub const _GtkBinClass = struct__GtkBinClass;
pub const _GtkWindowClass = struct__GtkWindowClass;
pub const _GtkWindowGeometryInfo = struct__GtkWindowGeometryInfo;
pub const _GtkWindowGroupPrivate = struct__GtkWindowGroupPrivate;
pub const _GtkWindowGroup = struct__GtkWindowGroup;
pub const _GtkWindowGroupClass = struct__GtkWindowGroupClass;
pub const _GtkDialogPrivate = struct__GtkDialogPrivate;
pub const _GtkDialog = struct__GtkDialog;
pub const _GtkDialogClass = struct__GtkDialogClass;
pub const _GtkAboutDialogPrivate = struct__GtkAboutDialogPrivate;
pub const _GtkAboutDialog = struct__GtkAboutDialog;
pub const _GtkAboutDialogClass = struct__GtkAboutDialogClass;
pub const _GtkMiscPrivate = struct__GtkMiscPrivate;
pub const _GtkMisc = struct__GtkMisc;
pub const _GtkMiscClass = struct__GtkMiscClass;
pub const _GtkMenuShellPrivate = struct__GtkMenuShellPrivate;
pub const _GtkMenuShell = struct__GtkMenuShell;
pub const _GtkMenuShellClass = struct__GtkMenuShellClass;
pub const _GtkMenuPrivate = struct__GtkMenuPrivate;
pub const _GtkMenu = struct__GtkMenu;
pub const _GtkMenuClass = struct__GtkMenuClass;
pub const _GtkLabelPrivate = struct__GtkLabelPrivate;
pub const _GtkLabel = struct__GtkLabel;
pub const _GtkLabelClass = struct__GtkLabelClass;
pub const _GtkLabelSelectionInfo = struct__GtkLabelSelectionInfo;
pub const _GtkAccelLabelPrivate = struct__GtkAccelLabelPrivate;
pub const _GtkAccelLabel = struct__GtkAccelLabel;
pub const _GtkAccelLabelClass = struct__GtkAccelLabelClass;
pub const _GtkAccelMap = struct__GtkAccelMap;
pub const _GtkAccelMapClass = struct__GtkAccelMapClass;
pub const _GtkAccessiblePrivate = struct__GtkAccessiblePrivate;
pub const _GtkAccessible = struct__GtkAccessible;
pub const _GtkAccessibleClass = struct__GtkAccessibleClass;
pub const _GtkActionable = struct__GtkActionable;
pub const _GtkActionableInterface = struct__GtkActionableInterface;
pub const _GtkActionBar = struct__GtkActionBar;
pub const _GtkActionBarPrivate = struct__GtkActionBarPrivate;
pub const _GtkActionBarClass = struct__GtkActionBarClass;
pub const _GtkAdjustmentClass = struct__GtkAdjustmentClass;
pub const _GtkAppChooser = struct__GtkAppChooser;
pub const _GtkAppChooserDialogPrivate = struct__GtkAppChooserDialogPrivate;
pub const _GtkAppChooserDialog = struct__GtkAppChooserDialog;
pub const _GtkAppChooserDialogClass = struct__GtkAppChooserDialogClass;
pub const _GtkBoxPrivate = struct__GtkBoxPrivate;
pub const _GtkBox = struct__GtkBox;
pub const _GtkBoxClass = struct__GtkBoxClass;
pub const _GtkAppChooserWidgetPrivate = struct__GtkAppChooserWidgetPrivate;
pub const _GtkAppChooserWidget = struct__GtkAppChooserWidget;
pub const _GtkAppChooserWidgetClass = struct__GtkAppChooserWidgetClass;
pub const _GtkTreeIter = struct__GtkTreeIter;
pub const _GtkTreePath = struct__GtkTreePath;
pub const _GtkTreeRowReference = struct__GtkTreeRowReference;
pub const _GtkTreeModel = struct__GtkTreeModel;
pub const _GtkTreeModelIface = struct__GtkTreeModelIface;
pub const _GtkCellEditable = struct__GtkCellEditable;
pub const _GtkCellEditableIface = struct__GtkCellEditableIface;
pub const _GtkCellRendererPrivate = struct__GtkCellRendererPrivate;
pub const _GtkCellRenderer = struct__GtkCellRenderer;
pub const _GtkCellRendererClassPrivate = struct__GtkCellRendererClassPrivate;
pub const _GtkCellRendererClass = struct__GtkCellRendererClass;
pub const _GtkTreeSortable = struct__GtkTreeSortable;
pub const _GtkTreeSortableIface = struct__GtkTreeSortableIface;
pub const _GtkCellAreaPrivate = struct__GtkCellAreaPrivate;
pub const _GtkCellArea = struct__GtkCellArea;
pub const _GtkCellAreaContextPrivate = struct__GtkCellAreaContextPrivate;
pub const _GtkCellAreaContext = struct__GtkCellAreaContext;
pub const _GtkCellAreaClass = struct__GtkCellAreaClass;
pub const _GtkTreeViewColumnPrivate = struct__GtkTreeViewColumnPrivate;
pub const _GtkTreeViewColumn = struct__GtkTreeViewColumn;
pub const _GtkTreeViewColumnClass = struct__GtkTreeViewColumnClass;
pub const _GtkTextAttributes = struct__GtkTextAttributes;
pub const _GtkTextAppearance = struct__GtkTextAppearance;
pub const _GtkTextChildAnchor = struct__GtkTextChildAnchor;
pub const _GtkTextChildAnchorClass = struct__GtkTextChildAnchorClass;
pub const _GtkTextIter = struct__GtkTextIter;
pub const _GtkTextTagTablePrivate = struct__GtkTextTagTablePrivate;
pub const _GtkTextTagTable = struct__GtkTextTagTable;
pub const _GtkTextTagPrivate = struct__GtkTextTagPrivate;
pub const _GtkTextTag = struct__GtkTextTag;
pub const _GtkTextTagClass = struct__GtkTextTagClass;
pub const _GtkTextBufferPrivate = struct__GtkTextBufferPrivate;
pub const _GtkTextBuffer = struct__GtkTextBuffer;
pub const _GtkTargetPair = struct__GtkTargetPair;
pub const _GtkTargetList = struct__GtkTargetList;
pub const _GtkTargetEntry = struct__GtkTargetEntry;
pub const _GtkEditable = struct__GtkEditable;
pub const _GtkEditableInterface = struct__GtkEditableInterface;
pub const _GtkIMContext = struct__GtkIMContext;
pub const _GtkIMContextClass = struct__GtkIMContextClass;
pub const _GtkEntryBufferPrivate = struct__GtkEntryBufferPrivate;
pub const _GtkEntryBuffer = struct__GtkEntryBuffer;
pub const _GtkEntryBufferClass = struct__GtkEntryBufferClass;
pub const _GtkListStorePrivate = struct__GtkListStorePrivate;
pub const _GtkListStore = struct__GtkListStore;
pub const _GtkListStoreClass = struct__GtkListStoreClass;
pub const _GtkTreeModelFilterPrivate = struct__GtkTreeModelFilterPrivate;
pub const _GtkTreeModelFilter = struct__GtkTreeModelFilter;
pub const _GtkTreeModelFilterClass = struct__GtkTreeModelFilterClass;
pub const _GtkEntryCompletionPrivate = struct__GtkEntryCompletionPrivate;
pub const _GtkEntryCompletion = struct__GtkEntryCompletion;
pub const _GtkEntryCompletionClass = struct__GtkEntryCompletionClass;
pub const _GtkImagePrivate = struct__GtkImagePrivate;
pub const _GtkImage = struct__GtkImage;
pub const _GtkImageClass = struct__GtkImageClass;
pub const _GtkEntryPrivate = struct__GtkEntryPrivate;
pub const _GtkEntry = struct__GtkEntry;
pub const _GtkEntryClass = struct__GtkEntryClass;
pub const _GtkTreeViewPrivate = struct__GtkTreeViewPrivate;
pub const _GtkTreeView = struct__GtkTreeView;
pub const _GtkTreeViewClass = struct__GtkTreeViewClass;
pub const _GtkTreeSelectionPrivate = struct__GtkTreeSelectionPrivate;
pub const _GtkTreeSelection = struct__GtkTreeSelection;
pub const _GtkTreeSelectionClass = struct__GtkTreeSelectionClass;
pub const _GtkComboBoxPrivate = struct__GtkComboBoxPrivate;
pub const _GtkComboBox = struct__GtkComboBox;
pub const _GtkComboBoxClass = struct__GtkComboBoxClass;
pub const _GtkAppChooserButtonPrivate = struct__GtkAppChooserButtonPrivate;
pub const _GtkAppChooserButton = struct__GtkAppChooserButton;
pub const _GtkAppChooserButtonClass = struct__GtkAppChooserButtonClass;
pub const _GtkShortcutsWindow = struct__GtkShortcutsWindow;
pub const _GtkShortcutsWindowClass = struct__GtkShortcutsWindowClass;
pub const _GtkApplicationWindowPrivate = struct__GtkApplicationWindowPrivate;
pub const _GtkApplicationWindowClass = struct__GtkApplicationWindowClass;
pub const _GtkApplicationWindow = struct__GtkApplicationWindow;
pub const _GtkFramePrivate = struct__GtkFramePrivate;
pub const _GtkFrame = struct__GtkFrame;
pub const _GtkFrameClass = struct__GtkFrameClass;
pub const _GtkAspectFramePrivate = struct__GtkAspectFramePrivate;
pub const _GtkAspectFrame = struct__GtkAspectFrame;
pub const _GtkAspectFrameClass = struct__GtkAspectFrameClass;
pub const _GtkAssistantPrivate = struct__GtkAssistantPrivate;
pub const _GtkAssistant = struct__GtkAssistant;
pub const _GtkAssistantClass = struct__GtkAssistantClass;
pub const _GtkButtonBoxPrivate = struct__GtkButtonBoxPrivate;
pub const _GtkButtonBox = struct__GtkButtonBox;
pub const _GtkButtonBoxClass = struct__GtkButtonBoxClass;
pub const _GtkBindingSet = struct__GtkBindingSet;
pub const _GtkBindingEntry = struct__GtkBindingEntry;
pub const _GtkBindingArg = struct__GtkBindingArg;
pub const _GtkBindingSignal = struct__GtkBindingSignal;
pub const _GtkBuilderClass = struct__GtkBuilderClass;
pub const _GtkBuildable = struct__GtkBuildable;
pub const _GtkBuildableIface = struct__GtkBuildableIface;
pub const _GtkButtonPrivate = struct__GtkButtonPrivate;
pub const _GtkButton = struct__GtkButton;
pub const _GtkButtonClass = struct__GtkButtonClass;
pub const _GtkCalendarPrivate = struct__GtkCalendarPrivate;
pub const _GtkCalendar = struct__GtkCalendar;
pub const _GtkCalendarClass = struct__GtkCalendarClass;
pub const _GtkCellAreaBoxPrivate = struct__GtkCellAreaBoxPrivate;
pub const _GtkCellAreaBox = struct__GtkCellAreaBox;
pub const _GtkCellAreaBoxClass = struct__GtkCellAreaBoxClass;
pub const _GtkCellAreaContextClass = struct__GtkCellAreaContextClass;
pub const _GtkCellLayout = struct__GtkCellLayout;
pub const _GtkCellLayoutIface = struct__GtkCellLayoutIface;
pub const _GtkCellRendererTextPrivate = struct__GtkCellRendererTextPrivate;
pub const _GtkCellRendererText = struct__GtkCellRendererText;
pub const _GtkCellRendererTextClass = struct__GtkCellRendererTextClass;
pub const _GtkCellRendererAccelPrivate = struct__GtkCellRendererAccelPrivate;
pub const _GtkCellRendererAccel = struct__GtkCellRendererAccel;
pub const _GtkCellRendererAccelClass = struct__GtkCellRendererAccelClass;
pub const _GtkCellRendererComboPrivate = struct__GtkCellRendererComboPrivate;
pub const _GtkCellRendererCombo = struct__GtkCellRendererCombo;
pub const _GtkCellRendererComboClass = struct__GtkCellRendererComboClass;
pub const _GtkCellRendererPixbufPrivate = struct__GtkCellRendererPixbufPrivate;
pub const _GtkCellRendererPixbuf = struct__GtkCellRendererPixbuf;
pub const _GtkCellRendererPixbufClass = struct__GtkCellRendererPixbufClass;
pub const _GtkCellRendererProgressPrivate = struct__GtkCellRendererProgressPrivate;
pub const _GtkCellRendererProgress = struct__GtkCellRendererProgress;
pub const _GtkCellRendererProgressClass = struct__GtkCellRendererProgressClass;
pub const _GtkCellRendererSpinPrivate = struct__GtkCellRendererSpinPrivate;
pub const _GtkCellRendererSpin = struct__GtkCellRendererSpin;
pub const _GtkCellRendererSpinClass = struct__GtkCellRendererSpinClass;
pub const _GtkCellRendererSpinnerPrivate = struct__GtkCellRendererSpinnerPrivate;
pub const _GtkCellRendererSpinner = struct__GtkCellRendererSpinner;
pub const _GtkCellRendererSpinnerClass = struct__GtkCellRendererSpinnerClass;
pub const _GtkCellRendererTogglePrivate = struct__GtkCellRendererTogglePrivate;
pub const _GtkCellRendererToggle = struct__GtkCellRendererToggle;
pub const _GtkCellRendererToggleClass = struct__GtkCellRendererToggleClass;
pub const _GtkCellViewPrivate = struct__GtkCellViewPrivate;
pub const _GtkCellView = struct__GtkCellView;
pub const _GtkCellViewClass = struct__GtkCellViewClass;
pub const _GtkToggleButtonPrivate = struct__GtkToggleButtonPrivate;
pub const _GtkToggleButton = struct__GtkToggleButton;
pub const _GtkToggleButtonClass = struct__GtkToggleButtonClass;
pub const _GtkCheckButton = struct__GtkCheckButton;
pub const _GtkCheckButtonClass = struct__GtkCheckButtonClass;
pub const _GtkMenuItemPrivate = struct__GtkMenuItemPrivate;
pub const _GtkMenuItem = struct__GtkMenuItem;
pub const _GtkMenuItemClass = struct__GtkMenuItemClass;
pub const _GtkCheckMenuItemPrivate = struct__GtkCheckMenuItemPrivate;
pub const _GtkCheckMenuItem = struct__GtkCheckMenuItem;
pub const _GtkCheckMenuItemClass = struct__GtkCheckMenuItemClass;
pub const _GtkColorButtonPrivate = struct__GtkColorButtonPrivate;
pub const _GtkColorButton = struct__GtkColorButton;
pub const _GtkColorButtonClass = struct__GtkColorButtonClass;
pub const _GtkColorChooser = struct__GtkColorChooser;
pub const _GtkColorChooserInterface = struct__GtkColorChooserInterface;
pub const _GtkColorChooserDialogPrivate = struct__GtkColorChooserDialogPrivate;
pub const _GtkColorChooserDialog = struct__GtkColorChooserDialog;
pub const _GtkColorChooserDialogClass = struct__GtkColorChooserDialogClass;
pub const _GtkColorChooserWidgetPrivate = struct__GtkColorChooserWidgetPrivate;
pub const _GtkColorChooserWidget = struct__GtkColorChooserWidget;
pub const _GtkColorChooserWidgetClass = struct__GtkColorChooserWidgetClass;
pub const _GtkComboBoxTextPrivate = struct__GtkComboBoxTextPrivate;
pub const _GtkComboBoxText = struct__GtkComboBoxText;
pub const _GtkComboBoxTextClass = struct__GtkComboBoxTextClass;
pub const _GtkCssSection = struct__GtkCssSection;
pub const _GtkCssProviderPrivate = struct__GtkCssProviderPrivate;
pub const _GtkCssProvider = struct__GtkCssProvider;
pub const _GtkCssProviderClass = struct__GtkCssProviderClass;
pub const _GtkDrawingArea = struct__GtkDrawingArea;
pub const _GtkDrawingAreaClass = struct__GtkDrawingAreaClass;
pub const _GtkEventBoxPrivate = struct__GtkEventBoxPrivate;
pub const _GtkEventBox = struct__GtkEventBox;
pub const _GtkEventBoxClass = struct__GtkEventBoxClass;
pub const _GtkEventController = struct__GtkEventController;
pub const _GtkEventControllerClass = struct__GtkEventControllerClass;
pub const _GtkEventControllerKey = struct__GtkEventControllerKey;
pub const _GtkEventControllerKeyClass = struct__GtkEventControllerKeyClass;
pub const _GtkEventControllerMotion = struct__GtkEventControllerMotion;
pub const _GtkEventControllerMotionClass = struct__GtkEventControllerMotionClass;
pub const _GtkEventControllerScroll = struct__GtkEventControllerScroll;
pub const _GtkEventControllerScrollClass = struct__GtkEventControllerScrollClass;
pub const _GtkExpanderPrivate = struct__GtkExpanderPrivate;
pub const _GtkExpander = struct__GtkExpander;
pub const _GtkExpanderClass = struct__GtkExpanderClass;
pub const _GtkFixedPrivate = struct__GtkFixedPrivate;
pub const _GtkFixed = struct__GtkFixed;
pub const _GtkFixedClass = struct__GtkFixedClass;
pub const _GtkFixedChild = struct__GtkFixedChild;
pub const _GtkFileFilter = struct__GtkFileFilter;
pub const _GtkFileFilterInfo = struct__GtkFileFilterInfo;
pub const _GtkFileChooser = struct__GtkFileChooser;
pub const _GtkFileChooserButtonPrivate = struct__GtkFileChooserButtonPrivate;
pub const _GtkFileChooserButton = struct__GtkFileChooserButton;
pub const _GtkFileChooserButtonClass = struct__GtkFileChooserButtonClass;
pub const _GtkFileChooserDialogPrivate = struct__GtkFileChooserDialogPrivate;
pub const _GtkFileChooserDialog = struct__GtkFileChooserDialog;
pub const _GtkFileChooserDialogClass = struct__GtkFileChooserDialogClass;
pub const _GtkNativeDialog = struct__GtkNativeDialog;
pub const _GtkNativeDialogClass = struct__GtkNativeDialogClass;
pub const _GtkFileChooserNative = struct__GtkFileChooserNative;
pub const _GtkFileChooserWidgetPrivate = struct__GtkFileChooserWidgetPrivate;
pub const _GtkFileChooserWidget = struct__GtkFileChooserWidget;
pub const _GtkFileChooserWidgetClass = struct__GtkFileChooserWidgetClass;
pub const _GtkFlowBox = struct__GtkFlowBox;
pub const _GtkFlowBoxChild = struct__GtkFlowBoxChild;
pub const _GtkFlowBoxClass = struct__GtkFlowBoxClass;
pub const _GtkFlowBoxChildClass = struct__GtkFlowBoxChildClass;
pub const _GtkFontButtonPrivate = struct__GtkFontButtonPrivate;
pub const _GtkFontButton = struct__GtkFontButton;
pub const _GtkFontButtonClass = struct__GtkFontButtonClass;
pub const _GtkFontChooser = struct__GtkFontChooser;
pub const _GtkFontChooserIface = struct__GtkFontChooserIface;
pub const _GtkFontChooserDialogPrivate = struct__GtkFontChooserDialogPrivate;
pub const _GtkFontChooserDialog = struct__GtkFontChooserDialog;
pub const _GtkFontChooserDialogClass = struct__GtkFontChooserDialogClass;
pub const _GtkFontChooserWidgetPrivate = struct__GtkFontChooserWidgetPrivate;
pub const _GtkFontChooserWidget = struct__GtkFontChooserWidget;
pub const _GtkFontChooserWidgetClass = struct__GtkFontChooserWidgetClass;
pub const _GtkGesture = struct__GtkGesture;
pub const _GtkGestureClass = struct__GtkGestureClass;
pub const _GtkGestureSingle = struct__GtkGestureSingle;
pub const _GtkGestureSingleClass = struct__GtkGestureSingleClass;
pub const _GtkGestureDrag = struct__GtkGestureDrag;
pub const _GtkGestureDragClass = struct__GtkGestureDragClass;
pub const _GtkGestureLongPress = struct__GtkGestureLongPress;
pub const _GtkGestureLongPressClass = struct__GtkGestureLongPressClass;
pub const _GtkGestureMultiPress = struct__GtkGestureMultiPress;
pub const _GtkGestureMultiPressClass = struct__GtkGestureMultiPressClass;
pub const _GtkGesturePan = struct__GtkGesturePan;
pub const _GtkGesturePanClass = struct__GtkGesturePanClass;
pub const _GtkGestureRotate = struct__GtkGestureRotate;
pub const _GtkGestureRotateClass = struct__GtkGestureRotateClass;
pub const _GtkGestureStylus = struct__GtkGestureStylus;
pub const _GtkGestureStylusClass = struct__GtkGestureStylusClass;
pub const _GtkGestureSwipe = struct__GtkGestureSwipe;
pub const _GtkGestureSwipeClass = struct__GtkGestureSwipeClass;
pub const _GtkGestureZoom = struct__GtkGestureZoom;
pub const _GtkGestureZoomClass = struct__GtkGestureZoomClass;
pub const _GtkGLArea = struct__GtkGLArea;
pub const _GtkGLAreaClass = struct__GtkGLAreaClass;
pub const _GtkGridPrivate = struct__GtkGridPrivate;
pub const _GtkGrid = struct__GtkGrid;
pub const _GtkGridClass = struct__GtkGridClass;
pub const _GtkHeaderBar = struct__GtkHeaderBar;
pub const _GtkHeaderBarPrivate = struct__GtkHeaderBarPrivate;
pub const _GtkHeaderBarClass = struct__GtkHeaderBarClass;
pub const _GtkIconFactoryPrivate = struct__GtkIconFactoryPrivate;
pub const _GtkIconFactory = struct__GtkIconFactory;
pub const _GtkIconFactoryClass = struct__GtkIconFactoryClass;
pub const _GtkStylePropertiesPrivate = struct__GtkStylePropertiesPrivate;
pub const _GtkStyleProperties = struct__GtkStyleProperties;
pub const _GtkStylePropertiesClass = struct__GtkStylePropertiesClass;
pub const _GtkSymbolicColor = struct__GtkSymbolicColor;
pub const _GtkGradient = struct__GtkGradient;
pub const _GtkStyleProvider = struct__GtkStyleProvider;
pub const _GtkStyleProviderIface = struct__GtkStyleProviderIface;
pub const _GtkStyleContextClass = struct__GtkStyleContextClass;
pub const _GtkIconInfo = struct__GtkIconInfo;
pub const _GtkIconInfoClass = struct__GtkIconInfoClass;
pub const _GtkIconThemePrivate = struct__GtkIconThemePrivate;
pub const _GtkIconTheme = struct__GtkIconTheme;
pub const _GtkIconThemeClass = struct__GtkIconThemeClass;
pub const _GtkIconViewPrivate = struct__GtkIconViewPrivate;
pub const _GtkIconView = struct__GtkIconView;
pub const _GtkIconViewClass = struct__GtkIconViewClass;
pub const _GtkIMContextInfo = struct__GtkIMContextInfo;
pub const _GtkIMContextSimplePrivate = struct__GtkIMContextSimplePrivate;
pub const _GtkIMContextSimple = struct__GtkIMContextSimple;
pub const _GtkIMContextSimpleClass = struct__GtkIMContextSimpleClass;
pub const _GtkIMMulticontextPrivate = struct__GtkIMMulticontextPrivate;
pub const _GtkIMMulticontext = struct__GtkIMMulticontext;
pub const _GtkIMMulticontextClass = struct__GtkIMMulticontextClass;
pub const _GtkInfoBarPrivate = struct__GtkInfoBarPrivate;
pub const _GtkInfoBar = struct__GtkInfoBar;
pub const _GtkInfoBarClass = struct__GtkInfoBarClass;
pub const _GtkInvisiblePrivate = struct__GtkInvisiblePrivate;
pub const _GtkInvisible = struct__GtkInvisible;
pub const _GtkInvisibleClass = struct__GtkInvisibleClass;
pub const _GtkLayoutPrivate = struct__GtkLayoutPrivate;
pub const _GtkLayout = struct__GtkLayout;
pub const _GtkLayoutClass = struct__GtkLayoutClass;
pub const _GtkLevelBarPrivate = struct__GtkLevelBarPrivate;
pub const _GtkLevelBar = struct__GtkLevelBar;
pub const _GtkLevelBarClass = struct__GtkLevelBarClass;
pub const _GtkLinkButtonPrivate = struct__GtkLinkButtonPrivate;
pub const _GtkLinkButton = struct__GtkLinkButton;
pub const _GtkLinkButtonClass = struct__GtkLinkButtonClass;
pub const _GtkListBox = struct__GtkListBox;
pub const _GtkListBoxRow = struct__GtkListBoxRow;
pub const _GtkListBoxClass = struct__GtkListBoxClass;
pub const _GtkListBoxRowClass = struct__GtkListBoxRowClass;
pub const _GtkLockButtonPrivate = struct__GtkLockButtonPrivate;
pub const _GtkLockButton = struct__GtkLockButton;
pub const _GtkLockButtonClass = struct__GtkLockButtonClass;
pub const _GtkMenuBarPrivate = struct__GtkMenuBarPrivate;
pub const _GtkMenuBar = struct__GtkMenuBar;
pub const _GtkMenuBarClass = struct__GtkMenuBarClass;
pub const _GtkPopoverPrivate = struct__GtkPopoverPrivate;
pub const _GtkPopover = struct__GtkPopover;
pub const _GtkPopoverClass = struct__GtkPopoverClass;
pub const _GtkMenuButtonPrivate = struct__GtkMenuButtonPrivate;
pub const _GtkMenuButton = struct__GtkMenuButton;
pub const _GtkMenuButtonClass = struct__GtkMenuButtonClass;
pub const _GtkSizeGroupPrivate = struct__GtkSizeGroupPrivate;
pub const _GtkSizeGroup = struct__GtkSizeGroup;
pub const _GtkSizeGroupClass = struct__GtkSizeGroupClass;
pub const _GtkToolItemPrivate = struct__GtkToolItemPrivate;
pub const _GtkToolItem = struct__GtkToolItem;
pub const _GtkToolItemClass = struct__GtkToolItemClass;
pub const _GtkToolButtonPrivate = struct__GtkToolButtonPrivate;
pub const _GtkToolButton = struct__GtkToolButton;
pub const _GtkToolButtonClass = struct__GtkToolButtonClass;
pub const _GtkMenuToolButtonPrivate = struct__GtkMenuToolButtonPrivate;
pub const _GtkMenuToolButton = struct__GtkMenuToolButton;
pub const _GtkMenuToolButtonClass = struct__GtkMenuToolButtonClass;
pub const _GtkMessageDialogPrivate = struct__GtkMessageDialogPrivate;
pub const _GtkMessageDialog = struct__GtkMessageDialog;
pub const _GtkMessageDialogClass = struct__GtkMessageDialogClass;
pub const _GtkModelButton = struct__GtkModelButton;
pub const _GtkMountOperationPrivate = struct__GtkMountOperationPrivate;
pub const _GtkMountOperation = struct__GtkMountOperation;
pub const _GtkMountOperationClass = struct__GtkMountOperationClass;
pub const _GtkNotebookPrivate = struct__GtkNotebookPrivate;
pub const _GtkNotebook = struct__GtkNotebook;
pub const _GtkNotebookClass = struct__GtkNotebookClass;
pub const _GtkOffscreenWindow = struct__GtkOffscreenWindow;
pub const _GtkOffscreenWindowClass = struct__GtkOffscreenWindowClass;
pub const _GtkOrientable = struct__GtkOrientable;
pub const _GtkOrientableIface = struct__GtkOrientableIface;
pub const _GtkOverlayPrivate = struct__GtkOverlayPrivate;
pub const _GtkOverlay = struct__GtkOverlay;
pub const _GtkOverlayClass = struct__GtkOverlayClass;
pub const _GtkPadController = struct__GtkPadController;
pub const _GtkPadControllerClass = struct__GtkPadControllerClass;
pub const _GtkPadActionEntry = struct__GtkPadActionEntry;
pub const _GtkPaperSize = struct__GtkPaperSize;
pub const _GtkPageSetup = struct__GtkPageSetup;
pub const _GtkPanedPrivate = struct__GtkPanedPrivate;
pub const _GtkPaned = struct__GtkPaned;
pub const _GtkPanedClass = struct__GtkPanedClass;
pub const _GtkPlacesSidebar = struct__GtkPlacesSidebar;
pub const _GtkPlacesSidebarClass = struct__GtkPlacesSidebarClass;
pub const _GtkPopoverMenu = struct__GtkPopoverMenu;
pub const _GtkPopoverMenuClass = struct__GtkPopoverMenuClass;
pub const _GtkPrintContext = struct__GtkPrintContext;
pub const _GtkPrintSettings = struct__GtkPrintSettings;
pub const _GtkPageRange = struct__GtkPageRange;
pub const _GtkPrintOperationPreview = struct__GtkPrintOperationPreview;
pub const _GtkPrintOperationPreviewIface = struct__GtkPrintOperationPreviewIface;
pub const _GtkPrintOperationPrivate = struct__GtkPrintOperationPrivate;
pub const _GtkPrintOperation = struct__GtkPrintOperation;
pub const _GtkPrintOperationClass = struct__GtkPrintOperationClass;
pub const _GtkProgressBarPrivate = struct__GtkProgressBarPrivate;
pub const _GtkProgressBar = struct__GtkProgressBar;
pub const _GtkProgressBarClass = struct__GtkProgressBarClass;
pub const _GtkRadioButtonPrivate = struct__GtkRadioButtonPrivate;
pub const _GtkRadioButton = struct__GtkRadioButton;
pub const _GtkRadioButtonClass = struct__GtkRadioButtonClass;
pub const _GtkRadioMenuItemPrivate = struct__GtkRadioMenuItemPrivate;
pub const _GtkRadioMenuItem = struct__GtkRadioMenuItem;
pub const _GtkRadioMenuItemClass = struct__GtkRadioMenuItemClass;
pub const _GtkToggleToolButtonPrivate = struct__GtkToggleToolButtonPrivate;
pub const _GtkToggleToolButton = struct__GtkToggleToolButton;
pub const _GtkToggleToolButtonClass = struct__GtkToggleToolButtonClass;
pub const _GtkRadioToolButton = struct__GtkRadioToolButton;
pub const _GtkRadioToolButtonClass = struct__GtkRadioToolButtonClass;
pub const _GtkRangePrivate = struct__GtkRangePrivate;
pub const _GtkRange = struct__GtkRange;
pub const _GtkRangeClass = struct__GtkRangeClass;
pub const _GtkRecentInfo = struct__GtkRecentInfo;
pub const _GtkRecentData = struct__GtkRecentData;
pub const _GtkRecentManagerPrivate = struct__GtkRecentManagerPrivate;
pub const _GtkRecentManager = struct__GtkRecentManager;
pub const _GtkRecentManagerClass = struct__GtkRecentManagerClass;
pub const _GtkRecentFilter = struct__GtkRecentFilter;
pub const _GtkRecentFilterInfo = struct__GtkRecentFilterInfo;
pub const _GtkRecentChooser = struct__GtkRecentChooser;
pub const _GtkRecentChooserIface = struct__GtkRecentChooserIface;
pub const _GtkRecentChooserDialogPrivate = struct__GtkRecentChooserDialogPrivate;
pub const _GtkRecentChooserDialog = struct__GtkRecentChooserDialog;
pub const _GtkRecentChooserDialogClass = struct__GtkRecentChooserDialogClass;
pub const _GtkRecentChooserMenuPrivate = struct__GtkRecentChooserMenuPrivate;
pub const _GtkRecentChooserMenu = struct__GtkRecentChooserMenu;
pub const _GtkRecentChooserMenuClass = struct__GtkRecentChooserMenuClass;
pub const _GtkRecentChooserWidgetPrivate = struct__GtkRecentChooserWidgetPrivate;
pub const _GtkRecentChooserWidget = struct__GtkRecentChooserWidget;
pub const _GtkRecentChooserWidgetClass = struct__GtkRecentChooserWidgetClass;
pub const _GtkRevealer = struct__GtkRevealer;
pub const _GtkRevealerClass = struct__GtkRevealerClass;
pub const _GtkScalePrivate = struct__GtkScalePrivate;
pub const _GtkScale = struct__GtkScale;
pub const _GtkScaleClass = struct__GtkScaleClass;
pub const _GtkScaleButtonPrivate = struct__GtkScaleButtonPrivate;
pub const _GtkScaleButton = struct__GtkScaleButton;
pub const _GtkScaleButtonClass = struct__GtkScaleButtonClass;
pub const _GtkScrollable = struct__GtkScrollable;
pub const _GtkScrollableInterface = struct__GtkScrollableInterface;
pub const _GtkScrollbar = struct__GtkScrollbar;
pub const _GtkScrollbarClass = struct__GtkScrollbarClass;
pub const _GtkScrolledWindowPrivate = struct__GtkScrolledWindowPrivate;
pub const _GtkScrolledWindow = struct__GtkScrolledWindow;
pub const _GtkScrolledWindowClass = struct__GtkScrolledWindowClass;
pub const _GtkSearchBar = struct__GtkSearchBar;
pub const _GtkSearchBarClass = struct__GtkSearchBarClass;
pub const _GtkSearchEntry = struct__GtkSearchEntry;
pub const _GtkSearchEntryClass = struct__GtkSearchEntryClass;
pub const _GtkSeparatorPrivate = struct__GtkSeparatorPrivate;
pub const _GtkSeparator = struct__GtkSeparator;
pub const _GtkSeparatorClass = struct__GtkSeparatorClass;
pub const _GtkSeparatorMenuItem = struct__GtkSeparatorMenuItem;
pub const _GtkSeparatorMenuItemClass = struct__GtkSeparatorMenuItemClass;
pub const _GtkSeparatorToolItemPrivate = struct__GtkSeparatorToolItemPrivate;
pub const _GtkSeparatorToolItem = struct__GtkSeparatorToolItem;
pub const _GtkSeparatorToolItemClass = struct__GtkSeparatorToolItemClass;
pub const _GtkSettingsClass = struct__GtkSettingsClass;
pub const _GtkSettingsValue = struct__GtkSettingsValue;
pub const _GtkShortcutLabel = struct__GtkShortcutLabel;
pub const _GtkShortcutLabelClass = struct__GtkShortcutLabelClass;
pub const _GtkShortcutsGroup = struct__GtkShortcutsGroup;
pub const _GtkShortcutsGroupClass = struct__GtkShortcutsGroupClass;
pub const _GtkShortcutsSection = struct__GtkShortcutsSection;
pub const _GtkShortcutsSectionClass = struct__GtkShortcutsSectionClass;
pub const _GtkShortcutsShortcut = struct__GtkShortcutsShortcut;
pub const _GtkShortcutsShortcutClass = struct__GtkShortcutsShortcutClass;
pub const _GtkStack = struct__GtkStack;
pub const _GtkStackClass = struct__GtkStackClass;
pub const _GtkStackSidebar = struct__GtkStackSidebar;
pub const _GtkStackSidebarPrivate = struct__GtkStackSidebarPrivate;
pub const _GtkStackSidebarClass = struct__GtkStackSidebarClass;
pub const _GtkRequestedSize = struct__GtkRequestedSize;
pub const _GtkSpinButtonPrivate = struct__GtkSpinButtonPrivate;
pub const _GtkSpinButton = struct__GtkSpinButton;
pub const _GtkSpinButtonClass = struct__GtkSpinButtonClass;
pub const _GtkSpinnerPrivate = struct__GtkSpinnerPrivate;
pub const _GtkSpinner = struct__GtkSpinner;
pub const _GtkSpinnerClass = struct__GtkSpinnerClass;
pub const _GtkStackSwitcher = struct__GtkStackSwitcher;
pub const _GtkStackSwitcherClass = struct__GtkStackSwitcherClass;
pub const _GtkStatusbarPrivate = struct__GtkStatusbarPrivate;
pub const _GtkStatusbar = struct__GtkStatusbar;
pub const _GtkStatusbarClass = struct__GtkStatusbarClass;
pub const _GtkSwitchPrivate = struct__GtkSwitchPrivate;
pub const _GtkSwitch = struct__GtkSwitch;
pub const _GtkSwitchClass = struct__GtkSwitchClass;
pub const _GtkTextTagTableClass = struct__GtkTextTagTableClass;
pub const _GtkTextMark = struct__GtkTextMark;
pub const _GtkTextMarkClass = struct__GtkTextMarkClass;
pub const _GtkTextBTree = struct__GtkTextBTree;
pub const _GtkTextBufferClass = struct__GtkTextBufferClass;
pub const _GtkTextViewPrivate = struct__GtkTextViewPrivate;
pub const _GtkTextView = struct__GtkTextView;
pub const _GtkTextViewClass = struct__GtkTextViewClass;
pub const _GtkToolbarPrivate = struct__GtkToolbarPrivate;
pub const _GtkToolbar = struct__GtkToolbar;
pub const _GtkToolbarClass = struct__GtkToolbarClass;
pub const _GtkToolItemGroupPrivate = struct__GtkToolItemGroupPrivate;
pub const _GtkToolItemGroup = struct__GtkToolItemGroup;
pub const _GtkToolItemGroupClass = struct__GtkToolItemGroupClass;
pub const _GtkToolPalettePrivate = struct__GtkToolPalettePrivate;
pub const _GtkToolPalette = struct__GtkToolPalette;
pub const _GtkToolPaletteClass = struct__GtkToolPaletteClass;
pub const _GtkToolShell = struct__GtkToolShell;
pub const _GtkToolShellIface = struct__GtkToolShellIface;
pub const _GtkTreeDragSource = struct__GtkTreeDragSource;
pub const _GtkTreeDragSourceIface = struct__GtkTreeDragSourceIface;
pub const _GtkTreeDragDest = struct__GtkTreeDragDest;
pub const _GtkTreeDragDestIface = struct__GtkTreeDragDestIface;
pub const _GtkTreeModelSortPrivate = struct__GtkTreeModelSortPrivate;
pub const _GtkTreeModelSort = struct__GtkTreeModelSort;
pub const _GtkTreeModelSortClass = struct__GtkTreeModelSortClass;
pub const _GtkTreeStorePrivate = struct__GtkTreeStorePrivate;
pub const _GtkTreeStore = struct__GtkTreeStore;
pub const _GtkTreeStoreClass = struct__GtkTreeStoreClass;
pub const _GtkViewportPrivate = struct__GtkViewportPrivate;
pub const _GtkViewport = struct__GtkViewport;
pub const _GtkViewportClass = struct__GtkViewportClass;
pub const _GtkVolumeButton = struct__GtkVolumeButton;
pub const _GtkVolumeButtonClass = struct__GtkVolumeButtonClass;
pub const _GtkArrowPrivate = struct__GtkArrowPrivate;
pub const _GtkArrow = struct__GtkArrow;
pub const _GtkArrowClass = struct__GtkArrowClass;
pub const _GtkActionPrivate = struct__GtkActionPrivate;
pub const _GtkAction = struct__GtkAction;
pub const _GtkActionClass = struct__GtkActionClass;
pub const _GtkActivatable = struct__GtkActivatable;
pub const _GtkActivatableIface = struct__GtkActivatableIface;
pub const _GtkStockItem = struct__GtkStockItem;
pub const _GtkActionGroupPrivate = struct__GtkActionGroupPrivate;
pub const _GtkActionGroup = struct__GtkActionGroup;
pub const _GtkActionGroupClass = struct__GtkActionGroupClass;
pub const _GtkActionEntry = struct__GtkActionEntry;
pub const _GtkToggleActionEntry = struct__GtkToggleActionEntry;
pub const _GtkRadioActionEntry = struct__GtkRadioActionEntry;
pub const _GtkAlignmentPrivate = struct__GtkAlignmentPrivate;
pub const _GtkAlignment = struct__GtkAlignment;
pub const _GtkAlignmentClass = struct__GtkAlignmentClass;
pub const _GtkColorSelectionPrivate = struct__GtkColorSelectionPrivate;
pub const _GtkColorSelection = struct__GtkColorSelection;
pub const _GtkColorSelectionClass = struct__GtkColorSelectionClass;
pub const _GtkColorSelectionDialogPrivate = struct__GtkColorSelectionDialogPrivate;
pub const _GtkColorSelectionDialog = struct__GtkColorSelectionDialog;
pub const _GtkColorSelectionDialogClass = struct__GtkColorSelectionDialogClass;
pub const _GtkFontSelectionPrivate = struct__GtkFontSelectionPrivate;
pub const _GtkFontSelection = struct__GtkFontSelection;
pub const _GtkFontSelectionClass = struct__GtkFontSelectionClass;
pub const _GtkFontSelectionDialogPrivate = struct__GtkFontSelectionDialogPrivate;
pub const _GtkFontSelectionDialog = struct__GtkFontSelectionDialog;
pub const _GtkFontSelectionDialogClass = struct__GtkFontSelectionDialogClass;
pub const _GtkHandleBoxPrivate = struct__GtkHandleBoxPrivate;
pub const _GtkHandleBox = struct__GtkHandleBox;
pub const _GtkHandleBoxClass = struct__GtkHandleBoxClass;
pub const _GtkHButtonBox = struct__GtkHButtonBox;
pub const _GtkHButtonBoxClass = struct__GtkHButtonBoxClass;
pub const _GtkHBox = struct__GtkHBox;
pub const _GtkHBoxClass = struct__GtkHBoxClass;
pub const _GtkHPaned = struct__GtkHPaned;
pub const _GtkHPanedClass = struct__GtkHPanedClass;
pub const _GtkHSVPrivate = struct__GtkHSVPrivate;
pub const _GtkHSV = struct__GtkHSV;
pub const _GtkHSVClass = struct__GtkHSVClass;
pub const _GtkHScale = struct__GtkHScale;
pub const _GtkHScaleClass = struct__GtkHScaleClass;
pub const _GtkHScrollbar = struct__GtkHScrollbar;
pub const _GtkHScrollbarClass = struct__GtkHScrollbarClass;
pub const _GtkHSeparator = struct__GtkHSeparator;
pub const _GtkHSeparatorClass = struct__GtkHSeparatorClass;
pub const _GtkImageMenuItemPrivate = struct__GtkImageMenuItemPrivate;
pub const _GtkImageMenuItem = struct__GtkImageMenuItem;
pub const _GtkImageMenuItemClass = struct__GtkImageMenuItemClass;
pub const _GtkNumerableIconPrivate = struct__GtkNumerableIconPrivate;
pub const _GtkNumerableIcon = struct__GtkNumerableIcon;
pub const _GtkNumerableIconClass = struct__GtkNumerableIconClass;
pub const _GtkToggleActionPrivate = struct__GtkToggleActionPrivate;
pub const _GtkToggleAction = struct__GtkToggleAction;
pub const _GtkToggleActionClass = struct__GtkToggleActionClass;
pub const _GtkRadioActionPrivate = struct__GtkRadioActionPrivate;
pub const _GtkRadioAction = struct__GtkRadioAction;
pub const _GtkRadioActionClass = struct__GtkRadioActionClass;
pub const _GtkRcContext = struct__GtkRcContext;
pub const _GtkRcStyleClass = struct__GtkRcStyleClass;
pub const _GtkRcProperty = struct__GtkRcProperty;
pub const _GtkRecentActionPrivate = struct__GtkRecentActionPrivate;
pub const _GtkRecentAction = struct__GtkRecentAction;
pub const _GtkRecentActionClass = struct__GtkRecentActionClass;
pub const _GtkStatusIconPrivate = struct__GtkStatusIconPrivate;
pub const _GtkStatusIcon = struct__GtkStatusIcon;
pub const _GtkStatusIconClass = struct__GtkStatusIconClass;
pub const _GtkStyleClass = struct__GtkStyleClass;
pub const _GtkThemeEngine = struct__GtkThemeEngine;
pub const _GtkTablePrivate = struct__GtkTablePrivate;
pub const _GtkTable = struct__GtkTable;
pub const _GtkTableClass = struct__GtkTableClass;
pub const _GtkTableChild = struct__GtkTableChild;
pub const _GtkTableRowCol = struct__GtkTableRowCol;
pub const _GtkTearoffMenuItemPrivate = struct__GtkTearoffMenuItemPrivate;
pub const _GtkTearoffMenuItem = struct__GtkTearoffMenuItem;
pub const _GtkTearoffMenuItemClass = struct__GtkTearoffMenuItemClass;
pub const _GtkThemingEngine = struct__GtkThemingEngine;
pub const _GtkThemingEngineClass = struct__GtkThemingEngineClass;
pub const _GtkUIManagerPrivate = struct__GtkUIManagerPrivate;
pub const _GtkUIManager = struct__GtkUIManager;
pub const _GtkUIManagerClass = struct__GtkUIManagerClass;
pub const _GtkVButtonBox = struct__GtkVButtonBox;
pub const _GtkVButtonBoxClass = struct__GtkVButtonBoxClass;
pub const _GtkVBox = struct__GtkVBox;
pub const _GtkVBoxClass = struct__GtkVBoxClass;
pub const _GtkVPaned = struct__GtkVPaned;
pub const _GtkVPanedClass = struct__GtkVPanedClass;
pub const _GtkVScale = struct__GtkVScale;
pub const _GtkVScaleClass = struct__GtkVScaleClass;
pub const _GtkVScrollbar = struct__GtkVScrollbar;
pub const _GtkVScrollbarClass = struct__GtkVScrollbarClass;
pub const _GtkVSeparator = struct__GtkVSeparator;
pub const _GtkVSeparatorClass = struct__GtkVSeparatorClass;
